{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Allocproof.v","fileSamples":[{"statement":"(p : RTL.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : RTL.program) (tp : program) (H : transf_program p = OK tp)","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(m : move) (accu : list move) (b : bblock) : map expand_move (rev (m :: accu)) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b.","conclusion":"map expand_move (rev (m :: accu)) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b","hypotheses":"(m : move) (accu : list move) (b : bblock)","proofString":"simpl.\nrewrite map_app.\nrewrite app_ass.\nauto."},{"statement":"(m : move) (accu : list move) (b : bblock) : map expand_move (rev accu ++ m :: nil) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b.","conclusion":"map expand_move (rev accu ++ m :: nil) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b","hypotheses":"(m : move) (accu : list move) (b : bblock)","proofString":"rewrite map_app.\nrewrite app_ass.\nauto."},{"statement":"(m : move) (accu : list move) (b : bblock) : (map expand_move (rev accu) ++ map expand_move (m :: nil)) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b.","conclusion":"(map expand_move (rev accu) ++ map expand_move (m :: nil)) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b","hypotheses":"(m : move) (accu : list move) (b : bblock)","proofString":"rewrite app_ass.\nauto."},{"statement":"(m : move) (accu : list move) (b : bblock) : map expand_move (rev accu) ++ map expand_move (m :: nil) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b.","conclusion":"map expand_move (rev accu) ++ map expand_move (m :: nil) ++ b =\nmap expand_move (rev accu) ++ expand_move m :: b","hypotheses":"(m : move) (accu : list move) (b : bblock)","proofString":"auto."},{"statement":"forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b.","conclusion":"forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b","hypotheses":"","proofString":"intros; split; auto.\nunfold wf_moves in *; rewrite Forall_forall in *.\nintros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : wf_moves accu) : wf_moves (rev accu).","conclusion":"wf_moves (rev accu)","hypotheses":"(accu : moves) (b : bblock) (H : wf_moves accu)","proofString":"unfold wf_moves in *; rewrite Forall_forall in *.\nintros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x : move, In x accu -> wf_move x) : forall x : move, In x (rev accu) -> wf_move x.","conclusion":"forall x : move, In x (rev accu) -> wf_move x","hypotheses":"(accu : moves) (b : bblock) (H : forall x : move, In x accu -> wf_move x)","proofString":"intros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu)) : wf_move x.","conclusion":"wf_move x","hypotheses":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu))","proofString":"apply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu)) : In x accu.","conclusion":"In x accu","hypotheses":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu))","proofString":"rewrite <- in_rev in H0; auto."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) : forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b)","proofString":"assert (IND: forall b accu mv b',          extract_moves accu b = (mv, b') ->          wf_moves accu ->          wf_moves mv /\\ expand_moves (List.rev accu) b = expand_moves mv b').\ninduction b; simpl; intros.\ninv H.\nauto.\ndestruct a; try (inv H; apply BASE; auto; fail).\ndestruct (is_move_operation op args) as [arg|] eqn:E.\nexploit is_move_operation_correct; eauto.\nintros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nintros.\nexploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b'.","conclusion":"forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b)","proofString":"induction b; simpl; intros.\ninv H.\nauto.\ndestruct a; try (inv H; apply BASE; auto; fail).\ndestruct (is_move_operation op args) as [arg|] eqn:E.\nexploit is_move_operation_correct; eauto.\nintros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu mv : moves) (b' : bblock) (H : (rev accu, nil) = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\ expand_moves (rev accu) nil = expand_moves mv b'.","conclusion":"wf_moves mv /\\ expand_moves (rev accu) nil = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu mv : moves) (b' : bblock) (H : (rev accu, nil) = (mv, b')) (H0 : wf_moves accu)","proofString":"inv H.\nauto."},{"statement":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu : moves) (H0 : wf_moves accu) : wf_moves (rev accu) /\\\nexpand_moves (rev accu) nil = expand_moves (rev accu) nil.","conclusion":"wf_moves (rev accu) /\\\nexpand_moves (rev accu) nil = expand_moves (rev accu) nil","hypotheses":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu : moves) (H0 : wf_moves accu)","proofString":"auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (a : instruction) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match a with\n| Lop op args res =>\n    match is_move_operation op args with\n    | Some arg => extract_moves (MV (R arg) (R res) :: accu) b\n    | None => (rev accu, a :: b)\n    end\n| Lgetstack sl ofs ty dst =>\n    extract_moves (MV (S sl ofs ty) (R dst) :: accu) b\n| Lsetstack src sl ofs ty =>\n    extract_moves (MV (R src) (S sl ofs ty) :: accu) b\n| _ => (rev accu, a :: b)\nend = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\ expand_moves (rev accu) (a :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\ expand_moves (rev accu) (a :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (a : instruction) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match a with\n| Lop op args res =>\n    match is_move_operation op args with\n    | Some arg => extract_moves (MV (R arg) (R res) :: accu) b\n    | None => (rev accu, a :: b)\n    end\n| Lgetstack sl ofs ty dst =>\n    extract_moves (MV (S sl ofs ty) (R dst) :: accu) b\n| Lsetstack src sl ofs ty =>\n    extract_moves (MV (R src) (S sl ofs ty) :: accu) b\n| _ => (rev accu, a :: b)\nend = (mv, b')) (H0 : wf_moves accu)","proofString":"destruct a; try (inv H; apply BASE; auto; fail).\ndestruct (is_move_operation op args) as [arg|] eqn:E.\nexploit is_move_operation_correct; eauto.\nintros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match is_move_operation op args with\n| Some arg => extract_moves (MV (R arg) (R res) :: accu) b\n| None => (rev accu, Lop op args res :: b)\nend = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match is_move_operation op args with\n| Some arg => extract_moves (MV (R arg) (R res) :: accu) b\n| None => (rev accu, Lop op args res :: b)\nend = (mv, b')) (H0 : wf_moves accu)","proofString":"destruct (is_move_operation op args) as [arg|] eqn:E.\nexploit is_move_operation_correct; eauto.\nintros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation op args = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation op args = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit is_move_operation_correct; eauto.\nintros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation op args = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : op = Omove /\\ args = arg :: nil ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"op = Omove /\\ args = arg :: nil ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation op args = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"intros [A B]; subst.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (R arg) (R res) :: accu).","conclusion":"wf_moves (MV (R arg) (R res) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (R arg) (R res)).","conclusion":"wf_move (MV (R arg) (R res))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (R arg) (R res) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (R arg) (R res) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (E : is_move_operation Omove (arg :: nil) = Some arg) (H : extract_moves (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (E : is_move_operation op args = None) (H : (rev accu, Lop op args res :: b) = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (E : is_move_operation op args = None) (H : (rev accu, Lop op args res :: b) = (mv, b')) (H0 : wf_moves accu)","proofString":"inv H; apply BASE; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (S sl ofs ty) (R dst) :: accu).","conclusion":"wf_moves (MV (S sl ofs ty) (R dst) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (S sl ofs ty) (R dst)).","conclusion":"wf_move (MV (S sl ofs ty) (R dst))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (S sl ofs ty) (R dst) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (S sl ofs ty) (R dst) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (R src) (S sl ofs ty) :: accu).","conclusion":"wf_moves (MV (R src) (S sl ofs ty) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (R src) (S sl ofs ty)).","conclusion":"wf_move (MV (R src) (S sl ofs ty))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (R src) (S sl ofs ty) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (R src) (S sl ofs ty) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) (IND : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b') : forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) (IND : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b')","proofString":"intros.\nexploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves nil b = (mv, b')) : wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves nil b = (mv, b'))","proofString":"exploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves nil b = (mv, b')) : wf_moves nil.","conclusion":"wf_moves nil","hypotheses":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves nil b = (mv, b'))","proofString":"constructor."},{"statement":"forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b.","conclusion":"forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b","hypotheses":"","proofString":"intros; split; auto.\nunfold wf_moves in *; rewrite Forall_forall in *.\nintros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : wf_moves accu) : wf_moves (rev accu).","conclusion":"wf_moves (rev accu)","hypotheses":"(accu : moves) (b : bblock) (H : wf_moves accu)","proofString":"unfold wf_moves in *; rewrite Forall_forall in *.\nintros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x : move, In x accu -> wf_move x) : forall x : move, In x (rev accu) -> wf_move x.","conclusion":"forall x : move, In x (rev accu) -> wf_move x","hypotheses":"(accu : moves) (b : bblock) (H : forall x : move, In x accu -> wf_move x)","proofString":"intros.\napply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu)) : wf_move x.","conclusion":"wf_move x","hypotheses":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu))","proofString":"apply H.\nrewrite <- in_rev in H0; auto."},{"statement":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu)) : In x accu.","conclusion":"In x accu","hypotheses":"(accu : moves) (b : bblock) (H : forall x0 : move, In x0 accu -> wf_move x0) (x : move) (H0 : In x (rev accu))","proofString":"rewrite <- in_rev in H0; auto."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) : forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves_ext nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves_ext nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b)","proofString":"assert (IND: forall b accu mv b',          extract_moves_ext accu b = (mv, b') ->          wf_moves accu ->          wf_moves mv /\\ expand_moves (List.rev accu) b = expand_moves mv b').\ninduction b; simpl; intros.\ninv H.\nauto.\ndestruct a; try (inv H; apply BASE; auto; fail).\ndestruct (classify_operation op args).\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nintros.\nexploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves_ext accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b'.","conclusion":"forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves_ext accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b)","proofString":"induction b; simpl; intros.\ninv H.\nauto.\ndestruct a; try (inv H; apply BASE; auto; fail).\ndestruct (classify_operation op args).\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu mv : moves) (b' : bblock) (H : (rev accu, nil) = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\ expand_moves (rev accu) nil = expand_moves mv b'.","conclusion":"wf_moves mv /\\ expand_moves (rev accu) nil = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu mv : moves) (b' : bblock) (H : (rev accu, nil) = (mv, b')) (H0 : wf_moves accu)","proofString":"inv H.\nauto."},{"statement":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu : moves) (H0 : wf_moves accu) : wf_moves (rev accu) /\\\nexpand_moves (rev accu) nil = expand_moves (rev accu) nil.","conclusion":"wf_moves (rev accu) /\\\nexpand_moves (rev accu) nil = expand_moves (rev accu) nil","hypotheses":"(BASE : forall (accu0 : moves) (b : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b = expand_moves (rev accu0) b) (accu : moves) (H0 : wf_moves accu)","proofString":"auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (a : instruction) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match a with\n| Lop op args res =>\n    match classify_operation op args with\n    | operation_Omove arg => extract_moves_ext (MV (R arg) (R res) :: accu) b\n    | operation_Omakelong arg1 arg2 =>\n        extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b\n    | operation_Olowlong arg =>\n        extract_moves_ext (MVlowlong arg res :: accu) b\n    | operation_Ohighlong arg =>\n        extract_moves_ext (MVhighlong arg res :: accu) b\n    | operation_other _ _ => (rev accu, a :: b)\n    end\n| Lgetstack sl ofs ty dst =>\n    extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b\n| Lsetstack src sl ofs ty =>\n    extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b\n| _ => (rev accu, a :: b)\nend = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\ expand_moves (rev accu) (a :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\ expand_moves (rev accu) (a :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (a : instruction) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match a with\n| Lop op args res =>\n    match classify_operation op args with\n    | operation_Omove arg => extract_moves_ext (MV (R arg) (R res) :: accu) b\n    | operation_Omakelong arg1 arg2 =>\n        extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b\n    | operation_Olowlong arg =>\n        extract_moves_ext (MVlowlong arg res :: accu) b\n    | operation_Ohighlong arg =>\n        extract_moves_ext (MVhighlong arg res :: accu) b\n    | operation_other _ _ => (rev accu, a :: b)\n    end\n| Lgetstack sl ofs ty dst =>\n    extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b\n| Lsetstack src sl ofs ty =>\n    extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b\n| _ => (rev accu, a :: b)\nend = (mv, b')) (H0 : wf_moves accu)","proofString":"destruct a; try (inv H; apply BASE; auto; fail).\ndestruct (classify_operation op args).\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match classify_operation op args with\n| operation_Omove arg => extract_moves_ext (MV (R arg) (R res) :: accu) b\n| operation_Omakelong arg1 arg2 =>\n    extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b\n| operation_Olowlong arg => extract_moves_ext (MVlowlong arg res :: accu) b\n| operation_Ohighlong arg => extract_moves_ext (MVhighlong arg res :: accu) b\n| operation_other _ _ => (rev accu, Lop op args res :: b)\nend = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (op : operation) (args : list mreg) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : match classify_operation op args with\n| operation_Omove arg => extract_moves_ext (MV (R arg) (R res) :: accu) b\n| operation_Omakelong arg1 arg2 =>\n    extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b\n| operation_Olowlong arg => extract_moves_ext (MVlowlong arg res :: accu) b\n| operation_Ohighlong arg => extract_moves_ext (MVhighlong arg res :: accu) b\n| operation_other _ _ => (rev accu, Lop op args res :: b)\nend = (mv, b')) (H0 : wf_moves accu)","proofString":"destruct (classify_operation op args).\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\nexploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto.\ninv H; apply BASE; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (R arg) (R res) :: accu).","conclusion":"wf_moves (MV (R arg) (R res) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (R arg) (R res)).","conclusion":"wf_move (MV (R arg) (R res))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (R arg) (R res) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (R arg) (R res) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omove (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MV (R arg) (R res) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omakelong (arg1 :: arg2 :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop Omakelong (arg1 :: arg2 :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MVmakelong arg1 arg2 res :: accu).","conclusion":"wf_moves (MVmakelong arg1 arg2 res :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MVmakelong arg1 arg2 res).","conclusion":"wf_move (MVmakelong arg1 arg2 res)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MVmakelong arg1 arg2 res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omakelong (arg1 :: arg2 :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MVmakelong arg1 arg2 res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Omakelong (arg1 :: arg2 :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg1 arg2 : mreg) (H : extract_moves_ext (MVmakelong arg1 arg2 res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop Olowlong (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop Olowlong (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MVlowlong arg res :: accu).","conclusion":"wf_moves (MVlowlong arg res :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MVlowlong arg res).","conclusion":"wf_move (MVlowlong arg res)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MVlowlong arg res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Olowlong (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MVlowlong arg res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Olowlong (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVlowlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop Ohighlong (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop Ohighlong (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MVhighlong arg res :: accu).","conclusion":"wf_moves (MVhighlong arg res :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MVhighlong arg res).","conclusion":"wf_move (MVhighlong arg res)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MVhighlong arg res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Ohighlong (arg :: nil) res :: b) =\nexpand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MVhighlong arg res :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lop Ohighlong (arg :: nil) res :: b) =\nexpand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (arg : mreg) (H : extract_moves_ext (MVhighlong arg res :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (op : operation) (args : list mreg) (H : (rev accu, Lop op args res :: b) = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lop op args res :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (res : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (op : operation) (args : list mreg) (H : (rev accu, Lop op args res :: b) = (mv, b')) (H0 : wf_moves accu)","proofString":"inv H; apply BASE; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (S sl ofs ty) (R dst) :: accu).","conclusion":"wf_moves (MV (S sl ofs ty) (R dst) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (S sl ofs ty) (R dst)).","conclusion":"wf_move (MV (S sl ofs ty) (R dst))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (S sl ofs ty) (R dst) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (S sl ofs ty) (R dst) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lgetstack sl ofs ty dst :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (sl : slot) (ofs : Z) (ty : typ) (dst : mreg) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (S sl ofs ty) (R dst) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exploit IHb; eauto.\nconstructor; auto.\nexact I.\nrewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves (MV (R src) (S sl ofs ty) :: accu).","conclusion":"wf_moves (MV (R src) (S sl ofs ty) :: accu)","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"constructor; auto.\nexact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_move (MV (R src) (S sl ofs ty)).","conclusion":"wf_move (MV (R src) (S sl ofs ty))","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"exact I."},{"statement":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu) : wf_moves mv /\\\nexpand_moves (rev (MV (R src) (S sl ofs ty) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'.","conclusion":"wf_moves mv /\\\nexpand_moves (rev (MV (R src) (S sl ofs ty) :: accu)) b = expand_moves mv b' ->\nwf_moves mv /\\\nexpand_moves (rev accu) (Lsetstack src sl ofs ty :: b) = expand_moves mv b'","hypotheses":"(BASE : forall (accu0 : moves) (b0 : bblock),\nwf_moves accu0 ->\nwf_moves (rev accu0) /\\\nexpand_moves (rev accu0) b0 = expand_moves (rev accu0) b0) (src : mreg) (sl : slot) (ofs : Z) (ty : typ) (b : list instruction) (IHb : forall (accu0 mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu0 b = (mv0, b'0) ->\nwf_moves accu0 ->\nwf_moves mv0 /\\ expand_moves (rev accu0) b = expand_moves mv0 b'0) (accu mv : moves) (b' : bblock) (H : extract_moves_ext (MV (R src) (S sl ofs ty) :: accu) b = (mv, b')) (H0 : wf_moves accu)","proofString":"rewrite expand_moves_cons; auto."},{"statement":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) (IND : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves_ext accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b') : forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves_ext nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"forall (b : bblock) (mv : moves) (b' : bblock),\nextract_moves_ext nil b = (mv, b') -> wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\ expand_moves (rev accu) b = expand_moves (rev accu) b) (IND : forall (b : bblock) (accu mv : moves) (b' : bblock),\nextract_moves_ext accu b = (mv, b') ->\nwf_moves accu ->\nwf_moves mv /\\ expand_moves (rev accu) b = expand_moves mv b')","proofString":"intros.\nexploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves_ext nil b = (mv, b')) : wf_moves mv /\\ b = expand_moves mv b'.","conclusion":"wf_moves mv /\\ b = expand_moves mv b'","hypotheses":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves_ext nil b = (mv, b'))","proofString":"exploit IND; eauto.\nconstructor."},{"statement":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves_ext nil b = (mv, b')) : wf_moves nil.","conclusion":"wf_moves nil","hypotheses":"(BASE : forall (accu : moves) (b0 : bblock),\nwf_moves accu ->\nwf_moves (rev accu) /\\\nexpand_moves (rev accu) b0 = expand_moves (rev accu) b0) (IND : forall (b0 : bblock) (accu mv0 : moves) (b'0 : bblock),\nextract_moves_ext accu b0 = (mv0, b'0) ->\nwf_moves accu ->\nwf_moves mv0 /\\ expand_moves (rev accu) b0 = expand_moves mv0 b'0) (b : bblock) (mv : moves) (b' : bblock) (H : extract_moves_ext nil b = (mv, b'))","proofString":"constructor."},{"statement":"(s : node) (b : bblock) (H : check_succ s b = true) : exists k : list instruction, b = Lbranch s :: k.","conclusion":"exists k : list instruction, b = Lbranch s :: k","hypotheses":"(s : node) (b : bblock) (H : check_succ s b = true)","proofString":"destruct b; simpl in H; try discriminate.\ndestruct i; try discriminate.\ndestruct (peq s s0); simpl in H; inv H.\nexists b; auto."},{"statement":"(s : node) (i : instruction) (b : list instruction) (H : match i with\n| Lbranch s' => peq s s'\n| _ => false\nend = true) : exists k : list instruction, i :: b = Lbranch s :: k.","conclusion":"exists k : list instruction, i :: b = Lbranch s :: k","hypotheses":"(s : node) (i : instruction) (b : list instruction) (H : match i with\n| Lbranch s' => peq s s'\n| _ => false\nend = true)","proofString":"destruct i; try discriminate.\ndestruct (peq s s0); simpl in H; inv H.\nexists b; auto."},{"statement":"(s0 : node) (b : list instruction) : exists k : list instruction, Lbranch s0 :: b = Lbranch s0 :: k.","conclusion":"exists k : list instruction, Lbranch s0 :: b = Lbranch s0 :: k","hypotheses":"(s0 : node) (b : list instruction)","proofString":"exists b; auto."},{"statement":"forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b.","conclusion":"forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b","hypotheses":"","proofString":"unfold pair_Iop_block; intros.\nMonadInv.\ndestruct b0.\nMonadInv; UseParsingLemmas.\ndestruct i; MonadInv; UseParsingLemmas.\neapply ebs_op; eauto.\ninv H0.\neapply ebs_op_dead; eauto."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (H : (let (mv1, b1) := extract_moves nil b in\n match b1 with\n | Lop op' args' res' :: b2 =>\n     let (mv2, b3) := extract_moves nil b2 in\n     if eq_operation op op'\n     then\n      if check_succ s b3\n      then Some (BSop op args res mv1 args' res' mv2 s)\n      else None\n     else None\n | _ => if check_succ s b1 then Some (BSopdead op args res mv1 s) else None\n end) = Some bsh) : expand_block_shape bsh (Iop op args res s) b.","conclusion":"expand_block_shape bsh (Iop op args res s) b","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (H : (let (mv1, b1) := extract_moves nil b in\n match b1 with\n | Lop op' args' res' :: b2 =>\n     let (mv2, b3) := extract_moves nil b2 in\n     if eq_operation op op'\n     then\n      if check_succ s b3\n      then Some (BSop op args res mv1 args' res' mv2 s)\n      else None\n     else None\n | _ => if check_succ s b1 then Some (BSopdead op args res mv1 s) else None\n end) = Some bsh)","proofString":"MonadInv.\ndestruct b0.\nMonadInv; UseParsingLemmas.\ndestruct i; MonadInv; UseParsingLemmas.\neapply ebs_op; eauto.\ninv H0.\neapply ebs_op_dead; eauto."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (b0 : bblock) (Heqp : extract_moves nil b = (m, b0)) (H : match b0 with\n| Lop op' args' res' :: b2 =>\n    let (mv2, b3) := extract_moves nil b2 in\n    if eq_operation op op'\n    then\n     if check_succ s b3\n     then Some (BSop op args res m args' res' mv2 s)\n     else None\n    else None\n| _ => if check_succ s b0 then Some (BSopdead op args res m s) else None\nend = Some bsh) : expand_block_shape bsh (Iop op args res s) b.","conclusion":"expand_block_shape bsh (Iop op args res s) b","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (b0 : bblock) (Heqp : extract_moves nil b = (m, b0)) (H : match b0 with\n| Lop op' args' res' :: b2 =>\n    let (mv2, b3) := extract_moves nil b2 in\n    if eq_operation op op'\n    then\n     if check_succ s b3\n     then Some (BSop op args res m args' res' mv2 s)\n     else None\n    else None\n| _ => if check_succ s b0 then Some (BSopdead op args res m s) else None\nend = Some bsh)","proofString":"destruct b0.\nMonadInv; UseParsingLemmas.\ndestruct i; MonadInv; UseParsingLemmas.\neapply ebs_op; eauto.\ninv H0.\neapply ebs_op_dead; eauto."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (Heqp : extract_moves nil b = (m, nil)) (H : (if check_succ s nil then Some (BSopdead op args res m s) else None) =\nSome bsh) : expand_block_shape bsh (Iop op args res s) b.","conclusion":"expand_block_shape bsh (Iop op args res s) b","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (Heqp : extract_moves nil b = (m, nil)) (H : (if check_succ s nil then Some (BSopdead op args res m s) else None) =\nSome bsh)","proofString":"MonadInv; UseParsingLemmas."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (i : instruction) (b0 : list instruction) (Heqp : extract_moves nil b = (m, i :: b0)) (H : match i with\n| Lop op' args' res' =>\n    let (mv2, b3) := extract_moves nil b0 in\n    if eq_operation op op'\n    then\n     if check_succ s b3\n     then Some (BSop op args res m args' res' mv2 s)\n     else None\n    else None\n| _ =>\n    if check_succ s (i :: b0) then Some (BSopdead op args res m s) else None\nend = Some bsh) : expand_block_shape bsh (Iop op args res s) b.","conclusion":"expand_block_shape bsh (Iop op args res s) b","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (b : bblock) (bsh : block_shape) (m : moves) (i : instruction) (b0 : list instruction) (Heqp : extract_moves nil b = (m, i :: b0)) (H : match i with\n| Lop op' args' res' =>\n    let (mv2, b3) := extract_moves nil b0 in\n    if eq_operation op op'\n    then\n     if check_succ s b3\n     then Some (BSop op args res m args' res' mv2 s)\n     else None\n    else None\n| _ =>\n    if check_succ s (i :: b0) then Some (BSopdead op args res m s) else None\nend = Some bsh)","proofString":"destruct i; MonadInv; UseParsingLemmas.\neapply ebs_op; eauto.\ninv H0.\neapply ebs_op_dead; eauto."},{"statement":"(args : list reg) (res : reg) (s : node) (m : moves) (op0 : operation) (args0 : list mreg) (res0 : mreg) (m0 : moves) (H : wf_moves m0) (H0 : wf_moves m) (x : list instruction) : expand_block_shape (BSop op0 args res m args0 res0 m0 s) \n  (Iop op0 args res s)\n  (expand_moves m (Lop op0 args0 res0 :: expand_moves m0 (Lbranch s :: x))).","conclusion":"expand_block_shape (BSop op0 args res m args0 res0 m0 s) \n  (Iop op0 args res s)\n  (expand_moves m (Lop op0 args0 res0 :: expand_moves m0 (Lbranch s :: x)))","hypotheses":"(args : list reg) (res : reg) (s : node) (m : moves) (op0 : operation) (args0 : list mreg) (res0 : mreg) (m0 : moves) (H : wf_moves m0) (H0 : wf_moves m) (x : list instruction)","proofString":"eapply ebs_op; eauto."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (m : moves) (s0 : node) (b0 : list instruction) (H : wf_moves m) (x : list instruction) (H0 : Lbranch s0 :: b0 = Lbranch s :: x) : expand_block_shape (BSopdead op args res m s) (Iop op args res s)\n  (expand_moves m (Lbranch s0 :: b0)).","conclusion":"expand_block_shape (BSopdead op args res m s) (Iop op args res s)\n  (expand_moves m (Lbranch s0 :: b0))","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (m : moves) (s0 : node) (b0 : list instruction) (H : wf_moves m) (x : list instruction) (H0 : Lbranch s0 :: b0 = Lbranch s :: x)","proofString":"inv H0.\neapply ebs_op_dead; eauto."},{"statement":"(op : operation) (args : list reg) (res : reg) (s : node) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BSopdead op args res m s) (Iop op args res s)\n  (expand_moves m (Lbranch s :: x)).","conclusion":"expand_block_shape (BSopdead op args res m s) (Iop op args res s)\n  (expand_moves m (Lbranch s :: x))","hypotheses":"(op : operation) (args : list reg) (res : reg) (s : node) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"eapply ebs_op_dead; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) : forall (i : RTL.instruction) (b : bblock) (bsh : block_shape),\npair_instr_block i b = Some bsh -> expand_block_shape bsh i b.","conclusion":"forall (i : RTL.instruction) (b : bblock) (bsh : block_shape),\npair_instr_block i b = Some bsh -> expand_block_shape bsh i b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b)","proofString":"intros; destruct i; simpl in H; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct (classify_operation o l).\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\neauto.\ndestruct b0 as [ | [] b0]; MonadInv; UseParsingLemmas.\ndestruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_load2; eauto.\nInvBooleans.\nsubst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate.\neapply ebs_load; eauto.\ninv H.\neapply ebs_load_dead; eauto.\ndestruct b0; MonadInv.\ndestruct i; MonadInv; UseParsingLemmas.\ndestruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_store2; eauto.\neapply ebs_store; eauto.\ndestruct b0 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct b0 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct b1 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (n : RTL.node) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BSnop m n) (Inop n) (expand_moves m (Lbranch n :: x)).","conclusion":"expand_block_shape (BSnop m n) (Inop n) (expand_moves m (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (n : RTL.node) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (o : operation) (l : list reg) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (H : match classify_operation o l with\n| operation_Omove arg =>\n    let (mv, b1) := extract_moves nil b in\n    if check_succ n b1 then Some (BSmove arg r mv n) else None\n| operation_Omakelong arg1 arg2 =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_Olowlong arg =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BSlowlong arg r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_Ohighlong arg =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BShighlong arg r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_other _ _ => pair_Iop_block o l r n b\nend = Some bsh) : expand_block_shape bsh (Iop o l r n) b.","conclusion":"expand_block_shape bsh (Iop o l r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (o : operation) (l : list reg) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (H : match classify_operation o l with\n| operation_Omove arg =>\n    let (mv, b1) := extract_moves nil b in\n    if check_succ n b1 then Some (BSmove arg r mv n) else None\n| operation_Omakelong arg1 arg2 =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_Olowlong arg =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BSlowlong arg r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_Ohighlong arg =>\n    if Archi.splitlong\n    then\n     let (mv, b1) := extract_moves nil b in\n     if check_succ n b1 then Some (BShighlong arg r mv n) else None\n    else pair_Iop_block o l r n b\n| operation_other _ _ => pair_Iop_block o l r n b\nend = Some bsh)","proofString":"destruct (classify_operation o l).\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\ndestruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto.\neauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSmove arg r mv n) else None) = \nSome bsh) : expand_block_shape bsh (Iop Omove (arg :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Omove (arg :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSmove arg r mv n) else None) = \nSome bsh)","proofString":"MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BSmove arg r m n) (Iop Omove (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x)).","conclusion":"expand_block_shape (BSmove arg r m n) (Iop Omove (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg1 arg2 : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None\n else pair_Iop_block Omakelong (arg1 :: arg2 :: nil) r n b) = \nSome bsh) : expand_block_shape bsh (Iop Omakelong (arg1 :: arg2 :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Omakelong (arg1 :: arg2 :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg1 arg2 : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None\n else pair_Iop_block Omakelong (arg1 :: arg2 :: nil) r n b) = \nSome bsh)","proofString":"destruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg1 arg2 : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None) =\nSome bsh) : expand_block_shape bsh (Iop Omakelong (arg1 :: arg2 :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Omakelong (arg1 :: arg2 :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg1 arg2 : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSmakelong arg1 arg2 r mv n) else None) =\nSome bsh)","proofString":"MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg1 arg2 : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BSmakelong arg1 arg2 r m n)\n  (Iop Omakelong (arg1 :: arg2 :: nil) r n) (expand_moves m (Lbranch n :: x)).","conclusion":"expand_block_shape (BSmakelong arg1 arg2 r m n)\n  (Iop Omakelong (arg1 :: arg2 :: nil) r n) (expand_moves m (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg1 arg2 : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BSlowlong arg r mv n) else None\n else pair_Iop_block Olowlong (arg :: nil) r n b) = \nSome bsh) : expand_block_shape bsh (Iop Olowlong (arg :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Olowlong (arg :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BSlowlong arg r mv n) else None\n else pair_Iop_block Olowlong (arg :: nil) r n b) = \nSome bsh)","proofString":"destruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSlowlong arg r mv n) else None) = \nSome bsh) : expand_block_shape bsh (Iop Olowlong (arg :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Olowlong (arg :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BSlowlong arg r mv n) else None) = \nSome bsh)","proofString":"MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BSlowlong arg r m n) (Iop Olowlong (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x)).","conclusion":"expand_block_shape (BSlowlong arg r m n) (Iop Olowlong (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BShighlong arg r mv n) else None\n else pair_Iop_block Ohighlong (arg :: nil) r n b) = \nSome bsh) : expand_block_shape bsh (Iop Ohighlong (arg :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Ohighlong (arg :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (H : (if Archi.splitlong\n then\n  let (mv, b1) := extract_moves nil b in\n  if check_succ n b1 then Some (BShighlong arg r mv n) else None\n else pair_Iop_block Ohighlong (arg :: nil) r n b) = \nSome bsh)","proofString":"destruct Archi.splitlong eqn:SL; eauto.\nMonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BShighlong arg r mv n) else None) = \nSome bsh) : expand_block_shape bsh (Iop Ohighlong (arg :: nil) r n) b.","conclusion":"expand_block_shape bsh (Iop Ohighlong (arg :: nil) r n) b","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (arg : reg) (SL : Archi.splitlong = true) (H : (let (mv, b1) := extract_moves nil b in\n if check_succ n b1 then Some (BShighlong arg r mv n) else None) = \nSome bsh)","proofString":"MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction) : expand_block_shape (BShighlong arg r m n) (Iop Ohighlong (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x)).","conclusion":"expand_block_shape (BShighlong arg r m n) (Iop Ohighlong (arg :: nil) r n)\n  (expand_moves m (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (n : RTL.node) (arg : reg) (SL : Archi.splitlong = true) (m : moves) (H : wf_moves m) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op0 : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op0 args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op0 args0 res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (op : operation) (args : list reg) (H : pair_Iop_block op args r n b = Some bsh) : expand_block_shape bsh (Iop op args r n) b.","conclusion":"expand_block_shape bsh (Iop op args r n) b","hypotheses":"(OP : forall (op0 : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op0 args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op0 args0 res s) b0) (r : reg) (n : RTL.node) (b : bblock) (bsh : block_shape) (op : operation) (args : list reg) (H : pair_Iop_block op args r n b = Some bsh)","proofString":"eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (b0 : bblock) (H : match b0 with\n| Lload chunk' addr' args' dst' :: b2 =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     if chunk_eq chunk' Mint32\n     then\n      let (mv2, b3) := extract_moves nil b2 in\n      match b3 with\n      | Lload chunk'' addr'' args'' dst'' :: b4 =>\n          let (mv3, b5) := extract_moves nil b4 in\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b5\n             then\n              Some\n                (BSload2 a addr'' l r m0 args' dst' mv2 args'' dst'' mv3 n)\n             else None\n            else None\n           else None\n          else None\n      | _ =>\n          if check_succ n b3\n          then\n           if eq_addressing a addr'\n           then Some (BSload2_1 a l r m0 args' dst' mv2 n)\n           else\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr')\n            then Some (BSload2_2 a addr' l r m0 args' dst' mv2 n)\n            else None\n          else None\n      end\n     else None\n    else\n     let (mv2, b3) := extract_moves nil b2 in\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b3\n       then Some (BSload m a l r m0 args' dst' mv2 n)\n       else None\n      else None\n     else None\n| _ => if check_succ n b0 then Some (BSloaddead m a l r m0 n) else None\nend = Some bsh) (H0 : wf_moves m0) : expand_block_shape bsh (Iload m a l r n) (expand_moves m0 b0).","conclusion":"expand_block_shape bsh (Iload m a l r n) (expand_moves m0 b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (b0 : bblock) (H : match b0 with\n| Lload chunk' addr' args' dst' :: b2 =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     if chunk_eq chunk' Mint32\n     then\n      let (mv2, b3) := extract_moves nil b2 in\n      match b3 with\n      | Lload chunk'' addr'' args'' dst'' :: b4 =>\n          let (mv3, b5) := extract_moves nil b4 in\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b5\n             then\n              Some\n                (BSload2 a addr'' l r m0 args' dst' mv2 args'' dst'' mv3 n)\n             else None\n            else None\n           else None\n          else None\n      | _ =>\n          if check_succ n b3\n          then\n           if eq_addressing a addr'\n           then Some (BSload2_1 a l r m0 args' dst' mv2 n)\n           else\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr')\n            then Some (BSload2_2 a addr' l r m0 args' dst' mv2 n)\n            else None\n          else None\n      end\n     else None\n    else\n     let (mv2, b3) := extract_moves nil b2 in\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b3\n       then Some (BSload m a l r m0 args' dst' mv2 n)\n       else None\n      else None\n     else None\n| _ => if check_succ n b0 then Some (BSloaddead m a l r m0 n) else None\nend = Some bsh) (H0 : wf_moves m0)","proofString":"destruct b0 as [ | [] b0]; MonadInv; UseParsingLemmas.\ndestruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_load2; eauto.\nInvBooleans.\nsubst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate.\neapply ebs_load; eauto.\ninv H.\neapply ebs_load_dead; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b0 : list instruction) (H : (if chunk_eq m Mint64 && Archi.splitlong\n then\n  if chunk_eq chunk Mint32\n  then\n   let (mv2, b3) := extract_moves nil b0 in\n   match b3 with\n   | Lload chunk'' addr'' args'' dst'' :: b4 =>\n       let (mv3, b5) := extract_moves nil b4 in\n       if chunk_eq chunk'' Mint32\n       then\n        if eq_addressing a addr\n        then\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n         then\n          if check_succ n b5\n          then Some (BSload2 a addr'' l r m0 args dst mv2 args'' dst'' mv3 n)\n          else None\n         else None\n        else None\n       else None\n   | _ =>\n       if check_succ n b3\n       then\n        if eq_addressing a addr\n        then Some (BSload2_1 a l r m0 args dst mv2 n)\n        else\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n         then Some (BSload2_2 a addr l r m0 args dst mv2 n)\n         else None\n       else None\n   end\n  else None\n else\n  let (mv2, b3) := extract_moves nil b0 in\n  if chunk_eq m chunk\n  then\n   if eq_addressing a addr\n   then\n    if check_succ n b3 then Some (BSload m a l r m0 args dst mv2 n) else None\n   else None\n  else None) = Some bsh) (H0 : wf_moves m0) : expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0 (Lload chunk addr args dst :: b0)).","conclusion":"expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0 (Lload chunk addr args dst :: b0))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (b0 : list instruction) (H : (if chunk_eq m Mint64 && Archi.splitlong\n then\n  if chunk_eq chunk Mint32\n  then\n   let (mv2, b3) := extract_moves nil b0 in\n   match b3 with\n   | Lload chunk'' addr'' args'' dst'' :: b4 =>\n       let (mv3, b5) := extract_moves nil b4 in\n       if chunk_eq chunk'' Mint32\n       then\n        if eq_addressing a addr\n        then\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n         then\n          if check_succ n b5\n          then Some (BSload2 a addr'' l r m0 args dst mv2 args'' dst'' mv3 n)\n          else None\n         else None\n        else None\n       else None\n   | _ =>\n       if check_succ n b3\n       then\n        if eq_addressing a addr\n        then Some (BSload2_1 a l r m0 args dst mv2 n)\n        else\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n         then Some (BSload2_2 a addr l r m0 args dst mv2 n)\n         else None\n       else None\n   end\n  else None\n else\n  let (mv2, b3) := extract_moves nil b0 in\n  if chunk_eq m chunk\n  then\n   if eq_addressing a addr\n   then\n    if check_succ n b3 then Some (BSload m a l r m0 args dst mv2 n) else None\n   else None\n  else None) = Some bsh) (H0 : wf_moves m0)","proofString":"destruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_load2; eauto.\nInvBooleans.\nsubst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate.\neapply ebs_load; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (b : bblock) (H : match b with\n| Lload chunk'' addr'' args'' dst'' :: b4 =>\n    let (mv3, b5) := extract_moves nil b4 in\n    if chunk_eq chunk'' Mint32\n    then\n     if eq_addressing a addr\n     then\n      if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n      then\n       if check_succ n b5\n       then Some (BSload2 a addr'' l r m0 args dst m1 args'' dst'' mv3 n)\n       else None\n      else None\n     else None\n    else None\n| _ =>\n    if check_succ n b\n    then\n     if eq_addressing a addr\n     then Some (BSload2_1 a l r m0 args dst m1 n)\n     else\n      if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n      then Some (BSload2_2 a addr l r m0 args dst m1 n)\n      else None\n    else None\nend = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) : expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0 (Lload Mint32 addr args dst :: expand_moves m1 b)).","conclusion":"expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0 (Lload Mint32 addr args dst :: expand_moves m1 b))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (b : bblock) (H : match b with\n| Lload chunk'' addr'' args'' dst'' :: b4 =>\n    let (mv3, b5) := extract_moves nil b4 in\n    if chunk_eq chunk'' Mint32\n    then\n     if eq_addressing a addr\n     then\n      if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n      then\n       if check_succ n b5\n       then Some (BSload2 a addr'' l r m0 args dst m1 args'' dst'' mv3 n)\n       else None\n      else None\n     else None\n    else None\n| _ =>\n    if check_succ n b\n    then\n     if eq_addressing a addr\n     then Some (BSload2_1 a l r m0 args dst m1 n)\n     else\n      if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n      then Some (BSload2_2 a addr l r m0 args dst m1 n)\n      else None\n    else None\nend = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1)","proofString":"destruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_load2; eauto.\nInvBooleans.\nsubst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction) : expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload m addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x)))).","conclusion":"expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload m addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x))))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction)","proofString":"InvBooleans.\nsubst m.\neapply ebs_load2; eauto."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction) (H3 : Archi.splitlong = true) (H2 : m = Mint64) : expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload m addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x)))).","conclusion":"expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload m addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x))))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction) (H3 : Archi.splitlong = true) (H2 : m = Mint64)","proofString":"subst m.\neapply ebs_load2; eauto."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction) (H3 : Archi.splitlong = true) : expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload Mint64 addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x)))).","conclusion":"expand_block_shape (BSload2 addr addr0 l r m0 args dst m1 args0 dst0 m2 n)\n  (Iload Mint64 addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst\n      :: expand_moves m1\n           (Lload Mint32 addr0 args0 dst0 :: expand_moves m2 (Lbranch n :: x))))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (dst0 : mreg) (m2 : moves) (e1 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (H : wf_moves m2) (x : list instruction) (H3 : Archi.splitlong = true)","proofString":"eapply ebs_load2; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) : expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x)","proofString":"InvBooleans.\nsubst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) (H3 : m = Mint64) : expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload m a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) (H3 : m = Mint64)","proofString":"subst m.\ndestruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) : expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (H : (if eq_addressing a addr\n then Some (BSload2_1 a l r m0 args dst m1 n)\n else\n  if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n  then Some (BSload2_2 a addr l r m0 args dst m1 n)\n  else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true)","proofString":"destruct (eq_addressing a addr).\ninv H; inv H2.\neapply ebs_load2_1; eauto.\ndestruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (e : a = addr) (H : Some (BSload2_1 a l r m0 args dst m1 n) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) : expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (e : a = addr) (H : Some (BSload2_1 a l r m0 args dst m1 n) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true)","proofString":"inv H; inv H2.\neapply ebs_load2_1; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H4 : Archi.splitlong = true) : expand_block_shape (BSload2_1 addr l r m0 args dst m1 n)\n  (Iload Mint64 addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch n :: x))).","conclusion":"expand_block_shape (BSload2_1 addr l r m0 args dst m1 n)\n  (Iload Mint64 addr l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H4 : Archi.splitlong = true)","proofString":"eapply ebs_load2_1; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (H : (if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n then Some (BSload2_2 a addr l r m0 args dst m1 n)\n else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) : expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (H : (if option_eq eq_addressing (offset_addressing a 4) (Some addr)\n then Some (BSload2_2 a addr l r m0 args dst m1 n)\n else None) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true)","proofString":"destruct (option_eq eq_addressing (offset_addressing a 4) (Some addr)).\ninv H; inv H2.\neapply ebs_load2_2; eauto.\ndiscriminate."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (e : offset_addressing a 4 = Some addr) (H : Some (BSload2_2 a addr l r m0 args dst m1 n) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) : expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (e : offset_addressing a 4 = Some addr) (H : Some (BSload2_2 a addr l r m0 args dst m1 n) = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true)","proofString":"inv H; inv H2.\neapply ebs_load2_2; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (n0 : a <> addr) (e : offset_addressing a 4 = Some addr) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H4 : Archi.splitlong = true) : expand_block_shape (BSload2_2 a addr l r m0 args dst m1 n)\n  (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch n :: x))).","conclusion":"expand_block_shape (BSload2_2 a addr l r m0 args dst m1 n)\n  (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (n0 : a <> addr) (e : offset_addressing a 4 = Some addr) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H4 : Archi.splitlong = true)","proofString":"eapply ebs_load2_2; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (n1 : offset_addressing a 4 <> Some addr) (H : None = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true) : expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b))).","conclusion":"expand_block_shape bsh (Iload Mint64 a l r n)\n  (expand_moves m0\n     (Lload Mint32 addr args dst :: expand_moves m1 (Lbranch s :: b)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s0 : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s0 b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s0) b0) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (addr : addressing) (args : list mreg) (dst : mreg) (m1 : moves) (s : node) (b : list instruction) (n0 : a <> addr) (n1 : offset_addressing a 4 <> Some addr) (H : None = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Lbranch s :: b = Lbranch n :: x) (H4 : Archi.splitlong = true)","proofString":"discriminate."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq chunk Mint64 && Archi.splitlong = false) (m1 : moves) (H0 : wf_moves m0) (H : wf_moves m1) (x : list instruction) : expand_block_shape (BSload chunk addr l r m0 args dst m1 n)\n  (Iload chunk addr l r n)\n  (expand_moves m0\n     (Lload chunk addr args dst :: expand_moves m1 (Lbranch n :: x))).","conclusion":"expand_block_shape (BSload chunk addr l r m0 args dst m1 n)\n  (Iload chunk addr l r n)\n  (expand_moves m0\n     (Lload chunk addr args dst :: expand_moves m1 (Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (dst : mreg) (A : chunk_eq chunk Mint64 && Archi.splitlong = false) (m1 : moves) (H0 : wf_moves m0) (H : wf_moves m1) (x : list instruction)","proofString":"eapply ebs_load; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s0 : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s0 b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s0) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (s : node) (b0 : list instruction) (H0 : wf_moves m0) (x : list instruction) (H : Lbranch s :: b0 = Lbranch n :: x) : expand_block_shape (BSloaddead m a l r m0 n) (Iload m a l r n)\n  (expand_moves m0 (Lbranch s :: b0)).","conclusion":"expand_block_shape (BSloaddead m a l r m0 n) (Iload m a l r n)\n  (expand_moves m0 (Lbranch s :: b0))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s0 : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s0 b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s0) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (s : node) (b0 : list instruction) (H0 : wf_moves m0) (x : list instruction) (H : Lbranch s :: b0 = Lbranch n :: x)","proofString":"inv H.\neapply ebs_load_dead; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (H0 : wf_moves m0) (x : list instruction) : expand_block_shape (BSloaddead m a l r m0 n) (Iload m a l r n)\n  (expand_moves m0 (Lbranch n :: x)).","conclusion":"expand_block_shape (BSloaddead m a l r m0 n) (Iload m a l r n)\n  (expand_moves m0 (Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (H0 : wf_moves m0) (x : list instruction)","proofString":"eapply ebs_load_dead; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (b0 : bblock) (H : match b0 with\n| Lstore chunk' addr' args' src' :: b2 =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     let (mv2, b3) := extract_moves nil b2 in\n     match b3 with\n     | Lstore chunk'' addr'' args'' src'' :: b4 =>\n         if chunk_eq chunk' Mint32\n         then\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b4\n             then\n              Some (BSstore2 a addr'' l r m0 args' src' mv2 args'' src'' n)\n             else None\n            else None\n           else None\n          else None\n         else None\n     | _ => None\n     end\n    else\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b2\n       then Some (BSstore m a l r m0 args' src' n)\n       else None\n      else None\n     else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0) : expand_block_shape bsh (Istore m a l r n) (expand_moves m0 b0).","conclusion":"expand_block_shape bsh (Istore m a l r n) (expand_moves m0 b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (b0 : bblock) (H : match b0 with\n| Lstore chunk' addr' args' src' :: b2 =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     let (mv2, b3) := extract_moves nil b2 in\n     match b3 with\n     | Lstore chunk'' addr'' args'' src'' :: b4 =>\n         if chunk_eq chunk' Mint32\n         then\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b4\n             then\n              Some (BSstore2 a addr'' l r m0 args' src' mv2 args'' src'' n)\n             else None\n            else None\n           else None\n          else None\n         else None\n     | _ => None\n     end\n    else\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b2\n       then Some (BSstore m a l r m0 args' src' n)\n       else None\n      else None\n     else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0)","proofString":"destruct b0; MonadInv.\ndestruct i; MonadInv; UseParsingLemmas.\ndestruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_store2; eauto.\neapply ebs_store; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (i : instruction) (b0 : list instruction) (H : match i with\n| Lstore chunk' addr' args' src' =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     let (mv2, b3) := extract_moves nil b0 in\n     match b3 with\n     | Lstore chunk'' addr'' args'' src'' :: b4 =>\n         if chunk_eq chunk' Mint32\n         then\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b4\n             then\n              Some (BSstore2 a addr'' l r m0 args' src' mv2 args'' src'' n)\n             else None\n            else None\n           else None\n          else None\n         else None\n     | _ => None\n     end\n    else\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b0\n       then Some (BSstore m a l r m0 args' src' n)\n       else None\n      else None\n     else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0) : expand_block_shape bsh (Istore m a l r n) (expand_moves m0 (i :: b0)).","conclusion":"expand_block_shape bsh (Istore m a l r n) (expand_moves m0 (i :: b0))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (i : instruction) (b0 : list instruction) (H : match i with\n| Lstore chunk' addr' args' src' =>\n    if chunk_eq m Mint64 && Archi.splitlong\n    then\n     let (mv2, b3) := extract_moves nil b0 in\n     match b3 with\n     | Lstore chunk'' addr'' args'' src'' :: b4 =>\n         if chunk_eq chunk' Mint32\n         then\n          if chunk_eq chunk'' Mint32\n          then\n           if eq_addressing a addr'\n           then\n            if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n            then\n             if check_succ n b4\n             then\n              Some (BSstore2 a addr'' l r m0 args' src' mv2 args'' src'' n)\n             else None\n            else None\n           else None\n          else None\n         else None\n     | _ => None\n     end\n    else\n     if chunk_eq m chunk'\n     then\n      if eq_addressing a addr'\n      then\n       if check_succ n b0\n       then Some (BSstore m a l r m0 args' src' n)\n       else None\n      else None\n     else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0)","proofString":"destruct i; MonadInv; UseParsingLemmas.\ndestruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_store2; eauto.\neapply ebs_store; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b0 : list instruction) (H : (if chunk_eq m Mint64 && Archi.splitlong\n then\n  let (mv2, b3) := extract_moves nil b0 in\n  match b3 with\n  | Lstore chunk'' addr'' args'' src'' :: b4 =>\n      if chunk_eq chunk Mint32\n      then\n       if chunk_eq chunk'' Mint32\n       then\n        if eq_addressing a addr\n        then\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n         then\n          if check_succ n b4\n          then Some (BSstore2 a addr'' l r m0 args src mv2 args'' src'' n)\n          else None\n         else None\n        else None\n       else None\n      else None\n  | _ => None\n  end\n else\n  if chunk_eq m chunk\n  then\n   if eq_addressing a addr\n   then\n    if check_succ n b0 then Some (BSstore m a l r m0 args src n) else None\n   else None\n  else None) = Some bsh) (H0 : wf_moves m0) : expand_block_shape bsh (Istore m a l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: b0)).","conclusion":"expand_block_shape bsh (Istore m a l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: b0))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (b0 : list instruction) (H : (if chunk_eq m Mint64 && Archi.splitlong\n then\n  let (mv2, b3) := extract_moves nil b0 in\n  match b3 with\n  | Lstore chunk'' addr'' args'' src'' :: b4 =>\n      if chunk_eq chunk Mint32\n      then\n       if chunk_eq chunk'' Mint32\n       then\n        if eq_addressing a addr\n        then\n         if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n         then\n          if check_succ n b4\n          then Some (BSstore2 a addr'' l r m0 args src mv2 args'' src'' n)\n          else None\n         else None\n        else None\n       else None\n      else None\n  | _ => None\n  end\n else\n  if chunk_eq m chunk\n  then\n   if eq_addressing a addr\n   then\n    if check_succ n b0 then Some (BSstore m a l r m0 args src n) else None\n   else None\n  else None) = Some bsh) (H0 : wf_moves m0)","proofString":"destruct (chunk_eq m Mint64 && Archi.splitlong) eqn:A; MonadInv; UseParsingLemmas.\ndestruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_store2; eauto.\neapply ebs_store; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (b : bblock) (H : match b with\n| Lstore chunk'' addr'' args'' src'' :: b4 =>\n    if chunk_eq chunk Mint32\n    then\n     if chunk_eq chunk'' Mint32\n     then\n      if eq_addressing a addr\n      then\n       if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n       then\n        if check_succ n b4\n        then Some (BSstore2 a addr'' l r m0 args src m1 args'' src'' n)\n        else None\n       else None\n      else None\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1) : expand_block_shape bsh (Istore m a l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: expand_moves m1 b)).","conclusion":"expand_block_shape bsh (Istore m a l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: expand_moves m1 b))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b0 : bblock) (bsh0 : block_shape),\npair_Iop_block op args0 res s b0 = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args0 res s) b0) (m : memory_chunk) (a : addressing) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (b : bblock) (H : match b with\n| Lstore chunk'' addr'' args'' src'' :: b4 =>\n    if chunk_eq chunk Mint32\n    then\n     if chunk_eq chunk'' Mint32\n     then\n      if eq_addressing a addr\n      then\n       if option_eq eq_addressing (offset_addressing a 4) (Some addr'')\n       then\n        if check_succ n b4\n        then Some (BSstore2 a addr'' l r m0 args src m1 args'' src'' n)\n        else None\n       else None\n      else None\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m0) (H1 : wf_moves m1)","proofString":"destruct b as [ | [] b]; MonadInv; UseParsingLemmas.\nInvBooleans.\nsubst m.\neapply ebs_store2; eauto."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) : expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore m addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x))).","conclusion":"expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore m addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq m Mint64 && Archi.splitlong = true) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction)","proofString":"InvBooleans.\nsubst m.\neapply ebs_store2; eauto."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Archi.splitlong = true) (H : m = Mint64) : expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore m addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x))).","conclusion":"expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore m addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (m : memory_chunk) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Archi.splitlong = true) (H : m = Mint64)","proofString":"subst m.\neapply ebs_store2; eauto."},{"statement":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Archi.splitlong = true) : expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore Mint64 addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x))).","conclusion":"expand_block_shape (BSstore2 addr addr0 l r m0 args src m1 args0 src0 n)\n  (Istore Mint64 addr l r n)\n  (expand_moves m0\n     (Lstore Mint32 addr args src\n      :: expand_moves m1 (Lstore Mint32 addr0 args0 src0 :: Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args1 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args1 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args1 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (addr : addressing) (args : list mreg) (src : mreg) (m1 : moves) (addr0 : addressing) (args0 : list mreg) (src0 : mreg) (e2 : offset_addressing addr 4 = Some addr0) (H0 : wf_moves m0) (H1 : wf_moves m1) (x : list instruction) (H2 : Archi.splitlong = true)","proofString":"eapply ebs_store2; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq chunk Mint64 && Archi.splitlong = false) (H0 : wf_moves m0) (x : list instruction) : expand_block_shape (BSstore chunk addr l r m0 args src n)\n  (Istore chunk addr l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: Lbranch n :: x)).","conclusion":"expand_block_shape (BSstore chunk addr l r m0 args src n)\n  (Istore chunk addr l r n)\n  (expand_moves m0 (Lstore chunk addr args src :: Lbranch n :: x))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (r : reg) (n : RTL.node) (m0 : moves) (chunk : memory_chunk) (addr : addressing) (args : list mreg) (src : mreg) (A : chunk_eq chunk Mint64 && Archi.splitlong = false) (H0 : wf_moves m0) (x : list instruction)","proofString":"eapply ebs_store; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s1 : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s1 b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s1) b) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lcall sg' ros' :: b2 =>\n    let (mv2, b3) := extract_moves_ext nil b2 in\n    if signature_eq s sg'\n    then\n     if check_succ n b3 then Some (BScall s s0 l r m ros' mv2 n) else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Icall s s0 l r n) (expand_moves m b0).","conclusion":"expand_block_shape bsh (Icall s s0 l r n) (expand_moves m b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s1 : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s1 b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s1) b) (s : signature) (s0 : reg + ident) (l : list reg) (r : reg) (n : RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lcall sg' ros' :: b2 =>\n    let (mv2, b3) := extract_moves_ext nil b2 in\n    if signature_eq s sg'\n    then\n     if check_succ n b3 then Some (BScall s s0 l r m ros' mv2 n) else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b0 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (s0 : reg + ident) (l : list reg) (r : reg) (n : RTL.node) (m : moves) (sg : signature) (ros : mreg + ident) (m0 : moves) (H0 : wf_moves m) (H : wf_moves m0) (x : list instruction) : expand_block_shape (BScall sg s0 l r m ros m0 n) (Icall sg s0 l r n)\n  (expand_moves m (Lcall sg ros :: expand_moves m0 (Lbranch n :: x))).","conclusion":"expand_block_shape (BScall sg s0 l r m ros m0 n) (Icall sg s0 l r n)\n  (expand_moves m (Lcall sg ros :: expand_moves m0 (Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (s0 : reg + ident) (l : list reg) (r : reg) (n : RTL.node) (m : moves) (sg : signature) (ros : mreg + ident) (m0 : moves) (H0 : wf_moves m) (H : wf_moves m0) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s1 : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s1 b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s1) b) (s : signature) (s0 : reg + ident) (l : list reg) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Ltailcall sg' ros' :: _ =>\n    if signature_eq s sg' then Some (BStailcall s s0 l m ros') else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Itailcall s s0 l) (expand_moves m b0).","conclusion":"expand_block_shape bsh (Itailcall s s0 l) (expand_moves m b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s1 : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s1 b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s1) b) (s : signature) (s0 : reg + ident) (l : list reg) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Ltailcall sg' ros' :: _ =>\n    if signature_eq s sg' then Some (BStailcall s s0 l m ros') else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b0 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (s0 : reg + ident) (l : list reg) (m : moves) (sg : signature) (ros : mreg + ident) (b0 : list instruction) (H0 : wf_moves m) : expand_block_shape (BStailcall sg s0 l m ros) (Itailcall sg s0 l)\n  (expand_moves m (Ltailcall sg ros :: b0)).","conclusion":"expand_block_shape (BStailcall sg s0 l m ros) (Itailcall sg s0 l)\n  (expand_moves m (Ltailcall sg ros :: b0))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (s0 : reg + ident) (l : list reg) (m : moves) (sg : signature) (ros : mreg + ident) (b0 : list instruction) (H0 : wf_moves m)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (e : external_function) (l : list (builtin_arg reg)) (b0 : builtin_res reg) (n : RTL.node) (bsh : block_shape) (m : moves) (b1 : bblock) (H : match b1 with\n| Lbuiltin ef' args' res' :: b2 =>\n    let (mv2, b3) := extract_moves nil b2 in\n    if external_function_eq e ef'\n    then\n     if check_succ n b3\n     then Some (BSbuiltin e l b0 m args' res' mv2 n)\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Ibuiltin e l b0 n) (expand_moves m b1).","conclusion":"expand_block_shape bsh (Ibuiltin e l b0 n) (expand_moves m b1)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (e : external_function) (l : list (builtin_arg reg)) (b0 : builtin_res reg) (n : RTL.node) (bsh : block_shape) (m : moves) (b1 : bblock) (H : match b1 with\n| Lbuiltin ef' args' res' :: b2 =>\n    let (mv2, b3) := extract_moves nil b2 in\n    if external_function_eq e ef'\n    then\n     if check_succ n b3\n     then Some (BSbuiltin e l b0 m args' res' mv2 n)\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b1 as [|[] ]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res0 : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res0 s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res0 s) b) (l : list (builtin_arg reg)) (b0 : builtin_res reg) (n : RTL.node) (m : moves) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (m0 : moves) (H0 : wf_moves m) (H : wf_moves m0) (x : list instruction) : expand_block_shape (BSbuiltin ef l b0 m args res m0 n) \n  (Ibuiltin ef l b0 n)\n  (expand_moves m (Lbuiltin ef args res :: expand_moves m0 (Lbranch n :: x))).","conclusion":"expand_block_shape (BSbuiltin ef l b0 m args res m0 n) \n  (Ibuiltin ef l b0 n)\n  (expand_moves m (Lbuiltin ef args res :: expand_moves m0 (Lbranch n :: x)))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res0 : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res0 s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res0 s) b) (l : list (builtin_arg reg)) (b0 : builtin_res reg) (n : RTL.node) (m : moves) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (m0 : moves) (H0 : wf_moves m) (H : wf_moves m0) (x : list instruction)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (c : condition) (l : list reg) (n n0 : RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lcond cond' args' s1' s2' :: _ =>\n    if eq_condition c cond'\n    then\n     if peq n s1'\n     then if peq n0 s2' then Some (BScond c l m args' n n0) else None\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Icond c l n n0) (expand_moves m b0).","conclusion":"expand_block_shape bsh (Icond c l n n0) (expand_moves m b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (c : condition) (l : list reg) (n n0 : RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lcond cond' args' s1' s2' :: _ =>\n    if eq_condition c cond'\n    then\n     if peq n s1'\n     then if peq n0 s2' then Some (BScond c l m args' n n0) else None\n     else None\n    else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (m : moves) (cond : condition) (args : list mreg) (s1 s2 : node) (b0 : list instruction) (H0 : wf_moves m) : expand_block_shape (BScond cond l m args s1 s2) (Icond cond l s1 s2)\n  (expand_moves m (Lcond cond args s1 s2 :: b0)).","conclusion":"expand_block_shape (BScond cond l m args s1 s2) (Icond cond l s1 s2)\n  (expand_moves m (Lcond cond args s1 s2 :: b0))","hypotheses":"(OP : forall (op : operation) (args0 : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args0 res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args0 res s) b) (l : list reg) (m : moves) (cond : condition) (args : list mreg) (s1 s2 : node) (b0 : list instruction) (H0 : wf_moves m)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (r : reg) (l : list RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Ljumptable arg' tbl' :: _ =>\n    if list_eq_dec peq l tbl' then Some (BSjumptable r m arg' l) else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Ijumptable r l) (expand_moves m b0).","conclusion":"expand_block_shape bsh (Ijumptable r l) (expand_moves m b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (r : reg) (l : list RTL.node) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Ljumptable arg' tbl' :: _ =>\n    if list_eq_dec peq l tbl' then Some (BSjumptable r m arg' l) else None\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (m : moves) (arg : mreg) (tbl : list node) (b0 : list instruction) (H0 : wf_moves m) : expand_block_shape (BSjumptable r m arg tbl) (Ijumptable r tbl)\n  (expand_moves m (Ljumptable arg tbl :: b0)).","conclusion":"expand_block_shape (BSjumptable r m arg tbl) (Ijumptable r tbl)\n  (expand_moves m (Ljumptable arg tbl :: b0))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (r : reg) (m : moves) (arg : mreg) (tbl : list node) (b0 : list instruction) (H0 : wf_moves m)","proofString":"econstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (o : option reg) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lreturn :: _ => Some (BSreturn o m)\n| _ => None\nend = Some bsh) (H0 : wf_moves m) : expand_block_shape bsh (Ireturn o) (expand_moves m b0).","conclusion":"expand_block_shape bsh (Ireturn o) (expand_moves m b0)","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh0 : block_shape),\npair_Iop_block op args res s b = Some bsh0 ->\nexpand_block_shape bsh0 (Iop op args res s) b) (o : option reg) (bsh : block_shape) (m : moves) (b0 : bblock) (H : match b0 with\n| Lreturn :: _ => Some (BSreturn o m)\n| _ => None\nend = Some bsh) (H0 : wf_moves m)","proofString":"destruct b0 as [|[]]; MonadInv; UseParsingLemmas.\neconstructor; eauto."},{"statement":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (o : option reg) (m : moves) (b0 : list instruction) (H0 : wf_moves m) : expand_block_shape (BSreturn o m) (Ireturn o)\n  (expand_moves m (Lreturn :: b0)).","conclusion":"expand_block_shape (BSreturn o m) (Ireturn o)\n  (expand_moves m (Lreturn :: b0))","hypotheses":"(OP : forall (op : operation) (args : list reg) (res : reg) \n  (s : node) (b : bblock) (bsh : block_shape),\npair_Iop_block op args res s b = Some bsh ->\nexpand_block_shape bsh (Iop op args res s) b) (o : option reg) (m : moves) (b0 : list instruction) (H0 : wf_moves m)","proofString":"econstructor; eauto."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : (pair_codes f1 f2) ! pc = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b.","conclusion":"exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : (pair_codes f1 f2) ! pc = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"unfold pair_codes in H.\nrewrite PTree.gcombine in H; auto.\nrewrite H0 in H.\ndestruct (LTL.fn_code f2)!pc as [b|].\nexists b; split; auto.\napply pair_instr_block_sound; auto.\ndiscriminate."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : (PTree.combine\n   (fun (opti : option RTL.instruction) (optb : option bblock) =>\n    match opti with\n    | Some i0 =>\n        match optb with\n        | Some b => pair_instr_block i0 b\n        | None => None\n        end\n    | None => None\n    end) (RTL.fn_code f1) (fn_code f2)) ! pc = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b.","conclusion":"exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : (PTree.combine\n   (fun (opti : option RTL.instruction) (optb : option bblock) =>\n    match opti with\n    | Some i0 =>\n        match optb with\n        | Some b => pair_instr_block i0 b\n        | None => None\n        end\n    | None => None\n    end) (RTL.fn_code f1) (fn_code f2)) ! pc = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"rewrite PTree.gcombine in H; auto.\nrewrite H0 in H.\ndestruct (LTL.fn_code f2)!pc as [b|].\nexists b; split; auto.\napply pair_instr_block_sound; auto.\ndiscriminate."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : match (RTL.fn_code f1) ! pc with\n| Some i0 =>\n    match (fn_code f2) ! pc with\n    | Some b => pair_instr_block i0 b\n    | None => None\n    end\n| None => None\nend = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b.","conclusion":"exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : match (RTL.fn_code f1) ! pc with\n| Some i0 =>\n    match (fn_code f2) ! pc with\n    | Some b => pair_instr_block i0 b\n    | None => None\n    end\n| None => None\nend = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"rewrite H0 in H.\ndestruct (LTL.fn_code f2)!pc as [b|].\nexists b; split; auto.\napply pair_instr_block_sound; auto.\ndiscriminate."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : match (fn_code f2) ! pc with\n| Some b => pair_instr_block i b\n| None => None\nend = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b.","conclusion":"exists b : bblock, (fn_code f2) ! pc = Some b /\\ expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : match (fn_code f2) ! pc with\n| Some b => pair_instr_block i b\n| None => None\nend = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"destruct (LTL.fn_code f2)!pc as [b|].\nexists b; split; auto.\napply pair_instr_block_sound; auto.\ndiscriminate."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (b : bblock) (H : pair_instr_block i b = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b0 : bblock, Some b = Some b0 /\\ expand_block_shape bsh i b0.","conclusion":"exists b0 : bblock, Some b = Some b0 /\\ expand_block_shape bsh i b0","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (b : bblock) (H : pair_instr_block i b = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"exists b; split; auto.\napply pair_instr_block_sound; auto."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (b : bblock) (H : pair_instr_block i b = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : expand_block_shape bsh i b.","conclusion":"expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (b : bblock) (H : pair_instr_block i b = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"apply pair_instr_block_sound; auto."},{"statement":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : None = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i) : exists b : bblock, None = Some b /\\ expand_block_shape bsh i b.","conclusion":"exists b : bblock, None = Some b /\\ expand_block_shape bsh i b","hypotheses":"(f1 : RTL.function) (f2 : function) (pc : positive) (bsh : block_shape) (i : RTL.instruction) (H : None = Some bsh) (H0 : (RTL.fn_code f1) ! pc = Some i)","proofString":"discriminate."},{"statement":"(rs : regset) (ls : locset) (q : EqSet.elt) (H : EqSet.In q\n  {|\n    eqs1 := EqSet.empty;\n    eqs2 := EqSet2.empty;\n    eqs_same := fun q0 : EqSet2.elt => Allocation.empty_eqs_obligation_1 q0\n  |}) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (q : EqSet.elt) (H : EqSet.In q\n  {|\n    eqs1 := EqSet.empty;\n    eqs2 := EqSet2.empty;\n    eqs_same := fun q0 : EqSet2.elt => Allocation.empty_eqs_obligation_1 q0\n  |})","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (e1 e2 : eqs) (H : forall q0 : EqSet.elt,\nEqSet.In q0 e2 ->\nVal.lessdef (sel_val (ekind q0) rs # (ereg q0)) (ls (eloc q0))) (H0 : EqSet.Subset e1 e2) (q : EqSet.elt) (H1 : EqSet.In q e1) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (e1 e2 : eqs) (H : forall q0 : EqSet.elt,\nEqSet.In q0 e2 ->\nVal.lessdef (sel_val (ekind q0) rs # (ereg q0)) (ls (eloc q0))) (H0 : EqSet.Subset e1 e2) (q : EqSet.elt) (H1 : EqSet.In q e1)","proofString":"apply H.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (e1 e2 : eqs) (H : forall q0 : EqSet.elt,\nEqSet.In q0 e2 ->\nVal.lessdef (sel_val (ekind q0) rs # (ereg q0)) (ls (eloc q0))) (H0 : EqSet.Subset e1 e2) (q : EqSet.elt) (H1 : EqSet.In q e1) : EqSet.In q e2.","conclusion":"EqSet.In q e2","hypotheses":"(rs : regset) (ls : locset) (e1 e2 : eqs) (H : forall q0 : EqSet.elt,\nEqSet.In q0 e2 ->\nVal.lessdef (sel_val (ekind q0) rs # (ereg q0)) (ls (eloc q0))) (H0 : EqSet.Subset e1 e2) (q : EqSet.elt) (H1 : EqSet.In q e1)","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) (rs # r <- Vundef) # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # r <- Vundef) # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq (ereg q) r); auto.\ndestruct (ekind q); simpl; auto."},{"statement":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e) : Val.lessdef\n  (sel_val (ekind q) (if peq (ereg q) r then Vundef else rs # (ereg q)))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (if peq (ereg q) r then Vundef else rs # (ereg q)))\n  (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e)","proofString":"destruct (peq (ereg q) r); auto.\ndestruct (ekind q); simpl; auto."},{"statement":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e) (e0 : ereg q = r) : Val.lessdef (sel_val (ekind q) Vundef) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) Vundef) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (e : eqs) (r : positive) (H : satisf rs ls e) (q : EqSet.elt) (H0 : EqSet.In q e) (e0 : ereg q = r)","proofString":"destruct (ekind q); simpl; auto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"apply H.\nunfold add_equation.\nsimpl.\napply EqSet.add_1.\nauto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.In q (add_equation q e).","conclusion":"EqSet.In q (add_equation q e)","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"unfold add_equation.\nsimpl.\napply EqSet.add_1.\nauto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.In q\n  {|\n    eqs1 := EqSet.add q e;\n    eqs2 := EqSet2.add q (eqs2 e);\n    eqs_same :=\n      fun q0 : EqSet2.elt => Allocation.add_equation_obligation_1 q e q0\n  |}.","conclusion":"EqSet.In q\n  {|\n    eqs1 := EqSet.add q e;\n    eqs2 := EqSet2.add q (eqs2 e);\n    eqs_same :=\n      fun q0 : EqSet2.elt => Allocation.add_equation_obligation_1 q e q0\n  |}","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"simpl.\napply EqSet.add_1.\nauto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.In q (EqSet.add q e).","conclusion":"EqSet.In q (EqSet.add q e)","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"apply EqSet.add_1.\nauto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : q = q.","conclusion":"q = q","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"eapply satisf_incr; eauto.\nunfold add_equation.\nsimpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.Subset e (add_equation q e).","conclusion":"EqSet.Subset e (add_equation q e)","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"unfold add_equation.\nsimpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.Subset e\n  {|\n    eqs1 := EqSet.add q e;\n    eqs2 := EqSet2.add q (eqs2 e);\n    eqs_same :=\n      fun q0 : EqSet2.elt => Allocation.add_equation_obligation_1 q e q0\n  |}.","conclusion":"EqSet.Subset e\n  {|\n    eqs1 := EqSet.add q e;\n    eqs2 := EqSet2.add q (eqs2 e);\n    eqs_same :=\n      fun q0 : EqSet2.elt => Allocation.add_equation_obligation_1 q e q0\n  |}","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"simpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e)) : EqSet.Subset e (EqSet.add q e).","conclusion":"EqSet.Subset e (EqSet.add q e)","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls (add_equation q e))","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (e' : eqs) (H0 : satisf rs ls e') : satisf rs ls e'.","conclusion":"satisf rs ls e'","hypotheses":"(rs : regset) (ls : locset) (e' : eqs) (H0 : satisf rs ls e')","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 -> satisf rs ls e'0 -> satisf rs ls e0) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 -> satisf rs ls e'0 -> satisf rs ls e0) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e')","proofString":"eapply add_equation_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' : eqs) (H0 : satisf rs ls e') : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(rs : regset) (ls : locset) (e' : eqs) (H0 : satisf rs ls e')","proofString":"constructor."},{"statement":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e') : Val.lessdef_list (rs # a :: rs ## rl) (ls (R m) :: reglist ls ml).","conclusion":"Val.lessdef_list (rs # a :: rs ## rl) (ls (R m) :: reglist ls ml)","hypotheses":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e')","proofString":"constructor; eauto.\napply add_equation_lessdef with (e := e) (q := Eq Full a (R m)).\neapply add_equations_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e') : Val.lessdef rs # a (ls (R m)).","conclusion":"Val.lessdef rs # a (ls (R m))","hypotheses":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e')","proofString":"apply add_equation_lessdef with (e := e) (q := Eq Full a (R m)).\neapply add_equations_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e') : satisf rs ls (add_equation {| ekind := Full; ereg := a; eloc := R m |} e).","conclusion":"satisf rs ls (add_equation {| ekind := Full; ereg := a; eloc := R m |} e)","hypotheses":"(rs : regset) (ls : locset) (a : reg) (rl : list reg) (IHrl : forall (ml0 : list mreg) (e0 e'0 : eqs),\nadd_equations rl ml0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> Val.lessdef_list rs ## rl (reglist ls ml0)) (m : mreg) (ml : list mreg) (e e' : eqs) (H : add_equations rl ml\n  (add_equation {| ekind := Full; ereg := a; eloc := R m |} e) = \nSome e') (H0 : satisf rs ls e')","proofString":"eapply add_equations_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e e' : eqs) : add_equations_args rl tyl ll e = Some e' -> satisf rs ls e' -> satisf rs ls e.","conclusion":"add_equations_args rl tyl ll e = Some e' -> satisf rs ls e' -> satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e e' : eqs)","proofString":"functional induction (add_equations_args rl tyl ll e); intros.\ninv H; auto.\neapply add_equation_satisf; eauto.\ndiscriminate.\neapply add_equation_satisf.\neapply add_equation_satisf.\neauto.\ncongruence."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (H : Some e = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (H : Some e = Some e') (H0 : satisf rs ls e')","proofString":"inv H; auto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nsatisf rs ls (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nsatisf rs ls (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e')","proofString":"eapply add_equation_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = true) (H : None = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = true) (H : None = Some e') (H0 : satisf rs ls e')","proofString":"discriminate."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nsatisf rs ls\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e))) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nsatisf rs ls\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e))) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e')","proofString":"eapply add_equation_satisf.\neapply add_equation_satisf.\neauto."},{"statement":"(rs : regset) (ls : locset) (e' : eqs) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e : eqs) (y : match rl with\n| nil =>\n    match tyl with\n    | nil => match ll with\n             | nil => False\n             | _ :: _ => True\n             end\n    | _ :: _ => True\n    end\n| _ :: _ =>\n    match tyl with\n    | nil => True\n    | Tlong :: _ => match ll with\n                    | nil => True\n                    | _ => False\n                    end\n    | _ => match ll with\n           | One _ :: _ => False\n           | _ => True\n           end\n    end\nend) (H : None = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (e' : eqs) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e : eqs) (y : match rl with\n| nil =>\n    match tyl with\n    | nil => match ll with\n             | nil => False\n             | _ :: _ => True\n             end\n    | _ :: _ => True\n    end\n| _ :: _ =>\n    match tyl with\n    | nil => True\n    | Tlong :: _ => match ll with\n                    | nil => True\n                    | _ => False\n                    end\n    | _ => match ll with\n           | One _ :: _ => False\n           | _ => True\n           end\n    end\nend) (H : None = Some e') (H0 : satisf rs ls e')","proofString":"congruence."},{"statement":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword v) (Val.loword v) = v.","conclusion":"Val.longofwords (Val.hiword v) (Val.loword v) = v","hypotheses":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.ptr64 = false)","proofString":"red in H.\ndestruct v; try contradiction.\nreflexivity.\nsimpl.\nrewrite Int64.ofwords_recompose.\nauto.\ncongruence."},{"statement":"(v : val) (H : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword v) (Val.loword v) = v.","conclusion":"Val.longofwords (Val.hiword v) (Val.loword v) = v","hypotheses":"(v : val) (H : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend) (H0 : Archi.ptr64 = false)","proofString":"destruct v; try contradiction.\nreflexivity.\nsimpl.\nrewrite Int64.ofwords_recompose.\nauto.\ncongruence."},{"statement":"(H : True) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword Vundef) (Val.loword Vundef) = Vundef.","conclusion":"Val.longofwords (Val.hiword Vundef) (Val.loword Vundef) = Vundef","hypotheses":"(H : True) (H0 : Archi.ptr64 = false)","proofString":"reflexivity."},{"statement":"(i : int64) (H : True) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword (Vlong i)) (Val.loword (Vlong i)) = Vlong i.","conclusion":"Val.longofwords (Val.hiword (Vlong i)) (Val.loword (Vlong i)) = Vlong i","hypotheses":"(i : int64) (H : True) (H0 : Archi.ptr64 = false)","proofString":"simpl.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(i : int64) (H : True) (H0 : Archi.ptr64 = false) : Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)) = Vlong i.","conclusion":"Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)) = Vlong i","hypotheses":"(i : int64) (H : True) (H0 : Archi.ptr64 = false)","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(i : int64) (H : True) (H0 : Archi.ptr64 = false) : Vlong i = Vlong i.","conclusion":"Vlong i = Vlong i","hypotheses":"(i : int64) (H : True) (H0 : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(b : block) (i : ptrofs) (H : Archi.ptr64 = true) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword (Vptr b i)) (Val.loword (Vptr b i)) = Vptr b i.","conclusion":"Val.longofwords (Val.hiword (Vptr b i)) (Val.loword (Vptr b i)) = Vptr b i","hypotheses":"(b : block) (i : ptrofs) (H : Archi.ptr64 = true) (H0 : Archi.ptr64 = false)","proofString":"congruence."},{"statement":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.splitlong = true) : Val.longofwords (Val.hiword v) (Val.loword v) = v.","conclusion":"Val.longofwords (Val.hiword v) (Val.loword v) = v","hypotheses":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.splitlong = true)","proofString":"apply Archi.splitlong_ptr32 in H0.\napply val_longofwords_eq_1; assumption."},{"statement":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.ptr64 = false) : Val.longofwords (Val.hiword v) (Val.loword v) = v.","conclusion":"Val.longofwords (Val.hiword v) (Val.loword v) = v","hypotheses":"(v : val) (H : Val.has_type v Tlong) (H0 : Archi.ptr64 = false)","proofString":"apply val_longofwords_eq_1; assumption."},{"statement":"(rs : regset) (ls : locset) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e e' : eqs) : add_equations_args rl tyl ll e = Some e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl tyl ->\nVal.lessdef_list rs ## rl (map (fun p : rpair loc => Locmap.getpair p ls) ll).","conclusion":"add_equations_args rl tyl ll e = Some e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl tyl ->\nVal.lessdef_list rs ## rl (map (fun p : rpair loc => Locmap.getpair p ls) ll)","hypotheses":"(rs : regset) (ls : locset) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e e' : eqs)","proofString":"functional induction (add_equations_args rl tyl ll e); simpl; intros.\ninv H; auto.\ndestruct H1.\nconstructor; auto.\neapply add_equation_lessdef with (q := Eq Full r1 l1).\neapply add_equations_args_satisf; eauto.\ndiscriminate.\ndestruct H1.\nconstructor; auto.\nrewrite <- (val_longofwords_eq_1 (rs#r1)) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto.\neapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto.\ndiscriminate."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (H : Some e = Some e') (H0 : satisf rs ls e') (H1 : True) : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (H : Some e = Some e') (H0 : satisf rs ls e') (H1 : True)","proofString":"inv H; auto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty /\\ Val.has_type_list rs ## rl0 tyl0) : Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll0).","conclusion":"Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll0)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty /\\ Val.has_type_list rs ## rl0 tyl0)","proofString":"destruct H1.\nconstructor; auto.\neapply add_equation_lessdef with (q := Eq Full r1 l1).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll0).","conclusion":"Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll0)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"constructor; auto.\neapply add_equation_lessdef with (q := Eq Full r1 l1).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef rs # r1 (ls l1).","conclusion":"Val.lessdef rs # r1 (ls l1)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (ty : typ) (tyl0 : list typ) (l1 : loc) (ll0 : list (rpair loc)) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 ty) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"eapply add_equation_lessdef with (q := Eq Full r1 l1).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = true) (H : None = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong /\\ Val.has_type_list rs ## rl0 tyl0) : Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0).","conclusion":"Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = true) (H : None = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong /\\ Val.has_type_list rs ## rl0 tyl0)","proofString":"discriminate."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong /\\ Val.has_type_list rs ## rl0 tyl0) : Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0).","conclusion":"Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong /\\ Val.has_type_list rs ## rl0 tyl0)","proofString":"destruct H1.\nconstructor; auto.\nrewrite <- (val_longofwords_eq_1 (rs#r1)) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto.\neapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0).","conclusion":"Val.lessdef_list (rs # r1 :: rs ## rl0)\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll0)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"constructor; auto.\nrewrite <- (val_longofwords_eq_1 (rs#r1)) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto.\neapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef rs # r1 (Val.longofwords (ls l1) (ls l2)).","conclusion":"Val.lessdef rs # r1 (Val.longofwords (ls l1) (ls l2))","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"rewrite <- (val_longofwords_eq_1 (rs#r1)) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto.\neapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef (Val.longofwords (Val.hiword rs # r1) (Val.loword rs # r1))\n  (Val.longofwords (ls l1) (ls l2)).","conclusion":"Val.lessdef (Val.longofwords (Val.hiword rs # r1) (Val.loword rs # r1))\n  (Val.longofwords (ls l1) (ls l2))","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"apply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto.\neapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef (Val.hiword rs # r1) (ls l1).","conclusion":"Val.lessdef (Val.hiword rs # r1) (ls l1)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"eapply add_equation_lessdef with (q := Eq High r1 l1).\neapply add_equation_satisf.\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0) : Val.lessdef (Val.loword rs # r1) (ls l2).","conclusion":"Val.lessdef (Val.loword rs # r1) (ls l2)","hypotheses":"(rs : regset) (ls : locset) (e' e : eqs) (r1 : reg) (rl0 : list reg) (tyl0 : list typ) (l1 l2 : loc) (ll0 : list (rpair loc)) (e3 : Archi.ptr64 = false) (IHo : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e' ->\nsatisf rs ls e' ->\nVal.has_type_list rs ## rl0 tyl0 ->\nVal.lessdef_list rs ## rl0\n  (map (fun p : rpair loc => Locmap.getpair p ls) ll0)) (H : add_equations_args rl0 tyl0 ll0\n  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}\n     (add_equation {| ekind := High; ereg := r1; eloc := l1 |} e)) = \nSome e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r1 Tlong) (H2 : Val.has_type_list rs ## rl0 tyl0)","proofString":"eapply add_equation_lessdef with (q := Eq Low r1 l2).\neapply add_equations_args_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (e' : eqs) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e : eqs) (y : match rl with\n| nil =>\n    match tyl with\n    | nil => match ll with\n             | nil => False\n             | _ :: _ => True\n             end\n    | _ :: _ => True\n    end\n| _ :: _ =>\n    match tyl with\n    | nil => True\n    | Tlong :: _ => match ll with\n                    | nil => True\n                    | _ => False\n                    end\n    | _ => match ll with\n           | One _ :: _ => False\n           | _ => True\n           end\n    end\nend) (H : None = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type_list rs ## rl tyl) : Val.lessdef_list rs ## rl (map (fun p : rpair loc => Locmap.getpair p ls) ll).","conclusion":"Val.lessdef_list rs ## rl (map (fun p : rpair loc => Locmap.getpair p ls) ll)","hypotheses":"(rs : regset) (ls : locset) (e' : eqs) (rl : list reg) (tyl : list typ) (ll : list (rpair loc)) (e : eqs) (y : match rl with\n| nil =>\n    match tyl with\n    | nil => match ll with\n             | nil => False\n             | _ :: _ => True\n             end\n    | _ :: _ => True\n    end\n| _ :: _ =>\n    match tyl with\n    | nil => True\n    | Tlong :: _ => match ll with\n                    | nil => True\n                    | _ => False\n                    end\n    | _ => match ll with\n           | One _ :: _ => False\n           | _ => True\n           end\n    end\nend) (H : None = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type_list rs ## rl tyl)","proofString":"discriminate."},{"statement":"(rs : regset) (ls : locset) (ros : reg + ident) (mos : mreg + ident) (e e' : eqs) (H : match ros with\n| inl r =>\n    match mos with\n    | inl mr =>\n        Some (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e)\n    | inr _ => None\n    end\n| inr id =>\n    match mos with\n    | inl _ => None\n    | inr id' => if ident_eq id id' then Some e else None\n    end\nend = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (ros : reg + ident) (mos : mreg + ident) (e e' : eqs) (H : match ros with\n| inl r =>\n    match mos with\n    | inl mr =>\n        Some (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e)\n    | inr _ => None\n    end\n| inr id =>\n    match mos with\n    | inl _ => None\n    | inr id' => if ident_eq id id' then Some e else None\n    end\nend = Some e') (H0 : satisf rs ls e')","proofString":"destruct ros; destruct mos; MonadInv.\neapply add_equation_satisf; eauto.\nauto."},{"statement":"(rs : regset) (ls : locset) (r : reg) (m : mreg) (e : eqs) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R m |} e)) : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(rs : regset) (ls : locset) (r : reg) (m : mreg) (e : eqs) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R m |} e))","proofString":"eapply add_equation_satisf; eauto."},{"statement":"(rs : regset) (ls : locset) (i0 : ident) (e' : eqs) (H0 : satisf rs ls e') : satisf rs ls e'.","conclusion":"satisf rs ls e'","hypotheses":"(rs : regset) (ls : locset) (i0 : ident) (e' : eqs) (H0 : satisf rs ls e')","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e) : satisf rs ls (remove_equation q e).","conclusion":"satisf rs ls (remove_equation q e)","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e)","proofString":"eapply satisf_incr; eauto.\nunfold remove_equation; simpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e) : EqSet.Subset (remove_equation q e) e.","conclusion":"EqSet.Subset (remove_equation q e) e","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e)","proofString":"unfold remove_equation; simpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e) : EqSet.Subset (EqSet.remove q e) e.","conclusion":"EqSet.Subset (EqSet.remove q e) e","hypotheses":"(rs : regset) (ls : locset) (q : equation) (e : eqs) (H : satisf rs ls e)","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H : remove_equations_res r l e = Some e') (H0 : satisf rs ls e) : satisf rs ls e'.","conclusion":"satisf rs ls e'","hypotheses":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H : remove_equations_res r l e = Some e') (H0 : satisf rs ls e)","proofString":"functional inversion H.\napply remove_equation_satisf; auto.\napply remove_equation_satisf.\napply remove_equation_satisf; auto."},{"statement":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr : mreg) (H4 : p = One mr) (H2 : One mr = l) (H3 : e0 = e) (H1 : remove_equation {| ekind := Full; ereg := r; eloc := R mr |} e = e') (H : remove_equations_res r l e = Some e') : satisf rs ls (remove_equation {| ekind := Full; ereg := r; eloc := R mr |} e).","conclusion":"satisf rs ls (remove_equation {| ekind := Full; ereg := r; eloc := R mr |} e)","hypotheses":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr : mreg) (H4 : p = One mr) (H2 : One mr = l) (H3 : e0 = e) (H1 : remove_equation {| ekind := Full; ereg := r; eloc := R mr |} e = e') (H : remove_equations_res r l e = Some e')","proofString":"apply remove_equation_satisf; auto."},{"statement":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H2 : p = Twolong mr1 mr2) (H5 : mreg_eq mr2 mr1 = right _x) (H3 : Twolong mr1 mr2 = l) (H4 : e0 = e) (H1 : remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : remove_equations_res r l e = Some e') : satisf rs ls\n  (remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)).","conclusion":"satisf rs ls\n  (remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))","hypotheses":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H2 : p = Twolong mr1 mr2) (H5 : mreg_eq mr2 mr1 = right _x) (H3 : Twolong mr1 mr2 = l) (H4 : e0 = e) (H1 : remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : remove_equations_res r l e = Some e')","proofString":"apply remove_equation_satisf.\napply remove_equation_satisf; auto."},{"statement":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H2 : p = Twolong mr1 mr2) (H5 : mreg_eq mr2 mr1 = right _x) (H3 : Twolong mr1 mr2 = l) (H4 : e0 = e) (H1 : remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : remove_equations_res r l e = Some e') : satisf rs ls\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e).","conclusion":"satisf rs ls\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)","hypotheses":"(rs : regset) (ls : locset) (r : reg) (l : rpair mreg) (e e' : eqs) (H0 : satisf rs ls e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H2 : p = Twolong mr1 mr2) (H5 : mreg_eq mr2 mr1 = right _x) (H3 : Twolong mr1 mr2 = l) (H4 : e0 = e) (H1 : remove_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : remove_equations_res r l e = Some e')","proofString":"apply remove_equation_satisf; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2 \\/ OrderedEquation.lt q1 q2) (H0 : (r <=? ereg q1)%positive = true) : (r <=? ereg q2)%positive = true.","conclusion":"(r <=? ereg q2)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2 \\/ OrderedEquation.lt q1 q2) (H0 : (r <=? ereg q1)%positive = true)","proofString":"destruct H.\nred in H.\ncongruence.\nrewrite Pos.leb_le in *.\nred in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite <- A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2) (H0 : (r <=? ereg q1)%positive = true) : (r <=? ereg q2)%positive = true.","conclusion":"(r <=? ereg q2)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2) (H0 : (r <=? ereg q1)%positive = true)","proofString":"red in H.\ncongruence."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : q1 = q2) (H0 : (r <=? ereg q1)%positive = true) : (r <=? ereg q2)%positive = true.","conclusion":"(r <=? ereg q2)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : q1 = q2) (H0 : (r <=? ereg q1)%positive = true)","proofString":"congruence."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q1 q2) (H0 : (r <=? ereg q1)%positive = true) : (r <=? ereg q2)%positive = true.","conclusion":"(r <=? ereg q2)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q1 q2) (H0 : (r <=? ereg q1)%positive = true)","proofString":"rewrite Pos.leb_le in *.\nred in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite <- A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q1 q2) (H0 : (r <= ereg q1)%positive) : (r <= ereg q2)%positive.","conclusion":"(r <= ereg q2)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q1 q2) (H0 : (r <= ereg q1)%positive)","proofString":"red in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite <- A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : Plt (ereg q1) (ereg q2) \\/\nereg q1 = ereg q2 /\\\n(OrderedLoc.lt (eloc q1) (eloc q2) \\/\n eloc q1 = eloc q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2))) (H0 : (r <= ereg q1)%positive) : (r <= ereg q2)%positive.","conclusion":"(r <= ereg q2)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : Plt (ereg q1) (ereg q2) \\/\nereg q1 = ereg q2 /\\\n(OrderedLoc.lt (eloc q1) (eloc q2) \\/\n eloc q1 = eloc q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2))) (H0 : (r <= ereg q1)%positive)","proofString":"destruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite <- A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : Plt (ereg q1) (ereg q2)) (H0 : (r <= ereg q1)%positive) : (r <= ereg q2)%positive.","conclusion":"(r <= ereg q2)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : Plt (ereg q1) (ereg q2)) (H0 : (r <= ereg q1)%positive)","proofString":"red in A.\nzify; lia."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : (ereg q1 < ereg q2)%positive) (H0 : (r <= ereg q1)%positive) : (r <= ereg q2)%positive.","conclusion":"(r <= ereg q2)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : (ereg q1 < ereg q2)%positive) (H0 : (r <= ereg q1)%positive)","proofString":"zify; lia."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : ereg q1 = ereg q2) (B : OrderedLoc.lt (eloc q1) (eloc q2) \\/\neloc q1 = eloc q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2)) (H0 : (r <= ereg q1)%positive) : (r <= ereg q2)%positive.","conclusion":"(r <= ereg q2)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : ereg q1 = ereg q2) (B : OrderedLoc.lt (eloc q1) (eloc q2) \\/\neloc q1 = eloc q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2)) (H0 : (r <= ereg q1)%positive)","proofString":"rewrite <- A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2 \\/ OrderedEquation.lt q2 q1) (H0 : (ereg q1 <=? r)%positive = true) : (ereg q2 <=? r)%positive = true.","conclusion":"(ereg q2 <=? r)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2 \\/ OrderedEquation.lt q2 q1) (H0 : (ereg q1 <=? r)%positive = true)","proofString":"destruct H.\nred in H.\ncongruence.\nrewrite Pos.leb_le in *.\nred in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2) (H0 : (ereg q1 <=? r)%positive = true) : (ereg q2 <=? r)%positive = true.","conclusion":"(ereg q2 <=? r)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.eq q1 q2) (H0 : (ereg q1 <=? r)%positive = true)","proofString":"red in H.\ncongruence."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : q1 = q2) (H0 : (ereg q1 <=? r)%positive = true) : (ereg q2 <=? r)%positive = true.","conclusion":"(ereg q2 <=? r)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : q1 = q2) (H0 : (ereg q1 <=? r)%positive = true)","proofString":"congruence."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q2 q1) (H0 : (ereg q1 <=? r)%positive = true) : (ereg q2 <=? r)%positive = true.","conclusion":"(ereg q2 <=? r)%positive = true","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q2 q1) (H0 : (ereg q1 <=? r)%positive = true)","proofString":"rewrite Pos.leb_le in *.\nred in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q2 q1) (H0 : (ereg q1 <= r)%positive) : (ereg q2 <= r)%positive.","conclusion":"(ereg q2 <= r)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : OrderedEquation.lt q2 q1) (H0 : (ereg q1 <= r)%positive)","proofString":"red in H.\ndestruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (H : Plt (ereg q2) (ereg q1) \\/\nereg q2 = ereg q1 /\\\n(OrderedLoc.lt (eloc q2) (eloc q1) \\/\n eloc q2 = eloc q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1))) (H0 : (ereg q1 <= r)%positive) : (ereg q2 <= r)%positive.","conclusion":"(ereg q2 <= r)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (H : Plt (ereg q2) (ereg q1) \\/\nereg q2 = ereg q1 /\\\n(OrderedLoc.lt (eloc q2) (eloc q1) \\/\n eloc q2 = eloc q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1))) (H0 : (ereg q1 <= r)%positive)","proofString":"destruct H as [A | [A B]].\nred in A.\nzify; lia.\nrewrite A; auto."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : Plt (ereg q2) (ereg q1)) (H0 : (ereg q1 <= r)%positive) : (ereg q2 <= r)%positive.","conclusion":"(ereg q2 <= r)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : Plt (ereg q2) (ereg q1)) (H0 : (ereg q1 <= r)%positive)","proofString":"red in A.\nzify; lia."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : (ereg q2 < ereg q1)%positive) (H0 : (ereg q1 <= r)%positive) : (ereg q2 <= r)%positive.","conclusion":"(ereg q2 <= r)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : (ereg q2 < ereg q1)%positive) (H0 : (ereg q1 <= r)%positive)","proofString":"zify; lia."},{"statement":"(r : reg) (q1 q2 : OrderedEquation.t) (A : ereg q2 = ereg q1) (B : OrderedLoc.lt (eloc q2) (eloc q1) \\/\neloc q2 = eloc q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1)) (H0 : (ereg q1 <= r)%positive) : (ereg q2 <= r)%positive.","conclusion":"(ereg q2 <= r)%positive","hypotheses":"(r : reg) (q1 q2 : OrderedEquation.t) (A : ereg q2 = ereg q1) (B : OrderedLoc.lt (eloc q2) (eloc q1) \\/\neloc q2 = eloc q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1)) (H0 : (ereg q1 <= r)%positive)","proofString":"rewrite A; auto."},{"statement":"(r : reg) (q : equation) : (r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true ->\nereg q = r.","conclusion":"(r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true ->\nereg q = r","hypotheses":"(r : reg) (q : equation)","proofString":"rewrite ! Pos.leb_le.\nunfold reg; zify; lia."},{"statement":"(r : reg) (q : equation) : (r <= ereg q <= r)%positive -> ereg q = r.","conclusion":"(r <= ereg q <= r)%positive -> ereg q = r","hypotheses":"(r : reg) (q : equation)","proofString":"unfold reg; zify; lia."},{"statement":"(r : reg) (q : equation) : ereg q = r ->\n(r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true.","conclusion":"ereg q = r ->\n(r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true","hypotheses":"(r : reg) (q : equation)","proofString":"intros.\nrewrite H.\nrewrite ! Pos.leb_refl; auto."},{"statement":"(r : reg) (q : equation) (H : ereg q = r) : (r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true.","conclusion":"(r <=? ereg q)%positive = true /\\ (ereg q <=? r)%positive = true","hypotheses":"(r : reg) (q : equation) (H : ereg q = r)","proofString":"rewrite H.\nrewrite ! Pos.leb_refl; auto."},{"statement":"(r : reg) (q : equation) (H : ereg q = r) : (r <=? r)%positive = true /\\ (r <=? r)%positive = true.","conclusion":"(r <=? r)%positive = true /\\ (r <=? r)%positive = true","hypotheses":"(r : reg) (q : equation) (H : ereg q = r)","proofString":"rewrite ! Pos.leb_refl; auto."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) : ereg q <> r.","conclusion":"ereg q <> r","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e)","proofString":"red; intros.\napply select_reg_charact in H1.\nassert (EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true).\napply EqSet.mem_between_2 with q; auto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r).\ntauto.\ntauto.\nrewrite H2 in H; discriminate."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : False.","conclusion":"False","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"apply select_reg_charact in H1.\nassert (EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true).\napply EqSet.mem_between_2 with q; auto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r).\ntauto.\ntauto.\nrewrite H2 in H; discriminate."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : False.","conclusion":"False","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"assert (EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true).\napply EqSet.mem_between_2 with q; auto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r).\ntauto.\ntauto.\nrewrite H2 in H; discriminate."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true.","conclusion":"EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"apply EqSet.mem_between_2 with q; auto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r).\ntauto.\ntauto."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"exact (select_reg_l_monotone r)."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"exact (select_reg_h_monotone r)."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : select_reg_l r q = true.","conclusion":"select_reg_l r q = true","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"tauto."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : select_reg_h r q = true.","conclusion":"select_reg_h r q = true","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"tauto."},{"statement":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) (H2 : EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true) : False.","conclusion":"False","hypotheses":"(r : reg) (e : eqs) (q : EqSet.elt) (H : negb (EqSet.mem_between (select_reg_l r) (select_reg_h r) e) = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) (H2 : EqSet.mem_between (select_reg_l r) (select_reg_h r) e = true)","proofString":"rewrite H2 in H; discriminate."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) (rs # r <- v) # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # r <- v) # (ereg q)) (ls (eloc q))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"rewrite PMap.gso.\nauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"auto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : ereg q <> r.","conclusion":"ereg q <> r","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (v : val) (H : reg_unconstrained r e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q1 q2) (H0 : match OrderedLoc.compare (eloc q1) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q1 q2) (H0 : match OrderedLoc.compare (eloc q1) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = true)","proofString":"set (lb := OrderedLoc.diff_low_bound l) in *.\ndestruct H.\nred in H.\nsubst q2; auto.\nassert (eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)).\nred in H.\ntauto.\ndestruct H1.\nrewrite <- H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"destruct H.\nred in H.\nsubst q2; auto.\nassert (eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)).\nred in H.\ntauto.\ndestruct H1.\nrewrite <- H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"red in H.\nsubst q2; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : q1 = q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : q1 = q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"subst q2; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"assert (eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)).\nred in H.\ntauto.\ndestruct H1.\nrewrite <- H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2).","conclusion":"eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"red in H.\ntauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedLoc.lt (eloc q1) (eloc q2) \\/\neloc q1 = eloc q2 /\\\n(Plt (ereg q1) (ereg q2) \\/\n ereg q1 = ereg q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2))) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) : eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2).","conclusion":"eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedLoc.lt (eloc q1) (eloc q2) \\/\neloc q1 = eloc q2 /\\\n(Plt (ereg q1) (ereg q2) \\/\n ereg q1 = ereg q2 /\\ OrderedEqKind.lt (ekind q1) (ekind q2))) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true)","proofString":"tauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2)) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : eloc q1 = eloc q2 \\/ OrderedLoc.lt (eloc q1) (eloc q2))","proofString":"destruct H1.\nrewrite <- H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : eloc q1 = eloc q2) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : eloc q1 = eloc q2)","proofString":"rewrite <- H1; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) : match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| LT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2))","proofString":"destruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb)","proofString":"assert (OrderedLoc.lt (eloc q1) lb) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| LT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb)","proofString":"destruct (OrderedLoc.compare (eloc q1) lb).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (l1 : OrderedLoc.lt (eloc q1) lb) (H0 : false = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (l1 : OrderedLoc.lt (eloc q1) lb) (H0 : false = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb)","proofString":"auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (e : OrderedLoc.eq (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (e : OrderedLoc.eq (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb)","proofString":"eelim OrderedLoc.lt_not_eq; eauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (l1 : OrderedLoc.lt lb (eloc q1)) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q1 q2) (lb : loc) (l1 : OrderedLoc.lt lb (eloc q1)) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q1) (eloc q2)) (l0 : OrderedLoc.lt (eloc q2) lb) (H2 : OrderedLoc.lt (eloc q1) lb)","proofString":"eelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q2 q1) (H0 : match OrderedLoc.compare (eloc q1) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q2 q1) (H0 : match OrderedLoc.compare (eloc q1) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = true)","proofString":"set (lb := OrderedLoc.diff_high_bound l) in *.\ndestruct H.\nred in H.\nsubst q2; auto.\nassert (eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)).\nred in H.\ntauto.\ndestruct H1.\nrewrite H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2 \\/ OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"destruct H.\nred in H.\nsubst q2; auto.\nassert (eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)).\nred in H.\ntauto.\ndestruct H1.\nrewrite H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.eq q1 q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"red in H.\nsubst q2; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : q1 = q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : q1 = q2) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"subst q2; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"assert (eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)).\nred in H.\ntauto.\ndestruct H1.\nrewrite H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1).","conclusion":"eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"red in H.\ntauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedLoc.lt (eloc q2) (eloc q1) \\/\neloc q2 = eloc q1 /\\\n(Plt (ereg q2) (ereg q1) \\/\n ereg q2 = ereg q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1))) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) : eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1).","conclusion":"eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedLoc.lt (eloc q2) (eloc q1) \\/\neloc q2 = eloc q1 /\\\n(Plt (ereg q2) (ereg q1) \\/\n ereg q2 = ereg q1 /\\ OrderedEqKind.lt (ekind q2) (ekind q1))) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true)","proofString":"tauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1)) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : eloc q2 = eloc q1 \\/ OrderedLoc.lt (eloc q2) (eloc q1))","proofString":"destruct H1.\nrewrite H1; auto.\ndestruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : eloc q2 = eloc q1) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : eloc q2 = eloc q1)","proofString":"rewrite H1; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) : match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true.","conclusion":"match OrderedLoc.compare (eloc q2) lb with\n| GT _ => false\n| _ => true\nend = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1))","proofString":"destruct (OrderedLoc.compare (eloc q2) lb); auto.\nassert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2))","proofString":"assert (OrderedLoc.lt lb (eloc q1)) by (eapply OrderedLoc.lt_trans; eauto).\ndestruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1)) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (H0 : match OrderedLoc.compare (eloc q1) lb with\n| GT _ => false\n| _ => true\nend = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1))","proofString":"destruct (OrderedLoc.compare (eloc q1) lb).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto.\neelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (l1 : OrderedLoc.lt (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1)) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (l1 : OrderedLoc.lt (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1))","proofString":"eelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans.\neexact l1.\neexact H2.\nred; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (e : OrderedLoc.eq (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1)) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (e : OrderedLoc.eq (eloc q1) lb) (H0 : true = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1))","proofString":"eelim OrderedLoc.lt_not_eq.\neexact H2.\napply OrderedLoc.eq_sym; auto."},{"statement":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (l1 : OrderedLoc.lt lb (eloc q1)) (H0 : false = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1)) : false = true.","conclusion":"false = true","hypotheses":"(l : loc) (q1 q2 : OrderedEquation'.t) (H : OrderedEquation'.lt q2 q1) (lb : loc) (l1 : OrderedLoc.lt lb (eloc q1)) (H0 : false = true) (H1 : OrderedLoc.lt (eloc q2) (eloc q1)) (l0 : OrderedLoc.lt lb (eloc q2)) (H2 : OrderedLoc.lt lb (eloc q1))","proofString":"auto."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false)","proofString":"apply OrderedLoc.outside_interval_diff.\ndestruct H.\nleft.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)); assumption || discriminate.\nright.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false) : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q).","conclusion":"OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false)","proofString":"destruct H.\nleft.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)); assumption || discriminate.\nright.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false) : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q).","conclusion":"OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false)","proofString":"left.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false) : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l).","conclusion":"OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false)","proofString":"destruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false) : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q).","conclusion":"OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l) \\/\nOrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false)","proofString":"right.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false) : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q).","conclusion":"OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)","hypotheses":"(l : loc) (q : equation) (H : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false)","proofString":"destruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)); assumption || discriminate."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false.","conclusion":"match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q))","proofString":"exploit OrderedLoc.diff_outside_interval.\neauto.\nintros [A | A].\nleft.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto.\nright.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto.\neelim OrderedLoc.lt_not_eq; eauto.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false.","conclusion":"match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l))","proofString":"left.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false.","conclusion":"match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l))","proofString":"destruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l)).\nauto.\neelim OrderedLoc.lt_not_eq; eauto.\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A l0 : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) : false = false.","conclusion":"false = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A l0 : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l))","proofString":"auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_low_bound l)) : true = false.","conclusion":"true = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_low_bound l))","proofString":"eelim OrderedLoc.lt_not_eq; eauto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) (l0 : OrderedLoc.lt (OrderedLoc.diff_low_bound l) (eloc q)) : true = false.","conclusion":"true = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (eloc q) (OrderedLoc.diff_low_bound l)) (l0 : OrderedLoc.lt (OrderedLoc.diff_low_bound l) (eloc q))","proofString":"eelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false.","conclusion":"match OrderedLoc.compare (eloc q) (OrderedLoc.diff_low_bound l) with\n| LT _ => false\n| _ => true\nend = false \\/\nmatch OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q))","proofString":"right.\ndestruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto.\neelim OrderedLoc.lt_not_eq; eauto.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) : match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false.","conclusion":"match OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l) with\n| GT _ => false\n| _ => true\nend = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q))","proofString":"destruct (OrderedLoc.compare (eloc q) (OrderedLoc.diff_high_bound l)).\neelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto.\neelim OrderedLoc.lt_not_eq; eauto.\napply OrderedLoc.eq_sym; auto.\nauto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (l0 : OrderedLoc.lt (eloc q) (OrderedLoc.diff_high_bound l)) : true = false.","conclusion":"true = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (l0 : OrderedLoc.lt (eloc q) (OrderedLoc.diff_high_bound l))","proofString":"eelim OrderedLoc.lt_not_eq.\neapply OrderedLoc.lt_trans; eauto.\nred; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_high_bound l)) : true = false.","conclusion":"true = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_high_bound l))","proofString":"eelim OrderedLoc.lt_not_eq; eauto.\napply OrderedLoc.eq_sym; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_high_bound l)) : OrderedLoc.eq (OrderedLoc.diff_high_bound l) (eloc q).","conclusion":"OrderedLoc.eq (OrderedLoc.diff_high_bound l) (eloc q)","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) (e : OrderedLoc.eq (eloc q) (OrderedLoc.diff_high_bound l))","proofString":"apply OrderedLoc.eq_sym; auto."},{"statement":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A l0 : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q)) : false = false.","conclusion":"false = false","hypotheses":"(l : loc) (q : equation) (H : Loc.diff l (eloc q)) (A l0 : OrderedLoc.lt (OrderedLoc.diff_high_bound l) (eloc q))","proofString":"auto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e)","proofString":"destruct (select_loc_l l q) eqn:SL.\ndestruct (select_loc_h l q) eqn:SH.\nassert (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true).\napply EqSet2.mem_between_2 with q; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l).\napply eqs_same.\nauto.\nrewrite H1 in H; discriminate.\napply select_loc_charact; auto.\napply select_loc_charact; auto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true)","proofString":"destruct (select_loc_h l q) eqn:SH.\nassert (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true).\napply EqSet2.mem_between_2 with q; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l).\napply eqs_same.\nauto.\nrewrite H1 in H; discriminate.\napply select_loc_charact; auto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"assert (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true).\napply EqSet2.mem_between_2 with q; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l).\napply eqs_same.\nauto.\nrewrite H1 in H; discriminate."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true.","conclusion":"EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"apply EqSet2.mem_between_2 with q; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l).\napply eqs_same.\nauto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"exact (select_loc_l_monotone l)."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"exact (select_loc_h_monotone l)."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : EqSet2.In q (eqs2 e).","conclusion":"EqSet2.In q (eqs2 e)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"apply eqs_same.\nauto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) : EqSet.In q e.","conclusion":"EqSet.In q e","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true)","proofString":"auto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) (H1 : EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = true) (H1 : EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e) = true)","proofString":"rewrite H1 in H; discriminate."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = true) (SH : select_loc_h l q = false)","proofString":"apply select_loc_charact; auto."},{"statement":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(l : loc) (e : eqs) (q : EqSet.elt) (H : negb (EqSet2.mem_between (select_loc_l l) (select_loc_h l) (eqs2 e)) = true) (H0 : EqSet.In q e) (SL : select_loc_l l q = false)","proofString":"apply select_loc_charact; auto."},{"statement":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (H2 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) : Val.lessdef (sel_val k rs # r) v.","conclusion":"Val.lessdef (sel_val k rs # r) v","hypotheses":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (H2 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e)","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) : EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e).","conclusion":"EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e)","hypotheses":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |})","proofString":"simpl.\nESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) : EqSet.In q (EqSet.remove {| ekind := k; ereg := r; eloc := l |} e).","conclusion":"EqSet.In q (EqSet.remove {| ekind := k; ereg := r; eloc := l |} e)","hypotheses":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |})","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) (H3 : EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (v : val) (l : loc) (H : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (H0 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : Val.lessdef (sel_val k rs # r) v) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) (H3 : EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e))","proofString":"apply H; auto."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) : ereg q <> r /\\ Loc.diff l (eloc q).","conclusion":"ereg q <> r /\\ Loc.diff l (eloc q)","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e)","proofString":"destruct (andb_prop _ _ H).\nsplit.\neapply reg_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true) : ereg q <> r /\\ Loc.diff l (eloc q).","conclusion":"ereg q <> r /\\ Loc.diff l (eloc q)","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true)","proofString":"split.\neapply reg_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true) : ereg q <> r.","conclusion":"ereg q <> r","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true)","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : reg_loc_unconstrained r l e = true) (H0 : EqSet.In q e) (H1 : reg_unconstrained r e = true) (H2 : loc_unconstrained l e = true)","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (rs : regset) (ls : locset) (v v' : val) (l : loc) (H : Val.lessdef (sel_val k v) v') (H0 : reg_loc_unconstrained r (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) : EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e).","conclusion":"EqSet.In q (remove_equation {| ekind := k; ereg := r; eloc := l |} e)","hypotheses":"(k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (rs : regset) (ls : locset) (v v' : val) (l : loc) (H : Val.lessdef (sel_val k v) v') (H0 : reg_loc_unconstrained r (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |})","proofString":"simpl.\nESD.fsetdec."},{"statement":"(k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (rs : regset) (ls : locset) (v v' : val) (l : loc) (H : Val.lessdef (sel_val k v) v') (H0 : reg_loc_unconstrained r (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |}) : EqSet.In q (EqSet.remove {| ekind := k; ereg := r; eloc := l |} e).","conclusion":"EqSet.In q (EqSet.remove {| ekind := k; ereg := r; eloc := l |} e)","hypotheses":"(k : equation_kind) (r : reg) (mr : mreg) (e : eqs) (rs : regset) (ls : locset) (v v' : val) (l : loc) (H : Val.lessdef (sel_val k v) v') (H0 : reg_loc_unconstrained r (R mr)\n  (remove_equation {| ekind := k; ereg := r; eloc := l |} e) = true) (H1 : satisf rs ls (remove_equation {| ekind := k; ereg := r; eloc := l |} e)) (q : EqSet.elt) (H2 : EqSet.In q e) (n : q <> {| ekind := k; ereg := r; eloc := l |})","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H : remove_equations_res res res' e = Some e') (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v') : satisf rs # res <- v (Locmap.setpair res' v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair res' v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H : remove_equations_res res res' e = Some e') (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v')","proofString":"functional inversion H.\nsubst.\nsimpl in H2.\nInvBooleans.\nsimpl.\napply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto.\nsubst.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nsimpl in H2.\nInvBooleans.\nsimpl.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v') (p : rpair mreg) (e0 : eqs) (mr : mreg) (H7 : p = One mr) (H5 : One mr = res') (H6 : e0 = e) (H4 : remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e = e') (H : remove_equations_res res res' e = Some e') : satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v') (p : rpair mreg) (e0 : eqs) (mr : mreg) (H7 : p = One mr) (H5 : One mr = res') (H6 : e0 = e) (H4 : remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e = e') (H : remove_equations_res res res' e = Some e')","proofString":"subst.\nsimpl in H2.\nInvBooleans.\nsimpl.\napply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H2 : forallb\n  (fun l : loc =>\n   loc_unconstrained l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (One mr))) = true) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) : satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H2 : forallb\n  (fun l : loc =>\n   loc_unconstrained l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (One mr))) = true) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))","proofString":"simpl in H2.\nInvBooleans.\nsimpl.\napply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H2 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) && true =\ntrue) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) : satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H2 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) && true =\ntrue) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))","proofString":"InvBooleans.\nsimpl.\napply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true) : satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (One mr) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true)","proofString":"simpl.\napply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true) : satisf rs # res <- v (Locmap.set (R mr) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.set (R mr) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true)","proofString":"apply parallel_assignment_satisf with Full; auto.\nunfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true) : reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true.","conclusion":"reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true)","proofString":"unfold reg_loc_unconstrained.\nrewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true) : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) &&\nloc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true.","conclusion":"reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) &&\nloc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true)","proofString":"rewrite H1, H4.\nauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true) : true && true = true.","conclusion":"true && true = true","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr : mreg) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H0 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H3 : Val.lessdef v v') (H : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : loc_unconstrained (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H5 : true = true)","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v') (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H5 : p = Twolong mr1 mr2) (H8 : mreg_eq mr2 mr1 = right _x) (H6 : Twolong mr1 mr2 = res') (H7 : e0 = e) (H4 : remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e) = e') (H : remove_equations_res res res' e = Some e') : satisf rs # res <- v (Locmap.setpair (Twolong mr1 mr2) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (Twolong mr1 mr2) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (res' : rpair mreg) (e e' : eqs) (v v' : val) (H0 : satisf rs ls e') (H1 : reg_unconstrained res e' = true) (H2 : forallb (fun l : loc => loc_unconstrained l e') (map R (regs_of_rpair res')) =\ntrue) (H3 : Val.lessdef v v') (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H5 : p = Twolong mr1 mr2) (H8 : mreg_eq mr2 mr1 = right _x) (H6 : Twolong mr1 mr2 = res') (H7 : e0 = e) (H4 : remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e) = e') (H : remove_equations_res res res' e = Some e')","proofString":"subst.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nsimpl in H2.\nInvBooleans.\nsimpl.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (H2 : forallb\n  (fun l : loc =>\n   loc_unconstrained l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (Twolong mr1 mr2))) = true) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H0 : satisf rs ls\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) : satisf rs # res <- v (Locmap.setpair (Twolong mr1 mr2) v' ls) e.","conclusion":"satisf rs # res <- v (Locmap.setpair (Twolong mr1 mr2) v' ls) e","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (H2 : forallb\n  (fun l : loc =>\n   loc_unconstrained l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (Twolong mr1 mr2))) = true) (H1 : reg_unconstrained res\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H0 : satisf rs ls\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))","proofString":"set (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nsimpl in H2.\nInvBooleans.\nsimpl.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (e0 : q = {| ekind := Low; ereg := res; eloc := R mr2 |}) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (e0 : q = {| ekind := Low; ereg := res; eloc := R mr2 |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) : Val.lessdef (Val.loword (rs # res <- v) # res)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr2)).","conclusion":"Val.lessdef (Val.loword (rs # res <- v) # res)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr2))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e)","proofString":"rewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) : Val.lessdef (Val.loword v)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr2)).","conclusion":"Val.lessdef (Val.loword v)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr2))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e)","proofString":"rewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) : Val.lessdef (Val.loword v) (Val.loword v').","conclusion":"Val.lessdef (Val.loword v) (Val.loword v')","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (H5 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e)","proofString":"apply Val.loword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (e0 : q = {| ekind := High; ereg := res; eloc := R mr1 |}) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (e0 : q = {| ekind := High; ereg := res; eloc := R mr1 |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) : Val.lessdef (Val.hiword (rs # res <- v) # res)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr1)).","conclusion":"Val.lessdef (Val.hiword (rs # res <- v) # res)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr1))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e)","proofString":"rewrite Regmap.gss.\nrewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) : Val.lessdef (Val.hiword v)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr1)).","conclusion":"Val.lessdef (Val.hiword v)\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (R mr1))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e)","proofString":"rewrite Locmap.gso by auto.\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) : Val.lessdef (Val.hiword v) (Locmap.set (R mr1) (Val.hiword v') ls (R mr1)).","conclusion":"Val.lessdef (Val.hiword v) (Locmap.set (R mr1) (Val.hiword v') ls (R mr1))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e)","proofString":"rewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) : Val.lessdef (Val.hiword v) (Val.hiword v').","conclusion":"Val.lessdef (Val.hiword v) (Val.hiword v')","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) (H5 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e)","proofString":"apply Val.hiword_lessdef; auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"rewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R mr2) (Val.loword v') (Locmap.set (R mr1) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"rewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"auto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Loc.diff (R mr1) (eloc q).","conclusion":"Loc.diff (R mr1) (eloc q)","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Loc.diff (R mr2) (eloc q).","conclusion":"Loc.diff (R mr2) (eloc q)","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : ereg q <> res.","conclusion":"ereg q <> res","hypotheses":"(rs : regset) (ls : locset) (res : reg) (e : eqs) (v v' : val) (mr1 mr2 : mreg) (e' : eqs) (H1 : reg_unconstrained res e' = true) (H0 : satisf rs ls e') (H3 : Val.lessdef v v') (_x : mr2 <> mr1) (H8 : mreg_eq mr2 mr1 = right _x) (H : remove_equations_res res (Twolong mr1 mr2) e = Some e') (H4 : loc_unconstrained (R mr1) e' = true) (H2 : loc_unconstrained (R mr2) e' = true) (H6 : true = true) (q : EqSet.elt) (H5 : EqSet.In q e) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt) : EqSet.In q (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) s) <->\nEqSet.In q s /\\ ereg q = r1.","conclusion":"EqSet.In q (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) s) <->\nEqSet.In q s /\\ ereg q = r1","hypotheses":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt)","proofString":"rewrite EqSet.elements_between_iff, select_reg_charact.\ntauto.\nexact (select_reg_l_monotone r1).\nexact (select_reg_h_monotone r1)."},{"statement":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt) : EqSet.In q s /\\ ereg q = r1 <-> EqSet.In q s /\\ ereg q = r1.","conclusion":"EqSet.In q s /\\ ereg q = r1 <-> EqSet.In q s /\\ ereg q = r1","hypotheses":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt)","proofString":"tauto."},{"statement":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r1 x1 = true -> select_reg_l r1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r1 x1 = true -> select_reg_l r1 x2 = true","hypotheses":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt)","proofString":"exact (select_reg_l_monotone r1)."},{"statement":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r1 x1 = true -> select_reg_h r1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r1 x1 = true -> select_reg_h r1 x2 = true","hypotheses":"(r1 : reg) (s : EqSet.t) (q : EqSet.elt)","proofString":"exact (select_reg_h_monotone r1)."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) : ereg q = r1 /\\\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (subst_reg r1 r2 e0) \\/ ereg q <> r1 /\\ EqSet.In q (subst_reg r1 r2 e0).","conclusion":"ereg q = r1 /\\\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (subst_reg r1 r2 e0) \\/ ereg q <> r1 /\\ EqSet.In q (subst_reg r1 r2 e0)","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0)","proofString":"unfold subst_reg.\nset (f := fun (q: EqSet.elt) e => add_equation (Eq (ekind q) r2 (eloc q)) (remove_equation q e)).\ngeneralize (in_elements_between_1 r1 e0).\nset (elt := EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0).\nintros IN_ELT.\nset (P := fun e1 e2 =>         EqSet.In q e1 ->         EqSet.In (Eq (ekind q) r2 (eloc q)) e2).\nassert (P elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold P; intros.\nESD.fsetdec.\nsimpl.\nred in H1.\napply H1 in H3.\ndestruct H3.\nsubst x.\nESD.fsetdec.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto.\nset (Q := fun e1 e2 =>         ~EqSet.In q e1 ->         EqSet.In q e2).\nassert (Q elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold Q; intros.\nauto.\nsimpl.\nred in H2.\nrewrite H2 in H4.\nESD.fsetdec.\ndestruct (ESP.In_dec q elt).\nleft.\nsplit.\napply IN_ELT.\nauto.\napply H.\nauto.\nright.\nsplit.\nred; intros.\nelim n.\nrewrite IN_ELT.\nauto.\napply H0.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) : ereg q = r1 /\\\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.fold\n     (fun (q0 : EqSet.elt) (e : eqs) =>\n      add_equation {| ekind := ekind q0; ereg := r2; eloc := eloc q0 |}\n        (remove_equation q0 e))\n     (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0) e0) \\/\nereg q <> r1 /\\\nEqSet.In q\n  (EqSet.fold\n     (fun (q0 : EqSet.elt) (e : eqs) =>\n      add_equation {| ekind := ekind q0; ereg := r2; eloc := eloc q0 |}\n        (remove_equation q0 e))\n     (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0) e0).","conclusion":"ereg q = r1 /\\\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.fold\n     (fun (q0 : EqSet.elt) (e : eqs) =>\n      add_equation {| ekind := ekind q0; ereg := r2; eloc := eloc q0 |}\n        (remove_equation q0 e))\n     (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0) e0) \\/\nereg q <> r1 /\\\nEqSet.In q\n  (EqSet.fold\n     (fun (q0 : EqSet.elt) (e : eqs) =>\n      add_equation {| ekind := ekind q0; ereg := r2; eloc := eloc q0 |}\n        (remove_equation q0 e))\n     (EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0) e0)","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0)","proofString":"set (f := fun (q: EqSet.elt) e => add_equation (Eq (ekind q) r2 (eloc q)) (remove_equation q e)).\ngeneralize (in_elements_between_1 r1 e0).\nset (elt := EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0).\nintros IN_ELT.\nset (P := fun e1 e2 =>         EqSet.In q e1 ->         EqSet.In (Eq (ekind q) r2 (eloc q)) e2).\nassert (P elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold P; intros.\nESD.fsetdec.\nsimpl.\nred in H1.\napply H1 in H3.\ndestruct H3.\nsubst x.\nESD.fsetdec.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto.\nset (Q := fun e1 e2 =>         ~EqSet.In q e1 ->         EqSet.In q e2).\nassert (Q elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold Q; intros.\nauto.\nsimpl.\nred in H2.\nrewrite H2 in H4.\nESD.fsetdec.\ndestruct (ESP.In_dec q elt).\nleft.\nsplit.\napply IN_ELT.\nauto.\napply H.\nauto.\nright.\nsplit.\nred; intros.\nelim n.\nrewrite IN_ELT.\nauto.\napply H0.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H : EqSet.Empty s') (H0 : EqSet.In q s') : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} e0.","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} e0","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H : EqSet.Empty s') (H0 : EqSet.In q s')","proofString":"ESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : ESP.Add x s' s'') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s'') : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : ESP.Add x s' s'') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s'')","proofString":"red in H1.\napply H1 in H3.\ndestruct H3.\nsubst x.\nESD.fsetdec.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s'') : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s'')","proofString":"apply H1 in H3.\ndestruct H3.\nsubst x.\nESD.fsetdec.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : x = q \\/ EqSet.In q s') : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : x = q \\/ EqSet.In q s')","proofString":"destruct H3.\nsubst x.\nESD.fsetdec.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : x = q) : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : x = q)","proofString":"subst x.\nESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n     (EqSet.remove q a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n     (EqSet.remove q a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a)","proofString":"ESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') : EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s')","proofString":"rewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') : {| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.remove x a).","conclusion":"{| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |}\n  (EqSet.remove x a)","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s')","proofString":"rewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') : {| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := ekind q; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := ekind q; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s')","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (e : x = {| ekind := ekind q; ereg := r2; eloc := eloc q |}) : {| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := ekind q; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := ekind q; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (e : x = {| ekind := ekind q; ereg := r2; eloc := eloc q |})","proofString":"left.\nsubst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (e : x = {| ekind := ekind q; ereg := r2; eloc := eloc q |}) : {| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := ekind x; ereg := r2; eloc := eloc x |} =\n{| ekind := ekind q; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nEqSet.In {| ekind := ekind q; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (e : x = {| ekind := ekind q; ereg := r2; eloc := eloc q |})","proofString":"subst x; auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H0 : EqSet.Empty s') (H1 : ~ EqSet.In q s') : EqSet.In q e0.","conclusion":"EqSet.In q e0","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H0 : EqSet.Empty s') (H1 : ~ EqSet.In q s')","proofString":"auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : ESP.Add x s' s'') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ EqSet.In q s'') : EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : ESP.Add x s' s'') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ EqSet.In q s'')","proofString":"red in H2.\nrewrite H2 in H4.\nESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ EqSet.In q s'') : EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ EqSet.In q s'')","proofString":"rewrite H2 in H4.\nESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s')) : EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a)).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := r2; eloc := eloc x |}\n     (EqSet.remove x a))","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s'))","proofString":"ESD.fsetdec."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) : ereg q = r1.","conclusion":"ereg q = r1","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt)","proofString":"apply IN_ELT.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) : EqSet.In q elt.","conclusion":"EqSet.In q elt","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt)","proofString":"auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) : EqSet.In q elt.","conclusion":"EqSet.In q elt","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt)","proofString":"auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) : ereg q <> r1.","conclusion":"ereg q <> r1","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt)","proofString":"red; intros.\nelim n.\nrewrite IN_ELT.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1) : False.","conclusion":"False","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1)","proofString":"elim n.\nrewrite IN_ELT.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1) : EqSet.In q elt.","conclusion":"EqSet.In q elt","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1)","proofString":"rewrite IN_ELT.\nauto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1) : EqSet.In q e0 /\\ ereg q = r1.","conclusion":"EqSet.In q e0 /\\ ereg q = r1","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) (H1 : ereg q = r1)","proofString":"auto."},{"statement":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) : ~ EqSet.In q elt.","conclusion":"~ EqSet.In q elt","hypotheses":"(r1 r2 : reg) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt)","proofString":"auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e)","proofString":"destruct (in_subst_reg dst src q e H0) as [[A B] | [A B]].\nsubst dst.\nrewrite Regmap.gss.\nexploit H; eauto.\nrewrite Regmap.gso; auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e) (A : ereg q = dst) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg dst src e)) : Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e) (A : ereg q = dst) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg dst src e))","proofString":"subst dst.\nrewrite Regmap.gss.\nexploit H; eauto."},{"statement":"(src : reg) (rs : regset) (ls : locset) (e : eqs) (q : EqSet.elt) (H : satisf rs ls (subst_reg (ereg q) src e)) (H0 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg (ereg q) src e)) : Val.lessdef (sel_val (ekind q) (rs # (ereg q) <- (rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # (ereg q) <- (rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src : reg) (rs : regset) (ls : locset) (e : eqs) (q : EqSet.elt) (H : satisf rs ls (subst_reg (ereg q) src e)) (H0 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg (ereg q) src e))","proofString":"rewrite Regmap.gss.\nexploit H; eauto."},{"statement":"(src : reg) (rs : regset) (ls : locset) (e : eqs) (q : EqSet.elt) (H : satisf rs ls (subst_reg (ereg q) src e)) (H0 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg (ereg q) src e)) : Val.lessdef (sel_val (ekind q) rs # src) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # src) (ls (eloc q))","hypotheses":"(src : reg) (rs : regset) (ls : locset) (e : eqs) (q : EqSet.elt) (H : satisf rs ls (subst_reg (ereg q) src e)) (H0 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := src; eloc := eloc q |}\n  (subst_reg (ereg q) src e))","proofString":"exploit H; eauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e) (A : ereg q <> dst) (B : EqSet.In q (subst_reg dst src e)) : Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # dst <- (rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (H : satisf rs ls (subst_reg dst src e)) (q : EqSet.elt) (H0 : EqSet.In q e) (A : ereg q <> dst) (B : EqSet.In q (subst_reg dst src e))","proofString":"rewrite Regmap.gso; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) : (ereg q, ekind q) = (r1, k1) /\\\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (subst_reg_kind r1 k1 r2 k2 e0) \\/\nEqSet.In q (subst_reg_kind r1 k1 r2 k2 e0).","conclusion":"(ereg q, ekind q) = (r1, k1) /\\\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (subst_reg_kind r1 k1 r2 k2 e0) \\/\nEqSet.In q (subst_reg_kind r1 k1 r2 k2 e0)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0)","proofString":"unfold subst_reg.\nset (f := fun (q: EqSet.elt) e =>      if IndexedEqKind.eq (ekind q) k1      then add_equation (Eq k2 r2 (eloc q)) (remove_equation q e)      else e).\ngeneralize (in_elements_between_1 r1 e0).\nset (elt := EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0).\nintros IN_ELT.\nset (P := fun e1 e2 =>         EqSet.In q e1 -> ekind q = k1 ->         EqSet.In (Eq k2 r2 (eloc q)) e2).\nassert (P elt (EqSet.fold f elt e0)).\nintros; apply ESP.fold_rec; unfold P; intros.\nESD.fsetdec.\nsimpl.\nred in H1.\napply H1 in H3.\ndestruct H3.\nsubst x.\nunfold f.\ndestruct (IndexedEqKind.eq (ekind q) k1).\nsimpl.\nESD.fsetdec.\ncontradiction.\nunfold f.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto.\nauto.\nset (Q := fun e1 e2 =>         ~EqSet.In q e1 \\/ ekind q <> k1 ->         EqSet.In q e2).\nassert (Q elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold Q; intros.\nauto.\nunfold f.\nred in H2.\nrewrite H2 in H4.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence.\napply H3.\nintuition auto.\ndestruct (ESP.In_dec q elt).\ndestruct (IndexedEqKind.eq (ekind q) k1).\nleft.\nsplit.\nf_equal.\napply IN_ELT.\nauto.\nauto.\napply H.\nauto.\nauto.\nright.\napply H0.\nauto.\nright.\napply H0.\nauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) : (ereg q, ekind q) = (r1, k1) /\\\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (subst_reg_kind r1 k1 r2 k2 e0) \\/\nEqSet.In q (subst_reg_kind r1 k1 r2 k2 e0).","conclusion":"(ereg q, ekind q) = (r1, k1) /\\\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (subst_reg_kind r1 k1 r2 k2 e0) \\/\nEqSet.In q (subst_reg_kind r1 k1 r2 k2 e0)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0)","proofString":"set (f := fun (q: EqSet.elt) e =>      if IndexedEqKind.eq (ekind q) k1      then add_equation (Eq k2 r2 (eloc q)) (remove_equation q e)      else e).\ngeneralize (in_elements_between_1 r1 e0).\nset (elt := EqSet.elements_between (select_reg_l r1) (select_reg_h r1) e0).\nintros IN_ELT.\nset (P := fun e1 e2 =>         EqSet.In q e1 -> ekind q = k1 ->         EqSet.In (Eq k2 r2 (eloc q)) e2).\nassert (P elt (EqSet.fold f elt e0)).\nintros; apply ESP.fold_rec; unfold P; intros.\nESD.fsetdec.\nsimpl.\nred in H1.\napply H1 in H3.\ndestruct H3.\nsubst x.\nunfold f.\ndestruct (IndexedEqKind.eq (ekind q) k1).\nsimpl.\nESD.fsetdec.\ncontradiction.\nunfold f.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto.\nauto.\nset (Q := fun e1 e2 =>         ~EqSet.In q e1 \\/ ekind q <> k1 ->         EqSet.In q e2).\nassert (Q elt (EqSet.fold f elt e0)).\napply ESP.fold_rec; unfold Q; intros.\nauto.\nunfold f.\nred in H2.\nrewrite H2 in H4.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence.\napply H3.\nintuition auto.\ndestruct (ESP.In_dec q elt).\ndestruct (IndexedEqKind.eq (ekind q) k1).\nleft.\nsplit.\nf_equal.\napply IN_ELT.\nauto.\nauto.\napply H.\nauto.\nauto.\nright.\napply H0.\nauto.\nright.\napply H0.\nauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H : EqSet.Empty s') (H0 : EqSet.In q s') (H1 : ekind q = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} e0.","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} e0","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H : EqSet.Empty s') (H0 : EqSet.In q s') (H1 : ekind q = k1)","proofString":"ESD.fsetdec."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (if IndexedEqKind.eq (ekind q) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc q |}\n      (remove_equation q a)\n   else a).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (if IndexedEqKind.eq (ekind q) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc q |}\n      (remove_equation q a)\n   else a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1)","proofString":"destruct (IndexedEqKind.eq (ekind q) k1).\nsimpl.\nESD.fsetdec.\ncontradiction."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (e : ekind q = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc q |}\n     (remove_equation q a)).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc q |}\n     (remove_equation q a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (e : ekind q = k1)","proofString":"simpl.\nESD.fsetdec."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (e : ekind q = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc q |} (EqSet.remove q a)).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc q |} (EqSet.remove q a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (e : ekind q = k1)","proofString":"ESD.fsetdec."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (n : ekind q <> k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a.","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (a : eqs) (s' s'' : EqSet.t) (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> q = y \\/ EqSet.In y s') (H0 : ~ EqSet.In q s') (H : EqSet.In q elt) (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H4 : ekind q = k1) (n : ekind q <> k1)","proofString":"contradiction."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1)","proofString":"destruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto.\nauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n     (remove_equation x a)).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n     (remove_equation x a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1)","proofString":"simpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc x |} (EqSet.remove x a)).","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |}\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc x |} (EqSet.remove x a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1)","proofString":"rewrite ESF.add_iff.\nrewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) : {| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} (EqSet.remove x a).","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} (EqSet.remove x a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1)","proofString":"rewrite ESF.remove_iff.\ndestruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) : {| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := k2; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := k2; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1)","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := k2; ereg := r2; eloc := eloc q |}); auto.\nleft.\nsubst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) (e1 : x = {| ekind := k2; ereg := r2; eloc := eloc q |}) : {| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := k2; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |} \\/\nEqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a /\\\nx <> {| ekind := k2; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) (e1 : x = {| ekind := k2; ereg := r2; eloc := eloc q |})","proofString":"left.\nsubst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) (e1 : x = {| ekind := k2; ereg := r2; eloc := eloc q |}) : {| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |}.","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} =\n{| ekind := k2; ereg := r2; eloc := eloc q |}","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (e : ekind x = k1) (e1 : x = {| ekind := k2; ereg := r2; eloc := eloc q |})","proofString":"subst x; auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (n : ekind x <> k1) : EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a.","conclusion":"EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H : EqSet.In x elt) (H0 : ~ EqSet.In x s') (H1 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H2 : EqSet.In q s' ->\nekind q = k1 -> EqSet.In {| ekind := k2; ereg := r2; eloc := eloc q |} a) (H3 : EqSet.In q s') (H4 : ekind q = k1) (n : ekind x <> k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H0 : EqSet.Empty s') (H1 : ~ EqSet.In q s' \\/ ekind q <> k1) : EqSet.In q e0.","conclusion":"EqSet.In q e0","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (s' : EqSet.t) (H0 : EqSet.Empty s') (H1 : ~ EqSet.In q s' \\/ ekind q <> k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : ESP.Add x s' s'') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ EqSet.In q s'' \\/ ekind q <> k1) : EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a).","conclusion":"EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : ESP.Add x s' s'') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ EqSet.In q s'' \\/ ekind q <> k1)","proofString":"red in H2.\nrewrite H2 in H4.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence.\napply H3.\nintuition auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ EqSet.In q s'' \\/ ekind q <> k1) : EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a).","conclusion":"EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ EqSet.In q s'' \\/ ekind q <> k1)","proofString":"rewrite H2 in H4.\ndestruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence.\napply H3.\nintuition auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) : EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a).","conclusion":"EqSet.In q\n  (if IndexedEqKind.eq (ekind x) k1\n   then\n    add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n      (remove_equation x a)\n   else a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1)","proofString":"destruct (IndexedEqKind.eq (ekind x) k1).\nsimpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence.\napply H3.\nintuition auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : EqSet.In q\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n     (remove_equation x a)).","conclusion":"EqSet.In q\n  (add_equation {| ekind := k2; ereg := r2; eloc := eloc x |}\n     (remove_equation x a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"simpl.\nrewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : EqSet.In q\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc x |} (EqSet.remove x a)).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := k2; ereg := r2; eloc := eloc x |} (EqSet.remove x a))","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"rewrite ESF.add_iff.\nrewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : {| ekind := k2; ereg := r2; eloc := eloc x |} = q \\/\nEqSet.In q (EqSet.remove x a).","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} = q \\/\nEqSet.In q (EqSet.remove x a)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"rewrite ESF.remove_iff.\nright.\nsplit.\napply H3.\ntauto.\nintuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : {| ekind := k2; ereg := r2; eloc := eloc x |} = q \\/ EqSet.In q a /\\ x <> q.","conclusion":"{| ekind := k2; ereg := r2; eloc := eloc x |} = q \\/ EqSet.In q a /\\ x <> q","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"right.\nsplit.\napply H3.\ntauto.\nintuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : EqSet.In q a /\\ x <> q.","conclusion":"EqSet.In q a /\\ x <> q","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"split.\napply H3.\ntauto.\nintuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : EqSet.In q a.","conclusion":"EqSet.In q a","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"apply H3.\ntauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : ~ EqSet.In q s' \\/ ekind q <> k1.","conclusion":"~ EqSet.In q s' \\/ ekind q <> k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"tauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1) : x <> q.","conclusion":"x <> q","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (e : ekind x = k1)","proofString":"intuition congruence."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (n : ekind x <> k1) : EqSet.In q a.","conclusion":"EqSet.In q a","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (n : ekind x <> k1)","proofString":"apply H3.\nintuition auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (n : ekind x <> k1) : ~ EqSet.In q s' \\/ ekind q <> k1.","conclusion":"~ EqSet.In q s' \\/ ekind q <> k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (x : EqSet.elt) (a : eqs) (s' s'' : EqSet.t) (H0 : EqSet.In x elt) (H1 : ~ EqSet.In x s') (H2 : forall y : EqSet.elt, EqSet.In y s'' <-> x = y \\/ EqSet.In y s') (H3 : ~ EqSet.In q s' \\/ ekind q <> k1 -> EqSet.In q a) (H4 : ~ (x = q \\/ EqSet.In q s') \\/ ekind q <> k1) (n : ekind x <> k1)","proofString":"intuition auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : (ereg q, ekind q) = (r1, k1).","conclusion":"(ereg q, ekind q) = (r1, k1)","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"f_equal.\napply IN_ELT.\nauto.\nauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : ereg q = r1.","conclusion":"ereg q = r1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"apply IN_ELT.\nauto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : EqSet.In q elt.","conclusion":"EqSet.In q elt","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : ekind q = k1.","conclusion":"ekind q = k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : EqSet.In q elt.","conclusion":"EqSet.In q elt","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1) : ekind q = k1.","conclusion":"ekind q = k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (e : ekind q = k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (n : ekind q <> k1) : ~ EqSet.In q elt \\/ ekind q <> k1.","conclusion":"~ EqSet.In q elt \\/ ekind q <> k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (i : EqSet.In q elt) (n : ekind q <> k1)","proofString":"auto."},{"statement":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt) : ~ EqSet.In q elt \\/ ekind q <> k1.","conclusion":"~ EqSet.In q elt \\/ ekind q <> k1","hypotheses":"(r1 : reg) (k1 : equation_kind) (r2 : reg) (k2 : equation_kind) (q : EqSet.elt) (e0 : eqs) (IN0 : EqSet.In q e0) (f : EqSet.elt -> eqs -> eqs) (elt : EqSet.t) (IN_ELT : forall q0 : EqSet.elt, EqSet.In q0 elt <-> EqSet.In q0 e0 /\\ ereg q0 = r1) (P : EqSet.t -> EqSet.t -> Prop) (H : P elt (EqSet.fold f elt e0)) (Q : EqSet.t -> EqSet.t -> Prop) (H0 : Q elt (EqSet.fold f elt e0)) (n : ~ EqSet.In q elt)","proofString":"auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (C : (ereg {| ekind := Full; ereg := src1; eloc := eloc q |},\n ekind {| ekind := Full; ereg := src1; eloc := eloc q |}) = (\ndst, Low)) (D : EqSet.In\n  {|\n    ekind := Full;\n    ereg := src2;\n    eloc := eloc {| ekind := Full; ereg := src1; eloc := eloc q |}\n  |} e2) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (C : (ereg {| ekind := Full; ereg := src1; eloc := eloc q |},\n ekind {| ekind := Full; ereg := src1; eloc := eloc q |}) = (\ndst, Low)) (D : EqSet.In\n  {|\n    ekind := Full;\n    ereg := src2;\n    eloc := eloc {| ekind := Full; ereg := src1; eloc := eloc q |}\n  |} e2)","proofString":"simpl in C; simpl in D.\ninv C."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (C : (src1, Full) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (C : (src1, Full) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2)","proofString":"inv C."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2)","proofString":"inversion A.\nrewrite H3; rewrite H4.\nrewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src1).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # (ereg q) <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # (ereg q) <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"rewrite H3; rewrite H4.\nrewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src1).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef\n  (sel_val High (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # dst)\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val High (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # dst)\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"rewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src1).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef (sel_val High (Val.longofwords rs # src1 rs # src2))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val High (Val.longofwords rs # src1 rs # src2))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"apply Val.lessdef_trans with (rs#src1).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef (sel_val High (Val.longofwords rs # src1 rs # src2)) rs # src1.","conclusion":"Val.lessdef (sel_val High (Val.longofwords rs # src1 rs # src2)) rs # src1","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"simpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef (Val.hiword (Val.longofwords rs # src1 rs # src2)) rs # src1.","conclusion":"Val.lessdef (Val.hiword (Val.longofwords rs # src1 rs # src2)) rs # src1","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"destruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i : int) : Val.lessdef\n  (Val.hiword\n     match rs # src2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i).","conclusion":"Val.lessdef\n  (Val.hiword\n     match rs # src2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i : int)","proofString":"destruct (rs#src2); simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i i0 : int) : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i).","conclusion":"Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i i0 : int)","proofString":"rewrite Int64.hi_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i i0 : int) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) (i i0 : int)","proofString":"auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef rs # src1 (ls (eloc q)).","conclusion":"Val.lessdef rs # src1 (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"exploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High) : Val.lessdef rs # src1 (ls (eloc q)) -> Val.lessdef rs # src1 (ls (eloc q)).","conclusion":"Val.lessdef rs # src1 (ls (eloc q)) -> Val.lessdef rs # src1 (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, High)) (B : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e1) (D : EqSet.In {| ekind := Full; ereg := src1; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = High)","proofString":"auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2)","proofString":"inversion C.\nrewrite H3; rewrite H4.\nrewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src2).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # (ereg q) <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # (ereg q) <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"rewrite H3; rewrite H4.\nrewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src2).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef\n  (sel_val Low (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # dst)\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val Low (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # dst)\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"rewrite Regmap.gss.\napply Val.lessdef_trans with (rs#src2).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef (sel_val Low (Val.longofwords rs # src1 rs # src2)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val Low (Val.longofwords rs # src1 rs # src2)) (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"apply Val.lessdef_trans with (rs#src2).\nsimpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef (sel_val Low (Val.longofwords rs # src1 rs # src2)) rs # src2.","conclusion":"Val.lessdef (sel_val Low (Val.longofwords rs # src1 rs # src2)) rs # src2","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"simpl.\ndestruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef (Val.loword (Val.longofwords rs # src1 rs # src2)) rs # src2.","conclusion":"Val.lessdef (Val.loword (Val.longofwords rs # src1 rs # src2)) rs # src2","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"destruct (rs#src1); simpl; auto.\ndestruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i : int) : Val.lessdef\n  (Val.loword\n     match rs # src2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) rs # src2.","conclusion":"Val.lessdef\n  (Val.loword\n     match rs # src2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) rs # src2","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i : int)","proofString":"destruct (rs#src2); simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i i0 : int) : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0).","conclusion":"Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i i0 : int)","proofString":"rewrite Int64.lo_ofwords.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i i0 : int) : Val.lessdef (Vint i0) (Vint i0).","conclusion":"Val.lessdef (Vint i0) (Vint i0)","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) (i i0 : int)","proofString":"auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef rs # src2 (ls (eloc q)).","conclusion":"Val.lessdef rs # src2 (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"exploit H0.\neexact D.\nsimpl.\nauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low) : Val.lessdef rs # src2 (ls (eloc q)) -> Val.lessdef rs # src2 (ls (eloc q)).","conclusion":"Val.lessdef rs # src2 (ls (eloc q)) -> Val.lessdef rs # src2 (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (C : (ereg q, ekind q) = (dst, Low)) (D : EqSet.In {| ekind := Full; ereg := src2; eloc := eloc q |} e2) (H3 : ereg q = dst) (H4 : ekind q = Low)","proofString":"auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2) : Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (rs # dst <- (Val.longofwords rs # src1 rs # src2)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2)","proofString":"rewrite Regmap.gso.\napply H0; auto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2)","proofString":"apply H0; auto."},{"statement":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2) : ereg q <> dst.","conclusion":"ereg q <> dst","hypotheses":"(src1 src2 dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (e2 : eqs) (H : reg_unconstrained dst e2 = true) (H0 : satisf rs ls e2) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) (D : EqSet.In q e2)","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) : Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1)","proofString":"inversion A.\nrewrite H3; rewrite H4.\nsimpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef\n  (sel_val (ekind q) (rs # (ereg q) <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # (ereg q) <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"rewrite H3; rewrite H4.\nsimpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (sel_val Full (rs # dst <- (Val.loword rs # src)) # dst)\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val Full (rs # dst <- (Val.loword rs # src)) # dst)\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"simpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (rs # dst <- (Val.loword rs # src)) # dst (ls (eloc q)).","conclusion":"Val.lessdef (rs # dst <- (Val.loword rs # src)) # dst (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"rewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (Val.loword rs # src) (ls (eloc q)).","conclusion":"Val.lessdef (Val.loword rs # src) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"exploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (Val.loword rs # src) (ls (eloc q)) ->\nVal.lessdef (Val.loword rs # src) (ls (eloc q)).","conclusion":"Val.lessdef (Val.loword rs # src) (ls (eloc q)) ->\nVal.lessdef (Val.loword rs # src) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := Low; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.loword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"rewrite Regmap.gso.\napply H0; auto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"apply H0; auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : ereg q <> dst.","conclusion":"ereg q <> dst","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) : Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1)","proofString":"inversion A.\nrewrite H3; rewrite H4.\nsimpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef\n  (sel_val (ekind q) (rs # (ereg q) <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # (ereg q) <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"rewrite H3; rewrite H4.\nsimpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (sel_val Full (rs # dst <- (Val.hiword rs # src)) # dst)\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val Full (rs # dst <- (Val.hiword rs # src)) # dst)\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"simpl.\nrewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (rs # dst <- (Val.hiword rs # src)) # dst (ls (eloc q)).","conclusion":"Val.lessdef (rs # dst <- (Val.hiword rs # src)) # dst (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"rewrite Regmap.gss.\nexploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (Val.hiword rs # src) (ls (eloc q)).","conclusion":"Val.lessdef (Val.hiword rs # src) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"exploit H0.\neexact B.\nsimpl.\nauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full) : Val.lessdef (Val.hiword rs # src) (ls (eloc q)) ->\nVal.lessdef (Val.hiword rs # src) (ls (eloc q)).","conclusion":"Val.lessdef (Val.hiword rs # src) (ls (eloc q)) ->\nVal.lessdef (Val.hiword rs # src) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (A : (ereg q, ekind q) = (dst, Full)) (B : EqSet.In {| ekind := High; ereg := src; eloc := eloc q |} e1) (H3 : ereg q = dst) (H4 : ekind q = Full)","proofString":"auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q) (rs # dst <- (Val.hiword rs # src)) # (ereg q))\n  (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"rewrite Regmap.gso.\napply H0; auto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"apply H0; auto."},{"statement":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1) : ereg q <> dst.","conclusion":"ereg q <> dst","hypotheses":"(src dst : reg) (rs : regset) (ls : locset) (e : eqs) (e1 : eqs) (H : reg_unconstrained dst e1 = true) (H0 : satisf rs ls e1) (q : EqSet.elt) (H1 : EqSet.In q e) (B : EqSet.In q e1)","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (H : EqSet2.fold\n  (fun (q : EqSet2.elt) (opte : option A) =>\n   match opte with\n   | Some e => f q e\n   | None => None\n   end) s (Some init) = Some final) (H0 : forall s' : EqSet2.t, EqSet2.Empty s' -> P s' init) (H1 : forall (x : EqSet2.elt) (a' a'' : A) (s' s'' : EqSet2.t),\nEqSet2.In x s ->\n~ EqSet2.In x s' ->\nESP2.Add x s' s'' -> f x a' = Some a'' -> P s' a' -> P s'' a'') : P s final.","conclusion":"P s final","hypotheses":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (H : EqSet2.fold\n  (fun (q : EqSet2.elt) (opte : option A) =>\n   match opte with\n   | Some e => f q e\n   | None => None\n   end) s (Some init) = Some final) (H0 : forall s' : EqSet2.t, EqSet2.Empty s' -> P s' init) (H1 : forall (x : EqSet2.elt) (a' a'' : A) (s' s'' : EqSet2.t),\nEqSet2.In x s ->\n~ EqSet2.In x s' ->\nESP2.Add x s' s'' -> f x a' = Some a'' -> P s' a' -> P s'' a'')","proofString":"set (g := fun q opte => match opte with Some e => f q e | None => None end) in *.\nset (Q := fun s1 opte => match opte with None => True | Some e => P s1 e end).\nchange (Q s (Some final)).\nrewrite <- H.\napply ESP2.fold_rec; unfold Q, g; intros.\nauto.\ndestruct a as [e|]; auto.\ndestruct (f x e) as [e'|] eqn:F; auto.\neapply H1; eauto."},{"statement":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x : EqSet2.elt) (a' a'' : A) (s'0 s'' : EqSet2.t),\nEqSet2.In x s ->\n~ EqSet2.In x s'0 ->\nESP2.Add x s'0 s'' -> f x a' = Some a'' -> P s'0 a' -> P s'' a'') (Q : EqSet2.t -> option A -> Prop) (s' : EqSet2.t) (H2 : EqSet2.Empty s') : P s' init.","conclusion":"P s' init","hypotheses":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x : EqSet2.elt) (a' a'' : A) (s'0 s'' : EqSet2.t),\nEqSet2.In x s ->\n~ EqSet2.In x s'0 ->\nESP2.Add x s'0 s'' -> f x a' = Some a'' -> P s'0 a' -> P s'' a'') (Q : EqSet2.t -> option A -> Prop) (s' : EqSet2.t) (H2 : EqSet2.Empty s')","proofString":"auto."},{"statement":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (a : option A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : match a with\n| Some e => P s' e\n| None => True\nend) : match match a with\n      | Some e => f x e\n      | None => None\n      end with\n| Some e => P s'' e\n| None => True\nend.","conclusion":"match match a with\n      | Some e => f x e\n      | None => None\n      end with\n| Some e => P s'' e\n| None => True\nend","hypotheses":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (a : option A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : match a with\n| Some e => P s' e\n| None => True\nend)","proofString":"destruct a as [e|]; auto.\ndestruct (f x e) as [e'|] eqn:F; auto.\neapply H1; eauto."},{"statement":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (e : A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : P s' e) : match f x e with\n| Some e0 => P s'' e0\n| None => True\nend.","conclusion":"match f x e with\n| Some e0 => P s'' e0\n| None => True\nend","hypotheses":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (e : A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : P s' e)","proofString":"destruct (f x e) as [e'|] eqn:F; auto.\neapply H1; eauto."},{"statement":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (e : A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : P s' e) (e' : A) (F : f x e = Some e') : P s'' e'.","conclusion":"P s'' e'","hypotheses":"(A : Type) (P : EqSet2.t -> A -> Prop) (f : EqSet2.elt -> A -> option A) (init final : A) (s : EqSet2.t) (g : EqSet2.elt -> option A -> option A) (H : EqSet2.fold g s (Some init) = Some final) (H0 : forall s'0 : EqSet2.t, EqSet2.Empty s'0 -> P s'0 init) (H1 : forall (x0 : EqSet2.elt) (a' a'' : A) (s'0 s''0 : EqSet2.t),\nEqSet2.In x0 s ->\n~ EqSet2.In x0 s'0 ->\nESP2.Add x0 s'0 s''0 -> f x0 a' = Some a'' -> P s'0 a' -> P s''0 a'') (Q : EqSet2.t -> option A -> Prop) (x : EqSet2.elt) (e : A) (s' s'' : EqSet2.t) (H2 : EqSet2.In x s) (H3 : ~ EqSet2.In x s') (H4 : ESP2.Add x s' s'') (H5 : P s' e) (e' : A) (F : f x e = Some e')","proofString":"eapply H1; eauto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0') : eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'.","conclusion":"eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0')","proofString":"set (elt := EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0)) in *.\nset (f := fun q0 e =>             if Loc.eq l1 (eloc q0) then                Some (add_equation                     {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}                     (remove_equation q0 e))             else None).\nset (P := fun e1 e2 => EqSet2.In q e1 -> eloc q = l1 /\\ EqSet.In (Eq (ekind q) (ereg q) l2) e2).\nassert (A: P elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold P; intros.\nESD2.fsetdec.\nunfold P, f; intros.\ndestruct (Loc.eq l1 (eloc x)); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e; auto.\napply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto.\nset (Q := fun e1 e2 => ~EqSet2.In q e1 -> EqSet.In q e2).\nassert (B: Q elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold Q; intros.\nauto.\nunfold Q, f; intros.\ndestruct (Loc.eq l1 (eloc x)); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto.\ndestruct (ESP2.In_dec q elt).\nleft.\napply A; auto.\nright.\nsplit; auto.\nrewrite <- select_loc_charact.\ndestruct (select_loc_l l1 q) eqn: LL; auto.\ndestruct (select_loc_h l1 q) eqn: LH; auto.\nelim n.\neapply EqSet2.elements_between_iff.\nexact (select_loc_l_monotone l1).\nexact (select_loc_h_monotone l1).\nsplit.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s') : eloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} e0.","conclusion":"eloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} e0","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s')","proofString":"ESD2.fsetdec."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  Some\n    (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a''.","conclusion":"eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a''","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  Some\n    (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e; auto.\napply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a')).","conclusion":"eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a'))","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"simpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e; auto.\napply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a')).","conclusion":"eloc q = l1 /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a'))","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"rewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e; auto.\napply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"apply H1 in H4; destruct H4.\nsubst x; rewrite e; auto.\napply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : x = q) : eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : x = q)","proofString":"subst x; rewrite e; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : EqSet2.In q s') : eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : EqSet2.In q s')","proofString":"apply H3 in H2; destruct H2.\nsplit.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') : eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\n({| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n {| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a')","proofString":"split.\ncongruence.\ndestruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') : eloc q = l1.","conclusion":"eloc q = l1","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a')","proofString":"congruence."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') : {| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n{| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}.","conclusion":"{| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n{| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a')","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := ekind q; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e2))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (e1 : x = {| ekind := ekind q; ereg := ereg q; eloc := l2 |}) : {| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n{| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}.","conclusion":"{| ekind := ekind x; ereg := ereg x; eloc := l2 |} =\n{| ekind := ekind q; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := ekind q; ereg := ereg q; eloc := l2 |}","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e2))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\ EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (H2 : eloc q = l1) (H4 : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := l2 |} a') (e1 : x = {| ekind := ekind q; ereg := ereg q; eloc := l2 |})","proofString":"subst x; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s') : EqSet.In q e0.","conclusion":"EqSet.In q e0","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s')","proofString":"auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  Some\n    (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q a''.","conclusion":"EqSet.In q a''","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  Some\n    (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a')).","conclusion":"EqSet.In q\n  (add_equation {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a'))","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"simpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a')).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := ekind x; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a'))","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"red in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s')) : {| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := ekind x; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e1))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s'))","proofString":"intuition auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_l_monotone l1)."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_h_monotone l1)."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"split.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0).","conclusion":"EqSet2.In q (eqs2 e0)","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"apply eqs_same; auto."},{"statement":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        Some\n          (add_equation {| ekind := ekind q0; ereg := ereg q0; eloc := l2 |}\n             (remove_equation q0 e))\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"rewrite EqSet2.for_all_between_iff in H.\ndestruct (select_loc_l l q) eqn: LL.\ndestruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto.\nright.\napply select_loc_charact.\nauto.\nintros; subst; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l)."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e)","proofString":"destruct (select_loc_l l q) eqn: LL.\ndestruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto.\nright.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true)","proofString":"destruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true)","proofString":"left; apply H; auto.\napply eqs_same; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true) : EqSet2.In q (eqs2 e).","conclusion":"EqSet2.In q (eqs2 e)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true)","proofString":"apply eqs_same; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"right.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"apply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : select_loc_l l q = false \\/ select_loc_h l q = false.","conclusion":"select_loc_l l q = false \\/ select_loc_h l q = false","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q).","conclusion":"subtype (sel_type (ekind q) (env (ereg q))) (Loc.type l) = true \\/\nLoc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"right.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"apply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : select_loc_l l q = false \\/ select_loc_h l q = false.","conclusion":"select_loc_l l q = false \\/ select_loc_h l q = false","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true ->\nsubtype (sel_type (ekind x) (env (ereg x))) (Loc.type l) = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 ->\nsubtype (sel_type (ekind x1) (env (ereg x1))) (Loc.type l) =\nsubtype (sel_type (ekind x2) (env (ereg x2))) (Loc.type l).","conclusion":"forall x1 x2 : equation,\nx1 = x2 ->\nsubtype (sel_type (ekind x1) (env (ereg x1))) (Loc.type l) =\nsubtype (sel_type (ekind x2) (env (ereg x2))) (Loc.type l)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"intros; subst; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"exact (select_loc_l_monotone l)."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between\n  (fun q0 : EqSet2.elt =>\n   subtype (sel_type (ekind q0) (env (ereg q0))) (Loc.type l))\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"exact (select_loc_h_monotone l)."},{"statement":"(env : regenv) (l : loc) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : match l with\n| R _ => true\n| S _ _ _ => loc_type_compat env l e\nend = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (H1 : wt_regset env rs) : match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend.","conclusion":"match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend","hypotheses":"(env : regenv) (l : loc) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : match l with\n| R _ => true\n| S _ _ _ => loc_type_compat env l e\nend = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (H1 : wt_regset env rs)","proofString":"destruct l as [mr | sl ofs ty].\nauto.\nexploit loc_type_compat_charact; eauto.\nintros [A | A].\nsimpl in A.\neapply Val.has_subtype; eauto.\ngeneralize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I.\neelim Loc.diff_not_eq.\neexact A.\nauto."},{"statement":"(env : regenv) (mr : mreg) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : true = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (H1 : wt_regset env rs) : True.","conclusion":"True","hypotheses":"(env : regenv) (mr : mreg) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : true = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (H1 : wt_regset env rs)","proofString":"auto."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) : Val.has_type (sel_val k rs # r) ty.","conclusion":"Val.has_type (sel_val k rs # r) ty","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs)","proofString":"exploit loc_type_compat_charact; eauto.\nintros [A | A].\nsimpl in A.\neapply Val.has_subtype; eauto.\ngeneralize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I.\neelim Loc.diff_not_eq.\neexact A.\nauto."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) : subtype\n  (sel_type (ekind {| ekind := k; ereg := r; eloc := S sl ofs ty |})\n     (env (ereg {| ekind := k; ereg := r; eloc := S sl ofs ty |})))\n  (Loc.type (S sl ofs ty)) = true \\/\nLoc.diff (S sl ofs ty)\n  (eloc {| ekind := k; ereg := r; eloc := S sl ofs ty |}) ->\nVal.has_type (sel_val k rs # r) ty.","conclusion":"subtype\n  (sel_type (ekind {| ekind := k; ereg := r; eloc := S sl ofs ty |})\n     (env (ereg {| ekind := k; ereg := r; eloc := S sl ofs ty |})))\n  (Loc.type (S sl ofs ty)) = true \\/\nLoc.diff (S sl ofs ty)\n  (eloc {| ekind := k; ereg := r; eloc := S sl ofs ty |}) ->\nVal.has_type (sel_val k rs # r) ty","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs)","proofString":"intros [A | A].\nsimpl in A.\neapply Val.has_subtype; eauto.\ngeneralize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I.\neelim Loc.diff_not_eq.\neexact A.\nauto."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype\n  (sel_type (ekind {| ekind := k; ereg := r; eloc := S sl ofs ty |})\n     (env (ereg {| ekind := k; ereg := r; eloc := S sl ofs ty |})))\n  (Loc.type (S sl ofs ty)) = true) : Val.has_type (sel_val k rs # r) ty.","conclusion":"Val.has_type (sel_val k rs # r) ty","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype\n  (sel_type (ekind {| ekind := k; ereg := r; eloc := S sl ofs ty |})\n     (env (ereg {| ekind := k; ereg := r; eloc := S sl ofs ty |})))\n  (Loc.type (S sl ofs ty)) = true)","proofString":"simpl in A.\neapply Val.has_subtype; eauto.\ngeneralize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true) : Val.has_type (sel_val k rs # r) ty.","conclusion":"Val.has_type (sel_val k rs # r) ty","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true)","proofString":"eapply Val.has_subtype; eauto.\ngeneralize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true) : Val.has_type (sel_val k rs # r) (sel_type k (env r)).","conclusion":"Val.has_type (sel_val k rs # r) (sel_type k (env r))","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true)","proofString":"generalize (H1 r).\ndestruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true) : Val.has_type rs # r (env r) ->\nVal.has_type (sel_val k rs # r) (sel_type k (env r)).","conclusion":"Val.has_type rs # r (env r) ->\nVal.has_type (sel_val k rs # r) (sel_type k (env r))","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type k (env r)) ty = true)","proofString":"destruct k; simpl; intros.\nauto.\ndestruct (rs#r); exact I.\ndestruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := Full; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type Full (env r)) ty = true) (H2 : Val.has_type rs # r (env r)) : Val.has_type rs # r (env r).","conclusion":"Val.has_type rs # r (env r)","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := Full; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type Full (env r)) ty = true) (H2 : Val.has_type rs # r (env r))","proofString":"auto."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := Low; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type Low (env r)) ty = true) (H2 : Val.has_type rs # r (env r)) : Val.has_type (Val.loword rs # r) Tint.","conclusion":"Val.has_type (Val.loword rs # r) Tint","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := Low; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type Low (env r)) ty = true) (H2 : Val.has_type rs # r (env r))","proofString":"destruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := High; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type High (env r)) ty = true) (H2 : Val.has_type rs # r (env r)) : Val.has_type (Val.hiword rs # r) Tint.","conclusion":"Val.has_type (Val.hiword rs # r) Tint","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := High; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : subtype (sel_type High (env r)) ty = true) (H2 : Val.has_type rs # r (env r))","proofString":"destruct (rs#r); exact I."},{"statement":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : Loc.diff (S sl ofs ty)\n  (eloc {| ekind := k; ereg := r; eloc := S sl ofs ty |})) : Val.has_type (sel_val k rs # r) ty.","conclusion":"Val.has_type (sel_val k rs # r) ty","hypotheses":"(env : regenv) (sl : slot) (ofs : Z) (ty : typ) (e : eqs) (k : equation_kind) (r : reg) (rs : regset) (H : loc_type_compat env (S sl ofs ty) e = true) (H0 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (H1 : wt_regset env rs) (A : Loc.diff (S sl ofs ty)\n  (eloc {| ekind := k; ereg := r; eloc := S sl ofs ty |}))","proofString":"eelim Loc.diff_not_eq.\neexact A.\nauto."},{"statement":"(v v' : val) (ty : typ) (H : Val.has_type v ty) (H0 : Val.lessdef v v') : Val.lessdef v (Val.load_result (chunk_of_type ty) v').","conclusion":"Val.lessdef v (Val.load_result (chunk_of_type ty) v')","hypotheses":"(v v' : val) (ty : typ) (H : Val.has_type v ty) (H0 : Val.lessdef v v')","proofString":"inv H0.\nrewrite Val.load_result_same; auto.\nauto."},{"statement":"(v' : val) (ty : typ) (H : Val.has_type v' ty) : Val.lessdef v' (Val.load_result (chunk_of_type ty) v').","conclusion":"Val.lessdef v' (Val.load_result (chunk_of_type ty) v')","hypotheses":"(v' : val) (ty : typ) (H : Val.has_type v' ty)","proofString":"rewrite Val.load_result_same; auto."},{"statement":"(v' : val) (ty : typ) (H : Val.has_type Vundef ty) : Val.lessdef Vundef (Val.load_result (chunk_of_type ty) v').","conclusion":"Val.lessdef Vundef (Val.load_result (chunk_of_type ty) v')","hypotheses":"(v' : val) (ty : typ) (H : Val.has_type Vundef ty)","proofString":"auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e)","proofString":"exploit in_subst_loc; eauto.\nintros [[A B] | [A B]].\nsubst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B).\nrewrite Locmap.gso; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) : eloc q = dst /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e' \\/\nLoc.diff dst (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q)).","conclusion":"eloc q = dst /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e' \\/\nLoc.diff dst (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e)","proofString":"intros [[A B] | [A B]].\nsubst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B).\nrewrite Locmap.gso; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) (A : eloc q = dst) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) (A : eloc q = dst) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"subst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (q : EqSet.elt) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (eloc q) (ls src) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (eloc q) (ls src) ls (eloc q))","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (q : EqSet.elt) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"rewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (q : EqSet.elt) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  match eloc q with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  match eloc q with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (q : EqSet.elt) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"destruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') : Val.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"Val.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e')","proofString":"exploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') : match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend ->\nVal.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend ->\nVal.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e')","proofString":"destruct l as [mr | sl ofs ty]; intros.\napply (H2 _ B).\napply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (mr : mreg) (H0 : well_typed_move env (R mr) e = true) (H : subst_loc (R mr) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : True) : Val.lessdef (sel_val k rs # r) (ls src).","conclusion":"Val.lessdef (sel_val k rs # r) (ls src)","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (mr : mreg) (H0 : well_typed_move env (R mr) e = true) (H : subst_loc (R mr) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : True)","proofString":"apply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : Val.has_type (sel_val k rs # r) ty) : Val.lessdef (sel_val k rs # r) (Val.load_result (chunk_of_type ty) (ls src)).","conclusion":"Val.lessdef (sel_val k rs # r) (Val.load_result (chunk_of_type ty) (ls src))","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : Val.has_type (sel_val k rs # r) ty)","proofString":"apply val_lessdef_normalize; auto.\napply (H2 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : Val.has_type (sel_val k rs # r) ty) : Val.lessdef (sel_val k rs # r) (ls src).","conclusion":"Val.lessdef (sel_val k rs # r) (ls src)","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H4 : Val.has_type (sel_val k rs # r) ty)","proofString":"apply (H2 _ B)."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (q : EqSet.elt) (H3 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"rewrite Locmap.gso; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0') : eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'.","conclusion":"eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0')","proofString":"set (elt := EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0)) in *.\nset (f := fun q0 e =>             if Loc.eq l1 (eloc q0) then             if IndexedEqKind.eq (ekind q0) k then                Some (add_equation                     {| ekind := Full; ereg := ereg q0; eloc := l2 |}                     (remove_equation q0 e))             else None else None).\nset (P := fun e1 e2 => EqSet2.In q e1 -> eloc q = l1 /\\ ekind q = k /\\ EqSet.In (Eq Full (ereg q) l2) e2).\nassert (A: P elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold P; intros.\nESD2.fsetdec.\nunfold P, f; intros.\ndestruct (Loc.eq l1 (eloc x)); try discriminate.\ndestruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto.\nset (Q := fun e1 e2 => ~EqSet2.In q e1 -> EqSet.In q e2).\nassert (B: Q elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold Q; intros.\nauto.\nunfold Q, f; intros.\ndestruct (Loc.eq l1 (eloc x)); try congruence.\ndestruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto.\ndestruct (ESP2.In_dec q elt).\nleft.\napply A; auto.\nright.\nsplit; auto.\nrewrite <- select_loc_charact.\ndestruct (select_loc_l l1 q) eqn: LL; auto.\ndestruct (select_loc_h l1 q) eqn: LH; auto.\nelim n.\neapply EqSet2.elements_between_iff.\nexact (select_loc_l_monotone l1).\nexact (select_loc_h_monotone l1).\nsplit.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s') : eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} e0.","conclusion":"eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} e0","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s')","proofString":"ESD2.fsetdec."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) k\n  then\n   Some\n     (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n        (remove_equation x a'))\n  else None\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a''.","conclusion":"eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a''","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) k\n  then\n   Some\n     (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n        (remove_equation x a'))\n  else None\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); try discriminate.\ndestruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e1))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) k\n then\n  Some\n    (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a''.","conclusion":"eloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a''","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e1))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) k\n then\n  Some\n    (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"destruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = k /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a')).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a'))","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"simpl.\nrewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = k /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a')).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a'))","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"rewrite ESF.add_iff, ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H4 : EqSet2.In q s'')","proofString":"apply H1 in H4; destruct H4.\nsubst x; rewrite e, <- e1; auto.\napply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H2 : x = q) : eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H2 : x = q)","proofString":"subst x; rewrite e, <- e1; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H2 : EqSet2.In q s') : eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (H2 : EqSet2.In q s')","proofString":"apply H3 in H2; destruct H2 as (X & Y & Z).\nsplit; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') : eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |}).","conclusion":"eloc q = l1 /\\\nekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a')","proofString":"split; auto.\nsplit; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') : ekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |}).","conclusion":"ekind q = k /\\\n({| ekind := Full; ereg := ereg x; eloc := l2 |} =\n {| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := Full; ereg := ereg q; eloc := l2 |})","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a')","proofString":"split; auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') : {| ekind := Full; ereg := ereg x; eloc := l2 |} =\n{| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := Full; ereg := ereg q; eloc := l2 |}.","conclusion":"{| ekind := Full; ereg := ereg x; eloc := l2 |} =\n{| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := Full; ereg := ereg q; eloc := l2 |}","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a')","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := Full; ereg := ereg q; eloc := l2 |}); auto.\nsubst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e3))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (e2 : x = {| ekind := Full; ereg := ereg q; eloc := l2 |}) : {| ekind := Full; ereg := ereg x; eloc := l2 |} =\n{| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := Full; ereg := ereg q; eloc := l2 |}.","conclusion":"{| ekind := Full; ereg := ereg x; eloc := l2 |} =\n{| ekind := Full; ereg := ereg q; eloc := l2 |} \\/\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a' /\\\nx <> {| ekind := Full; ereg := ereg q; eloc := l2 |}","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e3))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = k /\\ EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (X : eloc q = l1) (Y : ekind q = k) (Z : EqSet.In {| ekind := Full; ereg := ereg q; eloc := l2 |} a') (e2 : x = {| ekind := Full; ereg := ereg q; eloc := l2 |})","proofString":"subst x; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s') : EqSet.In q e0.","conclusion":"EqSet.In q e0","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s')","proofString":"auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) k\n  then\n   Some\n     (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n        (remove_equation x a'))\n  else None\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q a''.","conclusion":"EqSet.In q a''","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) k\n  then\n   Some\n     (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n        (remove_equation x a'))\n  else None\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); try congruence.\ndestruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e1))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) k\n then\n  Some\n    (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q a''.","conclusion":"EqSet.In q a''","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e1))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) k\n then\n  Some\n    (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n       (remove_equation x a'))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"destruct (IndexedEqKind.eq (ekind x) k); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a')).","conclusion":"EqSet.In q\n  (add_equation {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (remove_equation x a'))","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"simpl.\nrewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (EqSet.add {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a')).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := Full; ereg := ereg x; eloc := l2 |}\n     (EqSet.remove x a'))","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite ESF.add_iff, ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"red in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s')) : {| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := Full; ereg := ereg x; eloc := l2 |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e2))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = k) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s'))","proofString":"intuition auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_l_monotone l1)."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_h_monotone l1)."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"split.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0).","conclusion":"EqSet2.In q (eqs2 e0)","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"apply eqs_same; auto."},{"statement":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 : loc) (k : equation_kind) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) k\n        then\n         Some\n           (add_equation {| ekind := Full; ereg := ereg q0; eloc := l2 |}\n              (remove_equation q0 e))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"exploit in_subst_loc_part; eauto.\nintros [[A [B C]] | [A B]].\nrewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.loword_lessdef.\nexact C.\nrewrite Locmap.gso; auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) : eloc q = R dst /\\\nekind q = Low /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q)).","conclusion":"eloc q = R dst /\\\nekind q = Low /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"intros [[A [B C]] | [A B]].\nrewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.loword_lessdef.\nexact C.\nrewrite Locmap.gso; auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e')","proofString":"rewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.loword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e') : Val.lessdef (sel_val Low rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (R dst)).","conclusion":"Val.lessdef (sel_val Low rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (R dst))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e')","proofString":"apply H0 in C.\nrewrite Locmap.gss.\napply Val.loword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef (sel_val Low rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (R dst)).","conclusion":"Val.lessdef (sel_val Low rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (R dst))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"rewrite Locmap.gss.\napply Val.loword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef (sel_val Low rs # (ereg q)) (Val.loword (ls (R src))).","conclusion":"Val.lessdef (sel_val Low rs # (ereg q)) (Val.loword (ls (R src)))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"apply Val.loword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef rs # (ereg q) (ls (R src)).","conclusion":"Val.lessdef rs # (ereg q) (ls (R src))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Low) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"exact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.loword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) Low e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e')","proofString":"rewrite Locmap.gso; auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"exploit in_subst_loc_part; eauto.\nintros [[A [B C]] | [A B]].\nrewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.hiword_lessdef.\nexact C.\nrewrite Locmap.gso; auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) : eloc q = R dst /\\\nekind q = High /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q)).","conclusion":"eloc q = R dst /\\\nekind q = High /\\\nEqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"intros [[A [B C]] | [A B]].\nrewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.hiword_lessdef.\nexact C.\nrewrite Locmap.gso; auto."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e')","proofString":"rewrite A, B.\napply H0 in C.\nrewrite Locmap.gss.\napply Val.hiword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e') : Val.lessdef (sel_val High rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (R dst)).","conclusion":"Val.lessdef (sel_val High rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (R dst))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : EqSet.In {| ekind := Full; ereg := ereg q; eloc := R src |} e')","proofString":"apply H0 in C.\nrewrite Locmap.gss.\napply Val.hiword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef (sel_val High rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (R dst)).","conclusion":"Val.lessdef (sel_val High rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (R dst))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"rewrite Locmap.gss.\napply Val.hiword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef (sel_val High rs # (ereg q)) (Val.hiword (ls (R src))).","conclusion":"Val.lessdef (sel_val High rs # (ereg q)) (Val.hiword (ls (R src)))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"apply Val.hiword_lessdef.\nexact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |}))) : Val.lessdef rs # (ereg q) (ls (R src)).","conclusion":"Val.lessdef rs # (ereg q) (ls (R src))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = High) (C : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := ereg q; eloc := R src |})\n     rs # (ereg {| ekind := Full; ereg := ereg q; eloc := R src |}))\n  (ls (eloc {| ekind := Full; ereg := ereg q; eloc := R src |})))","proofString":"exact C."},{"statement":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.hiword (ls (R src))) ls (eloc q))","hypotheses":"(src dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_part (R dst) (R src) High e = Some e') (H0 : satisf rs ls e') (q : EqSet.elt) (H1 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e')","proofString":"rewrite Locmap.gso; auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} e0' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'.","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} e0' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} e0' \\/\nLoc.diff l1 (eloc q) /\\ EqSet.In q e0'","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end)\n  (EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0))\n  (Some e0) = Some e0')","proofString":"set (elt := EqSet2.elements_between (select_loc_l l1) (select_loc_h l1) (eqs2 e0)) in *.\nset (f := fun q0 e =>             if Loc.eq l1 (eloc q0) then             if IndexedEqKind.eq (ekind q0) Full then                Some (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}                     (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}                     (remove_equation q0 e)))             else None else None).\nset (P := fun e1 e2 => EqSet2.In q e1 -> eloc q = l1 /\\ ekind q = Full                                        /\\ EqSet.In (Eq High (ereg q) l2) e2                                        /\\ EqSet.In (Eq Low (ereg q) l2') e2).\nassert (A: P elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold P; intros.\nESD2.fsetdec.\nunfold P, f; intros.\ndestruct (Loc.eq l1 (eloc x)); try discriminate.\ndestruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto.\nset (Q := fun e1 e2 => ~EqSet2.In q e1 -> EqSet.In q e2).\nassert (B: Q elt e0').\neapply partial_fold_ind with (f := f) (s := elt) (final := e0').\neexact SUBST.\nunfold Q; intros.\nauto.\nunfold Q, f; intros.\ndestruct (Loc.eq l1 (eloc x)); try congruence.\ndestruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto.\ndestruct (ESP2.In_dec q elt).\nleft.\napply A; auto.\nright.\nsplit; auto.\nrewrite <- select_loc_charact.\ndestruct (select_loc_l l1 q) eqn: LL; auto.\ndestruct (select_loc_h l1 q) eqn: LH; auto.\nelim n.\neapply EqSet2.elements_between_iff.\nexact (select_loc_l_monotone l1).\nexact (select_loc_h_monotone l1).\nsplit.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} e0 /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} e0.","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} e0 /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} e0","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : EqSet2.In q s')","proofString":"ESD2.fsetdec."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) Full\n  then\n   Some\n     (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n        (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n           (remove_equation x a')))\n  else None\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a'' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a''.","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a'' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a''","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) Full\n  then\n   Some\n     (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n        (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n           (remove_equation x a')))\n  else None\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); try discriminate.\ndestruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e1)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) Full\n then\n  Some\n    (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n       (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n          (remove_equation x a')))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a'' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a''.","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a'' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a''","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e1)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) Full\n then\n  Some\n    (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n       (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n          (remove_equation x a')))\n else None) = Some a'') (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'')","proofString":"destruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a'))) /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |}\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a'))).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |}\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a'))) /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |}\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a')))","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'')","proofString":"simpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a'))) /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |}\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a'))).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |}\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a'))) /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |}\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a')))","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'')","proofString":"rewrite ! ESF.add_iff, ! ESF.remove_iff.\napply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'') : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H4 : EqSet2.In q s'')","proofString":"apply H1 in H4; destruct H4.\nsubst x.\nrewrite e, e1.\nintuition auto.\napply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H2 : x = q) : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H2 : x = q)","proofString":"subst x.\nrewrite e, e1.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind q = Full) (e : l1 = eloc q) (H1 : ESP2.Add q s' s'') (H0 : ~ EqSet2.In q s') (H : EqSet2.In q elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n q <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n q <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n q <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n q <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind q = Full) (e : l1 = eloc q) (H1 : ESP2.Add q s' s'') (H0 : ~ EqSet2.In q s') (H : EqSet2.In q elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a')","proofString":"rewrite e, e1.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind q = Full) (e : l1 = eloc q) (H1 : ESP2.Add q s' s'') (H0 : ~ EqSet2.In q s') (H : EqSet2.In q elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') : eloc q = eloc q /\\\nFull = Full /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n q <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n q <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = eloc q /\\\nFull = Full /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n q <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg q; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg q; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n q <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind q = Full) (e : l1 = eloc q) (H1 : ESP2.Add q s' s'') (H0 : ~ EqSet2.In q s') (H : EqSet2.In q elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a')","proofString":"intuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H2 : EqSet2.In q s') : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (H2 : EqSet2.In q s')","proofString":"apply H3 in H2; destruct H2 as (U & V & W & X).\ndestruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a')","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := High; ereg := ereg q; eloc := l2 |}).\nsubst x.\nintuition auto.\ndestruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e3)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (e2 : x = {| ekind := High; ereg := ereg q; eloc := l2 |}) : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e3)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (e2 : x = {| ekind := High; ereg := ereg q; eloc := l2 |})","proofString":"subst x.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind {| ekind := High; ereg := ereg q; eloc := l2 |} = Full) (e : l1 = eloc {| ekind := High; ereg := ereg q; eloc := l2 |}) (H1 : ESP2.Add {| ekind := High; ereg := ereg q; eloc := l2 |} s' s'') (H0 : ~ EqSet2.In {| ekind := High; ereg := ereg q; eloc := l2 |} s') (H : EqSet2.In {| ekind := High; ereg := ereg q; eloc := l2 |} elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') : eloc q = l1 /\\\nekind q = Full /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2'\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n {| ekind := High; ereg := ereg q; eloc := l2 |} <>\n {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2'\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n {| ekind := High; ereg := ereg q; eloc := l2 |} <>\n {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2'\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n {| ekind := High; ereg := ereg q; eloc := l2 |} <>\n {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := High; ereg := ereg q; eloc := l2 |};\n   eloc := l2'\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n {| ekind := High; ereg := ereg q; eloc := l2 |} <>\n {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind {| ekind := High; ereg := ereg q; eloc := l2 |} = Full) (e : l1 = eloc {| ekind := High; ereg := ereg q; eloc := l2 |}) (H1 : ESP2.Add {| ekind := High; ereg := ereg q; eloc := l2 |} s' s'') (H0 : ~ EqSet2.In {| ekind := High; ereg := ereg q; eloc := l2 |} s') (H : EqSet2.In {| ekind := High; ereg := ereg q; eloc := l2 |} elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a')","proofString":"intuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |})","proofString":"destruct (OrderedEquation.eq_dec x {| ekind := Low; ereg := ereg q; eloc := l2' |}).\nsubst x.\nintuition auto.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e3)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) (e2 : x = {| ekind := Low; ereg := ereg q; eloc := l2' |}) : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e3 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e3)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) (e2 : x = {| ekind := Low; ereg := ereg q; eloc := l2' |})","proofString":"subst x.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind {| ekind := Low; ereg := ereg q; eloc := l2' |} = Full) (e : l1 = eloc {| ekind := Low; ereg := ereg q; eloc := l2' |}) (H1 : ESP2.Add {| ekind := Low; ereg := ereg q; eloc := l2' |} s' s'') (H0 : ~ EqSet2.In {| ekind := Low; ereg := ereg q; eloc := l2' |} s') (H : EqSet2.In {| ekind := Low; ereg := ereg q; eloc := l2' |} elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n{| ekind := High; ereg := ereg q; eloc := l2 |}) : eloc q = l1 /\\\nekind q = Full /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2'\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2'\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2'\n |} = {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({|\n   ekind := High;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {|\n   ekind := Low;\n   ereg := ereg {| ekind := Low; ereg := ereg q; eloc := l2' |};\n   eloc := l2'\n |} = {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (a' : eqs) (s' s'' : EqSet2.t) (e1 : ekind {| ekind := Low; ereg := ereg q; eloc := l2' |} = Full) (e : l1 = eloc {| ekind := Low; ereg := ereg q; eloc := l2' |}) (H1 : ESP2.Add {| ekind := Low; ereg := ereg q; eloc := l2' |} s' s'') (H0 : ~ EqSet2.In {| ekind := Low; ereg := ereg q; eloc := l2' |} s') (H : EqSet2.In {| ekind := Low; ereg := ereg q; eloc := l2' |} elt) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : {| ekind := Low; ereg := ereg q; eloc := l2' |} <>\n{| ekind := High; ereg := ereg q; eloc := l2 |})","proofString":"intuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) (n0 : x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}) : eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |}).","conclusion":"eloc q = l1 /\\\nekind q = Full /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := High; ereg := ereg q; eloc := l2 |} \\/\n EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\n x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) /\\\n({| ekind := High; ereg := ereg x; eloc := l2 |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n {| ekind := Low; ereg := ereg x; eloc := l2' |} =\n {| ekind := Low; ereg := ereg q; eloc := l2' |} \\/\n EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a' /\\\n x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : EqSet2.In q s' ->\neloc q = l1 /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (U : eloc q = l1) (V : ekind q = Full) (W : EqSet.In {| ekind := High; ereg := ereg q; eloc := l2 |} a') (X : EqSet.In {| ekind := Low; ereg := ereg q; eloc := l2' |} a') (n : x <> {| ekind := High; ereg := ereg q; eloc := l2 |}) (n0 : x <> {| ekind := Low; ereg := ereg q; eloc := l2' |})","proofString":"intuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s') : EqSet.In q e0.","conclusion":"EqSet.In q e0","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (s' : EqSet2.t) (H : EqSet2.Empty s') (H0 : ~ EqSet2.In q s')","proofString":"auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) Full\n  then\n   Some\n     (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n        (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n           (remove_equation x a')))\n  else None\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q a''.","conclusion":"EqSet.In q a''","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (H2 : (if Loc.eq l1 (eloc x)\n then\n  if IndexedEqKind.eq (ekind x) Full\n  then\n   Some\n     (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n        (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n           (remove_equation x a')))\n  else None\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"destruct (Loc.eq l1 (eloc x)); try congruence.\ndestruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e1)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) Full\n then\n  Some\n    (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n       (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n          (remove_equation x a')))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q a''.","conclusion":"EqSet.In q a''","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e1 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e1)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' a'' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (H2 : (if IndexedEqKind.eq (ekind x) Full\n then\n  Some\n    (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n       (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n          (remove_equation x a')))\n else None) = Some a'') (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"destruct (IndexedEqKind.eq (ekind x) Full); inversion H2; subst a''; clear H2.\nsimpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a'))).","conclusion":"EqSet.In q\n  (add_equation {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (add_equation {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (remove_equation x a')))","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"simpl.\nrewrite ! ESF.add_iff, ! ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : EqSet.In q\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a'))).","conclusion":"EqSet.In q\n  (EqSet.add {| ekind := High; ereg := ereg x; eloc := l2 |}\n     (EqSet.add {| ekind := Low; ereg := ereg x; eloc := l2' |}\n        (EqSet.remove x a')))","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite ! ESF.add_iff, ! ESF.remove_iff.\nred in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : ESP2.Add x s' s'') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"red in H1.\nrewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'') : {| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ EqSet2.In q s'')","proofString":"rewrite H1 in H4.\nintuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s')) : {| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q.","conclusion":"{| ekind := High; ereg := ereg x; eloc := l2 |} = q \\/\n{| ekind := Low; ereg := ereg x; eloc := l2' |} = q \\/\nEqSet.In q a' /\\ x <> q","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e2 =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e2)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (x : EqSet2.elt) (a' : eqs) (s' s'' : EqSet2.t) (H : EqSet2.In x elt) (H0 : ~ EqSet2.In x s') (H1 : forall y : EqSet2.elt, EqSet2.In y s'' <-> x = y \\/ EqSet2.In y s') (e : l1 = eloc x) (e1 : ekind x = Full) (H3 : ~ EqSet2.In q s' -> EqSet.In q a') (H4 : ~ (x = q \\/ EqSet2.In q s'))","proofString":"intuition auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l1 x1 = true -> select_loc_l l1 x2 = true","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_l_monotone l1)."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l1 x1 = true -> select_loc_h l1 x2 = true","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"exact (select_loc_h_monotone l1)."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"EqSet2.In q (eqs2 e0) /\\ select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"split.\napply eqs_same; auto.\nauto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : EqSet2.In q (eqs2 e0).","conclusion":"EqSet2.In q (eqs2 e0)","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"apply eqs_same; auto."},{"statement":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true) : select_loc_l l1 q = true /\\ select_loc_h l1 q = true.","conclusion":"select_loc_l l1 q = true /\\ select_loc_h l1 q = true","hypotheses":"(l1 l2 l2' : loc) (q : EqSet.elt) (e0 e0' : eqs) (IN : EqSet.In q e0) (elt : EqSet2.t) (SUBST : EqSet2.fold\n  (fun (q0 : EqSet2.elt) (opte : option eqs) =>\n   match opte with\n   | Some e =>\n       if Loc.eq l1 (eloc q0)\n       then\n        if IndexedEqKind.eq (ekind q0) Full\n        then\n         Some\n           (add_equation {| ekind := High; ereg := ereg q0; eloc := l2 |}\n              (add_equation {| ekind := Low; ereg := ereg q0; eloc := l2' |}\n                 (remove_equation q0 e)))\n        else None\n       else None\n   | None => None\n   end) elt (Some e0) = Some e0') (f : equation -> eqs -> option eqs) (P : EqSet2.t -> EqSet.t -> Prop) (A : P elt e0') (Q : EqSet2.t -> EqSet.t -> Prop) (B : Q elt e0') (n : ~ EqSet2.In q elt) (LL : select_loc_l l1 q = true) (LH : select_loc_h l1 q = true)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"rewrite EqSet2.for_all_between_iff in H.\ndestruct (select_loc_l l q) eqn: LL.\ndestruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto.\nright.\napply select_loc_charact.\nauto.\nintros; subst; auto.\nexact (select_loc_l_monotone l).\nexact (select_loc_h_monotone l)."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e)","proofString":"destruct (select_loc_l l q) eqn: LL.\ndestruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto.\nright.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true)","proofString":"destruct (select_loc_h l q) eqn: LH.\nleft; apply H; auto.\napply eqs_same; auto.\nright.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true)","proofString":"left; apply H; auto.\napply eqs_same; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true) : EqSet2.In q (eqs2 e).","conclusion":"EqSet2.In q (eqs2 e)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = true)","proofString":"apply eqs_same; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"right.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"apply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false) : select_loc_l l q = false \\/ select_loc_h l q = false.","conclusion":"select_loc_l l q = false \\/ select_loc_h l q = false","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = true) (LH : select_loc_h l q = false)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q).","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"right.\napply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : Loc.diff l (eloc q).","conclusion":"Loc.diff l (eloc q)","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"apply select_loc_charact.\nauto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false) : select_loc_l l q = false \\/ select_loc_h l q = false.","conclusion":"select_loc_l l q = false \\/ select_loc_h l q = false","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet2.elt,\nEqSet2.In x (eqs2 e) ->\nselect_loc_l l x = true ->\nselect_loc_h l x = true -> subtype (env (ereg x)) Tlong = true) (H0 : EqSet.In q e) (LL : select_loc_l l q = false)","proofString":"auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 -> subtype (env (ereg x1)) Tlong = subtype (env (ereg x2)) Tlong.","conclusion":"forall x1 x2 : equation,\nx1 = x2 -> subtype (env (ereg x1)) Tlong = subtype (env (ereg x2)) Tlong","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"intros; subst; auto."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x1) (eloc x2) \\/\neloc x1 = eloc x2 /\\\n(Plt (ereg x1) (ereg x2) \\/\n ereg x1 = ereg x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_loc_l l x1 = true -> select_loc_l l x2 = true","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"exact (select_loc_l_monotone l)."},{"statement":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e) : forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nOrderedLoc.lt (eloc x2) (eloc x1) \\/\neloc x2 = eloc x1 /\\\n(Plt (ereg x2) (ereg x1) \\/\n ereg x2 = ereg x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_loc_h l x1 = true -> select_loc_h l x2 = true","hypotheses":"(env : regenv) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet2.for_all_between (fun q0 : EqSet2.elt => subtype (env (ereg q0)) Tlong)\n  (select_loc_l l) (select_loc_h l) (eqs2 e) = true) (H0 : EqSet.In q e)","proofString":"exact (select_loc_h_monotone l)."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e)","proofString":"exploit in_subst_loc_pair; eauto.\nintros [[A [B [C D]]] | [A B]].\nrewrite A, B.\napply H2 in C.\napply H2 in D.\nassert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption.\nrewrite Locmap.gso; auto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) : eloc q = R dst /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q)).","conclusion":"eloc q = R dst /\\\nekind q = Full /\\\nEqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e' /\\\nEqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e' \\/\nLoc.diff (R dst) (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e)","proofString":"intros [[A [B [C D]]] | [A B]].\nrewrite A, B.\napply H2 in C.\napply H2 in D.\nassert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption.\nrewrite Locmap.gso; auto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : EqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e') (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : EqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e') (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e')","proofString":"rewrite A, B.\napply H2 in C.\napply H2 in D.\nassert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : EqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e') (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e') : Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst)).","conclusion":"Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : EqSet.In {| ekind := High; ereg := ereg q; eloc := R src1 |} e') (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e')","proofString":"apply H2 in C.\napply H2 in D.\nassert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e') : Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst)).","conclusion":"Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : EqSet.In {| ekind := Low; ereg := ereg q; eloc := R src2 |} e')","proofString":"apply H2 in D.\nassert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) : Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst)).","conclusion":"Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |})))","proofString":"assert (subtype (env (ereg q)) Tlong = true).\nexploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto.\nrewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) : subtype (env (ereg q)) Tlong = true.","conclusion":"subtype (env (ereg q)) Tlong = true","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |})))","proofString":"exploit long_type_compat_charact; eauto.\nintros [P|P]; auto.\neelim Loc.diff_not_eq; eauto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) : subtype (env (ereg q)) Tlong = true \\/ Loc.diff (R dst) (eloc q) ->\nsubtype (env (ereg q)) Tlong = true.","conclusion":"subtype (env (ereg q)) Tlong = true \\/ Loc.diff (R dst) (eloc q) ->\nsubtype (env (ereg q)) Tlong = true","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |})))","proofString":"intros [P|P]; auto.\neelim Loc.diff_not_eq; eauto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (P : Loc.diff (R dst) (eloc q)) : subtype (env (ereg q)) Tlong = true.","conclusion":"subtype (env (ereg q)) Tlong = true","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (P : Loc.diff (R dst) (eloc q))","proofString":"eelim Loc.diff_not_eq; eauto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst)).","conclusion":"Val.lessdef (sel_val Full rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (R dst))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"rewrite Locmap.gss.\nsimpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef (sel_val Full rs # (ereg q))\n  (Val.longofwords (ls (R src1)) (ls (R src2))).","conclusion":"Val.lessdef (sel_val Full rs # (ereg q))\n  (Val.longofwords (ls (R src1)) (ls (R src2)))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"simpl.\nrewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef rs # (ereg q) (Val.longofwords (ls (R src1)) (ls (R src2))).","conclusion":"Val.lessdef rs # (ereg q) (Val.longofwords (ls (R src1)) (ls (R src2)))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"rewrite <- (val_longofwords_eq_1 rs#(ereg q)).\napply Val.longofwords_lessdef.\nexact C.\nexact D.\neapply Val.has_subtype; eauto.\nassumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef\n  (Val.longofwords (Val.hiword rs # (ereg q)) (Val.loword rs # (ereg q)))\n  (Val.longofwords (ls (R src1)) (ls (R src2))).","conclusion":"Val.lessdef\n  (Val.longofwords (Val.hiword rs # (ereg q)) (Val.loword rs # (ereg q)))\n  (Val.longofwords (ls (R src1)) (ls (R src2)))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"apply Val.longofwords_lessdef.\nexact C.\nexact D."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef (Val.hiword rs # (ereg q)) (ls (R src1)).","conclusion":"Val.lessdef (Val.hiword rs # (ereg q)) (ls (R src1))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"exact C."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.lessdef (Val.loword rs # (ereg q)) (ls (R src2)).","conclusion":"Val.lessdef (Val.loword rs # (ereg q)) (ls (R src2))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"exact D."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Val.has_type rs # (ereg q) Tlong.","conclusion":"Val.has_type rs # (ereg q) Tlong","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"eapply Val.has_subtype; eauto."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true) : Archi.ptr64 = false.","conclusion":"Archi.ptr64 = false","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = R dst) (B : ekind q = Full) (C : Val.lessdef\n  (sel_val (ekind {| ekind := High; ereg := ereg q; eloc := R src1 |})\n     rs # (ereg {| ekind := High; ereg := ereg q; eloc := R src1 |}))\n  (ls (eloc {| ekind := High; ereg := ereg q; eloc := R src1 |}))) (D : Val.lessdef\n  (sel_val (ekind {| ekind := Low; ereg := ereg q; eloc := R src2 |})\n     rs # (ereg {| ekind := Low; ereg := ereg q; eloc := R src2 |}))\n  (ls (eloc {| ekind := Low; ereg := ereg q; eloc := R src2 |}))) (H5 : subtype (env (ereg q)) Tlong = true)","proofString":"assumption."},{"statement":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R dst) (Val.longofwords (ls (R src1)) (ls (R src2))) ls\n     (eloc q))","hypotheses":"(env : regenv) (src1 src2 dst : mreg) (rs : regset) (ls : locset) (e e' : eqs) (H : subst_loc_pair (R dst) (R src1) (R src2) e = Some e') (H0 : long_type_compat env (R dst) e = true) (H1 : wt_regset env rs) (H2 : satisf rs ls e') (H3 : Archi.ptr64 = false) (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff (R dst) (eloc q)) (B : EqSet.In q e')","proofString":"rewrite Locmap.gso; auto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : true = true) (H0 : EqSet.In q e) : True.","conclusion":"True","hypotheses":"(e : eqs) (q : EqSet.elt) (H : true = true) (H0 : EqSet.In q e)","proofString":"tauto."},{"statement":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H : loc_unconstrained (R a) e && can_undef ml e = true) (H0 : EqSet.In q e) : Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml).","conclusion":"Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml)","hypotheses":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H : loc_unconstrained (R a) e && can_undef ml e = true) (H0 : EqSet.In q e)","proofString":"InvBooleans.\nsplit.\napply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto.\neauto."},{"statement":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true) : Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml).","conclusion":"Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml)","hypotheses":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true)","proofString":"split.\napply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto.\neauto."},{"statement":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true) : Loc.diff (eloc q) (R a).","conclusion":"Loc.diff (eloc q) (R a)","hypotheses":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true)","proofString":"apply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto."},{"statement":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true) : Loc.diff (R a) (eloc q).","conclusion":"Loc.diff (R a) (eloc q)","hypotheses":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true)","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true) : Loc.notin (eloc q) (map R ml).","conclusion":"Loc.notin (eloc q) (map R ml)","hypotheses":"(e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef ml e = true -> EqSet.In q0 e -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : loc_unconstrained (R a) e = true) (H2 : can_undef ml e = true)","proofString":"eauto."},{"statement":"(ls : locset) (l : loc) (H : True) : ls l = ls l.","conclusion":"ls l = ls l","hypotheses":"(ls : locset) (l : loc) (H : True)","proofString":"auto."},{"statement":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml)) : Locmap.set (R a) Vundef (undef_regs ml ls) l = ls l.","conclusion":"Locmap.set (R a) Vundef (undef_regs ml ls) l = ls l","hypotheses":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml))","proofString":"rewrite Locmap.gso.\napply IHml.\ntauto.\napply Loc.diff_sym.\ntauto."},{"statement":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml)) : undef_regs ml ls l = ls l.","conclusion":"undef_regs ml ls l = ls l","hypotheses":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml))","proofString":"apply IHml.\ntauto."},{"statement":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml)) : Loc.notin l (map R ml).","conclusion":"Loc.notin l (map R ml)","hypotheses":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml))","proofString":"tauto."},{"statement":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml)) : Loc.diff (R a) l.","conclusion":"Loc.diff (R a) l","hypotheses":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml))","proofString":"apply Loc.diff_sym.\ntauto."},{"statement":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml)) : Loc.diff l (R a).","conclusion":"Loc.diff l (R a)","hypotheses":"(a : mreg) (ml : list mreg) (IHml : forall (ls0 : locset) (l0 : loc),\nLoc.notin l0 (map R ml) -> undef_regs ml ls0 l0 = ls0 l0) (ls : locset) (l : loc) (H : Loc.diff l (R a) /\\ Loc.notin l (map R ml))","proofString":"tauto."},{"statement":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (undef_regs ml ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (undef_regs ml ls (eloc q))","hypotheses":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"rewrite undef_regs_outside.\neauto.\neapply can_undef_sound; eauto."},{"statement":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"eauto."},{"statement":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e) : Loc.notin (eloc q) (map R ml).","conclusion":"Loc.notin (eloc q) (map R ml)","hypotheses":"(ml : list mreg) (e : eqs) (rs : regset) (ls : locset) (H : can_undef ml e = true) (H0 : satisf rs ls e) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"eapply can_undef_sound; eauto."},{"statement":"(lx : loc) (e : eqs) (q : EqSet.elt) (H : true = true) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) : True.","conclusion":"True","hypotheses":"(lx : loc) (e : eqs) (q : EqSet.elt) (H : true = true) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx)","proofString":"tauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H : (Loc.eq lx (R a) || loc_unconstrained (R a) e) && can_undef_except lx ml e =\ntrue) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) : Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml).","conclusion":"Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H : (Loc.eq lx (R a) || loc_unconstrained (R a) e) && can_undef_except lx ml e =\ntrue) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx)","proofString":"InvBooleans.\nsplit.\ndestruct (orb_true_elim _ _ H2).\napply proj_sumbool_true in e0.\ncongruence.\napply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto.\neapply IHml; eauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) : Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml).","conclusion":"Loc.diff (eloc q) (R a) /\\ Loc.notin (eloc q) (map R ml)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true)","proofString":"split.\ndestruct (orb_true_elim _ _ H2).\napply proj_sumbool_true in e0.\ncongruence.\napply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto.\neapply IHml; eauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) : Loc.diff (eloc q) (R a).","conclusion":"Loc.diff (eloc q) (R a)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true)","proofString":"destruct (orb_true_elim _ _ H2).\napply proj_sumbool_true in e0.\ncongruence.\napply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : lx = R a) : Loc.diff (eloc q) (R a).","conclusion":"Loc.diff (eloc q) (R a)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : lx = R a)","proofString":"congruence."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : loc_unconstrained (R a) e = true) : Loc.diff (eloc q) (R a).","conclusion":"Loc.diff (eloc q) (R a)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : loc_unconstrained (R a) e = true)","proofString":"apply Loc.diff_sym.\neapply loc_unconstrained_sound; eauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : loc_unconstrained (R a) e = true) : Loc.diff (R a) (eloc q).","conclusion":"Loc.diff (R a) (eloc q)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) (e0 : loc_unconstrained (R a) e = true)","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true) : Loc.notin (eloc q) (map R ml).","conclusion":"Loc.notin (eloc q) (map R ml)","hypotheses":"(lx : loc) (e : eqs) (a : mreg) (ml : list mreg) (IHml : forall q0 : EqSet.elt,\ncan_undef_except lx ml e = true ->\nEqSet.In q0 e -> Loc.diff (eloc q0) lx -> Loc.notin (eloc q0) (map R ml)) (q : EqSet.elt) (H0 : EqSet.In q e) (H1 : Loc.diff (eloc q) lx) (H2 : Loc.eq lx (R a) || loc_unconstrained (R a) e = true) (H3 : can_undef_except lx ml e = true)","proofString":"eapply IHml; eauto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e)","proofString":"exploit in_subst_loc; eauto.\nintros [[A B] | [A B]].\nsubst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B).\nrewrite Locmap.gso; auto.\nrewrite undef_regs_outside.\neauto.\neapply can_undef_except_sound; eauto.\napply Loc.diff_sym; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) : eloc q = dst /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e' \\/\nLoc.diff dst (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q)).","conclusion":"eloc q = dst /\\\nEqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e' \\/\nLoc.diff dst (eloc q) /\\ EqSet.In q e' ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e)","proofString":"intros [[A B] | [A B]].\nsubst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B).\nrewrite Locmap.gso; auto.\nrewrite undef_regs_outside.\neauto.\neapply can_undef_except_sound; eauto.\napply Loc.diff_sym; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = dst) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : eloc q = dst) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"subst dst.\nrewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (q : EqSet.elt) (H1 : can_undef_except (eloc q) ml e = true) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (eloc q) (ls src) (undef_regs ml ls) (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (eloc q) (ls src) (undef_regs ml ls) (eloc q))","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (q : EqSet.elt) (H1 : can_undef_except (eloc q) ml e = true) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"rewrite Locmap.gss.\ndestruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (q : EqSet.elt) (H1 : can_undef_except (eloc q) ml e = true) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  match eloc q with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  match eloc q with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (q : EqSet.elt) (H1 : can_undef_except (eloc q) ml e = true) (H0 : well_typed_move env (eloc q) e = true) (H : subst_loc (eloc q) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In q e) (B : EqSet.In {| ekind := ekind q; ereg := ereg q; eloc := src |} e')","proofString":"destruct q as [k r l]; simpl in *.\nexploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H1 : can_undef_except l ml e = true) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') : Val.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"Val.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H1 : can_undef_except l ml e = true) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e')","proofString":"exploit well_typed_move_charact; eauto.\ndestruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H1 : can_undef_except l ml e = true) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') : match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend ->\nVal.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end.","conclusion":"match l with\n| R _ => True\n| S _ _ ty => Val.has_type (sel_val k rs # r) ty\nend ->\nVal.lessdef (sel_val k rs # r)\n  match l with\n  | R _ => ls src\n  | S _ _ ty => Val.load_result (chunk_of_type ty) (ls src)\n  end","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (l : loc) (H1 : can_undef_except l ml e = true) (H0 : well_typed_move env l e = true) (H : subst_loc l src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := l |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e')","proofString":"destruct l as [mr | sl ofs ty]; intros.\napply (H3 _ B).\napply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (mr : mreg) (H1 : can_undef_except (R mr) ml e = true) (H0 : well_typed_move env (R mr) e = true) (H : subst_loc (R mr) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : True) : Val.lessdef (sel_val k rs # r) (ls src).","conclusion":"Val.lessdef (sel_val k rs # r) (ls src)","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (mr : mreg) (H1 : can_undef_except (R mr) ml e = true) (H0 : well_typed_move env (R mr) e = true) (H : subst_loc (R mr) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := R mr |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : True)","proofString":"apply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H1 : can_undef_except (S sl ofs ty) ml e = true) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : Val.has_type (sel_val k rs # r) ty) : Val.lessdef (sel_val k rs # r) (Val.load_result (chunk_of_type ty) (ls src)).","conclusion":"Val.lessdef (sel_val k rs # r) (Val.load_result (chunk_of_type ty) (ls src))","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H1 : can_undef_except (S sl ofs ty) ml e = true) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : Val.has_type (sel_val k rs # r) ty)","proofString":"apply val_lessdef_normalize; auto.\napply (H3 _ B)."},{"statement":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H1 : can_undef_except (S sl ofs ty) ml e = true) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : Val.has_type (sel_val k rs # r) ty) : Val.lessdef (sel_val k rs # r) (ls src).","conclusion":"Val.lessdef (sel_val k rs # r) (ls src)","hypotheses":"(env : regenv) (src : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (k : equation_kind) (r : reg) (sl : slot) (ofs : Z) (ty : typ) (H1 : can_undef_except (S sl ofs ty) ml e = true) (H0 : well_typed_move env (S sl ofs ty) e = true) (H : subst_loc (S sl ofs ty) src e = Some e') (H2 : wt_regset env rs) (H3 : satisf rs ls e') (H4 : EqSet.In {| ekind := k; ereg := r; eloc := S sl ofs ty |} e) (B : EqSet.In {| ekind := k; ereg := r; eloc := src |} e') (H5 : Val.has_type (sel_val k rs # r) ty)","proofString":"apply (H3 _ B)."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set dst (ls src) (undef_regs ml ls) (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"rewrite Locmap.gso; auto.\nrewrite undef_regs_outside.\neauto.\neapply can_undef_except_sound; eauto.\napply Loc.diff_sym; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (undef_regs ml ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (undef_regs ml ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"rewrite undef_regs_outside.\neauto.\neapply can_undef_except_sound; eauto.\napply Loc.diff_sym; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"eauto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Loc.notin (eloc q) (map R ml).","conclusion":"Loc.notin (eloc q) (map R ml)","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"eapply can_undef_except_sound; eauto.\napply Loc.diff_sym; auto."},{"statement":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e') : Loc.diff (eloc q) dst.","conclusion":"Loc.diff (eloc q) dst","hypotheses":"(env : regenv) (src dst : loc) (rs : regset) (ls : locset) (ml : list mreg) (e e' : eqs) (H : subst_loc dst src e = Some e') (H0 : well_typed_move env dst e = true) (H1 : can_undef_except dst ml e = true) (H2 : wt_regset env rs) (H3 : satisf rs ls e') (q : EqSet.elt) (H4 : EqSet.In q e) (A : Loc.diff dst (eloc q)) (B : EqSet.In q e')","proofString":"apply Loc.diff_sym; auto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (H : (if\n  reg_loc_unconstrained res (R res')\n    (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n then\n  if\n   can_undef und\n     (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n  then\n   add_equations args args'\n     (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n  else None\n else None) = Some e') (H0 : satisf rs ls e') : Val.lessdef_list rs ## args (reglist ls args') /\\\n(forall v v' : val,\n Val.lessdef v v' ->\n satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e).","conclusion":"Val.lessdef_list rs ## args (reglist ls args') /\\\n(forall v v' : val,\n Val.lessdef v v' ->\n satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e)","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (H : (if\n  reg_loc_unconstrained res (R res')\n    (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n then\n  if\n   can_undef und\n     (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n  then\n   add_equations args args'\n     (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)\n  else None\n else None) = Some e') (H0 : satisf rs ls e')","proofString":"MonadInv.\nsplit.\neapply add_equations_lessdef; eauto.\nintros.\neapply parallel_assignment_satisf; eauto.\nassumption.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') : Val.lessdef_list rs ## args (reglist ls args') /\\\n(forall v v' : val,\n Val.lessdef v v' ->\n satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e).","conclusion":"Val.lessdef_list rs ## args (reglist ls args') /\\\n(forall v v' : val,\n Val.lessdef v v' ->\n satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e)","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e')","proofString":"split.\neapply add_equations_lessdef; eauto.\nintros.\neapply parallel_assignment_satisf; eauto.\nassumption.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') : Val.lessdef_list rs ## args (reglist ls args').","conclusion":"Val.lessdef_list rs ## args (reglist ls args')","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e')","proofString":"eapply add_equations_lessdef; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') : forall v v' : val,\nVal.lessdef v v' ->\nsatisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e.","conclusion":"forall v v' : val,\nVal.lessdef v v' ->\nsatisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e')","proofString":"intros.\neapply parallel_assignment_satisf; eauto.\nassumption.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v') : satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e.","conclusion":"satisf rs # res <- v (Locmap.set (R res') v' (undef_regs und ls)) e","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v')","proofString":"eapply parallel_assignment_satisf; eauto.\nassumption.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v') : Val.lessdef (sel_val Full v) v'.","conclusion":"Val.lessdef (sel_val Full v) v'","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v')","proofString":"assumption."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v') : satisf rs (undef_regs und ls)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e).","conclusion":"satisf rs (undef_regs und ls)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v')","proofString":"eapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto."},{"statement":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v') : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e).","conclusion":"satisf rs ls\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e)","hypotheses":"(args : list reg) (res : reg) (args' : list mreg) (res' : mreg) (und : list mreg) (e e' : eqs) (rs : regset) (ls : locset) (Heqb : reg_loc_unconstrained res (R res')\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (Heqb0 : can_undef und\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) = true) (H : add_equations args args'\n  (remove_equation {| ekind := Full; ereg := res; eloc := R res' |} e) =\nSome e') (H0 : satisf rs ls e') (v v' : val) (H1 : Val.lessdef v v')","proofString":"eapply add_equations_satisf; eauto."},{"statement":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H : add_equations_res r ty l e = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty) : Val.lessdef rs # r (Locmap.getpair (map_rpair R l) ls).","conclusion":"Val.lessdef rs # r (Locmap.getpair (map_rpair R l) ls)","hypotheses":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H : add_equations_res r ty l e = Some e') (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty)","proofString":"functional inversion H; simpl.\nsubst.\neapply add_equation_lessdef with (q := Eq Full r (R mr)); eauto.\nsubst.\nrewrite <- (val_longofwords_eq_1 rs#r) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r (R mr1)).\neapply add_equation_satisf.\neauto.\neapply add_equation_lessdef with (q := Eq Low r (R mr2)).\neauto."},{"statement":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty) (ty0 : typ) (p : rpair mreg) (e0 : eqs) (mr : mreg) (_x : typ) (H3 : p = One mr) (H7 : ty0 = ty) (H4 : _x = ty) (H5 : One mr = l) (H6 : e0 = e) (H2 : add_equation {| ekind := Full; ereg := r; eloc := R mr |} e = e') (H : add_equations_res r ty l e = Some e') : Val.lessdef rs # r (ls (R mr)).","conclusion":"Val.lessdef rs # r (ls (R mr))","hypotheses":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty) (ty0 : typ) (p : rpair mreg) (e0 : eqs) (mr : mreg) (_x : typ) (H3 : p = One mr) (H7 : ty0 = ty) (H4 : _x = ty) (H5 : One mr = l) (H6 : e0 = e) (H2 : add_equation {| ekind := Full; ereg := r; eloc := R mr |} e = e') (H : add_equations_res r ty l e = Some e')","proofString":"subst.\neapply add_equation_lessdef with (q := Eq Full r (R mr)); eauto."},{"statement":"(r : reg) (ty : typ) (e : eqs) (rs : regset) (ls : locset) (mr : mreg) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e)) (H1 : Val.has_type rs # r ty) (H : add_equations_res r ty (One mr) e =\nSome (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e)) : Val.lessdef rs # r (ls (R mr)).","conclusion":"Val.lessdef rs # r (ls (R mr))","hypotheses":"(r : reg) (ty : typ) (e : eqs) (rs : regset) (ls : locset) (mr : mreg) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e)) (H1 : Val.has_type rs # r ty) (H : add_equations_res r ty (One mr) e =\nSome (add_equation {| ekind := Full; ereg := r; eloc := R mr |} e))","proofString":"eapply add_equation_lessdef with (q := Eq Full r (R mr)); eauto."},{"statement":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty) (ty0 : typ) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (H3 : p = Twolong mr1 mr2) (H4 : ty0 = Tlong) (H8 : Archi.ptr64 = false) (H5 : Tlong = ty) (H6 : Twolong mr1 mr2 = l) (H7 : e0 = e) (H2 : add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : add_equations_res r ty l e = Some e') : Val.lessdef rs # r (Val.longofwords (ls (R mr1)) (ls (R mr2))).","conclusion":"Val.lessdef rs # r (Val.longofwords (ls (R mr1)) (ls (R mr2)))","hypotheses":"(r : reg) (ty : typ) (l : rpair mreg) (e e' : eqs) (rs : regset) (ls : locset) (H0 : satisf rs ls e') (H1 : Val.has_type rs # r ty) (ty0 : typ) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (H3 : p = Twolong mr1 mr2) (H4 : ty0 = Tlong) (H8 : Archi.ptr64 = false) (H5 : Tlong = ty) (H6 : Twolong mr1 mr2 = l) (H7 : e0 = e) (H2 : add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n  (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e) = e') (H : add_equations_res r ty l e = Some e')","proofString":"subst.\nrewrite <- (val_longofwords_eq_1 rs#r) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r (R mr1)).\neapply add_equation_satisf.\neauto.\neapply add_equation_lessdef with (q := Eq Low r (R mr2)).\neauto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) : Val.lessdef rs # r (Val.longofwords (ls (R mr1)) (ls (R mr2))).","conclusion":"Val.lessdef rs # r (Val.longofwords (ls (R mr1)) (ls (R mr2)))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)))","proofString":"rewrite <- (val_longofwords_eq_1 rs#r) by auto.\napply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r (R mr1)).\neapply add_equation_satisf.\neauto.\neapply add_equation_lessdef with (q := Eq Low r (R mr2)).\neauto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) : Val.lessdef (Val.longofwords (Val.hiword rs # r) (Val.loword rs # r))\n  (Val.longofwords (ls (R mr1)) (ls (R mr2))).","conclusion":"Val.lessdef (Val.longofwords (Val.hiword rs # r) (Val.loword rs # r))\n  (Val.longofwords (ls (R mr1)) (ls (R mr2)))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)))","proofString":"apply Val.longofwords_lessdef.\neapply add_equation_lessdef with (q := Eq High r (R mr1)).\neapply add_equation_satisf.\neauto.\neapply add_equation_lessdef with (q := Eq Low r (R mr2)).\neauto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) : Val.lessdef (Val.hiword rs # r) (ls (R mr1)).","conclusion":"Val.lessdef (Val.hiword rs # r) (ls (R mr1))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)))","proofString":"eapply add_equation_lessdef with (q := Eq High r (R mr1)).\neapply add_equation_satisf.\neauto."},{"statement":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) : Val.lessdef (Val.loword rs # r) (ls (R mr2)).","conclusion":"Val.lessdef (Val.loword rs # r) (ls (R mr2))","hypotheses":"(r : reg) (e : eqs) (rs : regset) (ls : locset) (mr1 mr2 : mreg) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e))) (H1 : Val.has_type rs # r Tlong) (H8 : Archi.ptr64 = false) (H : add_equations_res r Tlong (Twolong mr1 mr2) e =\nSome\n  (add_equation {| ekind := Low; ereg := r; eloc := R mr2 |}\n     (add_equation {| ekind := High; ereg := r; eloc := R mr1 |} e)))","proofString":"eapply add_equation_lessdef with (q := Eq Low r (R mr2)).\neauto."},{"statement":"(caller : Locmap.t) (callee : locset) (l : loc) (H : callee_save_loc l) : caller l = return_regs caller callee l.","conclusion":"caller l = return_regs caller callee l","hypotheses":"(caller : Locmap.t) (callee : locset) (l : loc) (H : callee_save_loc l)","proofString":"unfold return_regs.\nred in H.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto || congruence."},{"statement":"(caller : Locmap.t) (callee : locset) (l : loc) (H : callee_save_loc l) : caller l =\nmatch l with\n| R r => if is_callee_save r then caller (R r) else callee (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => caller (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend.","conclusion":"caller l =\nmatch l with\n| R r => if is_callee_save r then caller (R r) else callee (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => caller (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend","hypotheses":"(caller : Locmap.t) (callee : locset) (l : loc) (H : callee_save_loc l)","proofString":"red in H.\ndestruct l.\nrewrite H; auto.\ndestruct sl; auto || congruence."},{"statement":"(caller : Locmap.t) (callee : locset) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend) : caller l =\nmatch l with\n| R r => if is_callee_save r then caller (R r) else callee (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => caller (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend.","conclusion":"caller l =\nmatch l with\n| R r => if is_callee_save r then caller (R r) else callee (R r)\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => caller (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend","hypotheses":"(caller : Locmap.t) (callee : locset) (l : loc) (H : match l with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend)","proofString":"destruct l.\nrewrite H; auto.\ndestruct sl; auto || congruence."},{"statement":"(caller : Locmap.t) (callee : locset) (r : mreg) (H : is_callee_save r = true) : caller (R r) = (if is_callee_save r then caller (R r) else callee (R r)).","conclusion":"caller (R r) = (if is_callee_save r then caller (R r) else callee (R r))","hypotheses":"(caller : Locmap.t) (callee : locset) (r : mreg) (H : is_callee_save r = true)","proofString":"rewrite H; auto."},{"statement":"(caller : Locmap.t) (callee : locset) (sl : slot) (pos : Z) (ty : typ) (H : sl <> Outgoing) : caller (S sl pos ty) =\nmatch sl with\n| Outgoing => Vundef\n| _ => caller (S sl pos ty)\nend.","conclusion":"caller (S sl pos ty) =\nmatch sl with\n| Outgoing => Vundef\n| _ => caller (S sl pos ty)\nend","hypotheses":"(caller : Locmap.t) (callee : locset) (sl : slot) (pos : Z) (ty : typ) (H : sl <> Outgoing)","proofString":"destruct sl; auto || congruence."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) : match eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend.","conclusion":"match eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e)","proofString":"exploit EqSet.for_all_2; eauto.\nhnf.\nintros.\nsimpl in H1.\nrewrite H1.\nauto.\nlazy beta.\ndestruct (eloc q).\nauto.\ndestruct sl; congruence."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) : compat_bool (fun x y : OrderedEquation.t => x = y)\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end).","conclusion":"compat_bool (fun x y : OrderedEquation.t => x = y)\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end)","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e)","proofString":"hnf.\nintros.\nsimpl in H1.\nrewrite H1.\nauto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) : forall x y : equation,\nx = y ->\nmatch eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend.","conclusion":"forall x y : equation,\nx = y ->\nmatch eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e)","proofString":"intros.\nsimpl in H1.\nrewrite H1.\nauto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y) : match eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend.","conclusion":"match eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y)","proofString":"simpl in H1.\nrewrite H1.\nauto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y) : match eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend.","conclusion":"match eloc x with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y)","proofString":"rewrite H1.\nauto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y) : match eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend.","conclusion":"match eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend =\nmatch eloc y with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (x y : equation) (H1 : x = y)","proofString":"auto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) : (fun eq : EqSet.elt =>\n match eloc eq with\n | R r => is_callee_save r\n | S Outgoing _ _ => false\n | _ => true\n end) q = true ->\nmatch eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend.","conclusion":"(fun eq : EqSet.elt =>\n match eloc eq with\n | R r => is_callee_save r\n | S Outgoing _ _ => false\n | _ => true\n end) q = true ->\nmatch eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e)","proofString":"lazy beta.\ndestruct (eloc q).\nauto.\ndestruct sl; congruence."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) : match eloc q with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend = true ->\nmatch eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend.","conclusion":"match eloc q with\n| R r => is_callee_save r\n| S Outgoing _ _ => false\n| _ => true\nend = true ->\nmatch eloc q with\n| R r => is_callee_save r = true\n| S sl _ _ => sl <> Outgoing\nend","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e)","proofString":"destruct (eloc q).\nauto.\ndestruct sl; congruence."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r0 => is_callee_save r0\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (r : mreg) : is_callee_save r = true -> is_callee_save r = true.","conclusion":"is_callee_save r = true -> is_callee_save r = true","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r0 => is_callee_save r0\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (r : mreg)","proofString":"auto."},{"statement":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (sl : slot) (pos : Z) (ty : typ) : match sl with\n| Outgoing => false\n| _ => true\nend = true -> sl <> Outgoing.","conclusion":"match sl with\n| Outgoing => false\n| _ => true\nend = true -> sl <> Outgoing","hypotheses":"(e : eqs) (q : EqSet.elt) (H : EqSet.for_all\n  (fun eq : EqSet.elt =>\n   match eloc eq with\n   | R r => is_callee_save r\n   | S Outgoing _ _ => false\n   | _ => true\n   end) e = true) (H0 : EqSet.In q e) (sl : slot) (pos : Z) (ty : typ)","proofString":"destruct sl; congruence."},{"statement":"(v1 v2 : val) : Val.lessdef (Val.hiword (Val.longofwords v1 v2)) v1.","conclusion":"Val.lessdef (Val.hiword (Val.longofwords v1 v2)) v1","hypotheses":"(v1 v2 : val)","proofString":"destruct v1; simpl; auto.\ndestruct v2; auto.\nunfold Val.hiword.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(i : int) (v2 : val) : Val.lessdef\n  (Val.hiword\n     match v2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i).","conclusion":"Val.lessdef\n  (Val.hiword\n     match v2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)","hypotheses":"(i : int) (v2 : val)","proofString":"destruct v2; auto.\nunfold Val.hiword.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Val.hiword (Vlong (Int64.ofwords i i0))) (Vint i).","conclusion":"Val.lessdef (Val.hiword (Vlong (Int64.ofwords i i0))) (Vint i)","hypotheses":"(i i0 : int)","proofString":"unfold Val.hiword.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i).","conclusion":"Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)","hypotheses":"(i i0 : int)","proofString":"rewrite Int64.hi_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(i i0 : int)","proofString":"auto."},{"statement":"(v1 v2 : val) : Val.lessdef (Val.loword (Val.longofwords v1 v2)) v2.","conclusion":"Val.lessdef (Val.loword (Val.longofwords v1 v2)) v2","hypotheses":"(v1 v2 : val)","proofString":"destruct v1; simpl; auto.\ndestruct v2; auto.\nunfold Val.loword.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(i : int) (v2 : val) : Val.lessdef\n  (Val.loword\n     match v2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v2.","conclusion":"Val.lessdef\n  (Val.loword\n     match v2 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v2","hypotheses":"(i : int) (v2 : val)","proofString":"destruct v2; auto.\nunfold Val.loword.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Val.loword (Vlong (Int64.ofwords i i0))) (Vint i0).","conclusion":"Val.lessdef (Val.loword (Vlong (Int64.ofwords i i0))) (Vint i0)","hypotheses":"(i i0 : int)","proofString":"unfold Val.loword.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0).","conclusion":"Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)","hypotheses":"(i i0 : int)","proofString":"rewrite Int64.lo_ofwords.\nauto."},{"statement":"(i i0 : int) : Val.lessdef (Vint i0) (Vint i0).","conclusion":"Val.lessdef (Vint i0) (Vint i0)","hypotheses":"(i i0 : int)","proofString":"auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H0 : remove_equations_res res res' e = Some e') (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H0 : remove_equations_res res res' e = Some e') (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e)","proofString":"functional inversion H0.\nsubst.\nrewrite <- H8 in *.\nsimpl in *.\nInvBooleans.\nset (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto.\nsubst.\nrewrite <- H9 in *.\nsimpl in *.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nInvBooleans.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nexploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (p : rpair mreg) (e0 : eqs) (mr : mreg) (H10 : p = One mr) (H8 : One mr = res') (H9 : e0 = e) (H7 : remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e = e') (H0 : remove_equations_res res res' e = Some e') : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (p : rpair mreg) (e0 : eqs) (mr : mreg) (H10 : p = One mr) (H8 : One mr = res') (H9 : e0 = e) (H7 : remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e = e') (H0 : remove_equations_res res res' e = Some e')","proofString":"subst.\nrewrite <- H8 in *.\nsimpl in *.\nInvBooleans.\nset (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (loc_result sg))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : remove_equations_res res (loc_result sg) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (loc_result sg))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : remove_equations_res res (loc_result sg) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))","proofString":"rewrite <- H8 in *.\nsimpl in *.\nInvBooleans.\nset (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (One mr))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (One mr)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))\n  (map R (regs_of_rpair (One mr))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (One mr)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : remove_equations_res res (One mr) e =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))","proofString":"simpl in *.\nInvBooleans.\nset (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) && true =\ntrue) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H2 : reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) && true =\ntrue) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e))","proofString":"InvBooleans.\nset (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H : reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H7 : true = true) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) =\nSome (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e)) (H : reg_loc_unconstrained res (R mr)\n  (remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) = true) (H7 : true = true)","proofString":"set (e' := remove_equation {| ekind := Full; ereg := res; eloc := R mr |} e) in *.\ndestruct (OrderedEquation.eq_dec q (Eq Full res (R mr))).\nsubst q; simpl.\nrewrite Regmap.gss; auto.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl.\nESD.fsetdec.\nexploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (e0 : q = {| ekind := Full; ereg := res; eloc := R mr |}) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (e0 : q = {| ekind := Full; ereg := res; eloc := R mr |})","proofString":"subst q; simpl.\nrewrite Regmap.gss; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Full; ereg := res; eloc := R mr |} e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) : Val.lessdef (rs # res <- v) # res (ls_after (R mr)).","conclusion":"Val.lessdef (rs # res <- v) # res (ls_after (R mr))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Full; ereg := res; eloc := R mr |} e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true)","proofString":"rewrite Regmap.gss; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) : EqSet.In q (EqSet.remove {| ekind := Full; ereg := res; eloc := R mr |} e).","conclusion":"EqSet.In q (EqSet.remove {| ekind := Full; ereg := res; eloc := R mr |} e)","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |})","proofString":"ESD.fsetdec."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e')","proofString":"exploit reg_loc_unconstrained_sound; eauto.\nintros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') : ereg q <> res /\\ Loc.diff (R mr) (eloc q) ->\nVal.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"ereg q <> res /\\ Loc.diff (R mr) (eloc q) ->\nVal.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e')","proofString":"intros [A B].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q))","proofString":"rewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q))","proofString":"exploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) : callee_save_loc (eloc q) ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"callee_save_loc (eloc q) ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q))","proofString":"intros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) (H9 : callee_save_loc (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) (H9 : callee_save_loc (eloc q))","proofString":"red in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : forall l : loc, callee_save_loc l -> ls_before l = ls_after l) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) (H9 : callee_save_loc (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (ls_after (R mr))) (H5 : forall l : loc, callee_save_loc l -> ls_before l = ls_after l) (q : EqSet.elt) (H6 : EqSet.In q e) (H8 : One mr = loc_result sg) (H0 : Some e' = Some e') (H : reg_loc_unconstrained res (R mr) e' = true) (H7 : true = true) (n : q <> {| ekind := Full; ereg := res; eloc := R mr |}) (H2 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr) (eloc q)) (H9 : callee_save_loc (eloc q))","proofString":"rewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H8 : p = Twolong mr1 mr2) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = res') (H10 : e0 = e) (H7 : remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e) = e') (H0 : remove_equations_res res res' e = Some e') : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (res' : rpair mreg) (sg : signature) (e e' : eqs) (v : val) (H : res' = loc_result sg) (H1 : satisf rs ls_before e') (H2 : forallb (fun l : loc => reg_loc_unconstrained res l e')\n  (map R (regs_of_rpair res')) = true) (H3 : no_caller_saves e' = true) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R res') ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (p : rpair mreg) (e0 : eqs) (mr1 mr2 : mreg) (_x : mr2 <> mr1) (H8 : p = Twolong mr1 mr2) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = res') (H10 : e0 = e) (H7 : remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n  (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e) = e') (H0 : remove_equations_res res res' e = Some e')","proofString":"subst.\nrewrite <- H9 in *.\nsimpl in *.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nInvBooleans.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nexploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (loc_result sg))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : remove_equations_res res (loc_result sg) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (loc_result sg))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : remove_equations_res res (loc_result sg) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))","proofString":"rewrite <- H9 in *.\nsimpl in *.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nInvBooleans.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nexploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (Twolong mr1 mr2))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (Twolong mr1 mr2)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : remove_equations_res res (Twolong mr1 mr2) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : forallb\n  (fun l : loc =>\n   reg_loc_unconstrained res l\n     (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n        (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))\n  (map R (regs_of_rpair (Twolong mr1 mr2))) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Locmap.getpair (map_rpair R (Twolong mr1 mr2)) ls_after)) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : remove_equations_res res (Twolong mr1 mr2) e =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))","proofString":"simpl in *.\nset (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nInvBooleans.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nexploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : reg_loc_unconstrained res (R mr1)\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) &&\n(reg_loc_unconstrained res (R mr2)\n   (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n      (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) &&\n true) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1\n then None\n else\n  Some\n    (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n       (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (H3 : no_caller_saves\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) =\ntrue) (H2 : reg_loc_unconstrained res (R mr1)\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) &&\n(reg_loc_unconstrained res (R mr2)\n   (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n      (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) &&\n true) = true) (H1 : satisf rs ls_before\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1\n then None\n else\n  Some\n    (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n       (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e))) =\nSome\n  (remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}\n     (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)))","proofString":"set (e' := remove_equation {| ekind := Low; ereg := res; eloc := R mr2 |}          (remove_equation {| ekind := High; ereg := res; eloc := R mr1 |} e)) in *.\nInvBooleans.\ndestruct (OrderedEquation.eq_dec q (Eq Low res (R mr2))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords.\ndestruct (OrderedEquation.eq_dec q (Eq High res (R mr1))).\nsubst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords.\nassert (EqSet.In q e').\nunfold e', remove_equation; simpl; ESD.fsetdec.\nexploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (e0 : q = {| ekind := Low; ereg := res; eloc := R mr2 |}) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (e0 : q = {| ekind := Low; ereg := res; eloc := R mr2 |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) : Val.lessdef (Val.loword (rs # res <- v) # res) (ls_after (R mr2)).","conclusion":"Val.lessdef (Val.loword (rs # res <- v) # res) (ls_after (R mr2))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true)","proofString":"rewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) : Val.lessdef (Val.loword v) (ls_after (R mr2)).","conclusion":"Val.lessdef (Val.loword v) (ls_after (R mr2))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := Low; ereg := res; eloc := R mr2 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true)","proofString":"eapply Val.lessdef_trans.\napply Val.loword_lessdef.\neauto.\napply val_loword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (e0 : q = {| ekind := High; ereg := res; eloc := R mr1 |}) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (e0 : q = {| ekind := High; ereg := res; eloc := R mr1 |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) : Val.lessdef (Val.hiword (rs # res <- v) # res) (ls_after (R mr1)).","conclusion":"Val.lessdef (Val.hiword (rs # res <- v) # res) (ls_after (R mr1))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |})","proofString":"rewrite Regmap.gss.\neapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |}) : Val.lessdef (Val.hiword v) (ls_after (R mr1)).","conclusion":"Val.lessdef (Val.hiword v) (ls_after (R mr1))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (H6 : EqSet.In {| ekind := High; ereg := res; eloc := R mr1 |} e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : {| ekind := High; ereg := res; eloc := R mr1 |} <>\n{| ekind := Low; ereg := res; eloc := R mr2 |})","proofString":"eapply Val.lessdef_trans.\napply Val.hiword_lessdef.\neauto.\napply val_hiword_longofwords."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e')","proofString":"exploit reg_loc_unconstrained_sound.\neexact H.\neauto.\nintros [A B].\nexploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q))","proofString":"exploit reg_loc_unconstrained_sound.\neexact H2.\neauto.\nintros [C D].\nrewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) : Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # res <- v) # (ereg q))\n  (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q))","proofString":"rewrite Regmap.gso; auto.\nexploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q))","proofString":"exploit no_caller_saves_sound; eauto.\nintros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) : callee_save_loc (eloc q) ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"callee_save_loc (eloc q) ->\nVal.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q))","proofString":"intros.\nred in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) (H10 : callee_save_loc (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : agree_callee_save ls_before ls_after) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) (H10 : callee_save_loc (eloc q))","proofString":"red in H5.\nrewrite <- H5; auto."},{"statement":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : forall l : loc, callee_save_loc l -> ls_before l = ls_after l) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) (H10 : callee_save_loc (eloc q)) : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls_after (eloc q))","hypotheses":"(rs : regset) (ls_before : locset) (ls_after : Locmap.t) (res : reg) (sg : signature) (e : eqs) (v : val) (mr1 mr2 : mreg) (e' : eqs) (H3 : no_caller_saves e' = true) (H1 : satisf rs ls_before e') (H4 : Val.lessdef v (Val.longofwords (ls_after (R mr1)) (ls_after (R mr2)))) (H5 : forall l : loc, callee_save_loc l -> ls_before l = ls_after l) (q : EqSet.elt) (H6 : EqSet.In q e) (_x : mr2 <> mr1) (H11 : mreg_eq mr2 mr1 = right _x) (H9 : Twolong mr1 mr2 = loc_result sg) (H0 : (if mreg_eq mr2 mr1 then None else Some e') = Some e') (H : reg_loc_unconstrained res (R mr1) e' = true) (H2 : reg_loc_unconstrained res (R mr2) e' = true) (H8 : true = true) (n : q <> {| ekind := Low; ereg := res; eloc := R mr2 |}) (n0 : q <> {| ekind := High; ereg := res; eloc := R mr1 |}) (H7 : EqSet.In q e') (A : ereg q <> res) (B : Loc.diff (R mr1) (eloc q)) (C : ereg q <> res) (D : Loc.diff (R mr2) (eloc q)) (H10 : callee_save_loc (eloc q))","proofString":"rewrite <- H5; auto."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : ekind q = Full /\\ eloc q = l.","conclusion":"ekind q = Full /\\ eloc q = l","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"rewrite EqSet.for_all_between_iff in H.\napply select_reg_charact in H1.\ndestruct H1.\nexploit H; eauto.\nintros.\ndestruct (ekind q); try discriminate.\ndestruct (Loc.eq l (eloc q)); try discriminate.\nauto.\nintros.\nsubst x2.\nauto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r)."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"exact (select_reg_l_monotone r)."},{"statement":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true","hypotheses":"(r : reg) (l : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => Loc.eq l (eloc q0)\n   | _ => false\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"exact (select_reg_h_monotone r)."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"rewrite EqSet.for_all_between_iff in H.\napply select_reg_charact in H1.\ndestruct H1.\nexploit H; eauto.\nintros.\ndestruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto.\nintros.\nsubst x2.\nauto.\nexact (select_reg_l_monotone r).\nexact (select_reg_h_monotone r)."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"apply select_reg_charact in H1.\ndestruct H1.\nexploit H; eauto.\nintros.\ndestruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true /\\ select_reg_h r q = true)","proofString":"destruct H1.\nexploit H; eauto.\nintros.\ndestruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true)","proofString":"exploit H; eauto.\nintros.\ndestruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) : match ekind q with\n| Full => false\n| Low => Loc.eq l2 (eloc q)\n| High => Loc.eq l1 (eloc q)\nend = true -> ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"match ekind q with\n| Full => false\n| Low => Loc.eq l2 (eloc q)\n| High => Loc.eq l1 (eloc q)\nend = true -> ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true)","proofString":"intros.\ndestruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : match ekind q with\n| Full => false\n| Low => Loc.eq l2 (eloc q)\n| High => Loc.eq l1 (eloc q)\nend = true) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2.","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : match ekind q with\n| Full => false\n| Low => Loc.eq l2 (eloc q)\n| High => Loc.eq l1 (eloc q)\nend = true)","proofString":"destruct (ekind q); try discriminate.\nInvBooleans.\nauto.\nInvBooleans.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : l2 = eloc q) : Low = High /\\ eloc q = l1 \\/ Low = Low /\\ eloc q = l2.","conclusion":"Low = High /\\ eloc q = l1 \\/ Low = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : l2 = eloc q)","proofString":"auto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : l1 = eloc q) : High = High /\\ eloc q = l1 \\/ High = Low /\\ eloc q = l2.","conclusion":"High = High /\\ eloc q = l1 \\/ High = Low /\\ eloc q = l2","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : forall x : EqSet.elt,\nEqSet.In x e ->\nselect_reg_l r x = true ->\nselect_reg_h r x = true ->\nmatch ekind x with\n| Full => false\n| Low => Loc.eq l2 (eloc x)\n| High => Loc.eq l1 (eloc x)\nend = true) (H0 : EqSet.In q e) (H1 : select_reg_l r q = true) (H2 : select_reg_h r q = true) (H3 : l1 = eloc q)","proofString":"auto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : forall x1 x2 : equation,\nx1 = x2 ->\nmatch ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x2 with\n| Full => false\n| Low => Loc.eq l2 (eloc x2)\n| High => Loc.eq l1 (eloc x2)\nend.","conclusion":"forall x1 x2 : equation,\nx1 = x2 ->\nmatch ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x2 with\n| Full => false\n| Low => Loc.eq l2 (eloc x2)\n| High => Loc.eq l1 (eloc x2)\nend","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"intros.\nsubst x2.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) (x1 x2 : equation) (H2 : x1 = x2) : match ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x2 with\n| Full => false\n| Low => Loc.eq l2 (eloc x2)\n| High => Loc.eq l1 (eloc x2)\nend.","conclusion":"match ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x2 with\n| Full => false\n| Low => Loc.eq l2 (eloc x2)\n| High => Loc.eq l1 (eloc x2)\nend","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) (x1 x2 : equation) (H2 : x1 = x2)","proofString":"subst x2.\nauto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) (x1 : equation) : match ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend.","conclusion":"match ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend =\nmatch ekind x1 with\n| Full => false\n| Low => Loc.eq l2 (eloc x1)\n| High => Loc.eq l1 (eloc x1)\nend","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) (x1 : equation)","proofString":"auto."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x1) (ereg x2) \\/\nereg x1 = ereg x2 /\\\n(OrderedLoc.lt (eloc x1) (eloc x2) \\/\n eloc x1 = eloc x2 /\\ OrderedEqKind.lt (ekind x1) (ekind x2)) ->\nselect_reg_l r x1 = true -> select_reg_l r x2 = true","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"exact (select_reg_l_monotone r)."},{"statement":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r) : forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true.","conclusion":"forall x1 x2 : equation,\nx1 = x2 \\/\nPlt (ereg x2) (ereg x1) \\/\nereg x2 = ereg x1 /\\\n(OrderedLoc.lt (eloc x2) (eloc x1) \\/\n eloc x2 = eloc x1 /\\ OrderedEqKind.lt (ekind x2) (ekind x1)) ->\nselect_reg_h r x1 = true -> select_reg_h r x2 = true","hypotheses":"(r : reg) (l1 l2 : loc) (e : eqs) (q : EqSet.elt) (H : EqSet.for_all_between\n  (fun q0 : EqSet.elt =>\n   match ekind q0 with\n   | Full => false\n   | Low => Loc.eq l2 (eloc q0)\n   | High => Loc.eq l1 (eloc q0)\n   end) (select_reg_l r) (select_reg_h r) e = true) (H0 : EqSet.In q e) (H1 : ereg q = r)","proofString":"exact (select_reg_h_monotone r)."},{"statement":"(rl : list reg) (ll : list (rpair loc)) (e : eqs) : compat_entry rl ll e = true ->\nforall (vl : list val) (ls : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) ll) ->\nsatisf (init_regs vl rl) ls e.","conclusion":"compat_entry rl ll e = true ->\nforall (vl : list val) (ls : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) ll) ->\nsatisf (init_regs vl rl) ls e","hypotheses":"(rl : list reg) (ll : list (rpair loc)) (e : eqs)","proofString":"functional induction (compat_entry rl ll e); intros.\nsimpl.\nred; intros.\nrewrite Regmap.gi.\ndestruct (ekind q); simpl; auto.\nInvBooleans.\nsimpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto.\nInvBooleans.\nsimpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto.\ndiscriminate."},{"statement":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) : satisf (init_regs vl nil) ls e.","conclusion":"satisf (init_regs vl nil) ls e","hypotheses":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil))","proofString":"simpl.\nred; intros.\nrewrite Regmap.gi.\ndestruct (ekind q); simpl; auto."},{"statement":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) : satisf (Regmap.init Vundef) ls e.","conclusion":"satisf (Regmap.init Vundef) ls e","hypotheses":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil))","proofString":"red; intros.\nrewrite Regmap.gi.\ndestruct (ekind q); simpl; auto."},{"statement":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) (Regmap.init Vundef) # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (Regmap.init Vundef) # (ereg q)) (ls (eloc q))","hypotheses":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"rewrite Regmap.gi.\ndestruct (ekind q); simpl; auto."},{"statement":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) (q : EqSet.elt) (H1 : EqSet.In q e) : Val.lessdef (sel_val (ekind q) Vundef) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) Vundef) (ls (eloc q))","hypotheses":"(e : eqs) (H : true = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) nil)) (q : EqSet.elt) (H1 : EqSet.In q e)","proofString":"destruct (ekind q); simpl; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (H : compat_left r1 l1 e && compat_entry rl ll e = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (One l1 :: ll))) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (H : compat_left r1 l1 e && compat_entry rl ll e = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (One l1 :: ll)))","proofString":"InvBooleans.\nsimpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (One l1 :: ll))) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (One l1 :: ll))) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true)","proofString":"simpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll)) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (ls l1 :: map (fun p : rpair loc => Locmap.getpair p ls) ll)) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true)","proofString":"inv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) : satisf (init_regs (v1 :: vl1) (r1 :: rl)) ls e.","conclusion":"satisf (init_regs (v1 :: vl1) (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll))","proofString":"simpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) : satisf (init_regs vl1 rl) # r1 <- v1 ls e.","conclusion":"satisf (init_regs vl1 rl) # r1 <- v1 ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll))","proofString":"red; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) : Val.lessdef (sel_val (ekind q) ((init_regs vl1 rl) # r1 <- v1) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) ((init_regs vl1 rl) # r1 <- v1) # (ereg q))\n  (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) : Val.lessdef\n  (sel_val (ekind q)\n     (if peq (ereg q) r1 then v1 else (init_regs vl1 rl) # (ereg q)))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (if peq (ereg q) r1 then v1 else (init_regs vl1 rl) # (ereg q)))\n  (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e)","proofString":"destruct (peq (ereg q) r1).\nexploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) : Val.lessdef (sel_val (ekind q) v1) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) v1) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1)","proofString":"exploit compat_left_sound; eauto.\nintros [A B].\nrewrite A; rewrite B; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) : ekind q = Full /\\ eloc q = l1 ->\nVal.lessdef (sel_val (ekind q) v1) (ls (eloc q)).","conclusion":"ekind q = Full /\\ eloc q = l1 ->\nVal.lessdef (sel_val (ekind q) v1) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1)","proofString":"intros [A B].\nrewrite A; rewrite B; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Full) (B : eloc q = l1) : Val.lessdef (sel_val (ekind q) v1) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) v1) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Full) (B : eloc q = l1)","proofString":"rewrite A; rewrite B; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (n : ereg q <> r1) : Val.lessdef (sel_val (ekind q) (init_regs vl1 rl) # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (init_regs vl1 rl) # (ereg q)) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left r1 l1 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (ls l1)) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (n : ereg q <> r1)","proofString":"eapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (H : compat_left2 r1 l1 l2 e && compat_entry rl ll e = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (Twolong l1 l2 :: ll))) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (H : compat_left2 r1 l1 l2 e && compat_entry rl ll e = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (Twolong l1 l2 :: ll)))","proofString":"InvBooleans.\nsimpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (Twolong l1 l2 :: ll))) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (map (fun p : rpair loc => Locmap.getpair p ls) (Twolong l1 l2 :: ll))) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true)","proofString":"simpl in H0.\ninv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll)) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) : satisf (init_regs vl (r1 :: rl)) ls e.","conclusion":"satisf (init_regs vl (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl0 : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl0 (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl0 rl) ls0 e) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl\n  (Val.longofwords (ls l1) (ls l2)\n   :: map (fun p : rpair loc => Locmap.getpair p ls) ll)) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true)","proofString":"inv H0.\nsimpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) : satisf (init_regs (v1 :: vl1) (r1 :: rl)) ls e.","conclusion":"satisf (init_regs (v1 :: vl1) (r1 :: rl)) ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll))","proofString":"simpl.\nred; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) : satisf (init_regs vl1 rl) # r1 <- v1 ls e.","conclusion":"satisf (init_regs vl1 rl) # r1 <- v1 ls e","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll))","proofString":"red; intros.\nrewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) : Val.lessdef (sel_val (ekind q) ((init_regs vl1 rl) # r1 <- v1) # (ereg q))\n  (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) ((init_regs vl1 rl) # r1 <- v1) # (ereg q))\n  (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e)","proofString":"rewrite Regmap.gsspec.\ndestruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) : Val.lessdef\n  (sel_val (ekind q)\n     (if peq (ereg q) r1 then v1 else (init_regs vl1 rl) # (ereg q)))\n  (ls (eloc q)).","conclusion":"Val.lessdef\n  (sel_val (ekind q)\n     (if peq (ereg q) r1 then v1 else (init_regs vl1 rl) # (ereg q)))\n  (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e)","proofString":"destruct (peq (ereg q) r1).\nexploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords.\neapply IHb; eauto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) : Val.lessdef (sel_val (ekind q) v1) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) v1) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1)","proofString":"exploit compat_left2_sound; eauto.\nintros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) : ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2 ->\nVal.lessdef (sel_val (ekind q) v1) (ls (eloc q)).","conclusion":"ekind q = High /\\ eloc q = l1 \\/ ekind q = Low /\\ eloc q = l2 ->\nVal.lessdef (sel_val (ekind q) v1) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1)","proofString":"intros [[A B] | [A B]]; rewrite A; rewrite B; simpl.\napply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords.\napply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1) : Val.lessdef (Val.hiword v1) (ls l1).","conclusion":"Val.lessdef (Val.hiword v1) (ls l1)","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1)","proofString":"apply Val.lessdef_trans with (Val.hiword (Val.longofwords (ls l1) (ls l2))).\napply Val.hiword_lessdef; auto.\napply val_hiword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1) : Val.lessdef (Val.hiword v1) (Val.hiword (Val.longofwords (ls l1) (ls l2))).","conclusion":"Val.lessdef (Val.hiword v1) (Val.hiword (Val.longofwords (ls l1) (ls l2)))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1)","proofString":"apply Val.hiword_lessdef; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1) : Val.lessdef (Val.hiword (Val.longofwords (ls l1) (ls l2))) (ls l1).","conclusion":"Val.lessdef (Val.hiword (Val.longofwords (ls l1) (ls l2))) (ls l1)","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = High) (B : eloc q = l1)","proofString":"apply val_hiword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2) : Val.lessdef (Val.loword v1) (ls l2).","conclusion":"Val.lessdef (Val.loword v1) (ls l2)","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2)","proofString":"apply Val.lessdef_trans with (Val.loword (Val.longofwords (ls l1) (ls l2))).\napply Val.loword_lessdef; auto.\napply val_loword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2) : Val.lessdef (Val.loword v1) (Val.loword (Val.longofwords (ls l1) (ls l2))).","conclusion":"Val.lessdef (Val.loword v1) (Val.loword (Val.longofwords (ls l1) (ls l2)))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2)","proofString":"apply Val.loword_lessdef; auto."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2) : Val.lessdef (Val.loword (Val.longofwords (ls l1) (ls l2))) (ls l2).","conclusion":"Val.lessdef (Val.loword (Val.longofwords (ls l1) (ls l2))) (ls l2)","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (e0 : ereg q = r1) (A : ekind q = Low) (B : eloc q = l2)","proofString":"apply val_loword_longofwords."},{"statement":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (n : ereg q <> r1) : Val.lessdef (sel_val (ekind q) (init_regs vl1 rl) # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (init_regs vl1 rl) # (ereg q)) (ls (eloc q))","hypotheses":"(e : eqs) (r1 : reg) (rl : list reg) (l1 l2 : loc) (ll : list (rpair loc)) (IHb : compat_entry rl ll e = true ->\nforall (vl : list val) (ls0 : Locmap.t),\nVal.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls0) ll) ->\nsatisf (init_regs vl rl) ls0 e) (ls : Locmap.t) (H1 : compat_left2 r1 l1 l2 e = true) (H2 : compat_entry rl ll e = true) (v1 : val) (vl1 : list val) (H5 : Val.lessdef v1 (Val.longofwords (ls l1) (ls l2))) (H6 : Val.lessdef_list vl1 (map (fun p : rpair loc => Locmap.getpair p ls) ll)) (q : EqSet.elt) (H : EqSet.In q e) (n : ereg q <> r1)","proofString":"eapply IHb; eauto."},{"statement":"(rparams : list reg) (lparams : list (rpair loc)) (e : eqs) (y : match rparams with\n| nil => match lparams with\n         | nil => False\n         | _ :: _ => True\n         end\n| _ :: _ => match lparams with\n            | nil => True\n            | _ => False\n            end\nend) (H : false = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) lparams)) : satisf (init_regs vl rparams) ls e.","conclusion":"satisf (init_regs vl rparams) ls e","hypotheses":"(rparams : list reg) (lparams : list (rpair loc)) (e : eqs) (y : match rparams with\n| nil => match lparams with\n         | nil => False\n         | _ :: _ => True\n         end\n| _ :: _ => match lparams with\n            | nil => True\n            | _ => False\n            end\nend) (H : false = true) (vl : list val) (ls : Locmap.t) (H0 : Val.lessdef_list vl (map (fun p : rpair loc => Locmap.getpair p ls) lparams))","proofString":"discriminate."},{"statement":"(sg : signature) (ls : locset) : map (fun p : rpair loc => Locmap.getpair p (call_regs ls))\n  (loc_parameters sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg).","conclusion":"map (fun p : rpair loc => Locmap.getpair p (call_regs ls))\n  (loc_parameters sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg)","hypotheses":"(sg : signature) (ls : locset)","proofString":"unfold loc_parameters.\nrewrite list_map_compose.\napply list_map_exten; intros.\nsymmetry.\nassert (A: forall l, loc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l).\ndestruct l as [r | [] ofs ty]; simpl; auto; contradiction.\nexploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) : map (fun p : rpair loc => Locmap.getpair p (call_regs ls))\n  (map (map_rpair parameter_of_argument) (loc_arguments sg)) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg).","conclusion":"map (fun p : rpair loc => Locmap.getpair p (call_regs ls))\n  (map (map_rpair parameter_of_argument) (loc_arguments sg)) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg)","hypotheses":"(sg : signature) (ls : locset)","proofString":"rewrite list_map_compose.\napply list_map_exten; intros.\nsymmetry.\nassert (A: forall l, loc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l).\ndestruct l as [r | [] ofs ty]; simpl; auto; contradiction.\nexploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) : map\n  (fun x : rpair loc =>\n   Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg).","conclusion":"map\n  (fun x : rpair loc =>\n   Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments sg)","hypotheses":"(sg : signature) (ls : locset)","proofString":"apply list_map_exten; intros.\nsymmetry.\nassert (A: forall l, loc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l).\ndestruct l as [r | [] ofs ty]; simpl; auto; contradiction.\nexploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) : Locmap.getpair x ls =\nLocmap.getpair (map_rpair parameter_of_argument x) (call_regs ls).","conclusion":"Locmap.getpair x ls =\nLocmap.getpair (map_rpair parameter_of_argument x) (call_regs ls)","hypotheses":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg))","proofString":"symmetry.\nassert (A: forall l, loc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l).\ndestruct l as [r | [] ofs ty]; simpl; auto; contradiction.\nexploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) : Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls.","conclusion":"Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls","hypotheses":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg))","proofString":"assert (A: forall l, loc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l).\ndestruct l as [r | [] ofs ty]; simpl; auto; contradiction.\nexploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l.","conclusion":"forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l","hypotheses":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg))","proofString":"destruct l as [r | [] ofs ty]; simpl; auto; contradiction."},{"statement":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) : Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls.","conclusion":"Locmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls","hypotheses":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l)","proofString":"exploit loc_arguments_acceptable; eauto.\ndestruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) : forall_rpair loc_argument_acceptable x ->\nLocmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls.","conclusion":"forall_rpair loc_argument_acceptable x ->\nLocmap.getpair (map_rpair parameter_of_argument x) (call_regs ls) =\nLocmap.getpair x ls","hypotheses":"(sg : signature) (ls : locset) (x : rpair loc) (H : In x (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l)","proofString":"destruct x; simpl; intros.\nauto.\ndestruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls : locset) (r : loc) (H : In (One r) (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) (H0 : loc_argument_acceptable r) : call_regs ls (parameter_of_argument r) = ls r.","conclusion":"call_regs ls (parameter_of_argument r) = ls r","hypotheses":"(sg : signature) (ls : locset) (r : loc) (H : In (One r) (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) (H0 : loc_argument_acceptable r)","proofString":"auto."},{"statement":"(sg : signature) (ls : locset) (rhi rlo : loc) (H : In (Twolong rhi rlo) (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) (H0 : loc_argument_acceptable rhi /\\ loc_argument_acceptable rlo) : Val.longofwords (call_regs ls (parameter_of_argument rhi))\n  (call_regs ls (parameter_of_argument rlo)) =\nVal.longofwords (ls rhi) (ls rlo).","conclusion":"Val.longofwords (call_regs ls (parameter_of_argument rhi))\n  (call_regs ls (parameter_of_argument rlo)) =\nVal.longofwords (ls rhi) (ls rlo)","hypotheses":"(sg : signature) (ls : locset) (rhi rlo : loc) (H : In (Twolong rhi rlo) (loc_arguments sg)) (A : forall l : loc,\nloc_argument_acceptable l -> call_regs ls (parameter_of_argument l) = ls l) (H0 : loc_argument_acceptable rhi /\\ loc_argument_acceptable rlo)","proofString":"destruct H0; f_equal; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_is_possible sg = true) : map (fun p : rpair loc => Locmap.getpair p (return_regs ls1 ls2))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls2) (loc_arguments sg).","conclusion":"map (fun p : rpair loc => Locmap.getpair p (return_regs ls1 ls2))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls2) (loc_arguments sg)","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_is_possible sg = true)","proofString":"apply tailcall_is_possible_correct in H.\napply list_map_exten; intros.\napply Locmap.getpair_exten; intros.\nassert (In l (regs_of_rpairs (loc_arguments sg))) by (eapply in_regs_of_rpairs; eauto).\nexploit loc_arguments_acceptable_2; eauto.\nexploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) : map (fun p : rpair loc => Locmap.getpair p (return_regs ls1 ls2))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls2) (loc_arguments sg).","conclusion":"map (fun p : rpair loc => Locmap.getpair p (return_regs ls1 ls2))\n  (loc_arguments sg) =\nmap (fun p : rpair loc => Locmap.getpair p ls2) (loc_arguments sg)","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg)","proofString":"apply list_map_exten; intros.\napply Locmap.getpair_exten; intros.\nassert (In l (regs_of_rpairs (loc_arguments sg))) by (eapply in_regs_of_rpairs; eauto).\nexploit loc_arguments_acceptable_2; eauto.\nexploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) : Locmap.getpair x ls2 = Locmap.getpair x (return_regs ls1 ls2).","conclusion":"Locmap.getpair x ls2 = Locmap.getpair x (return_regs ls1 ls2)","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg))","proofString":"apply Locmap.getpair_exten; intros.\nassert (In l (regs_of_rpairs (loc_arguments sg))) by (eapply in_regs_of_rpairs; eauto).\nexploit loc_arguments_acceptable_2; eauto.\nexploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) : ls2 l = return_regs ls1 ls2 l.","conclusion":"ls2 l = return_regs ls1 ls2 l","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x))","proofString":"assert (In l (regs_of_rpairs (loc_arguments sg))) by (eapply in_regs_of_rpairs; eauto).\nexploit loc_arguments_acceptable_2; eauto.\nexploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg))) : ls2 l = return_regs ls1 ls2 l.","conclusion":"ls2 l = return_regs ls1 ls2 l","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"exploit loc_arguments_acceptable_2; eauto.\nexploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg))) : loc_argument_acceptable l -> ls2 l = return_regs ls1 ls2 l.","conclusion":"loc_argument_acceptable l -> ls2 l = return_regs ls1 ls2 l","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"exploit H; eauto.\ndestruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg))) : match l with\n| R _ => True\n| S _ _ _ => False\nend -> loc_argument_acceptable l -> ls2 l = return_regs ls1 ls2 l.","conclusion":"match l with\n| R _ => True\n| S _ _ _ => False\nend -> loc_argument_acceptable l -> ls2 l = return_regs ls1 ls2 l","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (l : loc) (H1 : In l (regs_of_rpair x)) (H2 : In l (regs_of_rpairs (loc_arguments sg)))","proofString":"destruct l; simpl; intros; try contradiction.\nrewrite H4; auto."},{"statement":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (r : mreg) (H1 : In (R r) (regs_of_rpair x)) (H2 : In (R r) (regs_of_rpairs (loc_arguments sg))) (H3 : True) (H4 : is_callee_save r = false) : ls2 (R r) = (if is_callee_save r then ls1 (R r) else ls2 (R r)).","conclusion":"ls2 (R r) = (if is_callee_save r then ls1 (R r) else ls2 (R r))","hypotheses":"(sg : signature) (ls1 ls2 : locset) (H : tailcall_possible sg) (x : rpair loc) (H0 : In x (loc_arguments sg)) (r : mreg) (H1 : In (R r) (regs_of_rpair x)) (H2 : In (R r) (regs_of_rpairs (loc_arguments sg))) (H3 : True) (H4 : is_callee_save r = false)","proofString":"rewrite H4; auto."},{"statement":"(tge : genv) (ros : mreg + ident) (ls1 ls2 : locset) (H : match ros with\n| inl r => negb (is_callee_save r)\n| inr _ => true\nend = true) : match ros with\n| inl r => Genv.find_funct tge (return_regs ls1 ls2 (R r))\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend =\nmatch ros with\n| inl r => Genv.find_funct tge (ls2 (R r))\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend.","conclusion":"match ros with\n| inl r => Genv.find_funct tge (return_regs ls1 ls2 (R r))\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend =\nmatch ros with\n| inl r => Genv.find_funct tge (ls2 (R r))\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend","hypotheses":"(tge : genv) (ros : mreg + ident) (ls1 ls2 : locset) (H : match ros with\n| inl r => negb (is_callee_save r)\n| inr _ => true\nend = true)","proofString":"destruct ros as [r|id]; auto.\nunfold return_regs.\ndestruct (is_callee_save r).\ndiscriminate.\nauto."},{"statement":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb (is_callee_save r) = true) : Genv.find_funct tge (return_regs ls1 ls2 (R r)) =\nGenv.find_funct tge (ls2 (R r)).","conclusion":"Genv.find_funct tge (return_regs ls1 ls2 (R r)) =\nGenv.find_funct tge (ls2 (R r))","hypotheses":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb (is_callee_save r) = true)","proofString":"unfold return_regs.\ndestruct (is_callee_save r).\ndiscriminate.\nauto."},{"statement":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb (is_callee_save r) = true) : Genv.find_funct tge (if is_callee_save r then ls1 (R r) else ls2 (R r)) =\nGenv.find_funct tge (ls2 (R r)).","conclusion":"Genv.find_funct tge (if is_callee_save r then ls1 (R r) else ls2 (R r)) =\nGenv.find_funct tge (ls2 (R r))","hypotheses":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb (is_callee_save r) = true)","proofString":"destruct (is_callee_save r).\ndiscriminate.\nauto."},{"statement":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb true = true) : Genv.find_funct tge (ls1 (R r)) = Genv.find_funct tge (ls2 (R r)).","conclusion":"Genv.find_funct tge (ls1 (R r)) = Genv.find_funct tge (ls2 (R r))","hypotheses":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb true = true)","proofString":"discriminate."},{"statement":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb false = true) : Genv.find_funct tge (ls2 (R r)) = Genv.find_funct tge (ls2 (R r)).","conclusion":"Genv.find_funct tge (ls2 (R r)) = Genv.find_funct tge (ls2 (R r))","hypotheses":"(tge : genv) (r : mreg) (ls1 ls2 : locset) (H : negb false = true)","proofString":"auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.splitlong = true) : exists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"exists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.splitlong = true)","proofString":"apply Archi.splitlong_ptr32 in H0.\nexploit Mem.loadv_int64_split; eauto.\nintros (v1 & v2 & A & B & C).\nexists v1, v2.\nsplit; auto.\nsplit; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) : exists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"exists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false)","proofString":"exploit Mem.loadv_int64_split; eauto.\nintros (v1 & v2 & A & B & C).\nexists v1, v2.\nsplit; auto.\nsplit; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) : (exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef v (Val.longofwords v1 v2)) ->\nexists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"(exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef v (Val.longofwords v1 v2)) ->\nexists v1 v2 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v2 else v1) /\\\n  Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false)","proofString":"intros (v1 & v2 & A & B & C).\nexists v1, v2.\nsplit; auto.\nsplit; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2)) : exists v0 v3 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v0 else v3) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v3 else v0) /\\\n  Val.lessdef (Val.hiword v) v0 /\\ Val.lessdef (Val.loword v) v3.","conclusion":"exists v0 v3 : val,\n  Mem.loadv Mint32 m a = Some (if Archi.big_endian then v0 else v3) /\\\n  Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n  Some (if Archi.big_endian then v3 else v0) /\\\n  Val.lessdef (Val.hiword v) v0 /\\ Val.lessdef (Val.loword v) v3","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2))","proofString":"exists v1, v2.\nsplit; auto.\nsplit; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2)) : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\nMem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1) /\\\nVal.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\nMem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1) /\\\nVal.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2))","proofString":"split; auto.\nsplit; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2)) : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1) /\\\nVal.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1) /\\\nVal.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2))","proofString":"split; auto.\ninv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2)) : Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2.","conclusion":"Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2","hypotheses":"(m : mem) (a v : val) (H : Mem.loadv Mint64 m a = Some v) (H0 : Archi.ptr64 = false) (v1 v2 : val) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (C : Val.lessdef v (Val.longofwords v1 v2))","proofString":"inv C; auto.\ndestruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a v1 v2 : val) (H : Mem.loadv Mint64 m a = Some (Val.longofwords v1 v2)) (H0 : Archi.ptr64 = false) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) : Val.lessdef (Val.hiword (Val.longofwords v1 v2)) v1 /\\\nVal.lessdef (Val.loword (Val.longofwords v1 v2)) v2.","conclusion":"Val.lessdef (Val.hiword (Val.longofwords v1 v2)) v1 /\\\nVal.lessdef (Val.loword (Val.longofwords v1 v2)) v2","hypotheses":"(m : mem) (a v1 v2 : val) (H : Mem.loadv Mint64 m a = Some (Val.longofwords v1 v2)) (H0 : Archi.ptr64 = false) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1))","proofString":"destruct v1, v2; simpl; auto.\nrewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(m : mem) (a : val) (i i0 : int) (H : Mem.loadv Mint64 m a = Some (Val.longofwords (Vint i) (Vint i0))) (H0 : Archi.ptr64 = false) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then Vint i else Vint i0)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then Vint i0 else Vint i)) : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i) /\\\nVal.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0).","conclusion":"Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i) /\\\nVal.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)","hypotheses":"(m : mem) (a : val) (i i0 : int) (H : Mem.loadv Mint64 m a = Some (Val.longofwords (Vint i) (Vint i0))) (H0 : Archi.ptr64 = false) (A : Mem.loadv Mint32 m a = Some (if Archi.big_endian then Vint i else Vint i0)) (B : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then Vint i0 else Vint i))","proofString":"rewrite Int64.hi_ofwords, Int64.lo_ofwords; auto."},{"statement":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 : loc) (e : eqs) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 : loc) (e : eqs) (H0 : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e))","proofString":"eapply add_equation_satisf; eauto."},{"statement":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (arg'1 arg'2 : builtin_arg loc) (e e' : eqs) (H : match arg'1 with\n| BA lhi =>\n    match arg'2 with\n    | BA llo =>\n        if typ_eq (env x) Tlong\n        then\n         if Archi.splitlong\n         then\n          Some\n            (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n               (add_equation {| ekind := High; ereg := x; eloc := lhi |} e))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (arg'1 arg'2 : builtin_arg loc) (e e' : eqs) (H : match arg'1 with\n| BA lhi =>\n    match arg'2 with\n    | BA llo =>\n        if typ_eq (env x) Tlong\n        then\n         if Archi.splitlong\n         then\n          Some\n            (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n               (add_equation {| ekind := High; ereg := x; eloc := lhi |} e))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e') (H0 : satisf rs ls e')","proofString":"destruct arg'1; MonadInv.\ndestruct arg'2; MonadInv.\neauto using add_equation_satisf."},{"statement":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 : loc) (arg'2 : builtin_arg loc) (e e' : eqs) (H : match arg'2 with\n| BA llo =>\n    if typ_eq (env x) Tlong\n    then\n     if Archi.splitlong\n     then\n      Some\n        (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n           (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))\n     else None\n    else None\n| _ => None\nend = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 : loc) (arg'2 : builtin_arg loc) (e e' : eqs) (H : match arg'2 with\n| BA llo =>\n    if typ_eq (env x) Tlong\n    then\n     if Archi.splitlong\n     then\n      Some\n        (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n           (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))\n     else None\n    else None\n| _ => None\nend = Some e') (H0 : satisf rs ls e')","proofString":"destruct arg'2; MonadInv.\neauto using add_equation_satisf."},{"statement":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 x1 : loc) (e : eqs) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(env : regenv) (rs : regset) (ls : locset) (x : reg) (x0 x1 : loc) (e : eqs) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (H0 : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e)))","proofString":"eauto using add_equation_satisf."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs)","proofString":"exploit add_equation_lessdef; eauto.\nsimpl; intros.\nexists (ls x0); auto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs) : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := x; eloc := x0 |})\n     rs # (ereg {| ekind := Full; ereg := x; eloc := x0 |}))\n  (ls (eloc {| ekind := Full; ereg := x; eloc := x0 |})) ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'.","conclusion":"Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := x; eloc := x0 |})\n     rs # (ereg {| ekind := Full; ereg := x; eloc := x0 |}))\n  (ls (eloc {| ekind := Full; ereg := x; eloc := x0 |})) ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs)","proofString":"simpl; intros.\nexists (ls x0); auto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs) (H : Val.lessdef rs # x (ls x0)) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA x0) v' /\\ Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 : loc) (SAT : satisf rs ls (add_equation {| ekind := Full; ereg := x; eloc := x0 |} e)) (WT : wt_regset env rs) (H : Val.lessdef rs # x (ls x0))","proofString":"exists (ls x0); auto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (AE : match arg'1 with\n| BA lhi =>\n    match arg'2 with\n    | BA llo =>\n        if typ_eq (env x) Tlong\n        then\n         if Archi.splitlong\n         then\n          Some\n            (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n               (add_equation {| ekind := High; ereg := x; eloc := lhi |} e))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (AE : match arg'1 with\n| BA lhi =>\n    match arg'2 with\n    | BA llo =>\n        if typ_eq (env x) Tlong\n        then\n         if Archi.splitlong\n         then\n          Some\n            (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n               (add_equation {| ekind := High; ereg := x; eloc := lhi |} e))\n         else None\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"destruct arg'1; MonadInv.\ndestruct arg'2; MonadInv.\nexploit add_equation_lessdef.\neauto.\nsimpl; intros LD1.\nexploit add_equation_lessdef.\neapply add_equation_satisf.\neauto.\nsimpl; intros LD2.\nexists (Val.longofwords (ls x0) (ls x1)); split; auto with barg.\nrewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e e' : eqs) (x0 : loc) (arg'2 : builtin_arg loc) (AE : match arg'2 with\n| BA llo =>\n    if typ_eq (env x) Tlong\n    then\n     if Archi.splitlong\n     then\n      Some\n        (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n           (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))\n     else None\n    else None\n| _ => None\nend = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) arg'2) v' /\\\n  Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) arg'2) v' /\\\n  Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e e' : eqs) (x0 : loc) (arg'2 : builtin_arg loc) (AE : match arg'2 with\n| BA llo =>\n    if typ_eq (env x) Tlong\n    then\n     if Archi.splitlong\n     then\n      Some\n        (add_equation {| ekind := Low; ereg := x; eloc := llo |}\n           (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))\n     else None\n    else None\n| _ => None\nend = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"destruct arg'2; MonadInv.\nexploit add_equation_lessdef.\neauto.\nsimpl; intros LD1.\nexploit add_equation_lessdef.\neapply add_equation_satisf.\neauto.\nsimpl; intros LD2.\nexists (Val.longofwords (ls x0) (ls x1)); split; auto with barg.\nrewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs)","proofString":"exploit add_equation_lessdef.\neauto.\nsimpl; intros LD1.\nexploit add_equation_lessdef.\neapply add_equation_satisf.\neauto.\nsimpl; intros LD2.\nexists (Val.longofwords (ls x0) (ls x1)); split; auto with barg.\nrewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1))","proofString":"exploit add_equation_lessdef.\neapply add_equation_satisf.\neauto.\nsimpl; intros LD2.\nexists (Val.longofwords (ls x0) (ls x1)); split; auto with barg.\nrewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0)) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong (BA x0) (BA x1)) v' /\\\n  Val.lessdef rs # x v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0))","proofString":"exists (Val.longofwords (ls x0) (ls x1)); split; auto with barg.\nrewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0)) : Val.lessdef rs # x (Val.longofwords (ls x0) (ls x1)).","conclusion":"Val.lessdef rs # x (Val.longofwords (ls x0) (ls x1))","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0))","proofString":"rewrite <- (val_longofwords_eq_2 rs#x); auto.\napply Val.longofwords_lessdef; auto.\nrewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0)) : Val.lessdef (Val.longofwords (Val.hiword rs # x) (Val.loword rs # x))\n  (Val.longofwords (ls x0) (ls x1)).","conclusion":"Val.lessdef (Val.longofwords (Val.hiword rs # x) (Val.loword rs # x))\n  (Val.longofwords (ls x0) (ls x1))","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0))","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0)) : Val.has_type rs # x Tlong.","conclusion":"Val.has_type rs # x Tlong","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (x : positive) (e : eqs) (x0 x1 : loc) (e0 : env x = Tlong) (Heqb : Archi.splitlong = true) (SAT : satisf rs ls\n  (add_equation {| ekind := Low; ereg := x; eloc := x1 |}\n     (add_equation {| ekind := High; ereg := x; eloc := x0 |} e))) (WT : wt_regset env rs) (LD1 : Val.lessdef (Val.loword rs # x) (ls x1)) (LD2 : Val.lessdef (Val.hiword rs # x) (ls x0))","proofString":"rewrite <- e0; apply WT."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (n0 : int) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_int n0) v' /\\ Val.lessdef (Vint n0) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_int n0) v' /\\ Val.lessdef (Vint n0) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (n0 : int) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (n0 : int64) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_long n0) v' /\\ Val.lessdef (Vlong n0) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_long n0) v' /\\ Val.lessdef (Vlong n0) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (n0 : int64) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (f : float) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_float f) v' /\\ Val.lessdef (Vfloat f) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_float f) v' /\\ Val.lessdef (Vfloat f) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (f : float) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (f : float32) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_single f) v' /\\ Val.lessdef (Vsingle f) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_single f) v' /\\ Val.lessdef (Vsingle f) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (f : float32) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (v : val) (chunk0 : memory_chunk) (ofs0 : ptrofs) (H : Mem.loadv chunk0 m (Val.offset_ptr sp ofs0) = Some v) (e' : eqs) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_loadstack chunk0 ofs0) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_loadstack chunk0 ofs0) v' /\\\n  Val.lessdef v v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (v : val) (chunk0 : memory_chunk) (ofs0 : ptrofs) (H : Mem.loadv chunk0 m (Val.offset_ptr sp ofs0) = Some v) (e' : eqs) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (ofs0 : ptrofs) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addrstack ofs0) v' /\\\n  Val.lessdef (Val.offset_ptr sp ofs0) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addrstack ofs0) v' /\\\n  Val.lessdef (Val.offset_ptr sp ofs0) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (ofs0 : ptrofs) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (v : val) (chunk0 : memory_chunk) (id0 : ident) (ofs0 : ptrofs) (H : Mem.loadv chunk0 m (Senv.symbol_address ge id0 ofs0) = Some v) (e' : eqs) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_loadglobal chunk0 id0 ofs0) v' /\\\n  Val.lessdef v v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_loadglobal chunk0 id0 ofs0) v' /\\\n  Val.lessdef v v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (v : val) (chunk0 : memory_chunk) (id0 : ident) (ofs0 : ptrofs) (H : Mem.loadv chunk0 m (Senv.symbol_address ge id0 ofs0) = Some v) (e' : eqs) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (id0 : ident) (ofs0 : ptrofs) (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addrglobal id0 ofs0) v' /\\\n  Val.lessdef (Senv.symbol_address ge id0 ofs0) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addrglobal id0 ofs0) v' /\\\n  Val.lessdef (Senv.symbol_address ge id0 ofs0) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (e' : eqs) (id0 : ident) (ofs0 : ptrofs) (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"econstructor; eauto with barg."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"exploit IHeval_builtin_arg1; eauto.\neapply add_equations_builtin_arg_satisf; eauto.\nintros (v1 & A & B).\nexploit IHeval_builtin_arg2; eauto.\nintros (v2 & C & D).\nexists (Val.longofwords v1 v2); split; auto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : satisf rs ls e0.","conclusion":"satisf rs ls e0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"eapply add_equations_builtin_arg_satisf; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : (exists v' : val, eval_builtin_arg ge ls sp m arg'1 v' /\\ Val.lessdef vhi v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"(exists v' : val, eval_builtin_arg ge ls sp m arg'1 v' /\\ Val.lessdef vhi v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"intros (v1 & A & B).\nexploit IHeval_builtin_arg2; eauto.\nintros (v2 & C & D).\nexists (Val.longofwords v1 v2); split; auto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1)","proofString":"exploit IHeval_builtin_arg2; eauto.\nintros (v2 & C & D).\nexists (Val.longofwords v1 v2); split; auto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) : (exists v' : val, eval_builtin_arg ge ls sp m arg'2 v' /\\ Val.lessdef vlo v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"(exists v' : val, eval_builtin_arg ge ls sp m arg'2 v' /\\ Val.lessdef vlo v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1)","proofString":"intros (v2 & C & D).\nexists (Val.longofwords v1 v2); split; auto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) (v2 : val) (C : eval_builtin_arg ge ls sp m arg'2 v2) (D : Val.lessdef vlo v2) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_splitlong arg'1 arg'2) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) (v2 : val) (C : eval_builtin_arg ge ls sp m arg'2 v2) (D : Val.lessdef vlo v2)","proofString":"exists (Val.longofwords v1 v2); split; auto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) (v2 : val) (C : eval_builtin_arg ge ls sp m arg'2 v2) (D : Val.lessdef vlo v2) : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1 v2).","conclusion":"Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1 v2)","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m hi vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m lo vlo) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env hi arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vhi v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env lo arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef vlo v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env hi arg'1 e = Some e0) (AE : add_equations_builtin_arg env lo arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1 : val) (A : eval_builtin_arg ge ls sp m arg'1 v1) (B : Val.lessdef vhi v1) (v2 : val) (C : eval_builtin_arg ge ls sp m arg'2 v2) (D : Val.lessdef vlo v2)","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"exploit IHeval_builtin_arg1; eauto.\neapply add_equations_builtin_arg_satisf; eauto.\nintros (v1' & A & B).\nexploit IHeval_builtin_arg2; eauto.\nintros (v2' & C & D).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : satisf rs ls e0.","conclusion":"satisf rs ls e0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"eapply add_equations_builtin_arg_satisf; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) : (exists v' : val, eval_builtin_arg ge ls sp m arg'1 v' /\\ Val.lessdef v1 v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"(exists v' : val, eval_builtin_arg ge ls sp m arg'1 v' /\\ Val.lessdef v1 v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs)","proofString":"intros (v1' & A & B).\nexploit IHeval_builtin_arg2; eauto.\nintros (v2' & C & D).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1') : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1')","proofString":"exploit IHeval_builtin_arg2; eauto.\nintros (v2' & C & D).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1') : (exists v' : val, eval_builtin_arg ge ls sp m arg'2 v' /\\ Val.lessdef v2 v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"(exists v' : val, eval_builtin_arg ge ls sp m arg'2 v' /\\ Val.lessdef v2 v') ->\nexists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1')","proofString":"intros (v2' & C & D).\neconstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_builtin_arg ge ls sp m arg'2 v2') (D : Val.lessdef v2 v2') : exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","conclusion":"exists v' : val,\n  eval_builtin_arg ge ls sp m (BA_addptr arg'1 arg'2) v' /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) sp m a2 v2) (IHeval_builtin_arg1 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a1 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v1 v') (IHeval_builtin_arg2 : forall (e1 e'0 : eqs) (arg' : builtin_arg loc),\nadd_equations_builtin_arg env a2 arg' e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nexists v' : val, eval_builtin_arg ge ls sp m arg' v' /\\ Val.lessdef v2 v') (e e' : eqs) (arg'1 arg'2 : builtin_arg loc) (e0 : eqs) (Heqo : add_equations_builtin_arg env a1 arg'1 e = Some e0) (AE : add_equations_builtin_arg env a2 arg'2 e0 = Some e') (SAT : satisf rs ls e') (WT : wt_regset env rs) (v1' : val) (A : eval_builtin_arg ge ls sp m arg'1 v1') (B : Val.lessdef v1 v1') (v2' : val) (C : eval_builtin_arg ge ls sp m arg'2 v2') (D : Val.lessdef v2 v2')","proofString":"econstructor; split.\neauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (e' : eqs) (H0 : satisf rs ls e') (H1 : wt_regset env rs) (H2 : Mem.extends m tm) : exists vl' : list val,\n  eval_builtin_args ge ls sp tm nil vl' /\\ Val.lessdef_list nil vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge ls sp tm nil vl' /\\ Val.lessdef_list nil vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (e' : eqs) (H0 : satisf rs ls e') (H1 : wt_regset env rs) (H2 : Mem.extends m tm)","proofString":"exists (@nil val); split; constructor."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl' /\\ Val.lessdef_list bl vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : exists vl' : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl' /\\ Val.lessdef_list bl vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"exploit IHlist_forall2; eauto.\nintros (vl' & A & B).\nexploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_builtin_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl' /\\ Val.lessdef_list bl vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : (exists vl' : list val,\n   eval_builtin_args ge ls sp tm arg' vl' /\\ Val.lessdef_list bl vl') ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"(exists vl' : list val,\n   eval_builtin_args ge ls sp tm arg' vl' /\\ Val.lessdef_list bl vl') ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl' /\\ Val.lessdef_list bl vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"intros (vl' & A & B).\nexploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_builtin_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') : exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl')","proofString":"exploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_builtin_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') : exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1')","proofString":"exploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') : (exists v2 : val, eval_builtin_arg ge ls sp tm b v2 /\\ Val.lessdef v1' v2) ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"(exists v2 : val, eval_builtin_arg ge ls sp tm b v2 /\\ Val.lessdef v1' v2) ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1')","proofString":"intros (v1'' & E & F).\nexists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'') : exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge ls sp tm (b :: arg') vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'')","proofString":"exists (v1'' :: vl'); split; constructor; auto.\neapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'') : Val.lessdef b1 v1''.","conclusion":"Val.lessdef b1 v1''","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e1 e'0 : eqs),\nadd_equations_builtin_args env al arg'0 e1 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val,\n  eval_builtin_args ge ls sp tm arg'0 vl'0 /\\ Val.lessdef_list bl vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e0 : eqs) (Heqo : add_equations_builtin_arg env a1 b e = Some e0) (H1 : add_equations_builtin_args env al arg' e0 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (A : eval_builtin_args ge ls sp tm arg' vl') (B : Val.lessdef_list bl vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'')","proofString":"eapply Val.lessdef_trans; eauto."},{"statement":"(env : regenv) (rs : regset) (ls : locset) (a : builtin_arg reg) (arg : list (builtin_arg reg)) (IHarg : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env arg arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> satisf rs ls e0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (H : match add_equations_builtin_arg env a b e with\n| Some e1 => add_equations_debug_args env arg arg' e1\n| None => add_equations_debug_args env arg (b :: arg') e\nend = Some e') (H0 : satisf rs ls e') : satisf rs ls e.","conclusion":"satisf rs ls e","hypotheses":"(env : regenv) (rs : regset) (ls : locset) (a : builtin_arg reg) (arg : list (builtin_arg reg)) (IHarg : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env arg arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 -> satisf rs ls e0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (H : match add_equations_builtin_arg env a b e with\n| Some e1 => add_equations_debug_args env arg arg' e1\n| None => add_equations_debug_args env arg (b :: arg') e\nend = Some e') (H0 : satisf rs ls e')","proofString":"destruct (add_equations_builtin_arg env a b e) as [e1|] eqn:A;  eauto using add_equations_builtin_arg_satisf."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (e' : eqs) (H0 : satisf rs ls e') (H1 : wt_regset env rs) (H2 : Mem.extends m tm) : exists vl' : list val, eval_builtin_args ge ls sp tm nil vl'.","conclusion":"exists vl' : list val, eval_builtin_args ge ls sp tm nil vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (e' : eqs) (H0 : satisf rs ls e') (H1 : wt_regset env rs) (H2 : Mem.extends m tm)","proofString":"exists (@nil val); constructor."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg' : list (builtin_arg loc)) (e e'0 : eqs),\nadd_equations_debug_args env al arg' e = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg' vl') (e' : eqs) (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : exists vl' : list val, eval_builtin_args ge ls sp tm nil vl'.","conclusion":"exists vl' : list val, eval_builtin_args ge ls sp tm nil vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg' : list (builtin_arg loc)) (e e'0 : eqs),\nadd_equations_debug_args env al arg' e = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg' vl') (e' : eqs) (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"exists (@nil val); constructor."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (H1 : match add_equations_builtin_arg env a1 b e with\n| Some e1 => add_equations_debug_args env al arg' e1\n| None => add_equations_debug_args env al (b :: arg') e\nend = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'.","conclusion":"exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (H1 : match add_equations_builtin_arg env a1 b e with\n| Some e1 => add_equations_debug_args env al arg' e1\n| None => add_equations_debug_args env al (b :: arg') e\nend = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"destruct (add_equations_builtin_arg env a1 b e) as [e1|] eqn:A.\nexploit IHlist_forall2; eauto.\nintros (vl' & B).\nexploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_debug_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto.\neauto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'.","conclusion":"exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"exploit IHlist_forall2; eauto.\nintros (vl' & B).\nexploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_debug_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : (exists vl' : list val, eval_builtin_args ge ls sp tm arg' vl') ->\nexists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'.","conclusion":"(exists vl' : list val, eval_builtin_args ge ls sp tm arg' vl') ->\nexists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"intros (vl' & B).\nexploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_debug_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') : exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0.","conclusion":"exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl')","proofString":"exploit add_equations_builtin_arg_lessdef; eauto.\neapply add_equations_debug_args_satisf; eauto.\nintros (v1' & C & D).\nexploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') : exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0.","conclusion":"exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1')","proofString":"exploit (@eval_builtin_arg_lessdef _ ge ls ls); eauto.\nintros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') : (exists v2 : val, eval_builtin_arg ge ls sp tm b v2 /\\ Val.lessdef v1' v2) ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0.","conclusion":"(exists v2 : val, eval_builtin_arg ge ls sp tm b v2 /\\ Val.lessdef v1' v2) ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1')","proofString":"intros (v1'' & E & F).\nexists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'') : exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0.","conclusion":"exists vl'0 : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'0","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl'0 : list val, eval_builtin_args ge ls sp tm arg'0 vl'0) (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' e1 : eqs) (A : add_equations_builtin_arg env a1 b e = Some e1) (H1 : add_equations_debug_args env al arg' e1 = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) (vl' : list val) (B : eval_builtin_args ge ls sp tm arg' vl') (v1' : val) (C : eval_builtin_arg ge ls sp m b v1') (D : Val.lessdef b1 v1') (v1'' : val) (E : eval_builtin_arg ge ls sp tm b v1'') (F : Val.lessdef v1' v1'')","proofString":"exists (v1'' :: vl'); constructor; auto."},{"statement":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (A : add_equations_builtin_arg env a1 b e = None) (H1 : add_equations_debug_args env al (b :: arg') e = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm) : exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'.","conclusion":"exists vl' : list val, eval_builtin_args ge ls sp tm (b :: arg') vl'","hypotheses":"(env : regenv) (ge : RTL.genv) (sp : val) (rs : Regmap.t val) (ls : locset) (m tm : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) sp m a1 b1) (H0 : list_forall2 (eval_builtin_arg ge (fun r : positive => rs # r) sp m) al bl) (IHlist_forall2 : forall (arg'0 : list (builtin_arg loc)) (e0 e'0 : eqs),\nadd_equations_debug_args env al arg'0 e0 = Some e'0 ->\nsatisf rs ls e'0 ->\nwt_regset env rs ->\nMem.extends m tm ->\nexists vl' : list val, eval_builtin_args ge ls sp tm arg'0 vl') (b : builtin_arg loc) (arg' : list (builtin_arg loc)) (e e' : eqs) (A : add_equations_builtin_arg env a1 b e = None) (H1 : add_equations_debug_args env al (b :: arg') e = Some e') (H2 : satisf rs ls e') (H3 : wt_regset env rs) (H4 : Mem.extends m tm)","proofString":"eauto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) : satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2').","conclusion":"satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2)","proofString":"assert (DEFAULT: add_equations_builtin_args env args args' e1 = Some e2 ->    satisf rs ls e1 /\\    exists vargs' vres' m2',       eval_builtin_args ge ls sp m1' args' vargs'    /\\ external_call ef ge vargs' m1' t vres' m2'    /\\ Val.lessdef vres vres'    /\\ Mem.extends m2 m2').\nintros.\nsplit.\neapply add_equations_builtin_args_satisf; eauto.\nexploit add_equations_builtin_args_lessdef; eauto.\nintros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto.\ndestruct ef; auto.\nsplit.\neapply add_equations_debug_args_satisf; eauto.\nexploit add_equations_debug_args_eval; eauto.\nintros (vargs' & A).\nsimpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2').","conclusion":"add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2)","proofString":"intros.\nsplit.\neapply add_equations_builtin_args_satisf; eauto.\nexploit add_equations_builtin_args_lessdef; eauto.\nintros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) : satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2').","conclusion":"satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2)","proofString":"split.\neapply add_equations_builtin_args_satisf; eauto.\nexploit add_equations_builtin_args_lessdef; eauto.\nintros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) : satisf rs ls e1.","conclusion":"satisf rs ls e1","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2)","proofString":"eapply add_equations_builtin_args_satisf; eauto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) : exists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"exists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2)","proofString":"exploit add_equations_builtin_args_lessdef; eauto.\nintros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) : (exists vl' : list val,\n   eval_builtin_args ge ls sp m1' args' vl' /\\ Val.lessdef_list vargs vl') ->\nexists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"(exists vl' : list val,\n   eval_builtin_args ge ls sp m1' args' vl' /\\ Val.lessdef_list vargs vl') ->\nexists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2)","proofString":"intros (vargs' & A & B).\nexploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs') : exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs')","proofString":"exploit external_call_mem_extends; eauto.\nintros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs') : (exists (vres' : val) (m2' : mem),\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') ->\nexists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"(exists (vres' : val) (m2' : mem),\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\\n   Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') ->\nexists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs')","proofString":"intros (vres' & m2' & C & D & E & F).\nexists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs') (vres' : val) (m2' : mem) (C : external_call ef ge vargs' m1' t vres' m2') (D : Val.lessdef vres vres') (E : Mem.extends m2 m2') (F : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') : exists (vargs'0 : list val) (vres'0 : val) (m2'0 : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres'0 m2'0 /\\\n  Val.lessdef vres vres'0 /\\ Mem.extends m2 m2'0.","conclusion":"exists (vargs'0 : list val) (vres'0 : val) (m2'0 : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call ef ge vargs'0 m1' t vres'0 m2'0 /\\\n  Val.lessdef vres vres'0 /\\ Mem.extends m2 m2'0","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (H5 : add_equations_builtin_args env args args' e1 = Some e2) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') (B : Val.lessdef_list vargs vargs') (vres' : val) (m2' : mem) (C : external_call ef ge vargs' m1' t vres' m2') (D : Val.lessdef vres vres') (E : Mem.extends m2 m2') (F : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2')","proofString":"exists vargs', vres', m2'; auto."},{"statement":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) : satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2').","conclusion":"satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')","hypotheses":"(ef : external_function) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call ef ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call ef ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2'))","proofString":"destruct ef; auto.\nsplit.\neapply add_equations_debug_args_satisf; eauto.\nexploit add_equations_debug_args_eval; eauto.\nintros (vargs' & A).\nsimpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) : satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2').","conclusion":"satisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2'))","proofString":"split.\neapply add_equations_debug_args_satisf; eauto.\nexploit add_equations_debug_args_eval; eauto.\nintros (vargs' & A).\nsimpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) : satisf rs ls e1.","conclusion":"satisf rs ls e1","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2'))","proofString":"eapply add_equations_debug_args_satisf; eauto."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) : exists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"exists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2'))","proofString":"exploit add_equations_debug_args_eval; eauto.\nintros (vargs' & A).\nsimpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) : (exists vl' : list val, eval_builtin_args ge ls sp m1' args' vl') ->\nexists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"(exists vl' : list val, eval_builtin_args ge ls sp m1' args' vl') ->\nexists (vargs' : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs' /\\\n  external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs' : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs' /\\\n   external_call (EF_debug kind text targs) ge vargs' m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2'))","proofString":"intros (vargs' & A).\nsimpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') : exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'.","conclusion":"exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\ Mem.extends m2 m2'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1 m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (t : trace) (vres : val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m1 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m1 args vargs) (H4 : external_call (EF_debug kind text targs) ge vargs m1 t vres m2) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' t vres' m2' /\\\n   Val.lessdef vres vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs')","proofString":"simpl in H4; inv H4.\nexists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') : exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\ Mem.extends m2 m2'.","conclusion":"exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n  eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n  external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\ Mem.extends m2 m2'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs')","proofString":"exists vargs', Vundef, m1'.\nintuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') : eval_builtin_args ge ls sp m1' args' vargs' /\\\nexternal_call (EF_debug kind text targs) ge vargs' m1' E0 Vundef m1' /\\\nVal.lessdef Vundef Vundef /\\ Mem.extends m2 m1'.","conclusion":"eval_builtin_args ge ls sp m1' args' vargs' /\\\nexternal_call (EF_debug kind text targs) ge vargs' m1' E0 Vundef m1' /\\\nVal.lessdef Vundef Vundef /\\ Mem.extends m2 m1'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs')","proofString":"intuition auto.\nsimpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') : external_call (EF_debug kind text targs) ge vargs' m1' E0 Vundef m1'.","conclusion":"external_call (EF_debug kind text targs) ge vargs' m1' E0 Vundef m1'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs')","proofString":"simpl.\nconstructor."},{"statement":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs') : extcall_debug_sem ge vargs' m1' E0 Vundef m1'.","conclusion":"extcall_debug_sem ge vargs' m1' E0 Vundef m1'","hypotheses":"(kind : positive) (text : ident) (targs : list typ) (env : regenv) (args : list (builtin_arg reg)) (args' : list (builtin_arg loc)) (e1 e2 : eqs) (m1' : mem) (rs : regset) (ls : locset) (ge : RTL.genv) (sp : val) (vargs : list val) (m2 : mem) (H : wt_regset env rs) (H0 : add_equations_debug_args env args args' e1 = Some e2) (H1 : Mem.extends m2 m1') (H2 : satisf rs ls e2) (H3 : eval_builtin_args ge (fun r : positive => rs # r) sp m2 args vargs) (DEFAULT : add_equations_builtin_args env args args' e1 = Some e2 ->\nsatisf rs ls e1 /\\\n(exists (vargs'0 : list val) (vres' : val) (m2' : mem),\n   eval_builtin_args ge ls sp m1' args' vargs'0 /\\\n   external_call (EF_debug kind text targs) ge vargs'0 m1' E0 vres' m2' /\\\n   Val.lessdef Vundef vres' /\\ Mem.extends m2 m2')) (vargs' : list val) (A : eval_builtin_args ge ls sp m1' args' vargs')","proofString":"constructor."},{"statement":"(env : regenv) (res : builtin_res reg) (res' : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H : remove_equations_builtin_res env res res' e0 = Some e1) (H0 : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (H1 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') : satisf (regmap_setres res v rs) (Locmap.setres res' v' ls) e0.","conclusion":"satisf (regmap_setres res v rs) (Locmap.setres res' v' ls) e0","hypotheses":"(env : regenv) (res : builtin_res reg) (res' : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H : remove_equations_builtin_res env res res' e0 = Some e1) (H0 : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (H1 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v')","proofString":"rewrite forallb_forall in *.\ndestruct res, res'; simpl in *; inv H.\napply parallel_assignment_satisf with (k := Full); auto.\nunfold reg_loc_unconstrained.\nrewrite H0 by auto.\nrewrite H1 by auto.\nauto.\ndestruct res'1; try discriminate.\ndestruct res'2; try discriminate.\nrename x0 into hi; rename x1 into lo.\nMonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto.\nauto."},{"statement":"(env : regenv) (res : builtin_res reg) (res' : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H : remove_equations_builtin_res env res res' e0 = Some e1) (H0 : forall x : reg,\nIn x (params_of_builtin_res res) -> reg_unconstrained x e1 = true) (H1 : forall x : mreg,\nIn x (params_of_builtin_res res') -> loc_unconstrained (R x) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') : satisf (regmap_setres res v rs) (Locmap.setres res' v' ls) e0.","conclusion":"satisf (regmap_setres res v rs) (Locmap.setres res' v' ls) e0","hypotheses":"(env : regenv) (res : builtin_res reg) (res' : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H : remove_equations_builtin_res env res res' e0 = Some e1) (H0 : forall x : reg,\nIn x (params_of_builtin_res res) -> reg_unconstrained x e1 = true) (H1 : forall x : mreg,\nIn x (params_of_builtin_res res') -> loc_unconstrained (R x) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v')","proofString":"destruct res, res'; simpl in *; inv H.\napply parallel_assignment_satisf with (k := Full); auto.\nunfold reg_loc_unconstrained.\nrewrite H0 by auto.\nrewrite H1 by auto.\nauto.\ndestruct res'1; try discriminate.\ndestruct res'2; try discriminate.\nrename x0 into hi; rename x1 into lo.\nMonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto.\nauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v') : satisf rs # x <- v (Locmap.set (R x0) v' ls) e0.","conclusion":"satisf rs # x <- v (Locmap.set (R x0) v' ls) e0","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v')","proofString":"apply parallel_assignment_satisf with (k := Full); auto.\nunfold reg_loc_unconstrained.\nrewrite H0 by auto.\nrewrite H1 by auto.\nauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v') : reg_loc_unconstrained x (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true.","conclusion":"reg_loc_unconstrained x (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v')","proofString":"unfold reg_loc_unconstrained.\nrewrite H0 by auto.\nrewrite H1 by auto.\nauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v') : reg_unconstrained x\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) &&\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true.","conclusion":"reg_unconstrained x\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) &&\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v')","proofString":"rewrite H0 by auto.\nrewrite H1 by auto.\nauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v') : true &&\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true.","conclusion":"true &&\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v')","proofString":"rewrite H1 by auto.\nauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v') : true && true = true.","conclusion":"true && true = true","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0)) (H1 : forall x1 : mreg,\nx0 = x1 \\/ False ->\nloc_unconstrained (R x1)\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H0 : forall x1 : reg,\nx = x1 \\/ False ->\nreg_unconstrained x1\n  (remove_equation {| ekind := Full; ereg := x; eloc := R x0 |} e0) = true) (H3 : Val.lessdef v v')","proofString":"auto."},{"statement":"(env : regenv) (x : reg) (res'1 res'2 : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res res'1 ++ params_of_builtin_res res'2) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : match res'1 with\n| BR rhi =>\n    match res'2 with\n    | BR rlo =>\n        if typ_eq (env x) Tlong\n        then\n         if mreg_eq rhi rlo\n         then None\n         else\n          Some\n            (remove_equation {| ekind := Low; ereg := x; eloc := R rlo |}\n               (remove_equation {| ekind := High; ereg := x; eloc := R rhi |}\n                  e0))\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e1) : satisf rs # x <- v\n  (Locmap.setres res'2 (Val.loword v')\n     (Locmap.setres res'1 (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres res'2 (Val.loword v')\n     (Locmap.setres res'1 (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (res'1 res'2 : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res res'1 ++ params_of_builtin_res res'2) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : match res'1 with\n| BR rhi =>\n    match res'2 with\n    | BR rlo =>\n        if typ_eq (env x) Tlong\n        then\n         if mreg_eq rhi rlo\n         then None\n         else\n          Some\n            (remove_equation {| ekind := Low; ereg := x; eloc := R rlo |}\n               (remove_equation {| ekind := High; ereg := x; eloc := R rhi |}\n                  e0))\n        else None\n    | _ => None\n    end\n| _ => None\nend = Some e1)","proofString":"destruct res'1; try discriminate.\ndestruct res'2; try discriminate.\nrename x0 into hi; rename x1 into lo.\nMonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (x0 : mreg) (res'2 : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x1 : reg, x = x1 \\/ False -> reg_unconstrained x1 e1 = true) (H1 : forall x1 : mreg,\nIn x1 (params_of_builtin_res (BR x0) ++ params_of_builtin_res res'2) ->\nloc_unconstrained (R x1) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : match res'2 with\n| BR rlo =>\n    if typ_eq (env x) Tlong\n    then\n     if mreg_eq x0 rlo\n     then None\n     else\n      Some\n        (remove_equation {| ekind := Low; ereg := x; eloc := R rlo |}\n           (remove_equation {| ekind := High; ereg := x; eloc := R x0 |} e0))\n    else None\n| _ => None\nend = Some e1) : satisf rs # x <- v\n  (Locmap.setres res'2 (Val.loword v')\n     (Locmap.setres (BR x0) (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres res'2 (Val.loword v')\n     (Locmap.setres (BR x0) (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (x0 : mreg) (res'2 : builtin_res mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x1 : reg, x = x1 \\/ False -> reg_unconstrained x1 e1 = true) (H1 : forall x1 : mreg,\nIn x1 (params_of_builtin_res (BR x0) ++ params_of_builtin_res res'2) ->\nloc_unconstrained (R x1) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : match res'2 with\n| BR rlo =>\n    if typ_eq (env x) Tlong\n    then\n     if mreg_eq x0 rlo\n     then None\n     else\n      Some\n        (remove_equation {| ekind := Low; ereg := x; eloc := R rlo |}\n           (remove_equation {| ekind := High; ereg := x; eloc := R x0 |} e0))\n    else None\n| _ => None\nend = Some e1)","proofString":"destruct res'2; try discriminate.\nrename x0 into hi; rename x1 into lo.\nMonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (x0 x1 : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x2 : reg, x = x2 \\/ False -> reg_unconstrained x2 e1 = true) (H1 : forall x2 : mreg,\nIn x2 (params_of_builtin_res (BR x0) ++ params_of_builtin_res (BR x1)) ->\nloc_unconstrained (R x2) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : (if typ_eq (env x) Tlong\n then\n  if mreg_eq x0 x1\n  then None\n  else\n   Some\n     (remove_equation {| ekind := Low; ereg := x; eloc := R x1 |}\n        (remove_equation {| ekind := High; ereg := x; eloc := R x0 |} e0))\n else None) = Some e1) : satisf rs # x <- v\n  (Locmap.setres (BR x1) (Val.loword v')\n     (Locmap.setres (BR x0) (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres (BR x1) (Val.loword v')\n     (Locmap.setres (BR x0) (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (x0 x1 : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x2 : reg, x = x2 \\/ False -> reg_unconstrained x2 e1 = true) (H1 : forall x2 : mreg,\nIn x2 (params_of_builtin_res (BR x0) ++ params_of_builtin_res (BR x1)) ->\nloc_unconstrained (R x2) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : (if typ_eq (env x) Tlong\n then\n  if mreg_eq x0 x1\n  then None\n  else\n   Some\n     (remove_equation {| ekind := Low; ereg := x; eloc := R x1 |}\n        (remove_equation {| ekind := High; ereg := x; eloc := R x0 |} e0))\n else None) = Some e1)","proofString":"rename x0 into hi; rename x1 into lo.\nMonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : (if typ_eq (env x) Tlong\n then\n  if mreg_eq hi lo\n  then None\n  else\n   Some\n     (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n        (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))\n else None) = Some e1) : satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (H5 : (if typ_eq (env x) Tlong\n then\n  if mreg_eq hi lo\n  then None\n  else\n   Some\n     (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n        (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))\n else None) = Some e1)","proofString":"MonadInv.\ndestruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (e : env x = Tlong) (H5 : (if mreg_eq hi lo\n then None\n else\n  Some\n    (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n       (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))) =\nSome e1) : satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e1 = true) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') (e : env x = Tlong) (H5 : (if mreg_eq hi lo\n then None\n else\n  Some\n    (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n       (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))) =\nSome e1)","proofString":"destruct (mreg_eq hi lo); inv H5.\nset (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0)) =\ntrue) (H0 : forall x0 : reg,\nx = x0 \\/ False ->\nreg_unconstrained x0\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0)) =\ntrue) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) : satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0.","conclusion":"satisf rs # x <- v\n  (Locmap.setres (BR lo) (Val.loword v')\n     (Locmap.setres (BR hi) (Val.hiword v') ls)) e0","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (H2 : satisf rs ls\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0))) (H1 : forall x0 : mreg,\nIn x0 (params_of_builtin_res (BR hi) ++ params_of_builtin_res (BR lo)) ->\nloc_unconstrained (R x0)\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0)) =\ntrue) (H0 : forall x0 : reg,\nx = x0 \\/ False ->\nreg_unconstrained x0\n  (remove_equation {| ekind := Low; ereg := x; eloc := R lo |}\n     (remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0)) =\ntrue) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo)","proofString":"set (e' := remove_equation {| ekind := High; ereg := x; eloc := R hi |} e0) in *.\nset (e'' := remove_equation {| ekind := Low; ereg := x; eloc := R lo |} e') in *.\nsimpl in *.\nred; intros.\ndestruct (OrderedEquation.eq_dec q (Eq Low x (R lo))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto.\ndestruct (OrderedEquation.eq_dec q (Eq High x (R hi))).\nsubst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto.\nassert (EqSet.In q e'').\nunfold e'', e', remove_equation; simpl; ESD.fsetdec.\nrewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (e1 : q = {| ekind := Low; ereg := x; eloc := R lo |}) : Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (e1 : q = {| ekind := Low; ereg := x; eloc := R lo |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0) : Val.lessdef (Val.loword (rs # x <- v) # x)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R lo)).","conclusion":"Val.lessdef (Val.loword (rs # x <- v) # x)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R lo))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0)","proofString":"rewrite Regmap.gss.\nrewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0) : Val.lessdef (Val.loword v)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R lo)).","conclusion":"Val.lessdef (Val.loword v)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R lo))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0)","proofString":"rewrite Locmap.gss.\napply Val.loword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0) : Val.lessdef (Val.loword v) (Val.loword v').","conclusion":"Val.lessdef (Val.loword v) (Val.loword v')","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (H : EqSet.In {| ekind := Low; ereg := x; eloc := R lo |} e0)","proofString":"apply Val.loword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (e1 : q = {| ekind := High; ereg := x; eloc := R hi |}) : Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (e1 : q = {| ekind := High; ereg := x; eloc := R hi |})","proofString":"subst q; simpl.\nrewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0) : Val.lessdef (Val.hiword (rs # x <- v) # x)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R hi)).","conclusion":"Val.lessdef (Val.hiword (rs # x <- v) # x)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R hi))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0)","proofString":"rewrite Regmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0) : Val.lessdef (Val.hiword v)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R hi)).","conclusion":"Val.lessdef (Val.hiword v)\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (R hi))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0)","proofString":"rewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0) : Val.lessdef (Val.hiword v) (Locmap.set (R hi) (Val.hiword v') ls (R hi)).","conclusion":"Val.lessdef (Val.hiword v) (Locmap.set (R hi) (Val.hiword v') ls (R hi))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0)","proofString":"rewrite Locmap.gss.\napply Val.hiword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0) : Val.lessdef (Val.hiword v) (Val.hiword v').","conclusion":"Val.lessdef (Val.hiword v) (Val.hiword v')","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (n0 : {| ekind := High; ereg := x; eloc := R hi |} <>\n{| ekind := Low; ereg := x; eloc := R lo |}) (H : EqSet.In {| ekind := High; ereg := x; eloc := R hi |} e0)","proofString":"apply Val.hiword_lessdef; auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) (rs # x <- v) # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"rewrite Regmap.gso.\nrewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto.\neapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q))\n  (Locmap.set (R lo) (Val.loword v') (Locmap.set (R hi) (Val.hiword v') ls)\n     (eloc q))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"rewrite ! Locmap.gso.\nauto.\neapply loc_unconstrained_sound; eauto.\neapply loc_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q)).","conclusion":"Val.lessdef (sel_val (ekind q) rs # (ereg q)) (ls (eloc q))","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"auto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : Loc.diff (R hi) (eloc q).","conclusion":"Loc.diff (R hi) (eloc q)","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : Loc.diff (R lo) (eloc q).","conclusion":"Loc.diff (R lo) (eloc q)","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"eapply loc_unconstrained_sound; eauto."},{"statement":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'') : ereg q <> x.","conclusion":"ereg q <> x","hypotheses":"(env : regenv) (x : reg) (hi lo : mreg) (e0 : eqs) (rs : regset) (ls : locset) (v v' : val) (e' : eqs) (e'' : eqs) (H2 : satisf rs ls e'') (H1 : forall x0 : mreg,\nhi = x0 \\/ lo = x0 \\/ False -> loc_unconstrained (R x0) e'' = true) (H0 : forall x0 : reg, x = x0 \\/ False -> reg_unconstrained x0 e'' = true) (H3 : Val.lessdef v v') (e : env x = Tlong) (n : hi <> lo) (q : EqSet.elt) (H : EqSet.In q e0) (n0 : q <> {| ekind := Low; ereg := x; eloc := R lo |}) (n1 : q <> {| ekind := High; ereg := x; eloc := R hi |}) (H4 : EqSet.In q e'')","proofString":"eapply reg_unconstrained_sound; eauto."},{"statement":"(env : regenv) (e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x : reg, False -> reg_unconstrained x e1 = true) (H1 : forall x : mreg, False -> loc_unconstrained (R x) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v') : satisf rs ls e1.","conclusion":"satisf rs ls e1","hypotheses":"(env : regenv) (e1 : eqs) (rs : regset) (ls : locset) (v v' : val) (H0 : forall x : reg, False -> reg_unconstrained x e1 = true) (H1 : forall x : mreg, False -> loc_unconstrained (R x) e1 = true) (H2 : satisf rs ls e1) (H3 : Val.lessdef v v')","proofString":"auto."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) : exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e.","conclusion":"exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e)","proofString":"exploit DS.fixpoint_allnodes_solution; eauto.\nrewrite H2.\nunfold DS.L.ge.\ndestruct (transfer f env bsh s an#s); intros.\nexists e0; auto.\ncontradiction."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) : DS.L.ge an # pc (transfer f env bsh s an # s) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e.","conclusion":"DS.L.ge an # pc (transfer f env bsh s an # s) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e)","proofString":"rewrite H2.\nunfold DS.L.ge.\ndestruct (transfer f env bsh s an#s); intros.\nexists e0; auto.\ncontradiction."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) : DS.L.ge (OK e) (transfer f env bsh s an # s) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e.","conclusion":"DS.L.ge (OK e) (transfer f env bsh s an # s) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e)","proofString":"unfold DS.L.ge.\ndestruct (transfer f env bsh s an#s); intros.\nexists e0; auto.\ncontradiction."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) : match transfer f env bsh s an # s with\n| OK b => EqSet.Subset b e\n| Error _ => False\nend ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e.","conclusion":"match transfer f env bsh s an # s with\n| OK b => EqSet.Subset b e\n| Error _ => False\nend ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e)","proofString":"destruct (transfer f env bsh s an#s); intros.\nexists e0; auto.\ncontradiction."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (e0 : eqs) (H3 : EqSet.Subset e0 e) : exists e' : eqs, OK e0 = OK e' /\\ EqSet.Subset e' e.","conclusion":"exists e' : eqs, OK e0 = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (e0 : eqs) (H3 : EqSet.Subset e0 e)","proofString":"exists e0; auto."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (e0 : errmsg) (H3 : False) : exists e' : eqs, Error e0 = OK e' /\\ EqSet.Subset e' e.","conclusion":"exists e' : eqs, Error e0 = OK e' /\\ EqSet.Subset e' e","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (H : DS.fixpoint_allnodes bsh successors_block_shape (transfer f env bsh) =\nSome an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (e0 : errmsg) (H3 : False)","proofString":"contradiction."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) : exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ satisf rs ls e'.","conclusion":"exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ satisf rs ls e'","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e)","proofString":"exploit analyze_successors; eauto.\nintros [e' [A B]].\nexists e'; split; auto.\neapply satisf_incr; eauto."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) : (exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ satisf rs ls e'.","conclusion":"(exists e' : eqs, transfer f env bsh s an # s = OK e' /\\ EqSet.Subset e' e) ->\nexists e' : eqs, transfer f env bsh s an # s = OK e' /\\ satisf rs ls e'","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e)","proofString":"intros [e' [A B]].\nexists e'; split; auto.\neapply satisf_incr; eauto."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) (e' : eqs) (A : transfer f env bsh s an # s = OK e') (B : EqSet.Subset e' e) : exists e'0 : eqs, transfer f env bsh s an # s = OK e'0 /\\ satisf rs ls e'0.","conclusion":"exists e'0 : eqs, transfer f env bsh s an # s = OK e'0 /\\ satisf rs ls e'0","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) (e' : eqs) (A : transfer f env bsh s an # s = OK e') (B : EqSet.Subset e' e)","proofString":"exists e'; split; auto.\neapply satisf_incr; eauto."},{"statement":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) (e' : eqs) (A : transfer f env bsh s an # s = OK e') (B : EqSet.Subset e' e) : satisf rs ls e'.","conclusion":"satisf rs ls e'","hypotheses":"(f : RTL.function) (env : regenv) (bsh : PTree.t block_shape) (an : PMap.t DS.L.t) (pc : positive) (bs : block_shape) (s : node) (e : eqs) (rs : regset) (ls : locset) (H : analyze f env bsh = Some an) (H0 : bsh ! pc = Some bs) (H1 : In s (successors_block_shape bs)) (H2 : an # pc = OK e) (H3 : satisf rs ls e) (e' : eqs) (A : transfer f env bsh s an # s = OK e') (B : EqSet.Subset e' e)","proofString":"eapply satisf_incr; eauto."},{"statement":"(f : RTL.function) (tf : function) (H : match type_function f with\n| OK env =>\n    match regalloc f with\n    | OK tf0 => bind (check_function f tf0 env) (fun _ : unit => OK tf0)\n    | Error m => Error m\n    end\n| Error m => Error m\nend = OK tf) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (H : match type_function f with\n| OK env =>\n    match regalloc f with\n    | OK tf0 => bind (check_function f tf0 env) (fun _ : unit => OK tf0)\n    | Error m => Error m\n    end\n| Error m => Error m\nend = OK tf)","proofString":"destruct (type_function f) as [env|] eqn:TY; try discriminate.\ndestruct (regalloc f); try discriminate.\ndestruct (check_function f f0 env) as [] eqn:?; inv H.\nunfold check_function in Heqr.\ndestruct (analyze f env (pair_codes f tf)) as [an|] eqn:?; try discriminate.\nmonadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (H : match regalloc f with\n| OK tf0 => bind (check_function f tf0 env) (fun _ : unit => OK tf0)\n| Error m => Error m\nend = OK tf) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (H : match regalloc f with\n| OK tf0 => bind (check_function f tf0 env) (fun _ : unit => OK tf0)\n| Error m => Error m\nend = OK tf)","proofString":"destruct (regalloc f); try discriminate.\ndestruct (check_function f f0 env) as [] eqn:?; inv H.\nunfold check_function in Heqr.\ndestruct (analyze f env (pair_codes f tf)) as [an|] eqn:?; try discriminate.\nmonadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (f0 : function) (H : bind (check_function f f0 env) (fun _ : unit => OK f0) = OK tf) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (f0 : function) (H : bind (check_function f f0 env) (fun _ : unit => OK f0) = OK tf)","proofString":"destruct (check_function f f0 env) as [] eqn:?; inv H.\nunfold check_function in Heqr.\ndestruct (analyze f env (pair_codes f tf)) as [an|] eqn:?; try discriminate.\nmonadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (Heqr : check_function f tf env = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (Heqr : check_function f tf env = OK u)","proofString":"unfold check_function in Heqr.\ndestruct (analyze f env (pair_codes f tf)) as [an|] eqn:?; try discriminate.\nmonadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (Heqr : match analyze f env (pair_codes f tf) with\n| Some a => check_entrypoints f tf env (pair_codes f tf) a\n| None => Error (msg \"allocation analysis diverges\")\nend = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (Heqr : match analyze f env (pair_codes f tf) with\n| Some a => check_entrypoints f tf env (pair_codes f tf) a\n| None => Error (msg \"allocation analysis diverges\")\nend = OK u)","proofString":"destruct (analyze f env (pair_codes f tf)) as [an|] eqn:?; try discriminate.\nmonadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (Heqr : check_entrypoints f tf env (pair_codes f tf) an = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (Heqr : check_entrypoints f tf env (pair_codes f tf) an = OK u)","proofString":"monadInv Heqr.\ndestruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (EQ0 : match check_entrypoints_aux f tf env x with\n| Some _ => OK tt\n| None => Error (msg \"invalid register allocation at entry point\")\nend = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (EQ0 : match check_entrypoints_aux f tf env x with\n| Some _ => OK tt\n| None => Error (msg \"invalid register allocation at entry point\")\nend = OK u)","proofString":"destruct (check_entrypoints_aux f tf env x) as [y|] eqn:?; try discriminate.\nunfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (y : unit) (Heqo0 : check_entrypoints_aux f tf env x = Some y) (EQ0 : OK tt = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (y : unit) (Heqo0 : check_entrypoints_aux f tf env x = Some y) (EQ0 : OK tt = OK u)","proofString":"unfold check_entrypoints_aux, pair_entrypoints in Heqo0.\nMonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (y : unit) (Heqo0 : match\n  match (fn_code tf) ! (fn_entrypoint tf) with\n  | Some b =>\n      let (mv, b1) := extract_moves_ext nil b in\n      if check_succ (RTL.fn_entrypoint f) b1 then Some mv else None\n  | None => None\n  end\nwith\n| Some mv =>\n    match track_moves env mv x with\n    | Some e2 =>\n        if compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e2\n        then\n         if can_undef destroyed_at_function_entry e2\n         then\n          if zeq (RTL.fn_stacksize f) (fn_stacksize tf)\n          then\n           if signature_eq (RTL.fn_sig f) (fn_sig tf) then Some tt else None\n          else None\n         else None\n        else None\n    | None => None\n    end\n| None => None\nend = Some y) (EQ0 : OK tt = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (y : unit) (Heqo0 : match\n  match (fn_code tf) ! (fn_entrypoint tf) with\n  | Some b =>\n      let (mv, b1) := extract_moves_ext nil b in\n      if check_succ (RTL.fn_entrypoint f) b1 then Some mv else None\n  | None => None\n  end\nwith\n| Some mv =>\n    match track_moves env mv x with\n    | Some e2 =>\n        if compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e2\n        then\n         if can_undef destroyed_at_function_entry e2\n         then\n          if zeq (RTL.fn_stacksize f) (fn_stacksize tf)\n          then\n           if signature_eq (RTL.fn_sig f) (fn_sig tf) then Some tt else None\n          else None\n         else None\n        else None\n    | None => None\n    end\n| None => None\nend = Some y) (EQ0 : OK tt = OK u)","proofString":"MonadInv.\nexploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u)","proofString":"exploit extract_moves_ext_sound; eauto.\nintros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) : wf_moves m /\\ b = expand_moves m b0 -> transf_function_spec f tf.","conclusion":"wf_moves m /\\ b = expand_moves m b0 -> transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u)","proofString":"intros [A B].\nsubst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) (B : b = expand_moves m b0) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b : bblock) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some b) (b0 : bblock) (Heqp : extract_moves_ext nil b = (m, b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) (B : b = expand_moves m b0)","proofString":"subst b.\nexploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m)","proofString":"exploit check_succ_sound; eauto.\nintros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) : (exists k : list instruction, b0 = Lbranch (RTL.fn_entrypoint f) :: k) ->\ntransf_function_spec f tf.","conclusion":"(exists k : list instruction, b0 = Lbranch (RTL.fn_entrypoint f) :: k) ->\ntransf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m)","proofString":"intros [k EQ1].\nsubst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) (k : list instruction) (EQ1 : b0 = Lbranch (RTL.fn_entrypoint f) :: k) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (b0 : bblock) (Heqp : extract_moves_ext nil (expand_moves m b0) = (m, b0)) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) = Some (expand_moves m b0)) (Heqb2 : check_succ (RTL.fn_entrypoint f) b0 = true) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) (k : list instruction) (EQ1 : b0 = Lbranch (RTL.fn_entrypoint f) :: k)","proofString":"subst b0.\neconstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) : transf_function_spec f tf.","conclusion":"transf_function_spec f tf","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m)","proofString":"econstructor; eauto.\neapply type_function_correct; eauto.\ncongruence."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) : wt_function f env.","conclusion":"wt_function f env","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m)","proofString":"eapply type_function_correct; eauto."},{"statement":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m) : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e = true.","conclusion":"compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e = true","hypotheses":"(f : RTL.function) (tf : function) (env : regenv) (TY : type_function f = OK env) (u : unit) (an : PMap.t DS.L.t) (Heqo : analyze f env (pair_codes f tf) = Some an) (x : eqs) (EQ : transfer f env (pair_codes f tf) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK x) (m : moves) (k : list instruction) (Heqb2 : check_succ (RTL.fn_entrypoint f) (Lbranch (RTL.fn_entrypoint f) :: k) = true) (Heqo3 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k))) (Heqp : extract_moves_ext nil (expand_moves m (Lbranch (RTL.fn_entrypoint f) :: k)) =\n(m, Lbranch (RTL.fn_entrypoint f) :: k)) (e : eqs) (Heqo2 : track_moves env m x = Some e) (Heqb0 : compat_entry (fn_params f) (loc_parameters (RTL.fn_sig f)) e = true) (Heqb1 : can_undef destroyed_at_function_entry e = true) (e0 : RTL.fn_stacksize f = fn_stacksize tf) (e1 : RTL.fn_sig f = fn_sig tf) (EQ0 : OK tt = OK u) (A : wf_moves m)","proofString":"congruence."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (opte : res eqs) (e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : transfer f env (pair_codes f tf) pc opte = OK e) : exists (eafter : eqs) (bsh : block_shape) (bb : bblock),\n  opte = OK eafter /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i.","conclusion":"exists (eafter : eqs) (bsh : block_shape) (bb : bblock),\n  opte = OK eafter /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (opte : res eqs) (e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : transfer f env (pair_codes f tf) pc opte = OK e)","proofString":"destruct opte as [eafter|]; simpl in H1; try discriminate.\nexists eafter.\ndestruct (pair_codes f tf)!pc as [bsh|] eqn:?; try discriminate.\nexists bsh.\nexploit matching_instr_block; eauto.\nintros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : match (pair_codes f tf) ! pc with\n| Some shape =>\n    match transfer_aux f env shape eafter with\n    | Some e' => OK e'\n    | None =>\n        Error\n          (MSG \"At PC \"\n           :: POS pc :: MSG \": invalid register allocation\" :: nil)\n    end\n| None => Error (MSG \"At PC \" :: POS pc :: MSG \": unmatched block\" :: nil)\nend = OK e) : exists (eafter0 : eqs) (bsh : block_shape) (bb : bblock),\n  OK eafter = OK eafter0 /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter0 = Some e /\\ wt_instr f env i.","conclusion":"exists (eafter0 : eqs) (bsh : block_shape) (bb : bblock),\n  OK eafter = OK eafter0 /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter0 = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : match (pair_codes f tf) ! pc with\n| Some shape =>\n    match transfer_aux f env shape eafter with\n    | Some e' => OK e'\n    | None =>\n        Error\n          (MSG \"At PC \"\n           :: POS pc :: MSG \": invalid register allocation\" :: nil)\n    end\n| None => Error (MSG \"At PC \" :: POS pc :: MSG \": unmatched block\" :: nil)\nend = OK e)","proofString":"exists eafter.\ndestruct (pair_codes f tf)!pc as [bsh|] eqn:?; try discriminate.\nexists bsh.\nexploit matching_instr_block; eauto.\nintros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : match (pair_codes f tf) ! pc with\n| Some shape =>\n    match transfer_aux f env shape eafter with\n    | Some e' => OK e'\n    | None =>\n        Error\n          (MSG \"At PC \"\n           :: POS pc :: MSG \": invalid register allocation\" :: nil)\n    end\n| None => Error (MSG \"At PC \" :: POS pc :: MSG \": unmatched block\" :: nil)\nend = OK e) : exists (bsh : block_shape) (bb : bblock),\n  OK eafter = OK eafter /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i.","conclusion":"exists (bsh : block_shape) (bb : bblock),\n  OK eafter = OK eafter /\\\n  (pair_codes f tf) ! pc = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (H1 : match (pair_codes f tf) ! pc with\n| Some shape =>\n    match transfer_aux f env shape eafter with\n    | Some e' => OK e'\n    | None =>\n        Error\n          (MSG \"At PC \"\n           :: POS pc :: MSG \": invalid register allocation\" :: nil)\n    end\n| None => Error (MSG \"At PC \" :: POS pc :: MSG \": unmatched block\" :: nil)\nend = OK e)","proofString":"destruct (pair_codes f tf)!pc as [bsh|] eqn:?; try discriminate.\nexists bsh.\nexploit matching_instr_block; eauto.\nintros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e) : exists (bsh0 : block_shape) (bb : bblock),\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh0 /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh0 i bb /\\\n  transfer_aux f env bsh0 eafter = Some e /\\ wt_instr f env i.","conclusion":"exists (bsh0 : block_shape) (bb : bblock),\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh0 /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh0 i bb /\\\n  transfer_aux f env bsh0 eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e)","proofString":"exists bsh.\nexploit matching_instr_block; eauto.\nintros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e) : exists bb : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i.","conclusion":"exists bb : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e)","proofString":"exploit matching_instr_block; eauto.\nintros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e) : (exists b : bblock, (fn_code tf) ! pc = Some b /\\ expand_block_shape bsh i b) ->\nexists bb : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i.","conclusion":"(exists b : bblock, (fn_code tf) ! pc = Some b /\\ expand_block_shape bsh i b) ->\nexists bb : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb /\\\n  expand_block_shape bsh i bb /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e)","proofString":"intros [bb [A B]].\ndestruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb) : exists bb0 : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb0 /\\\n  expand_block_shape bsh i bb0 /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i.","conclusion":"exists bb0 : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb0 /\\\n  expand_block_shape bsh i bb0 /\\\n  transfer_aux f env bsh eafter = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (H1 : match transfer_aux f env bsh eafter with\n| Some e' => OK e'\n| None =>\n    Error\n      (MSG \"At PC \" :: POS pc :: MSG \": invalid register allocation\" :: nil)\nend = OK e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb)","proofString":"destruct (transfer_aux f env bsh eafter) as [e1|] eqn:?; inv H1.\nexists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb) : exists bb0 : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb0 /\\\n  expand_block_shape bsh i bb0 /\\ Some e = Some e /\\ wt_instr f env i.","conclusion":"exists bb0 : bblock,\n  OK eafter = OK eafter /\\\n  Some bsh = Some bsh /\\\n  (fn_code tf) ! pc = Some bb0 /\\\n  expand_block_shape bsh i bb0 /\\ Some e = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb)","proofString":"exists bb.\nexploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb) : OK eafter = OK eafter /\\\nSome bsh = Some bsh /\\\n(fn_code tf) ! pc = Some bb /\\\nexpand_block_shape bsh i bb /\\ Some e = Some e /\\ wt_instr f env i.","conclusion":"OK eafter = OK eafter /\\\nSome bsh = Some bsh /\\\n(fn_code tf) ! pc = Some bb /\\\nexpand_block_shape bsh i bb /\\ Some e = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb)","proofString":"exploit wt_instr_at; eauto.\ntauto."},{"statement":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb) : wt_instr f env i ->\nOK eafter = OK eafter /\\\nSome bsh = Some bsh /\\\n(fn_code tf) ! pc = Some bb /\\\nexpand_block_shape bsh i bb /\\ Some e = Some e /\\ wt_instr f env i.","conclusion":"wt_instr f env i ->\nOK eafter = OK eafter /\\\nSome bsh = Some bsh /\\\n(fn_code tf) ! pc = Some bb /\\\nexpand_block_shape bsh i bb /\\ Some e = Some e /\\ wt_instr f env i","hypotheses":"(f : RTL.function) (env : regenv) (tf : function) (pc : positive) (i : RTL.instruction) (eafter e : eqs) (H : wt_function f env) (H0 : (RTL.fn_code f) ! pc = Some i) (bsh : block_shape) (Heqo : (pair_codes f tf) ! pc = Some bsh) (Heqo0 : transfer_aux f env bsh eafter = Some e) (bb : bblock) (A : (fn_code tf) ! pc = Some bb) (B : expand_block_shape bsh i bb)","proofString":"tauto."},{"statement":"(f : RTL.function) (x : function) (EQ : transf_function f = OK x) : funsig (Internal x) = RTL.funsig (Internal f).","conclusion":"funsig (Internal x) = RTL.funsig (Internal f)","hypotheses":"(f : RTL.function) (x : function) (EQ : transf_function f = OK x)","proofString":"destruct (transf_function_inv _ _ EQ).\nsimpl; auto."},{"statement":"(f : RTL.function) (x : function) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H : wt_function f env) (H0 : analyze f env (pair_codes f x) = Some an) (H1 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H2 : wf_moves mv) (H3 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H4 : track_moves env mv e1 = Some e2) (H5 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H6 : can_undef destroyed_at_function_entry e2 = true) (H7 : RTL.fn_stacksize f = fn_stacksize x) (H8 : RTL.fn_sig f = fn_sig x) : funsig (Internal x) = RTL.funsig (Internal f).","conclusion":"funsig (Internal x) = RTL.funsig (Internal f)","hypotheses":"(f : RTL.function) (x : function) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H : wt_function f env) (H0 : analyze f env (pair_codes f x) = Some an) (H1 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H2 : wf_moves mv) (H3 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H4 : track_moves env mv e1 = Some e2) (H5 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H6 : can_undef destroyed_at_function_entry e2 = true) (H7 : RTL.fn_stacksize f = fn_stacksize x) (H8 : RTL.fn_sig f = fn_sig x)","proofString":"simpl; auto."},{"statement":"(e : external_function) : funsig (External e) = RTL.funsig (External e).","conclusion":"funsig (External e) = RTL.funsig (External e)","hypotheses":"(e : external_function)","proofString":"auto."},{"statement":"(ros : reg + ident) (rs : regset) (fd : RTL.fundef) (ros' : mreg + ident) (e e' : eqs) (ls : locset) (H : match ros with\n| inl r => Genv.find_funct ge rs # r\n| inr symb =>\n    match Genv.find_symbol ge symb with\n    | Some b => Genv.find_funct_ptr ge b\n    | None => None\n    end\nend = Some fd) (H0 : add_equation_ros ros ros' e = Some e') (H1 : satisf rs ls e') : exists tfd : fundef,\n  match ros' with\n  | inl r => Genv.find_funct tge (ls (R r))\n  | inr symb =>\n      match Genv.find_symbol tge symb with\n      | Some b => Genv.find_funct_ptr tge b\n      | None => None\n      end\n  end = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  match ros' with\n  | inl r => Genv.find_funct tge (ls (R r))\n  | inr symb =>\n      match Genv.find_symbol tge symb with\n      | Some b => Genv.find_funct_ptr tge b\n      | None => None\n      end\n  end = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(ros : reg + ident) (rs : regset) (fd : RTL.fundef) (ros' : mreg + ident) (e e' : eqs) (ls : locset) (H : match ros with\n| inl r => Genv.find_funct ge rs # r\n| inr symb =>\n    match Genv.find_symbol ge symb with\n    | Some b => Genv.find_funct_ptr ge b\n    | None => None\n    end\nend = Some fd) (H0 : add_equation_ros ros ros' e = Some e') (H1 : satisf rs ls e')","proofString":"destruct ros as [r|id]; destruct ros' as [r'|id']; simpl in H0; MonadInv.\nexploit add_equation_lessdef; eauto.\nintros LD.\ninv LD.\neapply functions_translated; eauto.\nrewrite <- H2 in H.\nsimpl in H.\ncongruence.\nrewrite symbols_preserved.\nrewrite Heqo.\neapply function_ptr_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) : exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e))","proofString":"exploit add_equation_lessdef; eauto.\nintros LD.\ninv LD.\neapply functions_translated; eauto.\nrewrite <- H2 in H.\nsimpl in H.\ncongruence."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := r; eloc := R r' |})\n     rs # (ereg {| ekind := Full; ereg := r; eloc := R r' |}))\n  (ls (eloc {| ekind := Full; ereg := r; eloc := R r' |})) ->\nexists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := r; eloc := R r' |})\n     rs # (ereg {| ekind := Full; ereg := r; eloc := R r' |}))\n  (ls (eloc {| ekind := Full; ereg := r; eloc := R r' |})) ->\nexists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e))","proofString":"intros LD.\ninv LD.\neapply functions_translated; eauto.\nrewrite <- H2 in H.\nsimpl in H.\ncongruence."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (LD : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := r; eloc := R r' |})\n     rs # (ereg {| ekind := Full; ereg := r; eloc := R r' |}))\n  (ls (eloc {| ekind := Full; ereg := r; eloc := R r' |}))) : exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (LD : Val.lessdef\n  (sel_val (ekind {| ekind := Full; ereg := r; eloc := R r' |})\n     rs # (ereg {| ekind := Full; ereg := r; eloc := R r' |}))\n  (ls (eloc {| ekind := Full; ereg := r; eloc := R r' |})))","proofString":"inv LD.\neapply functions_translated; eauto.\nrewrite <- H2 in H.\nsimpl in H.\ncongruence."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H3 : rs # r = ls (R r')) : exists tfd : fundef,\n  Genv.find_funct tge rs # r = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge rs # r = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H3 : rs # r = ls (R r'))","proofString":"eapply functions_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r) : exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge rs # r = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r)","proofString":"rewrite <- H2 in H.\nsimpl in H.\ncongruence."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge Vundef = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r) : exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : Genv.find_funct ge Vundef = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r)","proofString":"simpl in H.\ncongruence."},{"statement":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : None = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r) : exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct tge (ls (R r')) = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(r : reg) (rs : regset) (fd : RTL.fundef) (r' : mreg) (e : eqs) (ls : locset) (H : None = Some fd) (H1 : satisf rs ls (add_equation {| ekind := Full; ereg := r; eloc := R r' |} e)) (H2 : Vundef = rs # r)","proofString":"congruence."},{"statement":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e') : exists tfd : fundef,\n  match Genv.find_symbol tge id' with\n  | Some b0 => Genv.find_funct_ptr tge b0\n  | None => None\n  end = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  match Genv.find_symbol tge id' with\n  | Some b0 => Genv.find_funct_ptr tge b0\n  | None => None\n  end = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e')","proofString":"rewrite symbols_preserved.\nrewrite Heqo.\neapply function_ptr_translated; eauto."},{"statement":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e') : exists tfd : fundef,\n  match Genv.find_symbol ge id' with\n  | Some b0 => Genv.find_funct_ptr tge b0\n  | None => None\n  end = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  match Genv.find_symbol ge id' with\n  | Some b0 => Genv.find_funct_ptr tge b0\n  | None => None\n  end = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e')","proofString":"rewrite Heqo.\neapply function_ptr_translated; eauto."},{"statement":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e') : exists tfd : fundef,\n  Genv.find_funct_ptr tge b = Some tfd /\\ transf_fundef fd = OK tfd.","conclusion":"exists tfd : fundef,\n  Genv.find_funct_ptr tge b = Some tfd /\\ transf_fundef fd = OK tfd","hypotheses":"(rs : regset) (fd : RTL.fundef) (id' : ident) (e' : eqs) (ls : locset) (b : block) (Heqo : Genv.find_symbol ge id' = Some b) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : satisf rs ls e')","proofString":"eapply function_ptr_translated; eauto."},{"statement":"(s : list RTL.stackframe) (ts : list stackframe) (sg sg' : signature) (H : match_stackframes s ts sg) (H0 : sig_res sg' = sig_res sg) : match_stackframes s ts sg'.","conclusion":"match_stackframes s ts sg'","hypotheses":"(s : list RTL.stackframe) (ts : list stackframe) (sg sg' : signature) (H : match_stackframes s ts sg) (H0 : sig_res sg' = sig_res sg)","proofString":"inv H.\nconstructor.\ncongruence.\neconstructor; eauto.\nunfold proj_sig_res in *.\nrewrite H0; auto.\nintros.\nrewrite (loc_result_exten sg' sg) in H by auto.\neauto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (H1 : sig_res sg = Xint) : match_stackframes nil nil sg'.","conclusion":"match_stackframes nil nil sg'","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (H1 : sig_res sg = Xint)","proofString":"constructor.\ncongruence."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (H1 : sig_res sg = Xint) : sig_res sg' = Xint.","conclusion":"sig_res sg' = Xint","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (H1 : sig_res sg = Xint)","proofString":"congruence."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e) : match_stackframes (RTL.Stackframe res f sp pc rs :: s0)\n  (Stackframe tf sp ls bb :: ts0) sg'.","conclusion":"match_stackframes (RTL.Stackframe res f sp pc rs :: s0)\n  (Stackframe tf sp ls bb :: ts0) sg'","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e)","proofString":"econstructor; eauto.\nunfold proj_sig_res in *.\nrewrite H0; auto.\nintros.\nrewrite (loc_result_exten sg' sg) in H by auto.\neauto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e) : env res = proj_sig_res sg'.","conclusion":"env res = proj_sig_res sg'","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e)","proofString":"unfold proj_sig_res in *.\nrewrite H0; auto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_xtype (sig_res sg)) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e) : env res = proj_xtype (sig_res sg').","conclusion":"env res = proj_xtype (sig_res sg')","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_xtype (sig_res sg)) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e)","proofString":"rewrite H0; auto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e) : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg')) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e.","conclusion":"forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg')) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e)","proofString":"intros.\nrewrite (loc_result_exten sg' sg) in H by auto.\neauto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v0 : val) (ls0 : Locmap.t) (m0 : mem),\nVal.lessdef v0 (Locmap.getpair (map_rpair R (loc_result sg)) ls0) ->\nVal.has_type v0 (env res) ->\nagree_callee_save ls ls0 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls0 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v0 ls2 e) (v : val) (ls1 : Locmap.t) (m : mem) (H : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg')) ls1)) (H1 : Val.has_type v (env res)) (H2 : agree_callee_save ls ls1) : exists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e.","conclusion":"exists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v0 : val) (ls0 : Locmap.t) (m0 : mem),\nVal.lessdef v0 (Locmap.getpair (map_rpair R (loc_result sg)) ls0) ->\nVal.has_type v0 (env res) ->\nagree_callee_save ls ls0 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls0 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v0 ls2 e) (v : val) (ls1 : Locmap.t) (m : mem) (H : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg')) ls1)) (H1 : Val.has_type v (env res)) (H2 : agree_callee_save ls ls1)","proofString":"rewrite (loc_result_exten sg' sg) in H by auto.\neauto."},{"statement":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v0 : val) (ls0 : Locmap.t) (m0 : mem),\nVal.lessdef v0 (Locmap.getpair (map_rpair R (loc_result sg)) ls0) ->\nVal.has_type v0 (env res) ->\nagree_callee_save ls ls0 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls0 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v0 ls2 e) (v : val) (ls1 : Locmap.t) (m : mem) (H : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1)) (H1 : Val.has_type v (env res)) (H2 : agree_callee_save ls ls1) : exists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e.","conclusion":"exists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m) E0 (State ts0 tf sp pc ls2 m) /\\\n  satisf rs # res <- v ls2 e","hypotheses":"(sg sg' : signature) (H0 : sig_res sg' = sig_res sg) (res : reg) (f : RTL.function) (sp : val) (pc : node) (rs : regset) (s0 : list RTL.stackframe) (tf : function) (bb : bblock) (ls : Locmap.t) (ts0 : list stackframe) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s0 ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES : env res = proj_sig_res sg) (STEPS : forall (v0 : val) (ls0 : Locmap.t) (m0 : mem),\nVal.lessdef v0 (Locmap.getpair (map_rpair R (loc_result sg)) ls0) ->\nVal.has_type v0 (env res) ->\nagree_callee_save ls ls0 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls0 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v0 ls2 e) (v : val) (ls1 : Locmap.t) (m : mem) (H : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1)) (H1 : Val.has_type v (env res)) (H2 : agree_callee_save ls ls1)","proofString":"eauto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H : wt_instr f env (Iload Mint64 addr args dst s)) (H0 : Archi.splitlong = true) (H1 : In r args) : r <> dst.","conclusion":"r <> dst","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H : wt_instr f env (Iload Mint64 addr args dst s)) (H0 : Archi.splitlong = true) (H1 : In r args)","proofString":"inv H.\nassert (A: forall ty, In ty (type_of_addressing addr) -> ty = Tptr).\nintros.\ntry (apply diff_false_true in H0).\ndestruct addr; simpl in H; intuition auto.\nassert (B: In (env r) (type_of_addressing addr)).\nrewrite <- H5.\napply in_map; auto.\nassert (C: env r = Tint).\napply A in B.\nrewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto.\nred; intros; subst r.\nrewrite C in H8; discriminate."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) : r <> dst.","conclusion":"r <> dst","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s)","proofString":"assert (A: forall ty, In ty (type_of_addressing addr) -> ty = Tptr).\nintros.\ntry (apply diff_false_true in H0).\ndestruct addr; simpl in H; intuition auto.\nassert (B: In (env r) (type_of_addressing addr)).\nrewrite <- H5.\napply in_map; auto.\nassert (C: env r = Tint).\napply A in B.\nrewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto.\nred; intros; subst r.\nrewrite C in H8; discriminate."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr.","conclusion":"forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s)","proofString":"intros.\ntry (apply diff_false_true in H0).\ndestruct addr; simpl in H; intuition auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (ty : typ) (H : In ty (type_of_addressing addr)) : ty = Tptr.","conclusion":"ty = Tptr","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (ty : typ) (H : In ty (type_of_addressing addr))","proofString":"try (apply diff_false_true in H0).\ndestruct addr; simpl in H; intuition auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : False) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (ty : typ) (H : In ty (type_of_addressing addr)) : ty = Tptr.","conclusion":"ty = Tptr","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : False) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (ty : typ) (H : In ty (type_of_addressing addr))","proofString":"destruct addr; simpl in H; intuition auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) : r <> dst.","conclusion":"r <> dst","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr)","proofString":"assert (B: In (env r) (type_of_addressing addr)).\nrewrite <- H5.\napply in_map; auto.\nassert (C: env r = Tint).\napply A in B.\nrewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto.\nred; intros; subst r.\nrewrite C in H8; discriminate."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) : In (env r) (type_of_addressing addr).","conclusion":"In (env r) (type_of_addressing addr)","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr)","proofString":"rewrite <- H5.\napply in_map; auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) : In (env r) (map env args).","conclusion":"In (env r) (map env args)","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr)","proofString":"apply in_map; auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr)) : r <> dst.","conclusion":"r <> dst","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr))","proofString":"assert (C: env r = Tint).\napply A in B.\nrewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto.\nred; intros; subst r.\nrewrite C in H8; discriminate."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr)) : env r = Tint.","conclusion":"env r = Tint","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr))","proofString":"apply A in B.\nrewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr) : env r = Tint.","conclusion":"env r = Tint","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr)","proofString":"rewrite B.\nunfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr) : Tptr = Tint.","conclusion":"Tptr = Tint","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr)","proofString":"unfold Tptr.\nrewrite Archi.splitlong_ptr32 by auto.\nauto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr) : (if Archi.ptr64 then Tlong else Tint) = Tint.","conclusion":"(if Archi.ptr64 then Tlong else Tint) = Tint","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr)","proofString":"rewrite Archi.splitlong_ptr32 by auto.\nauto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr) : Tint = Tint.","conclusion":"Tint = Tint","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : env r = Tptr)","proofString":"auto."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr)) (C : env r = Tint) : r <> dst.","conclusion":"r <> dst","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (r : reg) (H0 : Archi.splitlong = true) (H1 : In r args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (B : In (env r) (type_of_addressing addr)) (C : env r = Tint)","proofString":"red; intros; subst r.\nrewrite C in H8; discriminate."},{"statement":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (H0 : Archi.splitlong = true) (H1 : In dst args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (C : env dst = Tint) (B : In (env dst) (type_of_addressing addr)) : False.","conclusion":"False","hypotheses":"(env : regenv) (f : RTL.function) (addr : addressing) (args : list reg) (dst : reg) (s : RTL.node) (H0 : Archi.splitlong = true) (H1 : In dst args) (H5 : map env args = type_of_addressing addr) (H8 : env dst = type_of_chunk Mint64) (H9 : valid_successor f s) (A : forall ty : typ, In ty (type_of_addressing addr) -> ty = Tptr) (C : env dst = Tint) (B : In (env dst) (type_of_addressing addr))","proofString":"rewrite C in H8; discriminate."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Inop pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSnop mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Inop pc')) (H2 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Inop pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSnop mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Inop pc')) (H2 : wf_moves mv)","proofString":"exploit exec_moves; eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Inop pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSnop mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Inop pc')) (H2 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs ls1 enext) : match_states (RTL.State s f sp pc' rs m) (State ts tf sp pc' ls1 m').","conclusion":"match_states (RTL.State s f sp pc' rs m) (State ts tf sp pc' ls1 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Inop pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSnop mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Inop pc')) (H2 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs ls1 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv)","proofString":"generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS).\nintros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) : wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv)","proofString":"intros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : eval_operation ge sp Omove rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- v)","proofString":"simpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : Some rs # src = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (H0 : Some rs # src = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- v)","proofString":"inv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- (rs # src)) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (rs # src) m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (rs # src) m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- (rs # src))","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- (rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg res src eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (rs # src) ls1 enext) : match_states (RTL.State s f sp pc' rs # res <- (rs # src) m)\n  (State ts tf sp pc' ls1 m').","conclusion":"match_states (RTL.State s f sp pc' rs # res <- (rs # src) m)\n  (State ts tf sp pc' ls1 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omove (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmove src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (TR : track_moves env mv (subst_reg res src eafter) = Some e) (WTI : wt_instr f env (Iop Omove (src :: nil) res pc')) (H7 : wf_moves mv) (WTRS' : wt_regset env rs # res <- (rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg res src eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (rs # src) ls1 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS).\nintros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_makelong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"intros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_makelong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : eval_operation ge sp Omakelong rs ## (src1 :: src2 :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"simpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_makelong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : Some (Val.longofwords rs # src1 rs # src2) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H0 : Some (Val.longofwords rs # src1 rs # src2) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"inv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_makelong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.longofwords rs # src1 rs # src2)) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states\n    (RTL.State s f sp pc' rs # res <- (Val.longofwords rs # src1 rs # src2) m)\n    S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states\n    (RTL.State s f sp pc' rs # res <- (Val.longofwords rs # src1 rs # src2) m)\n    S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.longofwords rs # src1 rs # src2))","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_makelong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.longofwords rs # src1 rs # src2)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter))) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.longofwords rs # src1 rs # src2) ls1 enext) : match_states\n  (RTL.State s f sp pc' rs # res <- (Val.longofwords rs # src1 rs # src2) m)\n  (State ts tf sp pc' ls1 m').","conclusion":"match_states\n  (RTL.State s f sp pc' rs # res <- (Val.longofwords rs # src1 rs # src2) m)\n  (State ts tf sp pc' ls1 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src1 src2 : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Omakelong (src1 :: src2 :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSmakelong src1 src2 res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = true) (TR : track_moves env mv\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter)) = \nSome e) (WTI : wt_instr f env (Iop Omakelong (src1 :: src2 :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.longofwords rs # src1 rs # src2)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1\n  (subst_reg_kind res Low src2 Full\n     (subst_reg_kind res High src1 Full eafter))) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.longofwords rs # src1 rs # src2) ls1 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS).\nintros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_lowlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"intros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_lowlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : eval_operation ge sp Olowlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"simpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_lowlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : Some (Val.loword rs # src) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (H0 : Some (Val.loword rs # src) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"inv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_lowlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.loword rs # src)) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (Val.loword rs # src) m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (Val.loword rs # src) m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.loword rs # src))","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_lowlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.loword rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg_kind res Full src Low eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.loword rs # src) ls1 enext) : match_states (RTL.State s f sp pc' rs # res <- (Val.loword rs # src) m)\n  (State ts tf sp pc' ls1 m').","conclusion":"match_states (RTL.State s f sp pc' rs # res <- (Val.loword rs # src) m)\n  (State ts tf sp pc' ls1 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Olowlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSlowlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src Low eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src Low eafter) = Some e) (WTI : wt_instr f env (Iop Olowlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.loword rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg_kind res Full src Low eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.loword rs # src) ls1 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS).\nintros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_highlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) : wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true)","proofString":"intros WTRS'.\nsimpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_highlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : eval_operation ge sp Ohighlong rs ## (src :: nil) m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"simpl in H0.\ninv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_highlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : Some (Val.hiword rs # src) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (v : val) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (H0 : Some (Val.hiword rs # src) = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- v)","proofString":"inv H0.\nexploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_highlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.hiword rs # src)) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (Val.hiword rs # src) m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- (Val.hiword rs # src) m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.hiword rs # src))","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply subst_reg_kind_satisf_highlong.\neauto.\neauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.hiword rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg_kind res Full src High eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.hiword rs # src) ls1 enext) : match_states (RTL.State s f sp pc' rs # res <- (Val.hiword rs # src) m)\n  (State ts tf sp pc' ls1 m').","conclusion":"match_states (RTL.State s f sp pc' rs # res <- (Val.hiword rs # src) m)\n  (State ts tf sp pc' ls1 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (res : reg) (pc' : RTL.node) (src : reg) (H : (RTL.fn_code f) ! pc = Some (Iop Ohighlong (src :: nil) res pc')) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BShighlong src res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res (subst_reg_kind res Full src High eafter) = true) (TR : track_moves env mv (subst_reg_kind res Full src High eafter) = Some e) (WTI : wt_instr f env (Iop Ohighlong (src :: nil) res pc')) (H7 : wf_moves mv) (H8 : Archi.splitlong = true) (WTRS' : wt_regset env rs # res <- (Val.hiword rs # src)) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 (subst_reg_kind res Full src High eafter)) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- (Val.hiword rs # src) ls1 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2)","proofString":"generalize (wt_exec_Iop _ _ _ _ _ _ _ _ _ _ _ WTI H0 WTRS).\nintros WTRS'.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_operation_lessdef; eauto.\nintros [v' [F G]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := v').\nrewrite <- F.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) : wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"wt_regset env rs # res <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2)","proofString":"intros WTRS'.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_operation_lessdef; eauto.\nintros [v' [F G]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := v').\nrewrite <- F.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) (WTRS' : wt_regset env rs # res <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) (WTRS' : wt_regset env rs # res <- v)","proofString":"exploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_operation_lessdef; eauto.\nintros [v' [F G]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := v').\nrewrite <- F.\napply eval_operation_preserved.\nexact symbols_preserved.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) (WTRS' : wt_regset env rs # res <- v) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k))) ls m') E0\n  (Block ts tf sp (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (X : Val.lessdef_list rs ## args (reglist ls1 args')) (Y : forall v0 v'0 : val,\nVal.lessdef v0 v'0 ->\nsatisf rs # res <- v0\n  (Locmap.set (R res') v'0 (undef_regs (destroyed_by_op op) ls1)) e0) (v' : val) (F : eval_operation ge sp op (reglist ls1 args') m' = Some v') (G : Val.lessdef v v') (ls2 : locset) (A2 : star step tge\n  (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k))\n     (Locmap.set (R res') v' (undef_regs (destroyed_by_op op) ls1)) m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls2 m')) (B2 : satisf rs # res <- v ls2 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- v ls2 enext) : match_states (RTL.State s f sp pc' rs # res <- v m)\n  (State ts tf sp pc' ls2 m').","conclusion":"match_states (RTL.State s f sp pc' rs # res <- v m)\n  (State ts tf sp pc' ls2 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (res' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSop op args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args res args' res' (destroyed_by_op op) e0 = Some e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv1) (H8 : wf_moves mv2) (WTRS' : wt_regset env rs # res <- v) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k))) ls m') E0\n  (Block ts tf sp (Lop op args' res' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (X : Val.lessdef_list rs ## args (reglist ls1 args')) (Y : forall v0 v'0 : val,\nVal.lessdef v0 v'0 ->\nsatisf rs # res <- v0\n  (Locmap.set (R res') v'0 (undef_regs (destroyed_by_op op) ls1)) e0) (v' : val) (F : eval_operation ge sp op (reglist ls1 args') m' = Some v') (G : Val.lessdef v v') (ls2 : locset) (A2 : star step tge\n  (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k))\n     (Locmap.set (R res') v' (undef_regs (destroyed_by_op op) ls1)) m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls2 m')) (B2 : satisf rs # res <- v ls2 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- v ls2 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSopdead op args res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSopdead op args res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv)","proofString":"exploit exec_moves; eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors.\neauto.\neauto.\nsimpl; eauto.\neauto.\neapply reg_unconstrained_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto.\neapply wt_exec_Iop; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSopdead op args res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- v ls1 enext) : wt_regset env rs # res <- v.","conclusion":"wt_regset env rs # res <- v","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : RTL.node) (v : val) (H : (RTL.fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSopdead op args res mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained res eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iop op args res pc')) (H7 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # res <- v ls1 enext)","proofString":"eapply wt_exec_Iop; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2)","proofString":"generalize (wt_exec_Iload _ _ _ _ _ _ _ _ _ _ _ WTI H1 WTRS).\nintros WTRS'.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_addressing_lessdef; eauto.\nintros [a' [F G]].\nexploit Mem.loadv_extends; eauto.\nintros [v' [P Q]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a').\nrewrite <- F.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) : wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2)","proofString":"intros WTRS'.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_addressing_lessdef; eauto.\nintros [a' [F G]].\nexploit Mem.loadv_extends; eauto.\nintros [v' [P Q]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a').\nrewrite <- F.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (WTRS' : wt_regset env rs # dst <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (WTRS' : wt_regset env rs # dst <- v)","proofString":"exploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit transfer_use_def_satisf; eauto.\nintros [X Y].\nexploit eval_addressing_lessdef; eauto.\nintros [a' [F G]].\nexploit Mem.loadv_extends; eauto.\nintros [v' [P Q]].\nexploit (exec_moves mv2); eauto.\nintros [ls2 [A2 B2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a').\nrewrite <- F.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\neapply star_right.\neexact A2.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (WTRS' : wt_regset env rs # dst <- v) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e1) (X : Val.lessdef_list rs ## args (reglist ls1 args')) (Y : forall v0 v'0 : val,\nVal.lessdef v0 v'0 ->\nsatisf rs # dst <- v0\n  (Locmap.set (R dst') v'0 (undef_regs (destroyed_by_load chunk addr) ls1))\n  e0) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (v' : val) (P : Mem.loadv chunk m' a' = Some v') (Q : Val.lessdef v v') (ls2 : locset) (A2 : star step tge\n  (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k))\n     (Locmap.set (R dst') v' (undef_regs (destroyed_by_load chunk addr) ls1))\n     m') E0 (Block ts tf sp (Lbranch pc' :: k) ls2 m')) (B2 : satisf rs # dst <- v ls2 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # dst <- v ls2 enext) : match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls2 m').","conclusion":"match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls2 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload chunk addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : transfer_use_def args dst args' dst' (destroyed_by_load chunk addr) e0 =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (WTRS' : wt_regset env rs # dst <- v) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload chunk addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e1) (X : Val.lessdef_list rs ## args (reglist ls1 args')) (Y : forall v0 v'0 : val,\nVal.lessdef v0 v'0 ->\nsatisf rs # dst <- v0\n  (Locmap.set (R dst') v'0 (undef_regs (destroyed_by_load chunk addr) ls1))\n  e0) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (v' : val) (P : Mem.loadv chunk m' a' = Some v') (Q : Val.lessdef v v') (ls2 : locset) (A2 : star step tge\n  (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k))\n     (Locmap.set (R dst') v' (undef_regs (destroyed_by_load chunk addr) ls1))\n     m') E0 (Block ts tf sp (Lbranch pc' :: k) ls2 m')) (B2 : satisf rs # dst <- v ls2 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # dst <- v ls2 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2)","proofString":"generalize (wt_exec_Iload _ _ _ _ _ _ _ _ _ _ _ WTI H1 WTRS).\nintros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args1')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst1') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e2).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply reg_unconstrained_satisf.\neauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v1'; unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\nassert (LD3: Val.lessdef_list rs##args (reglist ls3 args2')).\nreplace (rs##args) with ((rs#dst<-v)##args).\neapply add_equations_lessdef; eauto.\napply list_map_exten; intros.\nrewrite Regmap.gso; auto.\neapply addressing_not_long; eauto.\nexploit eval_addressing_lessdef.\neexact LD3.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a2' [F2 G2]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a2' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G2]).\ndestruct LOADX as (v2'' & LOAD2' & LD4).\nset (ls4 := Locmap.set (R dst2') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls3)).\nassert (SAT4: satisf (rs#dst <- v) ls4 e0).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv3); eauto.\nintros [ls5 [A5 B5]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_trans.\neexact A3.\neapply star_left.\neconstructor.\ninstantiate (1 := a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls4); auto.\neapply star_right.\neexact A5.\nconstructor.\neauto.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) : wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2)","proofString":"intros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args1')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst1') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e2).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply reg_unconstrained_satisf.\neauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v1'; unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\nassert (LD3: Val.lessdef_list rs##args (reglist ls3 args2')).\nreplace (rs##args) with ((rs#dst<-v)##args).\neapply add_equations_lessdef; eauto.\napply list_map_exten; intros.\nrewrite Regmap.gso; auto.\neapply addressing_not_long; eauto.\nexploit eval_addressing_lessdef.\neexact LD3.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a2' [F2 G2]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a2' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G2]).\ndestruct LOADX as (v2'' & LOAD2' & LD4).\nset (ls4 := Locmap.set (R dst2') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls3)).\nassert (SAT4: satisf (rs#dst <- v) ls4 e0).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv3); eauto.\nintros [ls5 [A5 B5]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_trans.\neexact A3.\neapply star_left.\neconstructor.\ninstantiate (1 := a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls4); auto.\neapply star_right.\neexact A5.\nconstructor.\neauto.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v)","proofString":"exploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args1')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst1') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e2).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply reg_unconstrained_satisf.\neauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v1'; unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\nassert (LD3: Val.lessdef_list rs##args (reglist ls3 args2')).\nreplace (rs##args) with ((rs#dst<-v)##args).\neapply add_equations_lessdef; eauto.\napply list_map_exten; intros.\nrewrite Regmap.gso; auto.\neapply addressing_not_long; eauto.\nexploit eval_addressing_lessdef.\neexact LD3.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a2' [F2 G2]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a2' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G2]).\ndestruct LOADX as (v2'' & LOAD2' & LD4).\nset (ls4 := Locmap.set (R dst2') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls3)).\nassert (SAT4: satisf (rs#dst <- v) ls4 e0).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv3); eauto.\nintros [ls5 [A5 B5]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_trans.\neexact A3.\neapply star_left.\neconstructor.\ninstantiate (1 := a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls4); auto.\neapply star_right.\neexact A5.\nconstructor.\neauto.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) : (exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"(exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v)","proofString":"intros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args1')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst1') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e2).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply reg_unconstrained_satisf.\neauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v1'; unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\nassert (LD3: Val.lessdef_list rs##args (reglist ls3 args2')).\nreplace (rs##args) with ((rs#dst<-v)##args).\neapply add_equations_lessdef; eauto.\napply list_map_exten; intros.\nrewrite Regmap.gso; auto.\neapply addressing_not_long; eauto.\nexploit eval_addressing_lessdef.\neexact LD3.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a2' [F2 G2]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a2' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G2]).\ndestruct LOADX as (v2'' & LOAD2' & LD4).\nset (ls4 := Locmap.set (R dst2') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls3)).\nassert (SAT4: satisf (rs#dst <- v) ls4 e0).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv3); eauto.\nintros [ls5 [A5 B5]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_trans.\neexact A3.\neapply star_left.\neconstructor.\ninstantiate (1 := a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls4); auto.\neapply star_right.\neexact A5.\nconstructor.\neauto.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2)","proofString":"set (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args1')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst1') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e2).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply reg_unconstrained_satisf.\neauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v1'; unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\nassert (LD3: Val.lessdef_list rs##args (reglist ls3 args2')).\nreplace (rs##args) with ((rs#dst<-v)##args).\neapply add_equations_lessdef; eauto.\napply list_map_exten; intros.\nrewrite Regmap.gso; auto.\neapply addressing_not_long; eauto.\nexploit eval_addressing_lessdef.\neexact LD3.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a2' [F2 G2]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a2' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G2]).\ndestruct LOADX as (v2'' & LOAD2' & LD4).\nset (ls4 := Locmap.set (R dst2') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls3)).\nassert (SAT4: satisf (rs#dst <- v) ls4 e0).\neapply loc_unconstrained_satisf.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nassumption.\nrewrite Regmap.gss.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\nexploit (exec_moves mv3); eauto.\nintros [ls5 [A5 B5]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_trans.\neexact A3.\neapply star_left.\neconstructor.\ninstantiate (1 := a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls4); auto.\neapply star_right.\neexact A5.\nconstructor.\neauto.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr args1' dst1'\n         :: expand_moves mv2\n              (Lload Mint32 addr2 args2' dst2'\n               :: expand_moves mv3 (Lbranch pc' :: k)))) ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))) ls1 m')) (B1 : satisf rs ls1 e3) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args1')) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args1') = Some a1') (G1 : Val.lessdef a a1') (v1'' : val) (LOAD1' : Mem.loadv Mint32 m' a1' = Some v1'') (LD2 : Val.lessdef v1' v1'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e2) (ls3 : locset) (A3 : star step tge\n  (Block ts tf sp\n     (expand_moves mv2\n        (Lload Mint32 addr2 args2' dst2'\n         :: expand_moves mv3 (Lbranch pc' :: k))) ls2 m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr2 args2' dst2' :: expand_moves mv3 (Lbranch pc' :: k))\n     ls3 m')) (B3 : satisf rs # dst <- v ls3 e1) (LD3 : Val.lessdef_list rs ## args (reglist ls3 args2')) (a2' : val) (F2 : eval_addressing ge sp addr2 (reglist ls3 args2') = Some a2') (G2 : Val.lessdef (Val.add a (Vint (Int.repr 4))) a2') (v2'' : val) (LOAD2' : Mem.loadv Mint32 m' a2' = Some v2'') (LD4 : Val.lessdef v2' v2'') (ls4 : Locmap.t) (SAT4 : satisf rs # dst <- v ls4 e0) (ls5 : locset) (A5 : star step tge (Block ts tf sp (expand_moves mv3 (Lbranch pc' :: k)) ls4 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls5 m')) (B5 : satisf rs # dst <- v ls5 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls5 enext) : match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls5 m').","conclusion":"match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls5 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (dst1' : mreg) (mv2 : moves) (args2' : list mreg) (dst2' : mreg) (mv3 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2 addr addr2 args dst mv1 args1' dst1' mv2 args2' dst2' mv3 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))))) (e0 : eqs) (Heqo : track_moves env mv3 eafter = Some e0) (Heqb : loc_unconstrained (R dst2')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args2'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst2' |} e0) =\nSome e1) (e2 : eqs) (Heqo1 : track_moves env mv2 e1 = Some e2) (Heqb1 : loc_unconstrained (R dst1')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb2 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (Heqb3 : reg_unconstrained dst\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) = true) (e3 : eqs) (Heqo2 : add_equations args args1'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst1' |} e2) =\nSome e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H8 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : wf_moves mv3) (H12 : Archi.splitlong = true) (H13 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr args1' dst1'\n         :: expand_moves mv2\n              (Lload Mint32 addr2 args2' dst2'\n               :: expand_moves mv3 (Lbranch pc' :: k)))) ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr args1' dst1'\n      :: expand_moves mv2\n           (Lload Mint32 addr2 args2' dst2'\n            :: expand_moves mv3 (Lbranch pc' :: k))) ls1 m')) (B1 : satisf rs ls1 e3) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args1')) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args1') = Some a1') (G1 : Val.lessdef a a1') (v1'' : val) (LOAD1' : Mem.loadv Mint32 m' a1' = Some v1'') (LD2 : Val.lessdef v1' v1'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e2) (ls3 : locset) (A3 : star step tge\n  (Block ts tf sp\n     (expand_moves mv2\n        (Lload Mint32 addr2 args2' dst2'\n         :: expand_moves mv3 (Lbranch pc' :: k))) ls2 m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr2 args2' dst2' :: expand_moves mv3 (Lbranch pc' :: k))\n     ls3 m')) (B3 : satisf rs # dst <- v ls3 e1) (LD3 : Val.lessdef_list rs ## args (reglist ls3 args2')) (a2' : val) (F2 : eval_addressing ge sp addr2 (reglist ls3 args2') = Some a2') (G2 : Val.lessdef (Val.add a (Vint (Int.repr 4))) a2') (v2'' : val) (LOAD2' : Mem.loadv Mint32 m' a2' = Some v2'') (LD4 : Val.lessdef v2' v2'') (ls4 : Locmap.t) (SAT4 : satisf rs # dst <- v ls4 e0) (ls5 : locset) (A5 : star step tge (Block ts tf sp (expand_moves mv3 (Lbranch pc' :: k)) ls4 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls5 m')) (B5 : satisf rs # dst <- v ls5 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls5 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true)","proofString":"generalize (wt_exec_Iload _ _ _ _ _ _ _ _ _ _ _ WTI H1 WTRS).\nintros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) : wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true)","proofString":"intros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v)","proofString":"exploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) : (exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"(exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v)","proofString":"intros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2)","proofString":"set (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2)","proofString":"set (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nexploit Mem.loadv_extends.\neauto.\neexact LOAD1.\neexact G1.\nintros (v1'' & LOAD1' & LD2).\nset (ls2 := Locmap.set (R dst') v1'' (undef_regs (destroyed_by_load Mint32 addr) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v1';    unfold sel_val; unfold kind_first_word; unfold v1'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD1'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args')) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args') = Some a1') (G1 : Val.lessdef a a1') (v1'' : val) (LOAD1' : Mem.loadv Mint32 m' a1' = Some v1'') (LD2 : Val.lessdef v1' v1'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m')) (B3 : satisf rs # dst <- v ls3 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls3 enext) : match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls3 m').","conclusion":"match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls3 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_1 addr args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr)\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_first_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr args' dst' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args')) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args') = Some a1') (G1 : Val.lessdef a a1') (v1'' : val) (LOAD1' : Mem.loadv Mint32 m' a1' = Some v1'') (LD2 : Val.lessdef v1' v1'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m')) (B3 : satisf rs # dst <- v ls3 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls3 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2)","proofString":"generalize (wt_exec_Iload _ _ _ _ _ _ _ _ _ _ _ WTI H1 WTRS).\nintros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a1' [F1 G1]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a1' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G1]).\ndestruct LOADX as (v2'' & LOAD2' & LD2).\nset (ls2 := Locmap.set (R dst') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) : wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"wt_regset env rs # dst <- v ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2)","proofString":"intros WTRS'.\nexploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a1' [F1 G1]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a1' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G1]).\ndestruct LOADX as (v2'' & LOAD2' & LD2).\nset (ls2 := Locmap.set (R dst') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v)","proofString":"exploit loadv_int64_split; eauto.\nintros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a1' [F1 G1]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a1' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G1]).\ndestruct LOADX as (v2'' & LOAD2' & LD2).\nset (ls2 := Locmap.set (R dst') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) : (exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"(exists v1 v2 : val,\n   Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2) /\\\n   Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\n   Some (if Archi.big_endian then v2 else v1) /\\\n   Val.lessdef (Val.hiword v) v1 /\\ Val.lessdef (Val.loword v) v2) ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v)","proofString":"intros (v1 & v2 & LOAD1 & LOAD2 & V1 & V2).\nset (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a1' [F1 G1]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a1' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G1]).\ndestruct LOADX as (v2'' & LOAD2' & LD2).\nset (ls2 := Locmap.set (R dst') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (LOAD1 : Mem.loadv Mint32 m a = Some (if Archi.big_endian then v1 else v2)) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) =\nSome (if Archi.big_endian then v2 else v1)) (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2)","proofString":"set (v2' := if Archi.big_endian then v2 else v1) in *.\nset (v1' := if Archi.big_endian then v1 else v2) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nassert (LD1: Val.lessdef_list rs##args (reglist ls1 args')).\neapply add_equations_lessdef; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neapply eval_offset_addressing; eauto; apply Archi.splitlong_ptr32; auto.\nintros [a1' [F1 G1]].\nassert (LOADX: exists v2'', Mem.loadv Mint32 m' a1' = Some v2'' /\\ Val.lessdef v2' v2'').\ndiscriminate || (eapply Mem.loadv_extends; [eauto|eexact LOAD2|eexact G1]).\ndestruct LOADX as (v2'' & LOAD2' & LD2).\nset (ls2 := Locmap.set (R dst') v2'' (undef_regs (destroyed_by_load Mint32 addr2) ls1)).\nassert (SAT2: satisf (rs#dst <- v) ls2 e0).\neapply parallel_assignment_satisf; eauto.\napply Val.lessdef_trans with v2'; unfold sel_val; unfold kind_second_word; unfold v2'; destruct Archi.big_endian; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\ninstantiate (1 := a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\neexact LOAD2'.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\nconstructor.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [W Z]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args')) (a1' : val) (F1 : eval_addressing ge sp addr2 (reglist ls1 args') = Some a1') (G1 : Val.lessdef (Val.add a (Vint (Int.repr 4))) a1') (v2'' : val) (LOAD2' : Mem.loadv Mint32 m' a1' = Some v2'') (LD2 : Val.lessdef v2' v2'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m')) (B3 : satisf rs # dst <- v ls3 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls3 enext) : match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls3 m').","conclusion":"match_states (RTL.State s f sp pc' rs # dst <- v m)\n  (State ts tf sp pc' ls3 m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload Mint64 addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv Mint64 m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args' : list mreg) (dst' : mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BSload2_2 addr addr2 args dst mv1 args' dst' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (Heqb : reg_loc_unconstrained dst (R dst')\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (Heqb0 : can_undef (destroyed_by_load Mint32 addr2)\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) = true) (e1 : eqs) (Heqo0 : add_equations args args'\n  (remove_equation\n     {| ekind := kind_second_word; ereg := dst; eloc := R dst' |} e0) =\nSome e1) (TR : track_moves env mv1 e1 = Some e) (WTI : wt_instr f env (Iload Mint64 addr args dst pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (WTRS' : wt_regset env rs # dst <- v) (v1 v2 : val) (v1' : val) (LOAD1 : Mem.loadv Mint32 m a = Some v1') (v2' : val) (LOAD2 : Mem.loadv Mint32 m (Val.add a (Vint (Int.repr 4))) = Some v2') (V1 : Val.lessdef (Val.hiword v) v1) (V2 : Val.lessdef (Val.loword v) v2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp\n     (Lload Mint32 addr2 args' dst' :: expand_moves mv2 (Lbranch pc' :: k))\n     ls1 m')) (B1 : satisf rs ls1 e1) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args')) (a1' : val) (F1 : eval_addressing ge sp addr2 (reglist ls1 args') = Some a1') (G1 : Val.lessdef (Val.add a (Vint (Int.repr 4))) a1') (v2'' : val) (LOAD2' : Mem.loadv Mint32 m' a1' = Some v2'') (LD2 : Val.lessdef v2' v2'') (ls2 : Locmap.t) (SAT2 : satisf rs # dst <- v ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m')) (B3 : satisf rs # dst <- v ls3 eafter) (enext : eqs) (W : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Z : satisf rs # dst <- v ls3 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSloaddead chunk addr args dst mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained dst eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSloaddead chunk addr args dst mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained dst eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv)","proofString":"exploit exec_moves; eauto.\nintros [ls1 [X Y]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact X.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit satisf_successors.\neauto.\neauto.\nsimpl; eauto.\neauto.\neapply reg_unconstrained_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto.\neapply wt_exec_Iload; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSloaddead chunk addr args dst mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained dst eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # dst <- v ls1 enext) : wt_regset env rs # dst <- v.","conclusion":"wt_regset env rs # dst <- v","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : RTL.node) (a v : val) (H : (RTL.fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSloaddead chunk addr args dst mv pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lbranch pc' :: k))) (Heqb : reg_unconstrained dst eafter = true) (TR : track_moves env mv eafter = Some e) (WTI : wt_instr f env (Iload chunk addr args dst pc')) (H9 : wf_moves mv) (ls1 : locset) (X : star step tge (Block ts tf sp (expand_moves mv (Lbranch pc' :: k)) ls m') E0\n  (Block ts tf sp (Lbranch pc' :: k) ls1 m')) (Y : satisf rs ls1 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs # dst <- v ls1 enext)","proofString":"eapply wt_exec_Iload; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1)","proofString":"exploit exec_moves; eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef; eauto.\nintros LD.\nsimpl in LD.\ninv LD.\nexploit eval_addressing_lessdef; eauto.\nintros [a' [F G]].\nexploit Mem.storev_extends; eauto.\nintros [m'' [P Q]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_two.\neconstructor.\ninstantiate (1 := a').\nrewrite <- F.\napply eval_addressing_preserved.\nexact symbols_preserved.\neauto.\neauto.\nconstructor.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf; eauto.\neapply add_equations_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'') : eval_addressing tge sp addr (reglist ls1 args') = Some a'.","conclusion":"eval_addressing tge sp addr (reglist ls1 args') = Some a'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'')","proofString":"rewrite <- F.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'') : eval_addressing tge sp addr (reglist ls1 args') =\neval_addressing ge sp addr (reglist ls1 args').","conclusion":"eval_addressing tge sp addr (reglist ls1 args') =\neval_addressing ge sp addr (reglist ls1 args')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'')","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'') : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'')","proofString":"exact symbols_preserved."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'') (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs (undef_regs (destroyed_by_store chunk addr) ls1) enext) : match_states (RTL.State s f sp pc' rs m')\n  (State ts tf sp pc' (undef_regs (destroyed_by_store chunk addr) ls1) m'').","conclusion":"match_states (RTL.State s f sp pc' rs m')\n  (State ts tf sp pc' (undef_regs (destroyed_by_store chunk addr) ls1) m'')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list mreg) (src' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore chunk addr args src mv1 args' src' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k))) (Heqb : can_undef (destroyed_by_store chunk addr) eafter = true) (e0 : eqs) (Heqo : add_equations (src :: args) (src' :: args') eafter = Some e0) (TR : track_moves env mv1 e0 = Some e) (WTI : wt_instr f env (Istore chunk addr args src pc')) (H9 : wf_moves mv1) (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lstore chunk addr args' src' :: Lbranch pc' :: k)) ls\n     m'0) E0\n  (Block ts tf sp (Lstore chunk addr args' src' :: Lbranch pc' :: k) ls1 m'0)) (Y : satisf rs ls1 e0) (H5 : Val.lessdef rs # src (ls1 (R src'))) (H7 : Val.lessdef_list rs ## args (reglist ls1 args')) (a' : val) (F : eval_addressing ge sp addr (reglist ls1 args') = Some a') (G : Val.lessdef a a') (m'' : mem) (P : Mem.storev chunk m'0 a' (ls1 (R src')) = Some m'') (Q : Mem.extends m' m'') (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs (undef_regs (destroyed_by_store chunk addr) ls1) enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2)","proofString":"assert (SF: Archi.ptr64 = false) by (apply Archi.splitlong_ptr32; auto).\nexploit Mem.storev_int64_split; eauto.\nreplace (if Archi.big_endian then Val.hiword rs#src else Val.loword rs#src)     with (sel_val kind_first_word rs#src)       by (unfold kind_first_word; destruct Archi.big_endian; reflexivity).\nreplace (if Archi.big_endian then Val.loword rs#src else Val.hiword rs#src)     with (sel_val kind_second_word rs#src)       by (unfold kind_second_word; destruct Archi.big_endian; reflexivity).\nintros [m1 [STORE1 STORE2]].\nexploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false)","proofString":"exploit Mem.storev_int64_split; eauto.\nreplace (if Archi.big_endian then Val.hiword rs#src else Val.loword rs#src)     with (sel_val kind_first_word rs#src)       by (unfold kind_first_word; destruct Archi.big_endian; reflexivity).\nreplace (if Archi.big_endian then Val.loword rs#src else Val.hiword rs#src)     with (sel_val kind_second_word rs#src)       by (unfold kind_second_word; destruct Archi.big_endian; reflexivity).\nintros [m1 [STORE1 STORE2]].\nexploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) : (exists m1 : mem,\n   Mem.storev Mint32 m a\n     (if Archi.big_endian then Val.hiword rs # src else Val.loword rs # src) =\n   Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (if Archi.big_endian then Val.loword rs # src else Val.hiword rs # src) =\n   Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"(exists m1 : mem,\n   Mem.storev Mint32 m a\n     (if Archi.big_endian then Val.hiword rs # src else Val.loword rs # src) =\n   Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (if Archi.big_endian then Val.loword rs # src else Val.hiword rs # src) =\n   Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false)","proofString":"replace (if Archi.big_endian then Val.hiword rs#src else Val.loword rs#src)     with (sel_val kind_first_word rs#src)       by (unfold kind_first_word; destruct Archi.big_endian; reflexivity).\nreplace (if Archi.big_endian then Val.loword rs#src else Val.hiword rs#src)     with (sel_val kind_second_word rs#src)       by (unfold kind_second_word; destruct Archi.big_endian; reflexivity).\nintros [m1 [STORE1 STORE2]].\nexploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) : (exists m1 : mem,\n   Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (if Archi.big_endian then Val.loword rs # src else Val.hiword rs # src) =\n   Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"(exists m1 : mem,\n   Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (if Archi.big_endian then Val.loword rs # src else Val.hiword rs # src) =\n   Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false)","proofString":"replace (if Archi.big_endian then Val.loword rs#src else Val.hiword rs#src)     with (sel_val kind_second_word rs#src)       by (unfold kind_second_word; destruct Archi.big_endian; reflexivity).\nintros [m1 [STORE1 STORE2]].\nexploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) : (exists m1 : mem,\n   Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (sel_val kind_second_word rs # src) = Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"(exists m1 : mem,\n   Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1 /\\\n   Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n     (sel_val kind_second_word rs # src) = Some m') ->\nexists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false)","proofString":"intros [m1 [STORE1 STORE2]].\nexploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) (m1 : mem) (STORE1 : Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1) (STORE2 : Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n  (sel_val kind_second_word rs # src) = Some m') : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) (m1 : mem) (STORE1 : Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1) (STORE2 : Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n  (sel_val kind_second_word rs # src) = Some m')","proofString":"exploit (exec_moves mv1); eauto.\nintros [ls1 [X Y]].\nexploit add_equations_lessdef.\neexact Heqo1.\neexact Y.\nintros LD1.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo1.\neexact Y.\nsimpl.\nintros LD2.\nset (ls2 := undef_regs (destroyed_by_store Mint32 addr) ls1).\nassert (SAT2: satisf rs ls2 e1).\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nexploit eval_addressing_lessdef.\neexact LD1.\neauto.\nintros [a1' [F1 G1]].\nassert (F1': eval_addressing tge sp addr (reglist ls1 args1') = Some a1').\nrewrite <- F1.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit Mem.storev_extends.\neauto.\neexact STORE1.\neexact G1.\neauto.\nintros [m1' [STORE1' EXT1]].\nexploit (exec_moves mv2); eauto.\nintros [ls3 [U V]].\nexploit add_equations_lessdef.\neexact Heqo.\neexact V.\nintros LD3.\nexploit add_equation_lessdef.\neapply add_equations_satisf.\neexact Heqo.\neexact V.\nsimpl.\nintros LD4.\nexploit eval_addressing_lessdef.\neexact LD3.\neauto.\nintros [a2' [F2 G2]].\nassert (F2': eval_addressing tge sp addr (reglist ls3 args2') = Some a2').\nrewrite <- F2.\napply eval_addressing_preserved.\nexact symbols_preserved.\nexploit (eval_offset_addressing tge); eauto.\nintros F2''.\nassert (STOREX: exists m2', Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) = Some m2' /\\ Mem.extends m' m2').\ntry discriminate;    (eapply Mem.storev_extends;     [eexact EXT1 | eexact STORE2 | apply Val.add_lessdef; [eexact G2|eauto] | eauto]).\ndestruct STOREX as [m2' [STORE2' EXT2]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact X.\neapply star_left.\neconstructor.\neexact F1'.\neexact STORE1'.\ninstantiate (1 := ls2).\nauto.\neapply star_trans.\neexact U.\neapply star_two.\neapply exec_Lstore with (m' := m2').\neexact F2''.\ndiscriminate||exact STORE2'.\neauto.\nconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf.\neapply add_equations_satisf; eauto.\nintros [enext [P Q]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) (m1 : mem) (STORE1 : Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1) (STORE2 : Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n  (sel_val kind_second_word rs # src) = Some m') (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lstore Mint32 addr args1' src1'\n         :: expand_moves mv2\n              (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k))) ls m'0)\n  E0\n  (Block ts tf sp\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)) ls1 m'0)) (Y : satisf rs ls1 e2) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args1')) (LD2 : Val.lessdef (sel_val kind_first_word rs # src) (ls1 (R src1'))) (ls2 : locset) (SAT2 : satisf rs ls2 e1) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args1') = Some a1') (G1 : Val.lessdef a a1') (F1' : eval_addressing tge sp addr (reglist ls1 args1') = Some a1') (m1' : mem) (STORE1' : Mem.storev Mint32 m'0 a1' (ls1 (R src1')) = Some m1') (EXT1 : Mem.extends m1 m1') (ls3 : locset) (U : star step tge\n  (Block ts tf sp\n     (expand_moves mv2 (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k))\n     ls2 m1') E0\n  (Block ts tf sp (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k) ls3\n     m1')) (V : satisf rs ls3 e0) (LD3 : Val.lessdef_list rs ## args (reglist ls3 args2')) (LD4 : Val.lessdef (sel_val kind_second_word rs # src) (ls3 (R src2'))) (a2' : val) (F2 : eval_addressing ge sp addr (reglist ls3 args2') = Some a2') (G2 : Val.lessdef a a2') (F2' : eval_addressing tge sp addr (reglist ls3 args2') = Some a2') (F2'' : eval_addressing tge sp addr2 (reglist ls3 args2') =\nSome (Val.add a2' (Vint (Int.repr 4)))) (m2' : mem) (STORE2' : Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) =\nSome m2') (EXT2 : Mem.extends m' m2') (enext : eqs) (P : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Q : satisf rs (undef_regs (destroyed_by_store Mint32 addr2) ls3) enext) : match_states (RTL.State s f sp pc' rs m')\n  (State ts tf sp pc' (undef_regs (destroyed_by_store Mint32 addr2) ls3) m2').","conclusion":"match_states (RTL.State s f sp pc' rs m')\n  (State ts tf sp pc' (undef_regs (destroyed_by_store Mint32 addr2) ls3) m2')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (addr : addressing) (args : list reg) (src : reg) (pc' : RTL.node) (a : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Istore Mint64 addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev Mint64 m a rs # src = Some m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (addr2 : addressing) (mv1 : moves) (args1' : list mreg) (src1' : mreg) (mv2 : moves) (args2' : list mreg) (src2' : mreg) (BSH : (pair_codes f tf) ! pc =\nSome (BSstore2 addr addr2 args src mv1 args1' src1' mv2 args2' src2' pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)))) (Heqb : can_undef (destroyed_by_store Mint32 addr2) eafter = true) (e0 : eqs) (Heqo : add_equations args args2'\n  (add_equation {| ekind := kind_second_word; ereg := src; eloc := R src2' |}\n     eafter) = Some e0) (e1 : eqs) (Heqo0 : track_moves env mv2 e0 = Some e1) (Heqb0 : can_undef (destroyed_by_store Mint32 addr) e1 = true) (e2 : eqs) (Heqo1 : add_equations args args1'\n  (add_equation {| ekind := kind_first_word; ereg := src; eloc := R src1' |}\n     e1) = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Istore Mint64 addr args src pc')) (H9 : wf_moves mv1) (H10 : wf_moves mv2) (H11 : Archi.splitlong = true) (H12 : offset_addressing addr 4 = Some addr2) (SF : Archi.ptr64 = false) (m1 : mem) (STORE1 : Mem.storev Mint32 m a (sel_val kind_first_word rs # src) = Some m1) (STORE2 : Mem.storev Mint32 m1 (Val.add a (Vint (Int.repr 4)))\n  (sel_val kind_second_word rs # src) = Some m') (ls1 : locset) (X : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lstore Mint32 addr args1' src1'\n         :: expand_moves mv2\n              (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k))) ls m'0)\n  E0\n  (Block ts tf sp\n     (Lstore Mint32 addr args1' src1'\n      :: expand_moves mv2\n           (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k)) ls1 m'0)) (Y : satisf rs ls1 e2) (LD1 : Val.lessdef_list rs ## args (reglist ls1 args1')) (LD2 : Val.lessdef (sel_val kind_first_word rs # src) (ls1 (R src1'))) (ls2 : locset) (SAT2 : satisf rs ls2 e1) (a1' : val) (F1 : eval_addressing ge sp addr (reglist ls1 args1') = Some a1') (G1 : Val.lessdef a a1') (F1' : eval_addressing tge sp addr (reglist ls1 args1') = Some a1') (m1' : mem) (STORE1' : Mem.storev Mint32 m'0 a1' (ls1 (R src1')) = Some m1') (EXT1 : Mem.extends m1 m1') (ls3 : locset) (U : star step tge\n  (Block ts tf sp\n     (expand_moves mv2 (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k))\n     ls2 m1') E0\n  (Block ts tf sp (Lstore Mint32 addr2 args2' src2' :: Lbranch pc' :: k) ls3\n     m1')) (V : satisf rs ls3 e0) (LD3 : Val.lessdef_list rs ## args (reglist ls3 args2')) (LD4 : Val.lessdef (sel_val kind_second_word rs # src) (ls3 (R src2'))) (a2' : val) (F2 : eval_addressing ge sp addr (reglist ls3 args2') = Some a2') (G2 : Val.lessdef a a2') (F2' : eval_addressing tge sp addr (reglist ls3 args2') = Some a2') (F2'' : eval_addressing tge sp addr2 (reglist ls3 args2') =\nSome (Val.add a2' (Vint (Int.repr 4)))) (m2' : mem) (STORE2' : Mem.storev Mint32 m1' (Val.add a2' (Vint (Int.repr 4))) (ls3 (R src2')) =\nSome m2') (EXT2 : Mem.extends m' m2') (enext : eqs) (P : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (Q : satisf rs (undef_regs (destroyed_by_store Mint32 addr2) ls3) enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (H : (RTL.fn_code f) ! pc = Some (Icall (RTL.funsig fd) ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BScall (RTL.funsig fd) ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lcall (RTL.funsig fd) ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_res res (loc_result (RTL.funsig fd)) e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair (loc_result (RTL.funsig fd)))) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (Heqo2 : add_equations_args args (proj_sig_args (RTL.funsig fd))\n  (loc_arguments (RTL.funsig fd)) e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall (RTL.funsig fd) ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states\n    (RTL.Callstate (RTL.Stackframe res f sp pc' rs :: s) fd rs ## args m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states\n    (RTL.Callstate (RTL.Stackframe res f sp pc' rs :: s) fd rs ## args m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (H : (RTL.fn_code f) ! pc = Some (Icall (RTL.funsig fd) ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc =\nSome (BScall (RTL.funsig fd) ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lcall (RTL.funsig fd) ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_res res (loc_result (RTL.funsig fd)) e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair (loc_result (RTL.funsig fd)))) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (Heqo2 : add_equations_args args (proj_sig_args (RTL.funsig fd))\n  (loc_arguments (RTL.funsig fd)) e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall (RTL.funsig fd) ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2)","proofString":"set (sg := RTL.funsig fd) in *.\nset (args' := loc_arguments sg) in *.\nset (res' := loc_result sg) in *.\nexploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit find_function_translated.\neauto.\neauto.\neapply add_equations_args_satisf; eauto.\nintros [tfd [E F]].\nassert (SIG: funsig tfd = sg).\neapply sig_function_translated; eauto.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor; eauto.\neauto.\ntraceEq.\nexploit analyze_successors; eauto.\nsimpl.\nleft; eauto.\nintros [enext [U V]].\neconstructor; eauto.\neconstructor; eauto.\ninv WTI.\ncongruence.\nintros.\nexploit (exec_moves mv2).\neauto.\neauto.\neapply function_return_satisf with (v := v) (ls_before := ls1) (ls_after := ls0); eauto.\neapply add_equation_ros_satisf; eauto.\neapply add_equations_args_satisf; eauto.\ncongruence.\napply wt_regset_assign; auto.\nintros [ls2 [A2 B2]].\nexists ls2; split.\neapply star_right.\neexact A2.\nconstructor.\ntraceEq.\napply satisf_incr with eafter; auto.\nrewrite SIG.\neapply add_equations_args_lessdef; eauto.\ninv WTI.\nrewrite <- H7.\napply wt_regset_list; auto.\nsimpl.\nred; auto.\ninv WTI.\nrewrite SIG.\nrewrite <- H7.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) : env res = proj_sig_res (funsig tfd).","conclusion":"env res = proj_sig_res (funsig tfd)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter)","proofString":"inv WTI.\ncongruence."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : env res = proj_sig_res (funsig tfd).","conclusion":"env res = proj_sig_res (funsig tfd)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"congruence."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (v : val) (ls0 : Locmap.t) (m0 : mem) (H1 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result (funsig tfd))) ls0)) (H2 : Val.has_type v (env res)) (H3 : agree_callee_save ls1 ls0) : wf_moves mv2.","conclusion":"wf_moves mv2","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (v : val) (ls0 : Locmap.t) (m0 : mem) (H1 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result (funsig tfd))) ls0)) (H2 : Val.has_type v (env res)) (H3 : agree_callee_save ls1 ls0)","proofString":"eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (v : val) (ls0 : Locmap.t) (m0 : mem) (H1 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result (funsig tfd))) ls0)) (H2 : Val.has_type v (env res)) (H3 : agree_callee_save ls1 ls0) : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls0).","conclusion":"Val.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls0)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (v : val) (ls0 : Locmap.t) (m0 : mem) (H1 : Val.lessdef v (Locmap.getpair (map_rpair R (loc_result (funsig tfd))) ls0)) (H2 : Val.has_type v (env res)) (H3 : agree_callee_save ls1 ls0)","proofString":"congruence."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter)","proofString":"inv WTI.\nrewrite <- H7.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"rewrite <- H7.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : Val.has_type_list rs ## args (map env args).","conclusion":"Val.has_type_list rs ## args (map env args)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"apply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) : agree_callee_save\n  (parent_locset\n     (Stackframe tf sp ls1 (expand_moves mv2 (Lbranch pc' :: k)) :: ts)) ls1.","conclusion":"agree_callee_save\n  (parent_locset\n     (Stackframe tf sp ls1 (expand_moves mv2 (Lbranch pc' :: k)) :: ts)) ls1","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter)","proofString":"simpl.\nred; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) : agree_callee_save ls1 ls1.","conclusion":"agree_callee_save ls1 ls1","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (WTI : wt_instr f env (Icall sg ros args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter)","proofString":"red; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : Val.has_type_list rs ## args (proj_sig_args (funsig tfd)).","conclusion":"Val.has_type_list rs ## args (proj_sig_args (funsig tfd))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"rewrite SIG.\nrewrite <- H7.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"rewrite <- H7.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc') : Val.has_type_list rs ## args (map env args).","conclusion":"Val.has_type_list rs ## args (map env args)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : RTL.node) (fd : RTL.fundef) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Icall sg ros args res pc')) (H0 : RTL.find_function ge ros rs = Some fd) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (ros' : mreg + ident) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BScall sg ros args res mv1 ros' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (res' : rpair mreg) (Heqo0 : remove_equations_res res res' e0 = Some e1) (Heqb : forallb (fun l : loc => reg_loc_unconstrained res l e1)\n  (map R (regs_of_rpair res')) = true) (Heqb0 : no_caller_saves e1 = true) (e2 : eqs) (Heqo1 : add_equation_ros ros ros' e1 = Some e2) (e3 : eqs) (args' : list (rpair loc)) (Heqo2 : add_equations_args args (proj_sig_args sg) args' e2 = Some e3) (TR : track_moves env mv1 e3 = Some e) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1 (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)))\n     ls m') E0\n  (Block ts tf sp (Lcall sg ros' :: expand_moves mv2 (Lbranch pc' :: k)) ls1\n     m')) (B1 : satisf rs ls1 e3) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : EqSet.Subset enext eafter) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H7 : map env args = proj_sig_args sg) (H10 : env res = proj_sig_res sg) (H11 : valid_successor f pc')","proofString":"apply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Itailcall (RTL.funsig fd) ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall (RTL.funsig fd) ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv (Ltailcall (RTL.funsig fd) ros' :: k))) (Heqb : tailcall_is_possible (RTL.funsig fd) = true) (e0 : sig_res (RTL.funsig fd) = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (Heqo0 : add_equations_args args (proj_sig_args (RTL.funsig fd))\n  (loc_arguments (RTL.funsig fd)) e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall (RTL.funsig fd) ros args)) (H7 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Callstate s fd rs ## args m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Callstate s fd rs ## args m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Itailcall (RTL.funsig fd) ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall (RTL.funsig fd) ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome (expand_moves mv (Ltailcall (RTL.funsig fd) ros' :: k))) (Heqb : tailcall_is_possible (RTL.funsig fd) = true) (e0 : sig_res (RTL.funsig fd) = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (Heqo0 : add_equations_args args (proj_sig_args (RTL.funsig fd))\n  (loc_arguments (RTL.funsig fd)) e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall (RTL.funsig fd) ros args)) (H7 : wf_moves mv)","proofString":"set (sg := RTL.funsig fd) in *.\nset (args' := loc_arguments sg) in *.\nexploit Mem.free_parallel_extends; eauto.\nintros [m'' [P Q]].\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\nexploit find_function_translated.\neauto.\neauto.\neapply add_equations_args_satisf; eauto.\nintros [tfd [E F]].\nassert (SIG: funsig tfd = sg).\neapply sig_function_translated; eauto.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor; eauto.\nrewrite <- E.\napply find_function_tailcall; auto.\nreplace (fn_stacksize tf) with (RTL.fn_stacksize f); eauto.\ndestruct (transf_function_inv _ _ FUN); auto.\neauto.\ntraceEq.\neconstructor; eauto.\neapply match_stackframes_change_sig; eauto.\nrewrite SIG.\nrewrite e0.\ndecEq.\ndestruct (transf_function_inv _ _ FUN); auto.\nrewrite SIG.\nrewrite return_regs_arg_values; auto.\neapply add_equations_args_lessdef; eauto.\ninv WTI.\nrewrite <- H6.\napply wt_regset_list; auto.\napply return_regs_agree_callee_save.\nrewrite SIG.\ninv WTI.\nrewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : find_function tge ros' (return_regs (parent_locset ts) ls1) = Some tfd.","conclusion":"find_function tge ros' (return_regs (parent_locset ts) ls1) = Some tfd","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"rewrite <- E.\napply find_function_tailcall; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : find_function tge ros' (return_regs (parent_locset ts) ls1) =\nfind_function tge ros' ls1.","conclusion":"find_function tge ros' (return_regs (parent_locset ts) ls1) =\nfind_function tge ros' ls1","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"apply find_function_tailcall; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : RTL.fn_stacksize f = fn_stacksize tf.","conclusion":"RTL.fn_stacksize f = fn_stacksize tf","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"destruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : match_stackframes s ts (funsig tfd).","conclusion":"match_stackframes s ts (funsig tfd)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"eapply match_stackframes_change_sig; eauto.\nrewrite SIG.\nrewrite e0.\ndecEq.\ndestruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : sig_res (funsig tfd) = sig_res (fn_sig tf).","conclusion":"sig_res (funsig tfd) = sig_res (fn_sig tf)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"rewrite SIG.\nrewrite e0.\ndecEq.\ndestruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : sig_res sg = sig_res (fn_sig tf).","conclusion":"sig_res sg = sig_res (fn_sig tf)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"rewrite e0.\ndecEq.\ndestruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : sig_res (RTL.fn_sig f) = sig_res (fn_sig tf).","conclusion":"sig_res (RTL.fn_sig f) = sig_res (fn_sig tf)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"decEq.\ndestruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : RTL.fn_sig f = fn_sig tf.","conclusion":"RTL.fn_sig f = fn_sig tf","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"destruct (transf_function_inv _ _ FUN); auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"inv WTI.\nrewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg) : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg)","proofString":"rewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg) : Val.has_type_list rs ## args (map env args).","conclusion":"Val.has_type_list rs ## args (map env args)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg)","proofString":"apply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1).","conclusion":"agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"apply return_regs_agree_callee_save."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : Val.has_type_list rs ## args (proj_sig_args (funsig tfd)).","conclusion":"Val.has_type_list rs ## args (proj_sig_args (funsig tfd))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"rewrite SIG.\ninv WTI.\nrewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (WTI : wt_instr f env (Itailcall sg ros args)) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg)","proofString":"inv WTI.\nrewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg) : Val.has_type_list rs ## args (proj_sig_args sg).","conclusion":"Val.has_type_list rs ## args (proj_sig_args sg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg)","proofString":"rewrite <- H6.\napply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg) : Val.has_type_list rs ## args (map env args).","conclusion":"Val.has_type_list rs ## args (map env args)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : RTL.fundef) (m' : mem) (sg : signature) (H : (RTL.fn_code f) ! pc = Some (Itailcall sg ros args)) (H0 : RTL.find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (ros' : mreg + ident) (BSH : (pair_codes f tf) ! pc = Some (BStailcall sg ros args mv ros')) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ltailcall sg ros' :: k))) (Heqb : tailcall_is_possible sg = true) (e0 : sig_res sg = sig_res (RTL.fn_sig f)) (Heqb0 : ros_compatible_tailcall ros' = true) (e1 : eqs) (Heqo : add_equation_ros ros ros' empty_eqs = Some e1) (e2 : eqs) (args' : list (rpair loc)) (Heqo0 : add_equations_args args (proj_sig_args sg) args' e1 = Some e2) (TR : track_moves env mv e2 = Some e) (H7 : wf_moves mv) (m'' : mem) (P : Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m'') (Q : Mem.extends m' m'') (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero)\n     (expand_moves mv (Ltailcall sg ros' :: k)) ls m'0) E0\n  (Block ts tf (Vptr stk Ptrofs.zero) (Ltailcall sg ros' :: k) ls1 m'0)) (B1 : satisf rs ls1 e2) (tfd : fundef) (E : find_function tge ros' ls1 = Some tfd) (F : transf_fundef fd = OK tfd) (SIG : funsig tfd = sg) (H5 : match ros with\n| inl r => env r = Tptr\n| inr _ => True\nend) (H6 : map env args = proj_sig_args sg) (H8 : sig_res sg = sig_res (RTL.fn_sig f)) (H9 : tailcall_possible sg)","proofString":"apply wt_regset_list; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : RTL.node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list (builtin_arg loc)) (res' : builtin_res mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSbuiltin ef args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_builtin_res env res res' e0 = Some e1) (Heqb : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (Heqb0 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (Heqb1 : can_undef (destroyed_by_builtin ef) e1 = true) (e2 : eqs) (Heqo1 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Ibuiltin ef args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) t S2' /\\\n  match_states (RTL.State s f sp pc' (regmap_setres res vres rs) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m'0) t S2' /\\\n  match_states (RTL.State s f sp pc' (regmap_setres res vres rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : RTL.node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list (builtin_arg loc)) (res' : builtin_res mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSbuiltin ef args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_builtin_res env res res' e0 = Some e1) (Heqb : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (Heqb0 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (Heqb1 : can_undef (destroyed_by_builtin ef) e1 = true) (e2 : eqs) (Heqo1 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Ibuiltin ef args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2)","proofString":"exploit (exec_moves mv1); eauto.\nintros [ls1 [A1 B1]].\nexploit add_equations_builtin_eval; eauto.\nintros (C & vargs' & vres' & m'' & D & E & F & G).\nassert (WTRS': wt_regset env (regmap_setres res vres rs)) by (eapply wt_exec_Ibuiltin; eauto).\nset (ls2 := Locmap.setres res' vres' (undef_regs (destroyed_by_builtin ef) ls1)).\nassert (satisf (regmap_setres res vres rs) ls2 e0).\neapply parallel_set_builtin_res_satisf; eauto.\neapply can_undef_satisf; eauto.\nexploit (exec_moves mv2); eauto.\nintros [ls3 [A3 B3]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_trans.\neexact A1.\neapply star_left.\neconstructor.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved.\napply senv_preserved.\neauto.\ninstantiate (1 := ls2); auto.\neapply star_right.\neexact A3.\neconstructor.\nreflexivity.\nreflexivity.\nreflexivity.\ntraceEq.\nexploit satisf_successors; eauto.\nsimpl; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : RTL.node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list (builtin_arg loc)) (res' : builtin_res mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSbuiltin ef args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_builtin_res env res res' e0 = Some e1) (Heqb : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (Heqb0 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (Heqb1 : can_undef (destroyed_by_builtin ef) e1 = true) (e2 : eqs) (Heqo1 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Ibuiltin ef args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k))) ls\n     m'0) E0\n  (Block ts tf sp\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)) ls1 m'0)) (B1 : satisf rs ls1 e2) (C : satisf rs ls1 e1) (vargs' : list val) (vres' : val) (m'' : mem) (D : eval_builtin_args ge ls1 sp m'0 args' vargs') (E : external_call ef ge vargs' m'0 t vres' m'') (F : Val.lessdef vres vres') (G : Mem.extends m' m'') (WTRS' : wt_regset env (regmap_setres res vres rs)) (ls2 : Locmap.t) (H2 : satisf (regmap_setres res vres rs) ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m'')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m'')) (B3 : satisf (regmap_setres res vres rs) ls3 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf (regmap_setres res vres rs) ls3 enext) : match_states (RTL.State s f sp pc' (regmap_setres res vres rs) m')\n  (State ts tf sp pc' ls3 m'').","conclusion":"match_states (RTL.State s f sp pc' (regmap_setres res vres rs) m')\n  (State ts tf sp pc' ls3 m'')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : RTL.node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv1 : moves) (args' : list (builtin_arg loc)) (res' : builtin_res mreg) (mv2 : moves) (BSH : (pair_codes f tf) ! pc = Some (BSbuiltin ef args res mv1 args' res' mv2 pc')) (k : list instruction) (TCODE : (fn_code tf) ! pc =\nSome\n  (expand_moves mv1\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)))) (e0 : eqs) (Heqo : track_moves env mv2 eafter = Some e0) (e1 : eqs) (Heqo0 : remove_equations_builtin_res env res res' e0 = Some e1) (Heqb : forallb (fun r : reg => reg_unconstrained r e1) (params_of_builtin_res res) =\ntrue) (Heqb0 : forallb (fun mr : mreg => loc_unconstrained (R mr) e1)\n  (params_of_builtin_res res') = true) (Heqb1 : can_undef (destroyed_by_builtin ef) e1 = true) (e2 : eqs) (Heqo1 : match ef with\n| EF_debug _ _ _ => add_equations_debug_args env args args' e1\n| _ => add_equations_builtin_args env args args' e1\nend = Some e2) (TR : track_moves env mv1 e2 = Some e) (WTI : wt_instr f env (Ibuiltin ef args res pc')) (H8 : wf_moves mv1) (H9 : wf_moves mv2) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp\n     (expand_moves mv1\n        (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k))) ls\n     m'0) E0\n  (Block ts tf sp\n     (Lbuiltin ef args' res' :: expand_moves mv2 (Lbranch pc' :: k)) ls1 m'0)) (B1 : satisf rs ls1 e2) (C : satisf rs ls1 e1) (vargs' : list val) (vres' : val) (m'' : mem) (D : eval_builtin_args ge ls1 sp m'0 args' vargs') (E : external_call ef ge vargs' m'0 t vres' m'') (F : Val.lessdef vres vres') (G : Mem.extends m' m'') (WTRS' : wt_regset env (regmap_setres res vres rs)) (ls2 : Locmap.t) (H2 : satisf (regmap_setres res vres rs) ls2 e0) (ls3 : locset) (A3 : star step tge (Block ts tf sp (expand_moves mv2 (Lbranch pc' :: k)) ls2 m'')\n  E0 (Block ts tf sp (Lbranch pc' :: k) ls3 m'')) (B3 : satisf (regmap_setres res vres rs) ls3 eafter) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf (regmap_setres res vres rs) ls3 enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp (if b then ifso else ifnot) rs m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp (if b then ifso else ifnot) rs m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv)","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neapply eval_condition_lessdef; eauto.\neapply add_equations_lessdef; eauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\ninstantiate (1 := if b then ifso else ifnot).\nsimpl.\ndestruct b; auto.\neapply can_undef_satisf.\neauto.\neapply add_equations_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0) : Val.lessdef_list rs ## args (reglist ls1 args').","conclusion":"Val.lessdef_list rs ## args (reglist ls1 args')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0)","proofString":"eapply add_equations_lessdef; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0) : In (if b then ifso else ifnot)\n  (successors_block_shape (BScond cond args mv args' ifso ifnot)).","conclusion":"In (if b then ifso else ifnot)\n  (successors_block_shape (BScond cond args mv args' ifso ifnot))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0)","proofString":"simpl.\ndestruct b; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0) : ifso = (if b then ifso else ifnot) \\/\nifnot = (if b then ifso else ifnot) \\/ False.","conclusion":"ifso = (if b then ifso else ifnot) \\/\nifnot = (if b then ifso else ifnot) \\/ False","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0)","proofString":"destruct b; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0) (enext : eqs) (U : transfer f env (pair_codes f tf) (if b then ifso else ifnot)\n  an # (if b then ifso else ifnot) = OK enext) (V : satisf rs (undef_regs (destroyed_by_cond cond) ls1) enext) : match_states (RTL.State s f sp (if b then ifso else ifnot) rs m)\n  (State ts tf sp (if b then ifso else ifnot)\n     (undef_regs (destroyed_by_cond cond) ls1) m').","conclusion":"match_states (RTL.State s f sp (if b then ifso else ifnot) rs m)\n  (State ts tf sp (if b then ifso else ifnot)\n     (undef_regs (destroyed_by_cond cond) ls1) m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : RTL.node) (b : bool) (H : (RTL.fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (args' : list mreg) (BSH : (pair_codes f tf) ! pc = Some (BScond cond args mv args' ifso ifnot)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lcond cond args' ifso ifnot :: k))) (Heqb0 : can_undef (destroyed_by_cond cond) eafter = true) (e0 : eqs) (Heqo : add_equations args args' eafter = Some e0) (TR : track_moves env mv e0 = Some e) (WTI : wt_instr f env (Icond cond args ifso ifnot)) (H7 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Lcond cond args' ifso ifnot :: k)) ls m')\n  E0 (Block ts tf sp (Lcond cond args' ifso ifnot :: k) ls1 m')) (B1 : satisf rs ls1 e0) (enext : eqs) (U : transfer f env (pair_codes f tf) (if b then ifso else ifnot)\n  an # (if b then ifso else ifnot) = OK enext) (V : satisf rs (undef_regs (destroyed_by_cond cond) ls1) enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf sp pc ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc' rs m) S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv)","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\nassert (Val.lessdef (Vint n) (ls1 (R arg'))).\nrewrite <- H0.\neapply add_equation_lessdef with (q := Eq Full arg (R arg')); eauto.\ninv H2.\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\neauto.\neauto.\ntraceEq.\nexploit satisf_successors; eauto.\ninstantiate (1 := pc').\nsimpl.\neapply list_nth_z_in; eauto.\neapply can_undef_satisf.\neauto.\neapply add_equation_satisf; eauto.\nintros [enext [U V]].\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg')) : In pc' (successors_block_shape (BSjumptable arg mv arg' tbl)).","conclusion":"In pc' (successors_block_shape (BSjumptable arg mv arg' tbl))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg'))","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg')) : In pc' tbl.","conclusion":"In pc' tbl","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg'))","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg')) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs (undef_regs destroyed_by_jumptable ls1) enext) : match_states (RTL.State s f sp pc' rs m)\n  (State ts tf sp pc' (undef_regs destroyed_by_jumptable ls1) m').","conclusion":"match_states (RTL.State s f sp pc' rs m)\n  (State ts tf sp pc' (undef_regs destroyed_by_jumptable ls1) m')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list RTL.node) (n : int) (pc' : RTL.node) (H : (RTL.fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (WT : wt_state (RTL.State s f sp pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m' : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m') (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (arg' : mreg) (BSH : (pair_codes f tf) ! pc = Some (BSjumptable arg mv arg' tbl)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Ljumptable arg' tbl :: k))) (Heqb : can_undef destroyed_by_jumptable eafter = true) (TR : track_moves env mv\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter) =\nSome e) (WTI : wt_instr f env (Ijumptable arg tbl)) (H6 : wf_moves mv) (ls1 : locset) (A1 : star step tge\n  (Block ts tf sp (expand_moves mv (Ljumptable arg' tbl :: k)) ls m') E0\n  (Block ts tf sp (Ljumptable arg' tbl :: k) ls1 m')) (B1 : satisf rs ls1\n  (add_equation {| ekind := Full; ereg := arg; eloc := R arg' |} eafter)) (H5 : Vint n = ls1 (R arg')) (enext : eqs) (U : transfer f env (pair_codes f tf) pc' an # pc' = OK enext) (V : satisf rs (undef_regs destroyed_by_jumptable ls1) enext)","proofString":"econstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e1 => track_moves env mv e1\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e1 => track_moves env mv e1\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv)","proofString":"destruct (transf_function_inv _ _ FUN).\nexploit Mem.free_parallel_extends; eauto.\nrewrite H10.\nintros [m'' [P Q]].\ninv WTI; MonadInv.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf)","proofString":"exploit Mem.free_parallel_extends; eauto.\nrewrite H10.\nintros [m'' [P Q]].\ninv WTI; MonadInv.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) : (exists m2' : mem,\n   Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m2' /\\ Mem.extends m' m2') ->\nexists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"(exists m2' : mem,\n   Mem.free m'0 stk 0 (RTL.fn_stacksize f) = Some m2' /\\ Mem.extends m' m2') ->\nexists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf)","proofString":"rewrite H10.\nintros [m'' [P Q]].\ninv WTI; MonadInv.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) : (exists m2' : mem,\n   Mem.free m'0 stk 0 (fn_stacksize tf) = Some m2' /\\ Mem.extends m' m2') ->\nexists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"(exists m2' : mem,\n   Mem.free m'0 stk 0 (fn_stacksize tf) = Some m2' /\\ Mem.extends m' m2') ->\nexists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf)","proofString":"intros [m'' [P Q]].\ninv WTI; MonadInv.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn or mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : match or with\n| Some arg =>\n    match\n      add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n        (loc_result (RTL.fn_sig f)) empty_eqs\n    with\n    | Some e0 => track_moves env mv e0\n    | None => None\n    end\n| None => track_moves env mv empty_eqs\nend = Some e) (WTI : wt_instr f env (Ireturn or)) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'')","proofString":"inv WTI; MonadInv.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor.\nexploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget None Vundef rs) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget None Vundef rs) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid)","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs) : match_states (RTL.Returnstate s Vundef m')\n  (Returnstate ts (return_regs (parent_locset ts) ls1) m'').","conclusion":"match_states (RTL.Returnstate s Vundef m')\n  (Returnstate ts (return_regs (parent_locset ts) ls1) m'')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs)","proofString":"econstructor; eauto.\napply return_regs_agree_callee_save.\nconstructor."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs) : agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1).","conclusion":"agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs)","proofString":"apply return_regs_agree_callee_save."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs) : Val.has_type Vundef (proj_sig_res (fn_sig tf)).","conclusion":"Val.has_type Vundef (proj_sig_res (fn_sig tf))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (H : (RTL.fn_code f) ! pc = Some (Ireturn None)) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn None mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (TR : track_moves env mv empty_eqs = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) = Xvoid) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 empty_eqs)","proofString":"constructor."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) : exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget (Some arg) Vundef rs) m')\n    S2'.","conclusion":"exists S2' : state,\n  plus step tge (State ts tf (Vptr stk Ptrofs.zero) pc ls m'0) E0 S2' /\\\n  match_states (RTL.Returnstate s (regmap_optget (Some arg) Vundef rs) m')\n    S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f))","proofString":"exploit (exec_moves mv); eauto.\nintros [ls1 [A1 B1]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_right.\neexact A1.\neconstructor.\neauto.\neauto.\ntraceEq.\nsimpl.\neconstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : match_states (RTL.Returnstate s rs # arg m')\n  (Returnstate ts (return_regs (parent_locset ts) ls1) m'').","conclusion":"match_states (RTL.Returnstate s rs # arg m')\n  (Returnstate ts (return_regs (parent_locset ts) ls1) m'')","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"econstructor; eauto.\nrewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto.\napply return_regs_agree_callee_save.\nrewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (fn_sig tf)))\n     (return_regs (parent_locset ts) ls1)).","conclusion":"Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (fn_sig tf)))\n     (return_regs (parent_locset ts) ls1))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"rewrite <- H11.\nreplace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n     (return_regs (parent_locset ts) ls1)).","conclusion":"Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n     (return_regs (parent_locset ts) ls1))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"replace (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))                          (return_regs (parent_locset ts) ls1))  with (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).\neapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS.\ngeneralize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1).","conclusion":"Val.lessdef rs # arg\n  (Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"eapply add_equations_res_lessdef; eauto.\nrewrite <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.has_type rs # arg (proj_sig_res (RTL.fn_sig f)).","conclusion":"Val.has_type rs # arg (proj_sig_res (RTL.fn_sig f))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"rewrite <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.has_type rs # arg (env arg).","conclusion":"Val.has_type rs # arg (env arg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"apply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1 =\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n  (return_regs (parent_locset ts) ls1).","conclusion":"Locmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1 =\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n  (return_regs (parent_locset ts) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"generalize (loc_result_caller_save (RTL.fn_sig f)).\ndestruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : forall_rpair (fun r : mreg => is_callee_save r = false)\n  (loc_result (RTL.fn_sig f)) ->\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1 =\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n  (return_regs (parent_locset ts) ls1).","conclusion":"forall_rpair (fun r : mreg => is_callee_save r = false)\n  (loc_result (RTL.fn_sig f)) ->\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f))) ls1 =\nLocmap.getpair (map_rpair R (loc_result (RTL.fn_sig f)))\n  (return_regs (parent_locset ts) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"destruct (loc_result (RTL.fn_sig f)); simpl.\nintros A; rewrite A; auto.\nintros [A B]; rewrite A, B; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (r : mreg) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f)) (One r) empty_eqs =\nSome e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : is_callee_save r = false ->\nls1 (R r) = (if is_callee_save r then parent_locset ts (R r) else ls1 (R r)).","conclusion":"is_callee_save r = false ->\nls1 (R r) = (if is_callee_save r then parent_locset ts (R r) else ls1 (R r))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (r : mreg) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f)) (One r) empty_eqs =\nSome e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"intros A; rewrite A; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (rhi rlo : mreg) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f)) \n  (Twolong rhi rlo) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : is_callee_save rhi = false /\\ is_callee_save rlo = false ->\nVal.longofwords (ls1 (R rhi)) (ls1 (R rlo)) =\nVal.longofwords\n  (if is_callee_save rhi then parent_locset ts (R rhi) else ls1 (R rhi))\n  (if is_callee_save rlo then parent_locset ts (R rlo) else ls1 (R rlo)).","conclusion":"is_callee_save rhi = false /\\ is_callee_save rlo = false ->\nVal.longofwords (ls1 (R rhi)) (ls1 (R rlo)) =\nVal.longofwords\n  (if is_callee_save rhi then parent_locset ts (R rhi) else ls1 (R rhi))\n  (if is_callee_save rlo then parent_locset ts (R rlo) else ls1 (R rlo))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (rhi rlo : mreg) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f)) \n  (Twolong rhi rlo) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"intros [A B]; rewrite A, B; auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1).","conclusion":"agree_callee_save (parent_locset ts) (return_regs (parent_locset ts) ls1)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"apply return_regs_agree_callee_save."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.has_type rs # arg (proj_sig_res (fn_sig tf)).","conclusion":"Val.has_type rs # arg (proj_sig_res (fn_sig tf))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"rewrite <- H11, <- H14.\napply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0) : Val.has_type rs # arg (env arg).","conclusion":"Val.has_type rs # arg (env arg)","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (stk : block) (pc : positive) (rs : regset) (m m' : mem) (arg : reg) (H : (RTL.fn_code f) ! pc = Some (Ireturn (Some arg))) (H0 : Mem.free m stk 0 (RTL.fn_stacksize f) = Some m') (WT : wt_state (RTL.State s f (Vptr stk Ptrofs.zero) pc rs m)) (ts : list stackframe) (tf : function) (ls : locset) (m'0 : mem) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS : match_stackframes s ts (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (SAT : satisf rs ls e) (MEM : Mem.extends m m'0) (WTF : wt_function f env) (WTRS : wt_regset env rs) (eafter : eqs) (AFTER : an # pc = OK eafter) (mv : moves) (BSH : (pair_codes f tf) ! pc = Some (BSreturn (Some arg) mv)) (k : list instruction) (TCODE : (fn_code tf) ! pc = Some (expand_moves mv (Lreturn :: k))) (e0 : eqs) (Heqo : add_equations_res arg (proj_sig_res (RTL.fn_sig f))\n  (loc_result (RTL.fn_sig f)) empty_eqs = Some e0) (TR : track_moves env mv e0 = Some e) (H3 : wf_moves mv) (env0 : regenv) (an0 : PMap.t DS.L.t) (mv0 : moves) (k0 : list instruction) (e1 e2 : eqs) (H1 : wt_function f env0) (H2 : analyze f env0 (pair_codes f tf) = Some an0) (H4 : (fn_code tf) ! (fn_entrypoint tf) =\nSome (expand_moves mv0 (Lbranch (RTL.fn_entrypoint f) :: k0))) (H5 : wf_moves mv0) (H6 : transfer f env0 (pair_codes f tf) (RTL.fn_entrypoint f)\n  an0 # (RTL.fn_entrypoint f) = OK e1) (H7 : track_moves env0 mv0 e1 = Some e2) (H8 : compat_entry (fn_params f) (loc_parameters (fn_sig tf)) e2 = true) (H9 : can_undef destroyed_at_function_entry e2 = true) (H10 : RTL.fn_stacksize f = fn_stacksize tf) (H11 : RTL.fn_sig f = fn_sig tf) (m'' : mem) (P : Mem.free m'0 stk 0 (fn_stacksize tf) = Some m'') (Q : Mem.extends m' m'') (H13 : sig_res (RTL.fn_sig f) <> Xvoid) (H14 : env arg = proj_sig_res (RTL.fn_sig f)) (ls1 : locset) (A1 : star step tge\n  (Block ts tf (Vptr stk Ptrofs.zero) (expand_moves mv (Lreturn :: k)) ls m'0)\n  E0 (Block ts tf (Vptr stk Ptrofs.zero) (Lreturn :: k) ls1 m'0)) (B1 : satisf rs ls1 e0)","proofString":"apply WTRS."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (Internal f) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf))) : exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (Internal f) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf)))","proofString":"monadInv FUN.\nsimpl in *.\ndestruct (transf_function_inv _ _ EQ).\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\nrewrite H9; apply Z.le_refl.\nintros [m'' [U V]].\nassert (WTRS: wt_regset env (init_regs args (fn_params f))).\napply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto.\nexploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (Internal x))))) (STACKS : match_stackframes s ts (funsig (Internal x))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (Internal x)))) (EQ : transf_function f = OK x) : exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (Internal x))))) (STACKS : match_stackframes s ts (funsig (Internal x))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (Internal x)))) (EQ : transf_function f = OK x)","proofString":"simpl in *.\ndestruct (transf_function_inv _ _ EQ).\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\nrewrite H9; apply Z.le_refl.\nintros [m'' [U V]].\nassert (WTRS: wt_regset env (init_regs args (fn_params f))).\napply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto.\nexploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) : exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x)","proofString":"destruct (transf_function_inv _ _ EQ).\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\nrewrite H9; apply Z.le_refl.\nintros [m'' [U V]].\nassert (WTRS: wt_regset env (init_regs args (fn_params f))).\napply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto.\nexploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) : exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x)","proofString":"exploit Mem.alloc_extends; eauto.\napply Z.le_refl.\nrewrite H9; apply Z.le_refl.\nintros [m'' [U V]].\nassert (WTRS: wt_regset env (init_regs args (fn_params f))).\napply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto.\nexploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') : exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'')","proofString":"assert (WTRS: wt_regset env (init_regs args (fn_params f))).\napply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto.\nexploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') : wt_regset env (init_regs args (fn_params f)).","conclusion":"wt_regset env (init_regs args (fn_params f))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'')","proofString":"apply wt_init_regs.\ninv H1.\nrewrite wt_params.\nrewrite H10.\nauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') : Val.has_type_list args (map env (fn_params f)).","conclusion":"Val.has_type_list args (map env (fn_params f))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'')","proofString":"inv H1.\nrewrite wt_params.\nrewrite H10.\nauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f)) : Val.has_type_list args (map env (fn_params f)).","conclusion":"Val.has_type_list args (map env (fn_params f))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f))","proofString":"rewrite wt_params.\nrewrite H10.\nauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f)) : Val.has_type_list args (proj_sig_args (RTL.fn_sig f)).","conclusion":"Val.has_type_list args (proj_sig_args (RTL.fn_sig f))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f))","proofString":"rewrite H10.\nauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f)) : Val.has_type_list args (proj_sig_args (fn_sig x)).","conclusion":"Val.has_type_list args (proj_sig_args (fn_sig x))","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (wt_params : map env (fn_params f) = proj_sig_args (RTL.fn_sig f)) (wt_norepet : list_norepet (fn_params f)) (wt_instrs : forall (pc : positive) (instr : RTL.instruction),\n(RTL.fn_code f) ! pc = Some instr -> wt_instr f env instr) (wt_entrypoint : valid_successor f (RTL.fn_entrypoint f))","proofString":"auto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (WTRS : wt_regset env (init_regs args (fn_params f))) : exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (Internal x) ls m'0) E0 S2' /\\\n  match_states\n    (RTL.State s f (Vptr stk Ptrofs.zero) (RTL.fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (WTRS : wt_regset env (init_regs args (fn_params f)))","proofString":"exploit (exec_moves mv).\neauto.\neauto.\neapply can_undef_satisf; eauto.\neapply compat_entry_satisf; eauto.\nrewrite call_regs_param_values.\neexact ARGS.\nexact WTRS.\nintros [ls1 [A B]].\neconstructor; split.\neapply plus_left.\neconstructor; eauto.\neapply star_left.\neconstructor; eauto.\neapply star_right.\neexact A.\neconstructor; eauto.\neauto.\neauto.\ntraceEq.\neconstructor; eauto."},{"statement":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (WTRS : wt_regset env (init_regs args (fn_params f))) : wf_moves mv.","conclusion":"wf_moves mv","hypotheses":"(s : list RTL.stackframe) (f : RTL.function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (RTL.fn_sig f))) (H0 : Mem.alloc m 0 (RTL.fn_stacksize f) = (m', stk)) (WT : wt_state (RTL.Callstate s (Internal f) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (x : function) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (fn_sig x)))) (STACKS : match_stackframes s ts (fn_sig x)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (fn_sig x))) (EQ : transf_function f = OK x) (env : regenv) (an : PMap.t DS.L.t) (mv : moves) (k : list instruction) (e1 e2 : eqs) (H1 : wt_function f env) (H2 : analyze f env (pair_codes f x) = Some an) (H3 : (fn_code x) ! (fn_entrypoint x) =\nSome (expand_moves mv (Lbranch (RTL.fn_entrypoint f) :: k))) (H4 : wf_moves mv) (H5 : transfer f env (pair_codes f x) (RTL.fn_entrypoint f)\n  an # (RTL.fn_entrypoint f) = OK e1) (H6 : track_moves env mv e1 = Some e2) (H7 : compat_entry (fn_params f) (loc_parameters (fn_sig x)) e2 = true) (H8 : can_undef destroyed_at_function_entry e2 = true) (H9 : RTL.fn_stacksize f = fn_stacksize x) (H10 : RTL.fn_sig f = fn_sig x) (m'' : Mem.mem') (U : Mem.alloc m'0 0 (fn_stacksize x) = (m'', stk)) (V : Mem.extends m' m'') (WTRS : wt_regset env (init_regs args (fn_params f)))","proofString":"eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf))) : exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf)))","proofString":"exploit external_call_mem_extends; eauto.\nintros [v' [m'' [F [G [J K]]]]].\nsimpl in FUN; inv FUN.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved with (ge1 := ge); eauto.\napply senv_preserved.\neconstructor; eauto.\nsimpl.\ndestruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto.\nred; intros.\nrewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence.\neapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf))) : (exists (vres' : val) (m2' : mem),\n   external_call ef ge\n     (map (fun p : rpair loc => Locmap.getpair p ls)\n        (loc_arguments (funsig tf))) m'0 t vres' m2' /\\\n   Val.lessdef res vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\nexists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'.","conclusion":"(exists (vres' : val) (m2' : mem),\n   external_call ef ge\n     (map (fun p : rpair loc => Locmap.getpair p ls)\n        (loc_arguments (funsig tf))) m'0 t vres' m2' /\\\n   Val.lessdef res vres' /\\\n   Mem.extends m' m2' /\\ Mem.unchanged_on (loc_out_of_bounds m) m'0 m2') ->\nexists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf)))","proofString":"intros [v' [m'' [F [G [J K]]]]].\nsimpl in FUN; inv FUN.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved with (ge1 := ge); eauto.\napply senv_preserved.\neconstructor; eauto.\nsimpl.\ndestruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto.\nred; intros.\nrewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence.\neapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))\n  m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts tf ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (tf : fundef) (ls : Locmap.t) (m'0 : mem) (STACKS : match_stackframes s ts (funsig tf)) (FUN : transf_fundef (External ef) = OK tf) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig tf))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls) (loc_arguments (funsig tf)))\n  m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"simpl in FUN; inv FUN.\neconstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved with (ge1 := ge); eauto.\napply senv_preserved.\neconstructor; eauto.\nsimpl.\ndestruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto.\nred; intros.\nrewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence.\neapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : exists S2' : state,\n  plus step tge (Callstate ts (External ef) ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'.","conclusion":"exists S2' : state,\n  plus step tge (Callstate ts (External ef) ls m'0) t S2' /\\\n  match_states (RTL.Returnstate s res m') S2'","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"econstructor; split.\napply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved with (ge1 := ge); eauto.\napply senv_preserved.\neconstructor; eauto.\nsimpl.\ndestruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto.\nred; intros.\nrewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence.\neapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"apply senv_preserved."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : Val.lessdef res\n  (Locmap.getpair (map_rpair R (loc_result (funsig (External ef))))\n     (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls))).","conclusion":"Val.lessdef res\n  (Locmap.getpair (map_rpair R (loc_result (funsig (External ef))))\n     (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"simpl.\ndestruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : Val.lessdef res\n  (Locmap.getpair (map_rpair R (loc_result (ef_sig ef)))\n     (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls))).","conclusion":"Val.lessdef res\n  (Locmap.getpair (map_rpair R (loc_result (ef_sig ef)))\n     (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"destruct (loc_result (ef_sig ef)) eqn:RES; simpl.\nrewrite Locmap.gss; auto.\ngeneralize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (r : mreg) (RES : loc_result (ef_sig ef) = One r) : Val.lessdef res (Locmap.set (R r) v' (undef_caller_save_regs ls) (R r)).","conclusion":"Val.lessdef res (Locmap.set (R r) v' (undef_caller_save_regs ls) (R r))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (r : mreg) (RES : loc_result (ef_sig ef) = One r)","proofString":"rewrite Locmap.gss; auto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) : Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo))).","conclusion":"Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo)","proofString":"generalize (loc_result_pair (ef_sig ef)); rewrite RES; intros (A & B & C & D & E).\nassert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) : Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo))).","conclusion":"Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false)","proofString":"assert (WTRES': Val.has_type v' Tlong).\nrewrite <- B.\neapply external_call_well_typed; eauto.\nrewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) : Val.has_type v' Tlong.","conclusion":"Val.has_type v' Tlong","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false)","proofString":"rewrite <- B.\neapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) : Val.has_type v' (proj_sig_res (ef_sig ef)).","conclusion":"Val.has_type v' (proj_sig_res (ef_sig ef))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false)","proofString":"eapply external_call_well_typed; eauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong) : Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo))).","conclusion":"Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi))\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rlo)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong)","proofString":"rewrite Locmap.gss.\nrewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong) : Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi)) (Val.loword v')).","conclusion":"Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rlo) (Val.loword v')\n        (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls))\n        (R rhi)) (Val.loword v'))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong)","proofString":"rewrite Locmap.gso by (red; auto).\nrewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong) : Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls) (R rhi))\n     (Val.loword v')).","conclusion":"Val.lessdef res\n  (Val.longofwords\n     (Locmap.set (R rhi) (Val.hiword v') (undef_caller_save_regs ls) (R rhi))\n     (Val.loword v'))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong)","proofString":"rewrite Locmap.gss.\nrewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong) : Val.lessdef res (Val.longofwords (Val.hiword v') (Val.loword v')).","conclusion":"Val.lessdef res (Val.longofwords (Val.hiword v') (Val.loword v'))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong)","proofString":"rewrite val_longofwords_eq_1 by auto.\nauto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong) : Val.lessdef res v'.","conclusion":"Val.lessdef res v'","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (rhi rlo : mreg) (RES : loc_result (ef_sig ef) = Twolong rhi rlo) (A : rhi <> rlo) (B : proj_sig_res (ef_sig ef) = Tlong) (C : subtype Tint (mreg_type rhi) = true) (D : subtype Tint (mreg_type rlo) = true) (E : Archi.ptr64 = false) (WTRES' : Val.has_type v' Tlong)","proofString":"auto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : agree_callee_save (parent_locset ts)\n  (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls)).","conclusion":"agree_callee_save (parent_locset ts)\n  (Locmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"red; intros.\nrewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l) : parent_locset ts l =\nLocmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls) l.","conclusion":"parent_locset ts l =\nLocmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls) l","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l)","proofString":"rewrite (AG l H0).\nrewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l) : ls l =\nLocmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls) l.","conclusion":"ls l =\nLocmap.setpair (loc_result (ef_sig ef)) v' (undef_caller_save_regs ls) l","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l)","proofString":"rewrite locmap_get_set_loc_result_callee_save by auto.\nunfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l) : ls l = undef_caller_save_regs ls l.","conclusion":"ls l = undef_caller_save_regs ls l","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l)","proofString":"unfold undef_caller_save_regs.\ndestruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l) : ls l =\nmatch l with\n| R r => if is_callee_save r then ls (R r) else Vundef\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend.","conclusion":"ls l =\nmatch l with\n| R r => if is_callee_save r then ls (R r) else Vundef\n| S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls (S sl ofs ty)\n| S Outgoing _ _ => Vundef\nend","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (l : loc) (H0 : callee_save_loc l)","proofString":"destruct l; simpl in H0.\nrewrite H0; auto.\ndestruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (r : mreg) (H0 : is_callee_save r = true) : ls (R r) = (if is_callee_save r then ls (R r) else Vundef).","conclusion":"ls (R r) = (if is_callee_save r then ls (R r) else Vundef)","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (r : mreg) (H0 : is_callee_save r = true)","proofString":"rewrite H0; auto."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (sl : slot) (pos : Z) (ty : typ) (H0 : sl <> Outgoing) : ls (S sl pos ty) =\nmatch sl with\n| Outgoing => Vundef\n| _ => ls (S sl pos ty)\nend.","conclusion":"ls (S sl pos ty) =\nmatch sl with\n| Outgoing => Vundef\n| _ => ls (S sl pos ty)\nend","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') (sl : slot) (pos : Z) (ty : typ) (H0 : sl <> Outgoing)","proofString":"destruct sl; auto; congruence."},{"statement":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'') : Val.has_type res (proj_sig_res (funsig (External ef))).","conclusion":"Val.has_type res (proj_sig_res (funsig (External ef)))","hypotheses":"(s : list RTL.stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (WT : wt_state (RTL.Callstate s (External ef) args m)) (ts : list stackframe) (ls : Locmap.t) (m'0 : mem) (ARGS : Val.lessdef_list args\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef))))) (STACKS : match_stackframes s ts (funsig (External ef))) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m'0) (WTARGS : Val.has_type_list args (proj_sig_args (funsig (External ef)))) (v' : val) (m'' : mem) (F : external_call ef ge\n  (map (fun p : rpair loc => Locmap.getpair p ls)\n     (loc_arguments (funsig (External ef)))) m'0 t v' m'') (G : Val.lessdef res v') (J : Mem.extends m' m'') (K : Mem.unchanged_on (loc_out_of_bounds m) m'0 m'')","proofString":"eapply external_call_well_typed; eauto."},{"statement":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ts : list stackframe) (ls : Locmap.t) (m' : mem) (sg : signature) (STACKS : match_stackframes (RTL.Stackframe res f sp pc rs :: s) ts sg) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) : exists S2' : state,\n  plus step tge (Returnstate ts ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc rs # res <- vres m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (Returnstate ts ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc rs # res <- vres m) S2'","hypotheses":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ts : list stackframe) (ls : Locmap.t) (m' : mem) (sg : signature) (STACKS : match_stackframes (RTL.Stackframe res f sp pc rs :: s) ts sg) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg))","proofString":"inv STACKS.\nexploit STEPS; eauto.\nrewrite WTRES0; auto.\nintros [ls2 [A B]].\neconstructor; split.\neapply plus_left.\nconstructor.\neexact A.\ntraceEq.\neconstructor; eauto.\napply wt_regset_assign; auto.\nrewrite WTRES0; auto."},{"statement":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v ls2 e) : exists S2' : state,\n  plus step tge (Returnstate (Stackframe tf sp ls0 bb :: ts0) ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc rs # res <- vres m) S2'.","conclusion":"exists S2' : state,\n  plus step tge (Returnstate (Stackframe tf sp ls0 bb :: ts0) ls m') E0 S2' /\\\n  match_states (RTL.State s f sp pc rs # res <- vres m) S2'","hypotheses":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v ls2 e)","proofString":"exploit STEPS; eauto.\nrewrite WTRES0; auto.\nintros [ls2 [A B]].\neconstructor; split.\neapply plus_left.\nconstructor.\neexact A.\ntraceEq.\neconstructor; eauto.\napply wt_regset_assign; auto.\nrewrite WTRES0; auto."},{"statement":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v ls2 e) : Val.has_type vres (env res).","conclusion":"Val.has_type vres (env res)","hypotheses":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls2 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls2 m0) /\\\n  satisf rs # res <- v ls2 e)","proofString":"rewrite WTRES0; auto."},{"statement":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls3 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls3 m0) /\\\n  satisf rs # res <- v ls3 e) (ls2 : locset) (A : star step tge (Block ts0 tf sp bb ls m') E0 (State ts0 tf sp pc ls2 m')) (B : satisf rs # res <- vres ls2 e) : wt_regset env rs # res <- vres.","conclusion":"wt_regset env rs # res <- vres","hypotheses":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls3 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls3 m0) /\\\n  satisf rs # res <- v ls3 e) (ls2 : locset) (A : star step tge (Block ts0 tf sp bb ls m') E0 (State ts0 tf sp pc ls2 m')) (B : satisf rs # res <- vres ls2 e)","proofString":"apply wt_regset_assign; auto.\nrewrite WTRES0; auto."},{"statement":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls3 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls3 m0) /\\\n  satisf rs # res <- v ls3 e) (ls2 : locset) (A : star step tge (Block ts0 tf sp bb ls m') E0 (State ts0 tf sp pc ls2 m')) (B : satisf rs # res <- vres ls2 e) : Val.has_type vres (env res).","conclusion":"Val.has_type vres (env res)","hypotheses":"(res : reg) (f : RTL.function) (sp : val) (pc : RTL.node) (rs : regset) (s : list RTL.stackframe) (vres : val) (m : mem) (WT : wt_state (RTL.Returnstate (RTL.Stackframe res f sp pc rs :: s) vres m)) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef vres (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (tf : function) (bb : bblock) (ls0 : Locmap.t) (ts0 : list stackframe) (AG : agree_callee_save (parent_locset (Stackframe tf sp ls0 bb :: ts0)) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type vres (proj_sig_res sg)) (an : PMap.t DS.L.t) (e : eqs) (env : regenv) (STACKS0 : match_stackframes s ts0 (fn_sig tf)) (FUN : transf_function f = OK tf) (ANL : analyze f env (pair_codes f tf) = Some an) (EQ : transfer f env (pair_codes f tf) pc an # pc = OK e) (WTF : wt_function f env) (WTRS : wt_regset env rs) (WTRES0 : env res = proj_sig_res sg) (STEPS : forall (v : val) (ls1 : Locmap.t) (m0 : mem),\nVal.lessdef v (Locmap.getpair (map_rpair R (loc_result sg)) ls1) ->\nVal.has_type v (env res) ->\nagree_callee_save ls0 ls1 ->\nexists ls3 : locset,\n  star step tge (Block ts0 tf sp bb ls1 m0) E0 (State ts0 tf sp pc ls3 m0) /\\\n  satisf rs # res <- v ls3 e) (ls2 : locset) (A : star step tge (Block ts0 tf sp bb ls m') E0 (State ts0 tf sp pc ls2 m')) (B : satisf rs # res <- vres ls2 e)","proofString":"rewrite WTRES0; auto."},{"statement":"(st1 : RTL.state) (H : RTL.initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","conclusion":"exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2","hypotheses":"(st1 : RTL.state) (H : RTL.initial_state prog st1)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros [tf [FIND TR]].\nexploit sig_function_translated; eauto.\nintros SIG.\nexists (LTL.Callstate nil tf (Locmap.init Vundef) m0); split.\neconstructor; eauto.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nrewrite symbols_preserved.\nrewrite (match_program_main TRANSF).\nauto.\ncongruence.\nconstructor; auto.\nconstructor.\nrewrite SIG; rewrite H3; auto.\nrewrite SIG, H3, loc_arguments_main.\nauto.\nred; auto.\napply Mem.extends_refl.\nrewrite SIG, H3.\nconstructor."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Genv.init_mem tprog = Some m0.","conclusion":"Genv.init_mem tprog = Some m0","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"eapply (Genv.init_mem_transf_partial TRANSF); eauto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : funsig tf = signature_main.","conclusion":"funsig tf = signature_main","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"congruence."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : match_states (RTL.Callstate nil f nil m0)\n  (Callstate nil tf (Locmap.init Vundef) m0).","conclusion":"match_states (RTL.Callstate nil f nil m0)\n  (Callstate nil tf (Locmap.init Vundef) m0)","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"constructor; auto.\nconstructor.\nrewrite SIG; rewrite H3; auto.\nrewrite SIG, H3, loc_arguments_main.\nauto.\nred; auto.\napply Mem.extends_refl.\nrewrite SIG, H3.\nconstructor."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : match_stackframes nil nil (funsig tf).","conclusion":"match_stackframes nil nil (funsig tf)","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"constructor.\nrewrite SIG; rewrite H3; auto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : sig_res (funsig tf) = Xint.","conclusion":"sig_res (funsig tf) = Xint","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"rewrite SIG; rewrite H3; auto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Val.lessdef_list nil\n  (map (fun p : rpair loc => Locmap.getpair p (Locmap.init Vundef))\n     (loc_arguments (funsig tf))).","conclusion":"Val.lessdef_list nil\n  (map (fun p : rpair loc => Locmap.getpair p (Locmap.init Vundef))\n     (loc_arguments (funsig tf)))","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"rewrite SIG, H3, loc_arguments_main.\nauto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Val.lessdef_list nil\n  (map (fun p : rpair loc => Locmap.getpair p (Locmap.init Vundef)) nil).","conclusion":"Val.lessdef_list nil\n  (map (fun p : rpair loc => Locmap.getpair p (Locmap.init Vundef)) nil)","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"auto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : agree_callee_save (parent_locset nil) (Locmap.init Vundef).","conclusion":"agree_callee_save (parent_locset nil) (Locmap.init Vundef)","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"red; auto."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Mem.extends m0 m0.","conclusion":"Mem.extends m0 m0","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"apply Mem.extends_refl."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Val.has_type_list nil (proj_sig_args (funsig tf)).","conclusion":"Val.has_type_list nil (proj_sig_args (funsig tf))","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"rewrite SIG, H3.\nconstructor."},{"statement":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f) : Val.has_type_list nil (proj_sig_args signature_main).","conclusion":"Val.has_type_list nil (proj_sig_args signature_main)","hypotheses":"(b : block) (f : RTL.fundef) (m0 : mem) (ge0 : Genv.t RTL.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : RTL.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transf_fundef f = OK tf) (SIG : funsig tf = RTL.funsig f)","proofString":"constructor."},{"statement":"(st1 : RTL.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : RTL.final_state st1 r) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st1 : RTL.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : RTL.final_state st1 r)","proofString":"inv H0.\ninv H.\ninv STACKS.\neconstructor.\nrewrite <- (loc_result_exten sg).\ninv RES; auto.\nrewrite H; auto."},{"statement":"(st2 : state) (r : int) (m : mem) (H : match_states (RTL.Returnstate nil (Vint r) m) st2) : final_state st2 r.","conclusion":"final_state st2 r","hypotheses":"(st2 : state) (r : int) (m : mem) (H : match_states (RTL.Returnstate nil (Vint r) m) st2)","proofString":"inv H.\ninv STACKS.\neconstructor.\nrewrite <- (loc_result_exten sg).\ninv RES; auto.\nrewrite H; auto."},{"statement":"(r : int) (m : mem) (ts : list stackframe) (ls : Locmap.t) (m' : mem) (sg : signature) (STACKS : match_stackframes nil ts sg) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) : final_state (Returnstate ts ls m') r.","conclusion":"final_state (Returnstate ts ls m') r","hypotheses":"(r : int) (m : mem) (ts : list stackframe) (ls : Locmap.t) (m' : mem) (sg : signature) (STACKS : match_stackframes nil ts sg) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset ts) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg))","proofString":"inv STACKS.\neconstructor.\nrewrite <- (loc_result_exten sg).\ninv RES; auto.\nrewrite H; auto."},{"statement":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint) : final_state (Returnstate nil ls m') r.","conclusion":"final_state (Returnstate nil ls m') r","hypotheses":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint)","proofString":"econstructor.\nrewrite <- (loc_result_exten sg).\ninv RES; auto.\nrewrite H; auto."},{"statement":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint) : Locmap.getpair (map_rpair R (loc_result signature_main)) ls = Vint r.","conclusion":"Locmap.getpair (map_rpair R (loc_result signature_main)) ls = Vint r","hypotheses":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint)","proofString":"rewrite <- (loc_result_exten sg).\ninv RES; auto.\nrewrite H; auto."},{"statement":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint) : Locmap.getpair (map_rpair R (loc_result sg)) ls = Vint r.","conclusion":"Locmap.getpair (map_rpair R (loc_result sg)) ls = Vint r","hypotheses":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint)","proofString":"inv RES; auto."},{"statement":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint) : sig_res sg = sig_res signature_main.","conclusion":"sig_res sg = sig_res signature_main","hypotheses":"(r : int) (m : mem) (ls : Locmap.t) (m' : mem) (sg : signature) (RES : Val.lessdef (Vint r) (Locmap.getpair (map_rpair R (loc_result sg)) ls)) (AG : agree_callee_save (parent_locset nil) ls) (MEM : Mem.extends m m') (WTRES : Val.has_type (Vint r) (proj_sig_res sg)) (H : sig_res sg = Xint)","proofString":"rewrite H; auto."},{"statement":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog)) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog))","proofString":"exploit list_forall2_in_left.\neexact (proj1 TRANSF).\neauto.\nintros ([i' gd] & A & B & C).\nsimpl in *; subst i'.\ninv C.\ndestruct f; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto.\nconstructor."},{"statement":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog)) (gd : globdef fundef unit) (A : In (i, gd) (prog_defs tprog)) (C : match_globdef\n  (fun (_ : AST.program RTL.fundef unit) (f0 : RTL.fundef) (tf : fundef) =>\n   transf_fundef f0 = OK tf) eq prog (Gfun f) gd) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog)) (gd : globdef fundef unit) (A : In (i, gd) (prog_defs tprog)) (C : match_globdef\n  (fun (_ : AST.program RTL.fundef unit) (f0 : RTL.fundef) (tf : fundef) =>\n   transf_fundef f0 = OK tf) eq prog (Gfun f) gd)","proofString":"inv C.\ndestruct f; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto.\nconstructor."},{"statement":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : transf_fundef f = OK f2) : wt_fundef f.","conclusion":"wt_fundef f","hypotheses":"(i : ident) (f : RTL.fundef) (H : In (i, Gfun f) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : transf_fundef f = OK f2)","proofString":"destruct f; simpl in *.\nmonadInv H2.\nunfold transf_function in EQ.\ndestruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto.\nconstructor."},{"statement":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK f2) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : bind (transf_function f) (fun f' : function => OK (Internal f')) = OK f2)","proofString":"monadInv H2.\nunfold transf_function in EQ.\ndestruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto."},{"statement":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (EQ : transf_function f = OK x) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (EQ : transf_function f = OK x)","proofString":"unfold transf_function in EQ.\ndestruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto."},{"statement":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (EQ : match type_function f with\n| OK env =>\n    match regalloc f with\n    | OK tf => bind (check_function f tf env) (fun _ : unit => OK tf)\n    | Error m => Error m\n    end\n| Error m => Error m\nend = OK x) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (EQ : match type_function f with\n| OK env =>\n    match regalloc f with\n    | OK tf => bind (check_function f tf env) (fun _ : unit => OK tf)\n    | Error m => Error m\n    end\n| Error m => Error m\nend = OK x)","proofString":"destruct (type_function f) as [env|] eqn:TF; try discriminate.\neconstructor.\neapply type_function_correct; eauto."},{"statement":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (env : regenv) (TF : type_function f = OK env) (EQ : match regalloc f with\n| OK tf => bind (check_function f tf env) (fun _ : unit => OK tf)\n| Error m => Error m\nend = OK x) : wt_fundef (Internal f).","conclusion":"wt_fundef (Internal f)","hypotheses":"(i : ident) (f : RTL.function) (H : In (i, Gfun (Internal f)) (prog_defs prog)) (x : function) (A : In (i, Gfun (Internal x)) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (env : regenv) (TF : type_function f = OK env) (EQ : match regalloc f with\n| OK tf => bind (check_function f tf env) (fun _ : unit => OK tf)\n| Error m => Error m\nend = OK x)","proofString":"econstructor.\neapply type_function_correct; eauto."},{"statement":"(i : ident) (e : external_function) (H : In (i, Gfun (External e)) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : OK (External e) = OK f2) : wt_fundef (External e).","conclusion":"wt_fundef (External e)","hypotheses":"(i : ident) (e : external_function) (H : In (i, Gfun (External e)) (prog_defs prog)) (f2 : fundef) (A : In (i, Gfun f2) (prog_defs tprog)) (ctx' : AST.program RTL.fundef unit) (H1 : linkorder ctx' prog) (H2 : OK (External e) = OK f2)","proofString":"constructor."},{"statement":"(ms : RTL.state -> state -> Prop) : forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (RTL.semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (RTL.semantics prog)) id","hypotheses":"(ms : RTL.state -> state -> Prop)","proofString":"apply senv_preserved."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (H : Smallstep.initial_state (RTL.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2) : wt_state s1.","conclusion":"wt_state s1","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (H : Smallstep.initial_state (RTL.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2)","proofString":"apply wt_initial_state with (p := prog); auto.\nexact wt_prog."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (H : Smallstep.initial_state (RTL.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2) : wt_program prog.","conclusion":"wt_program prog","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (H : Smallstep.initial_state (RTL.semantics prog) s1) (st2 : state) (A : initial_state tprog st2) (B : match_states s1 st2)","proofString":"exact wt_prog."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : wt_state s1) (H1 : match_states s1 s2) (H0 : Smallstep.final_state (RTL.semantics prog) s1 r) : Smallstep.final_state (semantics tprog) s2 r.","conclusion":"Smallstep.final_state (semantics tprog) s2 r","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (s2 : Smallstep.state (semantics tprog)) (r : int) (H : wt_state s1) (H1 : match_states s1 s2) (H0 : Smallstep.final_state (RTL.semantics prog) s1 r)","proofString":"eapply final_states_simulation; eauto."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : Plus (semantics tprog) s2 t s2'.","conclusion":"Plus (semantics tprog) s2 t s2'","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"exact A."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : wt_state s1'.","conclusion":"wt_state s1'","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"eapply subject_reduction; eauto.\neexact wt_prog.\neexact H."},{"statement":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2') : match_states s1' s2'.","conclusion":"match_states s1' s2'","hypotheses":"(ms : RTL.state -> state -> Prop) (s1 : Smallstep.state (RTL.semantics prog)) (t : trace) (s1' : Smallstep.state (RTL.semantics prog)) (H : Step (RTL.semantics prog) s1 t s1') (s2 : Smallstep.state (semantics tprog)) (H0 : wt_state s1) (H1 : match_states s1 s2) (s2' : state) (A : plus step tge s2 t s2') (B : match_states s1' s2')","proofString":"auto."}]}