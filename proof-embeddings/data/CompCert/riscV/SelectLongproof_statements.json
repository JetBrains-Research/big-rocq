{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/riscV/SelectLongproof.v","fileSamples":[{"statement":"(le : letenv) (n : int64) : eval_expr ge sp e m le (Eop (Olongconst n) Enil) (Vlong n).","proofString":"EvalOp."},{"statement":"(v : val) (a : expr) (n : int64) (le : letenv) (H : match is_longconst_match a with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) (H0 : eval_expr ge sp e m le a v) : v = Vlong n.","proofString":"eapply SplitLongproof.is_longconst_sound; eauto."},{"statement":"(v : val) (n : int64) (le : letenv) (H0 : eval_expr ge sp e m le (Eop (Olongconst n) Enil) v) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : v = Vlong n.","proofString":"InvEval.\nauto."},{"statement":"(n : int64) (le : letenv) (H : match is_longconst_match (Eop (Olongconst n) Enil) with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : Vlong n = Vlong n.","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.addl x (Vlong Int64.zero)) x.","proofString":"destruct x; simpl; rewrite ?Int64.add_zero, ?Ptrofs.add_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    match addlimm_match a with\n    | addlimm_case1 m0 => longconst (Int64.add n m0)\n    | addlimm_case2 s m0 =>\n        Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case3 m0 =>\n        Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil\n    | addlimm_case4 m0 t => Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)\n    | addlimm_default e0 => Eop (Oaddlimm n) (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.addl x (Vlong n)) v.","proofString":"destruct (addlimm_match a); InvEval.\neconstructor; split.\napply eval_longconst.\nrewrite Int64.add_commut; auto.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge s); simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_commut; auto.\neconstructor; split.\nEvalOp.\nsimpl; eauto.\ndestruct sp; simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0).\nauto.\nsubst x.\nrewrite Val.addl_assoc.\nrewrite Int64.add_commut.\nTrivialExists.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (m0 : int64) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add n m0)) v /\\\n  Val.lessdef (Val.addl (Vlong m0) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nrewrite Int64.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (s : ident) (m0 : ptrofs) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrsymbol s (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Genv.symbol_address ge s m0) (Vlong n)) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\nunfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge s); simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (s : ident) (m0 : ptrofs) (H0 : n <> Int64.zero) : Val.lessdef (Val.addl (Genv.symbol_address ge s m0) (Vlong n))\n  (Genv.symbol_address ge s (Ptrofs.add (Ptrofs.of_int64 n) m0)).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge s); simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (s : ident) (m0 : ptrofs) (H0 : n <> Int64.zero) : Val.lessdef\n  (Val.addl\n     match Genv.find_symbol ge s with\n     | Some b => Vptr b m0\n     | None => Vundef\n     end (Vlong n))\n  match Genv.find_symbol ge s with\n  | Some b => Vptr b (Ptrofs.add (Ptrofs.of_int64 n) m0)\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol ge s); simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (s : ident) (m0 : ptrofs) (H0 : n <> Int64.zero) (b : block) : Val.lessdef\n  (if Archi.ptr64 then Vptr b (Ptrofs.add m0 (Ptrofs.of_int64 n)) else Vundef)\n  (Vptr b (Ptrofs.add (Ptrofs.of_int64 n) m0)).","proofString":"destruct Archi.ptr64; auto.\nrewrite Ptrofs.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (s : ident) (m0 : ptrofs) (H0 : n <> Int64.zero) (b : block) : Val.lessdef (Vptr b (Ptrofs.add m0 (Ptrofs.of_int64 n)))\n  (Vptr b (Ptrofs.add (Ptrofs.of_int64 n) m0)).","proofString":"rewrite Ptrofs.add_commut; auto."},{"statement":"(n : int64) (le : letenv) (m0 : ptrofs) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oaddrstack (Ptrofs.add (Ptrofs.of_int64 n) m0)) Enil) v /\\\n  Val.lessdef (Val.addl (Val.offset_ptr sp m0) (Vlong n)) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl; eauto.\ndestruct sp; simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0).\nauto."},{"statement":"(n : int64) (le : letenv) (m0 : ptrofs) (H0 : n <> Int64.zero) : Val.lessdef (Val.addl (Val.offset_ptr sp m0) (Vlong n))\n  (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n) m0)).","proofString":"destruct sp; simpl; auto.\ndestruct Archi.ptr64; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0).\nauto."},{"statement":"(n : int64) (le : letenv) (m0 : ptrofs) (H0 : n <> Int64.zero) (b : block) (i : ptrofs) : Val.lessdef\n  (if Archi.ptr64\n   then Vptr b (Ptrofs.add (Ptrofs.add i m0) (Ptrofs.of_int64 n))\n   else Vundef) (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0))).","proofString":"destruct Archi.ptr64; auto.\nrewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0).\nauto."},{"statement":"(n : int64) (le : letenv) (m0 : ptrofs) (H0 : n <> Int64.zero) (b : block) (i : ptrofs) : Val.lessdef (Vptr b (Ptrofs.add (Ptrofs.add i m0) (Ptrofs.of_int64 n)))\n  (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0))).","proofString":"rewrite Ptrofs.add_assoc, (Ptrofs.add_commut m0).\nauto."},{"statement":"(n : int64) (le : letenv) (m0 : ptrofs) (H0 : n <> Int64.zero) (b : block) (i : ptrofs) : Val.lessdef (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0)))\n  (Vptr b (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n) m0))).","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (x : val) (m0 : int64) (t : expr) (H0 : n <> Int64.zero) (v1 : val) (H3 : eval_expr ge sp e m le t v1) (H : Val.addl v1 (Vlong m0) = x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Vlong n)) v.","proofString":"subst x.\nrewrite Val.addl_assoc.\nrewrite Int64.add_commut.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (m0 : int64) (t : expr) (H0 : n <> Int64.zero) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong m0)) (Vlong n)) v.","proofString":"rewrite Val.addl_assoc.\nrewrite Int64.add_commut.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (m0 : int64) (t : expr) (H0 : n <> Int64.zero) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add n m0)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl v1 (Val.addl (Vlong m0) (Vlong n))) v.","proofString":"rewrite Int64.add_commut.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (m0 : int64) (t : expr) (H0 : n <> Int64.zero) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm (Int64.add m0 n)) (t ::: Enil)) v /\\\n  Val.lessdef (Val.addl v1 (Val.addl (Vlong m0) (Vlong n))) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddlimm n) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.addl x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl (Vlong n1) y) v.","proofString":"rewrite Val.addl_commut.\napply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 t2) v /\\\n  Val.lessdef (Val.addl y (Vlong n1)) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 t1) v /\\\n  Val.lessdef (Val.addl x (Vlong n2)) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.addl v1 (Vlong n1) = x) (H0 : Val.addl v0 (Vlong n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl x y) v.","proofString":"subst.\nreplace (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)))       with (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v.","proofString":"replace (Val.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)))       with (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.add n1 n2) (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2))) v.","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 v0).","proofString":"EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl (Val.addl v1 v0) (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2)).","proofString":"repeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_permut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl v1 (Val.addl v0 (Val.addl (Vlong n1) (Vlong n2))) =\nVal.addl v1 (Val.addl (Vlong n1) (Val.addl v0 (Vlong n2))).","proofString":"decEq.\napply Val.addl_permut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.addl v0 (Val.addl (Vlong n1) (Vlong n2)) =\nVal.addl (Vlong n1) (Val.addl v0 (Vlong n2)).","proofString":"apply Val.addl_permut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2))\n  (Val.addl (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) v1).","proofString":"simpl; eauto.\nrewrite Val.addl_commut.\ndestruct sp; simpl; auto.\ndestruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) (Val.offset_ptr sp n2))\n  (Val.addl (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) v1).","proofString":"rewrite Val.addl_commut.\ndestruct sp; simpl; auto.\ndestruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.lessdef (Val.addl (Val.offset_ptr sp n2) (Val.addl v1 (Vlong n1)))\n  (Val.addl (Val.offset_ptr sp (Ptrofs.add (Ptrofs.of_int64 n1) n2)) v1).","proofString":"destruct sp; simpl; auto.\ndestruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 v1) : Val.lessdef\n  match Val.addl v1 (Vlong n1) with\n  | Vlong n0 =>\n      if Archi.ptr64\n      then Vptr b0 (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 n0))\n      else Vundef\n  | _ => Vundef\n  end\n  match v1 with\n  | Vlong n0 =>\n      if Archi.ptr64\n      then\n       Vptr b0\n         (Ptrofs.add (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))\n            (Ptrofs.of_int64 n0))\n      else Vundef\n  | _ => Vundef\n  end.","proofString":"destruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) : Val.lessdef\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 (Int64.add i0 n1)))\n   else Vundef)\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))\n         (Ptrofs.of_int64 i0))\n   else Vundef).","proofString":"destruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Val.lessdef\n  (Vptr b0 (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 (Int64.add i0 n1))))\n  (Vptr b0\n     (Ptrofs.add (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))\n        (Ptrofs.of_int64 i0))).","proofString":"apply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Vptr b0 (Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 (Int64.add i0 n1))) =\nVptr b0\n  (Ptrofs.add (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))\n     (Ptrofs.of_int64 i0)).","proofString":"f_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.add i n2) (Ptrofs.of_int64 (Int64.add i0 n1)) =\nPtrofs.add (Ptrofs.add i (Ptrofs.add (Ptrofs.of_int64 n1) n2))\n  (Ptrofs.of_int64 i0).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add i (Ptrofs.add n2 (Ptrofs.of_int64 (Int64.add i0 n1))) =\nPtrofs.add i\n  (Ptrofs.add (Ptrofs.of_int64 n1) (Ptrofs.add n2 (Ptrofs.of_int64 i0))).","proofString":"f_equal.\nrewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add n2 (Ptrofs.of_int64 (Int64.add i0 n1)) =\nPtrofs.add (Ptrofs.of_int64 n1) (Ptrofs.add n2 (Ptrofs.of_int64 i0)).","proofString":"rewrite (Ptrofs.add_commut (Ptrofs.of_int64 n1)), Ptrofs.add_assoc.\nf_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add n2 (Ptrofs.of_int64 (Int64.add i0 n1)) =\nPtrofs.add n2 (Ptrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 n1)).","proofString":"f_equal.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : int64) (t1 : expr) (n2 : ptrofs) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t1 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i0 n1) =\nPtrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 n1).","proofString":"auto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Val.lessdef (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2)))\n  (Val.addl (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))) v1).","proofString":"simpl; eauto.\ndestruct sp; simpl; auto.\ndestruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : Val.lessdef (Val.addl (Val.offset_ptr sp n1) (Val.addl v1 (Vlong n2)))\n  (Val.addl (Val.offset_ptr sp (Ptrofs.add n1 (Ptrofs.of_int64 n2))) v1).","proofString":"destruct sp; simpl; auto.\ndestruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (v1 : val) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 v1) : Val.lessdef\n  match Val.addl v1 (Vlong n2) with\n  | Vlong n0 =>\n      if Archi.ptr64\n      then Vptr b0 (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 n0))\n      else Vundef\n  | _ => Vundef\n  end\n  match v1 with\n  | Vlong n0 =>\n      if Archi.ptr64\n      then\n       Vptr b0\n         (Ptrofs.add (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))\n            (Ptrofs.of_int64 n0))\n      else Vundef\n  | _ => Vundef\n  end.","proofString":"destruct v1; simpl; auto.\ndestruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) : Val.lessdef\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 (Int64.add i0 n2)))\n   else Vundef)\n  (if Archi.ptr64\n   then\n    Vptr b0\n      (Ptrofs.add (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))\n         (Ptrofs.of_int64 i0))\n   else Vundef).","proofString":"destruct Archi.ptr64 eqn:SF; auto.\napply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Val.lessdef\n  (Vptr b0 (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 (Int64.add i0 n2))))\n  (Vptr b0\n     (Ptrofs.add (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))\n        (Ptrofs.of_int64 i0))).","proofString":"apply Val.lessdef_same.\nf_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Vptr b0 (Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 (Int64.add i0 n2))) =\nVptr b0\n  (Ptrofs.add (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))\n     (Ptrofs.of_int64 i0)).","proofString":"f_equal.\nrewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add (Ptrofs.add i n1) (Ptrofs.of_int64 (Int64.add i0 n2)) =\nPtrofs.add (Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 n2)))\n  (Ptrofs.of_int64 i0).","proofString":"rewrite ! Ptrofs.add_assoc.\nf_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add i (Ptrofs.add n1 (Ptrofs.of_int64 (Int64.add i0 n2))) =\nPtrofs.add i\n  (Ptrofs.add n1 (Ptrofs.add (Ptrofs.of_int64 n2) (Ptrofs.of_int64 i0))).","proofString":"f_equal.\nf_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.add n1 (Ptrofs.of_int64 (Int64.add i0 n2)) =\nPtrofs.add n1 (Ptrofs.add (Ptrofs.of_int64 n2) (Ptrofs.of_int64 i0)).","proofString":"f_equal.\nrewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i0 n2) =\nPtrofs.add (Ptrofs.of_int64 n2) (Ptrofs.of_int64 i0).","proofString":"rewrite Ptrofs.add_commut.\nauto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (n1 : ptrofs) (n2 : int64) (t2 : expr) (i0 : int64) (b0 : block) (i : ptrofs) (H2 : eval_expr ge (Vptr b0 i) e m le t2 (Vlong i0)) (SF : Archi.ptr64 = true) : Ptrofs.of_int64 (Int64.add i0 n2) =\nPtrofs.add (Ptrofs.of_int64 i0) (Ptrofs.of_int64 n2).","proofString":"auto with ptrofs."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 (Vlong n1)) y) v.","proofString":"replace (Val.addl (Val.addl v1 (Vlong n1)) y)       with (Val.addl (Val.addl v1 y) (Vlong n1)).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_commut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl v1 y) (Vlong n1)) v.","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl v1 y).","proofString":"EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl (Val.addl v1 y) (Vlong n1) = Val.addl (Val.addl v1 (Vlong n1)) y.","proofString":"repeat rewrite Val.addl_assoc.\ndecEq.\napply Val.addl_commut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl v1 (Val.addl y (Vlong n1)) = Val.addl v1 (Val.addl (Vlong n1) y).","proofString":"decEq.\napply Val.addl_commut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a b : expr) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.addl y (Vlong n1) = Val.addl (Vlong n1) y.","proofString":"apply Val.addl_commut."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl x (Val.addl v1 (Vlong n2))) v.","proofString":"replace (Val.addl x (Val.addl v1 (Vlong n2)))       with (Val.addl (Val.addl x v1) (Vlong n2)).\napply eval_addlimm.\nEvalOp.\nrepeat rewrite Val.addl_assoc.\nreflexivity."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n2 (Eop Oaddl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.addl x v1) (Vlong n2)) v.","proofString":"apply eval_addlimm.\nEvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : eval_expr ge sp e m le (Eop Oaddl (t1 ::: t2 ::: Enil)) (Val.addl x v1).","proofString":"EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : Val.addl (Val.addl x v1) (Vlong n2) = Val.addl x (Val.addl v1 (Vlong n2)).","proofString":"repeat rewrite Val.addl_assoc.\nreflexivity."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int64) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : Val.addl x (Val.addl v1 (Vlong n2)) = Val.addl x (Val.addl v1 (Vlong n2)).","proofString":"reflexivity."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.subl x (Vlong n2)) v.","proofString":"rewrite Val.subl_addl_opp.\napply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.neg n2) t1) v /\\\n  Val.lessdef (Val.addl x (Vlong (Int64.neg n2))) v.","proofString":"apply eval_addlimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Val.addl v1 (Vlong n1) = x) (H0 : Val.addl v0 (Vlong n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x y) v.","proofString":"subst.\nrewrite Val.subl_addl_l.\nrewrite Val.subl_addl_r.\nrewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) (Val.addl v0 (Vlong n2))) v.","proofString":"rewrite Val.subl_addl_l.\nrewrite Val.subl_addl_r.\nrewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 (Val.addl v0 (Vlong n2))) (Vlong n1)) v.","proofString":"rewrite Val.subl_addl_r.\nrewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.addl (Val.subl v1 v0) (Vlong (Int64.neg n2))) (Vlong n1))\n    v.","proofString":"rewrite Val.addl_assoc.\nsimpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Val.addl (Vlong (Int64.neg n2)) (Vlong n1)))\n    v.","proofString":"simpl.\nrewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add (Int64.neg n2) n1))) v.","proofString":"rewrite Int64.add_commut.\nrewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.addl (Val.subl v1 v0) (Vlong (Int64.add n1 (Int64.neg n2)))) v.","proofString":"rewrite <- Int64.sub_add_opp.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (t1 : expr) (n2 : int64) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.sub n1 n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 v0) (Vlong (Int64.sub n1 n2))) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H : Val.addl v1 (Vlong n1) = x) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x y) v.","proofString":"subst.\nrewrite Val.subl_addl_l.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl (Val.addl v1 (Vlong n1)) y) v.","proofString":"rewrite Val.subl_addl_l.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addlimm n1 (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl v1 y) (Vlong n1)) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (t2 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) (H0 : Val.addl v1 (Vlong n2) = y) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x y) v.","proofString":"subst.\nrewrite Val.subl_addl_r.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (t2 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.subl x (Val.addl v1 (Vlong n2))) v.","proofString":"rewrite Val.subl_addl_r.\napply eval_addlimm; EvalOp."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (t2 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addlimm (Int64.neg n2) (Eop Osubl (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.addl (Val.subl x v1) (Vlong (Int64.neg n2))) v.","proofString":"apply eval_addlimm; EvalOp."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shll x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shl' i Int.zero)) (Vlong i).","proofString":"change (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shl i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shl_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shl' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shll (Vlong n1) (Vint n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shrlu x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shru' i Int.zero)) (Vlong i).","proofString":"change (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shru i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shru_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shru' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrlu (Vlong n1) (Vint n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; rewrite LT; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.shrl x (Vint n)) x.","proofString":"subst n; destruct x; simpl; auto.\ndestruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","proofString":"destruct (Int.ltu Int.zero Int64.iwordsize'); auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr' i Int.zero)) (Vlong i).","proofString":"change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.shr i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.shr_zero; auto."},{"statement":"(n : int) (SL : Archi.splitlong = true) (le : letenv) (n1 : int64) (H0 : n <> Int.zero) (LT : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.shr' n1 n)) Enil) v /\\\n  Val.lessdef (Val.shrl (Vlong n1) (Vint n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; rewrite LT; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists (Vlong Int64.zero); split.\napply eval_longconst.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : eval_expr ge sp e m le (Eop (Olongconst Int64.zero) Enil) (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : Val.lessdef (Val.mull x (Vlong n)) (Vlong Int64.zero).","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) (H0 : n = Int64.zero) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong Int64.zero).","proofString":"subst n; rewrite Int64.mul_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Val.mull x (Vlong n)) x.","proofString":"destruct x; simpl; auto.\nsubst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : Val.lessdef (Vlong (Int64.mul i n)) (Vlong i).","proofString":"subst n; rewrite Int64.mul_one; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mull (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nrewrite Int64.mul_commut; auto."},{"statement":"(n : int64) (le : letenv) (x : val) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H : Val.addl v1 (Vlong n2) = x) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exploit (eval_mullimm_base n); eauto.\nintros (v2 & A2 & B2).\nexploit (eval_addlimm (Int64.mul n n2)).\neexact A2.\nintros (v3 & A3 & B3).\nexists v3; split; auto.\nsubst x.\ndestruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (x : val) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H : Val.addl v1 (Vlong n2) = x) : (exists v : val,\n   eval_expr ge sp e m le (mullimm_base n t2) v /\\\n   Val.lessdef (Val.mull v1 (Vlong n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"intros (v2 & A2 & B2).\nexploit (eval_addlimm (Int64.mul n n2)).\neexact A2.\nintros (v3 & A3 & B3).\nexists v3; split; auto.\nsubst x.\ndestruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (x : val) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H : Val.addl v1 (Vlong n2) = x) (v2 : val) (A2 : eval_expr ge sp e m le (mullimm_base n t2) v2) (B2 : Val.lessdef (Val.mull v1 (Vlong n)) v2) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exploit (eval_addlimm (Int64.mul n n2)).\neexact A2.\nintros (v3 & A3 & B3).\nexists v3; split; auto.\nsubst x.\ndestruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (x : val) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H : Val.addl v1 (Vlong n2) = x) (v2 : val) (A2 : eval_expr ge sp e m le (mullimm_base n t2) v2) (B2 : Val.lessdef (Val.mull v1 (Vlong n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v3) (B3 : Val.lessdef (Val.addl v2 (Vlong (Int64.mul n n2))) v3) : exists v : val,\n  eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","proofString":"exists v3; split; auto.\nsubst x.\ndestruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (x : val) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (H : Val.addl v1 (Vlong n2) = x) (v2 : val) (A2 : eval_expr ge sp e m le (mullimm_base n t2) v2) (B2 : Val.lessdef (Val.mull v1 (Vlong n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v3) (B3 : Val.lessdef (Val.addl v2 (Vlong (Int64.mul n n2))) v3) : Val.lessdef (Val.mull x (Vlong n)) v3.","proofString":"subst x.\ndestruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v2 : val) (A2 : eval_expr ge sp e m le (mullimm_base n t2) v2) (B2 : Val.lessdef (Val.mull v1 (Vlong n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v3) (B3 : Val.lessdef (Val.addl v2 (Vlong (Int64.mul n n2))) v3) : Val.lessdef (Val.mull (Val.addl v1 (Vlong n2)) (Vlong n)) v3.","proofString":"destruct v1; simpl; auto.\nsimpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int64) (H4 : eval_expr ge sp e m le t2 (Vlong i)) (v2 : val) (A2 : eval_expr ge sp e m le (mullimm_base n t2) v2) (B2 : Val.lessdef (Val.mull (Vlong i) (Vlong n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v3) (B3 : Val.lessdef (Val.addl v2 (Vlong (Int64.mul n n2))) v3) : Val.lessdef (Vlong (Int64.mul (Int64.add i n2) n)) v3.","proofString":"simpl in B2; inv B2.\nsimpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int64) (H4 : eval_expr ge sp e m le t2 (Vlong i)) (A2 : eval_expr ge sp e m le (mullimm_base n t2) (Vlong (Int64.mul i n))) (v3 : val) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2)) v3) (B3 : Val.lessdef (Val.addl (Vlong (Int64.mul i n)) (Vlong (Int64.mul n n2))) v3) : Val.lessdef (Vlong (Int64.mul (Int64.add i n2) n)) v3.","proofString":"simpl in B3; inv B3.\nrewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int64) (H4 : eval_expr ge sp e m le t2 (Vlong i)) (A2 : eval_expr ge sp e m le (mullimm_base n t2) (Vlong (Int64.mul i n))) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n n2)))) : Val.lessdef (Vlong (Int64.mul (Int64.add i n2) n))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n n2))).","proofString":"rewrite Int64.mul_add_distr_l.\nrewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int64) (H4 : eval_expr ge sp e m le t2 (Vlong i)) (A2 : eval_expr ge sp e m le (mullimm_base n t2) (Vlong (Int64.mul i n))) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n n2)))) : Val.lessdef (Vlong (Int64.add (Int64.mul i n) (Int64.mul n2 n)))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n n2))).","proofString":"rewrite (Int64.mul_commut n).\nauto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (SL : Archi.splitlong = true) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (i : int64) (H4 : eval_expr ge sp e m le t2 (Vlong i)) (A2 : eval_expr ge sp e m le (mullimm_base n t2) (Vlong (Int64.mul i n))) (A3 : eval_expr ge sp e m le (addlimm (Int64.mul n n2) (mullimm_base n t2))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n n2)))) : Val.lessdef (Vlong (Int64.add (Int64.mul i n) (Int64.mul n2 n)))\n  (Vlong (Int64.add (Int64.mul i n) (Int64.mul n2 n))).","proofString":"auto."},{"statement":"(SL : Archi.splitlong = true) : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match mull_match e1 e2 with\n   | mull_case1 n1 t2 => mullimm n1 t2\n   | mull_case2 t1 n2 => mullimm n2 t1\n   | mull_default e0 e3 => Eop Omull (e0 ::: e3 ::: Enil)\n   end) Val.mull.","proofString":"red; intros; destruct (mull_match a b); InvEval.\nrewrite Val.mull_commut.\napply eval_mullimm; auto.\napply eval_mullimm; auto.\nTrivialExists."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull (Vlong n1) y) v.","proofString":"rewrite Val.mull_commut.\napply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mullimm n1 t2) v /\\\n  Val.lessdef (Val.mull y (Vlong n1)) v.","proofString":"apply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (mullimm n2 t1) v /\\\n  Val.lessdef (Val.mull x (Vlong n2)) v.","proofString":"apply eval_mullimm; auto."},{"statement":"(SL : Archi.splitlong = true) (le : letenv) (x y : val) (e1 : expr) (H : eval_expr ge sp e m le e1 x) (e2 : expr) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omull (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mull x y) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhu (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhu v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhu (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhu x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) : unary_constructor_sound\n  (fun a : expr => Eop Omullhs (a ::: longconst n ::: Enil))\n  (fun v : val => Val.mullhs v (Vlong n)).","proofString":"red; intros.\nTrivialExists."},{"statement":"(n : int64) (SL : Archi.splitlong = true) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omullhs (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhs x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (n2 : int64) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (H : Val.andl v1 (Vlong n2) = Vundef) : eval_expr ge sp e m le (andlimm_base (Int64.and Int64.zero n2) t2)\n  (Vlong Int64.zero).","proofString":"apply eval_longconst."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\nrewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl (Vlong n1) y) v.","proofString":"rewrite Val.andl_commut.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n1 t2) v /\\\n  Val.lessdef (Val.andl y (Vlong n1)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\ Val.lessdef (Val.andl x y) v.","proofString":"InvEval.\napply eval_andlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (andlimm n2 t1) v /\\\n  Val.lessdef (Val.andl x (Vlong n2)) v.","proofString":"apply eval_andlimm; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then a\n     else\n      if Int64.eq n Int64.mone\n      then Eop (Olongconst Int64.mone) Enil\n      else\n       match orlimm_match a with\n       | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n       | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n       | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto.\npredSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"exists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : Val.lessdef (Val.orl x (Vlong n)) x.","proofString":"subst.\ndestruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.orl x (Vlong Int64.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.or i Int64.zero)) (Vlong i).","proofString":"rewrite Int64.or_zero; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.mone\n     then Eop (Olongconst Int64.mone) Enil\n     else\n      match orlimm_match a with\n      | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n      | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n      | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.mone.\neconstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto.\ndestruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst Int64.mone) Enil) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Val.orl x (Vlong Int64.mone)) (Vlong Int64.mone).","proofString":"destruct x; simpl; auto.\nrewrite Int64.or_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.mone <> Int64.zero) : Val.lessdef (Vlong (Int64.or i Int64.mone)) (Vlong Int64.mone).","proofString":"rewrite Int64.or_mone; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le\n    match orlimm_match a with\n    | orlimm_case1 n2 => Eop (Olongconst (Int64.or n n2)) Enil\n    | orlimm_case2 n2 t2 => Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)\n    | orlimm_default e2 => Eop (Oorlimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"destruct (orlimm_match a); InvEval; subst.\neconstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto.\nTrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto.\nTrivialExists."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Olongconst (Int64.or n n2)) Enil) v /\\\n  Val.lessdef (Val.orl (Vlong n2) (Vlong n)) v.","proofString":"econstructor; split.\napply eval_longconst.\nsimpl.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : Val.lessdef (Vlong (Int64.or n2 n)) (Vlong (Int64.or n n2)).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm (Int64.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : eval_operation ge sp (Oorlimm (Int64.or n n2)) (v1 :: nil) m =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"simpl.\nrewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl (Val.orl v1 (Vlong n2)) (Vlong n)).","proofString":"rewrite Val.orl_assoc.\nrewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (n2 : int64) (t2 : expr) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : Some (Val.orl v1 (Vlong (Int64.or n n2))) =\nSome (Val.orl v1 (Val.orl (Vlong n2) (Vlong n))).","proofString":"rewrite Int64.or_commut; auto."},{"statement":"(n : int64) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) (H0 : n <> Int64.zero) (H1 : n <> Int64.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorlimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.orl x (Vlong n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\ Val.lessdef (Val.orl x y) v.","proofString":"InvEval.\nrewrite Val.orl_commut.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl (Vlong n1) y) v.","proofString":"rewrite Val.orl_commut.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n1 t2) v /\\\n  Val.lessdef (Val.orl y (Vlong n1)) v.","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\ Val.lessdef (Val.orl x y) v.","proofString":"InvEval.\napply eval_orlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (orlimm n2 t1) v /\\\n  Val.lessdef (Val.orl x (Vlong n2)) v.","proofString":"apply eval_orlimm; auto."},{"statement":"(le : letenv) (x y : val) (n1 : int64) (H : eval_expr ge sp e m le (Eop (Olongconst n1) Enil) x) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\nrewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl (Vlong n1) y) v.","proofString":"rewrite Val.xorl_commut.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (y : val) (n1 : int64) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n1 t2) v /\\\n  Val.lessdef (Val.xorl y (Vlong n1)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(le : letenv) (x y : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) (H0 : eval_expr ge sp e m le (Eop (Olongconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\ Val.lessdef (Val.xorl x y) v.","proofString":"InvEval.\napply eval_xorlimm; auto."},{"statement":"(le : letenv) (x : val) (t1 : expr) (H : eval_expr ge sp e m le t1 x) (n2 : int64) : exists v : val,\n  eval_expr ge sp e m le (xorlimm n2 t1) v /\\\n  Val.lessdef (Val.xorl x (Vlong n2)) v.","proofString":"apply eval_xorlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivl (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Odivlu (a ::: b ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = false) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"subst n.\ndestruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint Int.zero) = Some z) (SL : Archi.splitlong = false) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"destruct x; simpl in H0; inv H0.\neconstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : exists v : val,\n  eval_expr ge sp e m le a v /\\\n  Val.lessdef\n    match\n      (if Int.ltu Int.zero (Int.repr 63)\n       then Some (Vlong (Int64.shrx' i Int.zero))\n       else None)\n    with\n    | Some v0 => v0\n    | None => Vlong (Int64.shrx' i Int.zero)\n    end v.","proofString":"econstructor; split; eauto.\nchange (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef\n  match\n    (if Int.ltu Int.zero (Int.repr 63)\n     then Some (Vlong (Int64.shrx' i Int.zero))\n     else None)\n  with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"change (Int.ltu Int.zero (Int.repr 63)) with true.\nsimpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef\n  match (if true then Some (Vlong (Int64.shrx' i Int.zero)) else None) with\n  | Some v => v\n  | None => Vlong (Int64.shrx' i Int.zero)\n  end (Vlong i).","proofString":"simpl.\nrewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (SL : Archi.splitlong = false) : Val.lessdef (Vlong (Int64.shrx' i Int.zero)) (Vlong i).","proofString":"rewrite Int64.shrx'_zero; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrxl x (Vint n) = Some z) (SL : Archi.splitlong = false) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrlximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longoffloat x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olongoffloat (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuoffloat x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olonguoffloat (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatoflong (a ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatoflongu (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longofsingle x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olongofsingle (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuofsingle x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Olonguofsingle (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoflong (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y) (SL : Archi.splitlong = true) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleoflongu (a ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."}]}