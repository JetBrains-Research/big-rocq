[{"statement":"Lemma w_rel_trav_step T (TCCOH : tc_coherent G sc T)\n      w (REL : (W∩₁Rel) w)\n      (TS : itrav_step G sc w T (mkTC (covered T) (issued T ∪₁ eq w))) :\n  itrav_step G sc w\n             (mkTC (covered T) (issued T ∪₁ eq w))\n             (mkTC (covered T ∪₁ eq w) (issued T ∪₁ eq w)).","proof":"red in TS; unfold itrav_step in *; desf; simpls.\n{\nexfalso.\napply NEXT; apply COVEQ; vauto.\n}\nassert (E w) as WACTS by apply ISS.\nassert (~ (covered T) w) as WNCOV.\n{\nintros H.\napply NISS.\neapply w_covered_issued; eauto.\nby split; [apply REL|].\n}\nleft; splits; auto.\nred; split; [split; auto|].\n2: by left; left; split; [apply REL|right].\nsimpls.\nintros x [y H].\napply seq_eqv_r in H; desf.\ndestruct ISS as [[_ ISS] _].\napply ISS.\nexists y.\napply seq_eqv_r; split; auto.\nleft; left; left.\napply seq_eqv_r; split; auto.\n"},{"statement":"Lemma exists_sim_trav_step T (TCCOH : tc_coherent G sc T)\n      (RELCOV :  W ∩₁ Rel ∩₁ issued T ⊆₁ covered T)\n      (RMWCOV : forall r w (RMW : rmw r w), covered T r <-> covered T w)\n      T' (TS : trav_step G sc T T') :\n  exists T'', sim_trav_step T T''.","proof":"assert (tc_coherent G sc T') as TCCOH'.\n{\neapply trav_step_coherence; eauto.\n}\ndestruct TS as [e TS].\ncdes TS.\ndesf.\n{\ndestruct (lab_rwf lab e) as [RE|[WE|FE]].\n3: {\neexists; eexists.\neapply fence_trav_step; eauto.\neapply itrav_step_more.\n4: by eauto.\n{\ndone.\n}\n{\napply same_tc_Reflexive.\n}\nred.\nrewrite COVEQ.\nrewrite ISSEQ.\nby split.\n}\n{\ndestruct (classic (dom_rel rmw e)) as [RMW|NRMW].\n2: {\neexists; eexists.\neapply read_trav_step; eauto.\neapply itrav_step_more.\n4: by eauto.\n{\ndone.\n}\n{\napply same_tc_Reflexive.\n}\nred.\nrewrite COVEQ.\nrewrite ISSEQ.\nby split.\n}\ndestruct RMW as [w RMW].\nassert (~ covered T w) as COVW.\n{\nintros WCOV.\napply NEXT.\napply TCCOH in WCOV.\napply WCOV.\neexists.\napply seq_eqv_r.\nsplit; eauto.\nby apply rmw_in_sb.\n}\nassert (is_w lab w) as WW.\n{\napply (dom_r (wf_rmwD WF)) in RMW.\napply seq_eqv_r in RMW.\ndesf.\n}\nassert (dom_rel (sb ⨾ ⦗eq w⦘) ⊆₁ covered T ∪₁ eq e) as SBW.\n{\nhahn_rewrite (rmw_from_non_init WF) in RMW.\nhahn_rewrite (wf_rmwi WF) in RMW.\nhahn_rewrite (sb_immediate_adjacent WF) in RMW.\nunfold adjacent in *; unfolder in *; ins; desf.\napply LA_ca in H; desf; eauto.\ngeneralize (@sb_coverable G sc T).\nunfolder; ins; desf.\nleft; eapply H0; eauto.\n}\nassert (E w) as EW.\n{\napply (dom_r (wf_rmwE WF)) in RMW.\napply seq_eqv_r in RMW.\ndesf.\n}\nassert (~ (covered T ∪₁ eq e) w) as C1.\n{\nintros [H|H]; desf.\ntype_solver.\n}\ndestruct (classic (issued T w)) as [ISS|NISS].\n{\neexists; eexists.\neapply rlx_rmw_cover_step; eauto.\n{\nintros REL.\napply COVW.\napply RELCOV.\nby split; [split|].\n}\n{\nred.\nleft.\nsplits; simpls.\n}\nred.\nleft.\nsplits; simpls.\nsplit; [split|left; left; split]; auto.\n}\ndestruct (classic (Rel w)) as [REL|NREL].\n2: {\neexists; eexists.\neapply rlx_write_promise_step; eauto.\nred.\nright.\nsplits; auto.\nred.\nsplit; [split; [split|]|]; auto.\n{\nred.\nintros y H.\nspecialize (SBW y).\ndestruct SBW as [COVY|EY]; desf.\n{\ndestruct H as [x H].\napply seq_eqv_r in H; desf.\nexists x.\napply seq_eqv_r.\nsplit; auto.\napply bob_in_sb.\nby apply fwbob_in_bob.\n}\ndestruct H as [x H].\napply seq_eqv_r in H.\ndesf.\nred in H.\ndestruct H as [[[H|H]|H]|H].\n1,3: by apply seq_eqv_r in H; mode_solver.\nall: by apply seq_eqv_l in H; mode_solver.\n}\nred.\nrewrite <- ISSEQ.\neapply issuable_next_w; auto.\nsplit; auto.\nred.\nsplit; [split|]; auto.\n{\nred.\nby rewrite COVEQ.\n}\nred.\nintros AA.\napply C1.\nby apply COVEQ.\n}\neexists.\neexists.\nassert (itrav_step G sc e T {| covered := covered T ∪₁ eq e; issued := issued T |})        as A1.\n{\nred.\nleft.\nsplits; auto.\n}\nassert (tc_coherent G sc {| covered := covered T ∪₁ eq e; issued := issued T |}) as B1.\n{\neapply trav_step_coherence with (C:=T); eauto.\nby exists e.\n}\nassert (itrav_step G sc w {| covered := covered T ∪₁ eq e; issued := issued T |}                         {| covered := covered T ∪₁ eq e; issued := issued T ∪₁ eq w |})        as A2.\n{\nred.\nright.\nsplits; simpls.\neapply issuable_next_w; eauto.\nsplit; auto.\nred.\nsplit; [split|]; auto.\n}\napply rel_rmw_step; eauto.\nred.\nleft.\nsimpls.\nsplits; auto.\nred.\nsplit; [split|]; auto.\nleft.\nleft.\nsplit; auto.\nby right.\n}\nassert (issued T e) as ISS.\n{\neapply w_coverable_issued; eauto.\neby split.\n}\ndestruct (classic (Rel e)) as [REL|NREL].\n{\nexfalso.\napply NEXT.\napply RELCOV.\nsplit; [split|]; auto.\n}\ndestruct (classic (codom_rel rmw e)) as [RMW|NRMW].\n2: {\neexists.\neexists.\neapply rlx_write_cover_step; eauto.\neapply itrav_step_more.\n4: by eauto.\n{\ndone.\n}\n{\napply same_tc_Reflexive.\n}\nred.\nrewrite COVEQ.\nrewrite ISSEQ.\nby split.\n}\nexfalso.\napply NEXT.\ndestruct RMW as [r RMW].\napply (RMWCOV _ _ RMW).\neapply COV.\neexists.\napply seq_eqv_r.\nsplit; eauto.\nby apply (rmw_in_sb WF).\n}\nassert (is_w lab e) as WW by apply ISS.\ndestruct (classic (Rel e)) as [REL|NREL].\n2: {\neexists; eexists.\neapply rlx_write_promise_step; eauto.\neapply itrav_step_more.\n4: by eauto.\n{\ndone.\n}\n{\napply same_tc_Reflexive.\n}\nred.\nrewrite COVEQ.\nrewrite ISSEQ.\nby split.\n}\neexists; eexists.\napply rel_write_step; eauto.\n{\nintros [r RMW].\napply NISS.\neapply w_covered_issued; eauto.\nsplit; auto.\napply (RMWCOV _ _ RMW).\nred in ISS.\neapply ISS.\neexists.\napply seq_eqv_r.\nsplit; eauto.\nred.\nrepeat left.\napply seq_eqv_r.\nsplit.\n{\nby apply rmw_in_sb.\n}\nby split.\n}\n{\neapply itrav_step_more; eauto.\n{\napply same_tc_Reflexive.\n}\nred.\nrewrite COVEQ.\nrewrite ISSEQ.\nby split.\n}\neapply itrav_step_more.\n3: reflexivity.\nall: eauto.\n{\nred; eauto.\n}\napply w_rel_trav_step; eauto.\n{\nby split.\n}\neapply itrav_step_more; eauto.\n{\nreflexivity.\n}\nred.\nsimpls.\nrewrite COVEQ, ISSEQ.\nby split.\n"},{"statement":"Lemma sim_trav_step_to_step T T' thread\n      (TS : isim_trav_step thread T T') :\n  exists e T'', itrav_step G sc e T T'' /\\ tid e = thread.","proof":"destruct TS; eauto.\n"}]