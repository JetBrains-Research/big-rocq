{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/travorder/Next.v","fileSamples":[{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘ ⊆ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘.","conclusion":"⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘ ⊆ ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a)","proofString":"unfolder; ins; desc; splits; eauto; eexists; splits; eauto; subst.\nassert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y)","proofString":"assert (~ is_init a) as NA.\nintros H; apply NEXT, IC.\nsplit; auto.\napply NEXT.\nassert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) : ~ is_init a.","conclusion":"~ is_init a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y)","proofString":"intros H; apply NEXT, IC.\nsplit; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : (Init ∩₁ E) a.","conclusion":"(Init ∩₁ E) a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a)","proofString":"split; auto.\napply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a) : E a.","conclusion":"E a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (H : is_init a)","proofString":"apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a)","proofString":"assert (E y) as EY.\nby apply CE.\nassert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) : E y.","conclusion":"E y","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a)","proofString":"by apply CE."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y)","proofString":"assert (E a) as EA.\nby apply NEXT.\ndesf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) : E a.","conclusion":"E a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y)","proofString":"by apply NEXT."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a \\/ is_init y) (NA : ~ is_init a) (EY : E y) (EA : E a)","proofString":"desf; [|by apply init_ninit_sb].\nsymmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid y = tid a) (NA : ~ is_init a) (EY : E y) (EA : E a)","proofString":"symmetry in H0.\neapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid a = tid y) (NA : ~ is_init a) (EY : E y) (EA : E a) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (H0 : tid a = tid y) (NA : ~ is_init a) (EY : E y) (EA : E a)","proofString":"eapply same_thread in H0; eauto.\ndesf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y \\/ sb y a) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y \\/ sb y a)","proofString":"desf.\nexfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : sb y a.","conclusion":"sb y a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y)","proofString":"exfalso.\nred in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y) : False.","conclusion":"False","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb^? a y)","proofString":"red in H0; desf; [by apply NEXT in H1|].\napply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : False.","conclusion":"False","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y)","proofString":"apply NEXT.\napply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","conclusion":"C a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y)","proofString":"apply CC in H1.\napply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : dom_cond sb C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y) : C a.","conclusion":"C a","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) (y : actid) (H1 : dom_cond sb C y) (NA : ~ is_init a) (EY : E y) (EA : E a) (H0 : sb a y)","proofString":"apply H1; basic_solver 8."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘ ⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","conclusion":"⦗dom_rel (sb ⨾ ⦗eq a⦘)⦘ ⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a)","proofString":"rewrite sb_tid_init'.\nunfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a) : ⦗dom_rel ((sb ∩ same_tid ∪ ⦗Init⦘ ⨾ sb) ⨾ ⦗eq a⦘)⦘\n⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘.","conclusion":"⦗dom_rel ((sb ∩ same_tid ∪ ⦗Init⦘ ⨾ sb) ⨾ ⦗eq a⦘)⦘\n⊆ ⦗Tid_ (tid a) ∪₁ Init⦘ ⨾ ⦗C⦘","hypotheses":"(C : actid -> Prop) (a : actid) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (NEXT : next C a)","proofString":"unfold same_tid; unfolder; ins; desf; splits; eauto.\napply NEXT; basic_solver 10.\napply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (y : actid) (H2 : tid y = tid y0) (H0 : sb y y0) : C y.","conclusion":"C y","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (y : actid) (H2 : tid y = tid y0) (H0 : sb y y0)","proofString":"apply NEXT; basic_solver 10."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : C z.","conclusion":"C z","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0)","proofString":"apply IC.\nsplit; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : (Init ∩₁ E) z.","conclusion":"(Init ∩₁ E) z","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0)","proofString":"split; auto.\napply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0) : E z.","conclusion":"E z","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : sb z y0)","proofString":"apply (dom_l (@wf_sbE G)) in H2.\napply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : (⦗E⦘ ⨾ sb) z y0) : E z.","conclusion":"E z","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : (⦗E⦘ ⨾ sb) z y0)","proofString":"apply seq_eqv_l in H2.\ndesf."},{"statement":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : E z /\\ sb z y0) : E z.","conclusion":"E z","hypotheses":"(C : actid -> Prop) (IC : Init ∩₁ E ⊆₁ C) (CE : C ⊆₁ E) (CC : C ⊆₁ dom_cond sb C) (y0 : actid) (NEXT : next C y0) (z : actid) (H3 : is_init z) (H2 : E z /\\ sb z y0)","proofString":"desf."},{"statement":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a) : covered T ⊆₁ dom_cond sb (covered T).","conclusion":"covered T ⊆₁ dom_cond sb (covered T)","hypotheses":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a)","proofString":"apply dom_rel_to_cond.\neapply dom_sb_covered; eauto."},{"statement":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a) : dom_rel (sb ⨾ ⦗covered T⦘) ⊆₁ covered T.","conclusion":"dom_rel (sb ⨾ ⦗covered T⦘) ⊆₁ covered T","hypotheses":"(a : actid) (T : trav_label -> Prop) (TCOH : tls_coherent G T) (ICOH : iord_coherent G sc T) (NEXT : next (covered T) a)","proofString":"eapply dom_sb_covered; eauto."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : False.","conclusion":"False","hypotheses":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e)","proofString":"apply NEXT.\neapply init_covered; eauto.\nsplit; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : covered T e.","conclusion":"covered T e","hypotheses":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e)","proofString":"eapply init_covered; eauto.\nsplit; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : (Init ∩₁ E) e.","conclusion":"(Init ∩₁ E) e","hypotheses":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e)","proofString":"split; auto.\napply NEXT."},{"statement":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e) : E e.","conclusion":"E e","hypotheses":"(T : trav_label -> Prop) (e : actid) (NEXT : next (covered T) e) (TCOH : tls_coherent G T) (HH : is_init e)","proofString":"apply NEXT."}]}