{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/arm/Op.v","fileSamples":[{"statement":"forall x y : shift, {x = y} + {x <> y}.","proofString":"generalize Int.eq_dec; intro.\nassert (forall (x y: shift_amount), {x=y}+{x<>y}).\ndestruct x as [x Px].\ndestruct y as [y Py].\ndestruct (H x y).\nsubst x.\nrewrite (proof_irr Px Py).\nleft; auto.\nright.\nred; intro.\nelim n.\ninversion H0.\nauto.\ndecide equality."},{"statement":"(H : forall x y : int, {x = y} + {x <> y}) : forall x y : shift, {x = y} + {x <> y}.","proofString":"assert (forall (x y: shift_amount), {x=y}+{x<>y}).\ndestruct x as [x Px].\ndestruct y as [y Py].\ndestruct (H x y).\nsubst x.\nrewrite (proof_irr Px Py).\nleft; auto.\nright.\nred; intro.\nelim n.\ninversion H0.\nauto.\ndecide equality."},{"statement":"(H : forall x y : int, {x = y} + {x <> y}) : forall x y : shift_amount, {x = y} + {x <> y}.","proofString":"destruct x as [x Px].\ndestruct y as [y Py].\ndestruct (H x y).\nsubst x.\nrewrite (proof_irr Px Py).\nleft; auto.\nright.\nred; intro.\nelim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y : int, {x0 = y} + {x0 <> y}) (x : int) (Px : Int.ltu x Int.iwordsize = true) : forall y : shift_amount,\n{{| s_amount := x; s_range := Px |} = y} +\n{{| s_amount := x; s_range := Px |} <> y}.","proofString":"destruct y as [y Py].\ndestruct (H x y).\nsubst x.\nrewrite (proof_irr Px Py).\nleft; auto.\nright.\nred; intro.\nelim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) : {{| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}} +\n{{| s_amount := x; s_range := Px |} <> {| s_amount := y; s_range := Py |}}.","proofString":"destruct (H x y).\nsubst x.\nrewrite (proof_irr Px Py).\nleft; auto.\nright.\nred; intro.\nelim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (e : x = y) : {{| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}} +\n{{| s_amount := x; s_range := Px |} <> {| s_amount := y; s_range := Py |}}.","proofString":"subst x.\nrewrite (proof_irr Px Py).\nleft; auto."},{"statement":"(H : forall x y0 : int, {x = y0} + {x <> y0}) (y : int) (Px Py : Int.ltu y Int.iwordsize = true) : {{| s_amount := y; s_range := Px |} = {| s_amount := y; s_range := Py |}} +\n{{| s_amount := y; s_range := Px |} <> {| s_amount := y; s_range := Py |}}.","proofString":"rewrite (proof_irr Px Py).\nleft; auto."},{"statement":"(H : forall x y0 : int, {x = y0} + {x <> y0}) (y : int) (Px Py : Int.ltu y Int.iwordsize = true) : {{| s_amount := y; s_range := Py |} = {| s_amount := y; s_range := Py |}} +\n{{| s_amount := y; s_range := Py |} <> {| s_amount := y; s_range := Py |}}.","proofString":"left; auto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) : {{| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}} +\n{{| s_amount := x; s_range := Px |} <> {| s_amount := y; s_range := Py |}}.","proofString":"right.\nred; intro.\nelim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) : {| s_amount := x; s_range := Px |} <> {| s_amount := y; s_range := Py |}.","proofString":"red; intro.\nelim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) (H0 : {| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}) : False.","proofString":"elim n.\ninversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) (H0 : {| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}) : x = y.","proofString":"inversion H0.\nauto."},{"statement":"(H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (x : int) (Px : Int.ltu x Int.iwordsize = true) (y : int) (Py : Int.ltu y Int.iwordsize = true) (n : x <> y) (H0 : {| s_amount := x; s_range := Px |} = {| s_amount := y; s_range := Py |}) (H2 : x = y) : y = y.","proofString":"auto."},{"statement":"(H : forall x y : int, {x = y} + {x <> y}) (H0 : forall x y : shift_amount, {x = y} + {x <> y}) : forall x y : shift, {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"assert (forall (x y: comparison), {x=y}+{x<>y}).\ndecide equality.\ngeneralize eq_shift; intro.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}.","proofString":"decide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"generalize eq_shift; intro.\ndecide equality."},{"statement":"(x y : condition) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : comparison, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : shift, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : operation) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H2 : forall t1 t2 : typ, {t1 = t2} + {t1 <> t2}) : {x = y} + {x <> y}.","proofString":"generalize Float.eq_dec Float32.eq_dec; intros.\ngeneralize eq_shift; intro.\ngeneralize eq_condition; intro.\ndecide equality."},{"statement":"(x y : operation) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H2 : forall t1 t2 : typ, {t1 = t2} + {t1 <> t2}) (H3 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H4 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) : {x = y} + {x <> y}.","proofString":"generalize eq_shift; intro.\ngeneralize eq_condition; intro.\ndecide equality."},{"statement":"(x y : operation) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H2 : forall t1 t2 : typ, {t1 = t2} + {t1 <> t2}) (H3 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H4 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H5 : forall x0 y0 : shift, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"generalize eq_condition; intro.\ndecide equality."},{"statement":"(x y : operation) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) (H1 : forall x0 y0 : positive, {x0 = y0} + {x0 <> y0}) (H2 : forall t1 t2 : typ, {t1 = t2} + {t1 <> t2}) (H3 : forall f1 f2 : float, {f1 = f2} + {f1 <> f2}) (H4 : forall f1 f2 : float32, {f1 = f2} + {f1 <> f2}) (H5 : forall x0 y0 : shift, {x0 = y0} + {x0 <> y0}) (H6 : forall x0 y0 : condition, {x0 = y0} + {x0 <> y0}) : {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"generalize eq_shift; intro.\ndecide equality."},{"statement":"(x y : addressing) (H : forall x0 y0 : int, {x0 = y0} + {x0 <> y0}) (H0 : forall x0 y0 : shift, {x0 = y0} + {x0 <> y0}) : (forall x0 y0 : ptrofs, {x0 = y0} + {x0 <> y0}) -> {x = y} + {x <> y}.","proofString":"decide equality."},{"statement":"(F : Type) (V : Type) (genv : Genv.t F V) (sp : val) (ofs : ptrofs) : eval_addressing genv sp (Ainstack ofs) nil = Some (Val.offset_ptr sp ofs).","proofString":"reflexivity."},{"statement":"forall (s : shift) (v : val), Val.has_type (eval_shift s v) Tint.","proofString":"intros.\nunfold eval_shift.\ndestruct s; destruct v; simpl; auto; rewrite s_range; exact I."},{"statement":"(s : shift) (v : val) : Val.has_type (eval_shift s v) Tint.","proofString":"unfold eval_shift.\ndestruct s; destruct v; simpl; auto; rewrite s_range; exact I."},{"statement":"(s : shift) (v : val) : Val.has_type\n  match s with\n  | Slsl x => Val.shl v (Vint x)\n  | Slsr x => Val.shru v (Vint x)\n  | Sasr x => Val.shr v (Vint x)\n  | Sror x => Val.ror v (Vint x)\n  end Tint.","proofString":"destruct s; destruct v; simpl; auto; rewrite s_range; exact I."},{"statement":"(S : forall (s : shift) (v : val), Val.has_type (eval_shift s v) Tint) (v0 sp : val) (m : mem) (H : Omove <> Omove) : Val.has_type v0 Tint.","proofString":"congruence."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.modu n Int.iwordsize = n.","proofString":"unfold Int.modu.\ntransitivity (Int.repr (Int.unsigned n)).\ndecEq.\napply Z.mod_small.\napply Int.ltu_inv; auto.\napply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.repr (Int.unsigned n mod Int.unsigned Int.iwordsize) = n.","proofString":"transitivity (Int.repr (Int.unsigned n)).\ndecEq.\napply Z.mod_small.\napply Int.ltu_inv; auto.\napply Int.repr_unsigned."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.repr (Int.unsigned n mod Int.unsigned Int.iwordsize) =\nInt.repr (Int.unsigned n).","proofString":"decEq.\napply Z.mod_small.\napply Int.ltu_inv; auto."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.unsigned n mod Int.unsigned Int.iwordsize = Int.unsigned n.","proofString":"apply Z.mod_small.\napply Int.ltu_inv; auto."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : 0 <= Int.unsigned n < Int.unsigned Int.iwordsize.","proofString":"apply Int.ltu_inv; auto."},{"statement":"(n : int) (H : Int.ltu n Int.iwordsize = true) : Int.repr (Int.unsigned n) = n.","proofString":"apply Int.repr_unsigned."},{"statement":"(A : Type) (op : operation) (args : list A) (a : A) : is_move_operation op args = Some a -> op = Omove /\\ args = a :: nil.","proofString":"unfold is_move_operation; destruct op;  try (intros; discriminate).\ndestruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (args : list A) (a : A) : match args with\n| nil => None\n| arg :: nil => Some arg\n| arg :: _ :: _ => None\nend = Some a -> Omove = Omove /\\ args = a :: nil.","proofString":"destruct args.\nintros; discriminate.\ndestruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a : A) : None = Some a -> Omove = Omove /\\ nil = a :: nil.","proofString":"intros; discriminate."},{"statement":"(A : Type) (a0 : A) (args : list A) (a : A) : match args with\n| nil => Some a0\n| _ :: _ => None\nend = Some a -> Omove = Omove /\\ a0 :: args = a :: nil.","proofString":"destruct args.\nintros.\nintuition congruence.\nintros; discriminate."},{"statement":"(A : Type) (a0 a : A) : Some a0 = Some a -> Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intros.\nintuition congruence."},{"statement":"(A : Type) (a0 a : A) (H : Some a0 = Some a) : Omove = Omove /\\ a0 :: nil = a :: nil.","proofString":"intuition congruence."},{"statement":"(A : Type) (a0 a1 : A) (args : list A) (a : A) : None = Some a -> Omove = Omove /\\ a0 :: a1 :: args = a :: nil.","proofString":"intros; discriminate."},{"statement":"(cond : condition) (vl : list val) (m : mem) : eval_condition (negate_condition cond) vl m =\noption_map negb (eval_condition cond vl m).","proofString":"destruct cond; simpl.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmp_bool.\nrepeat (destruct vl; auto).\napply Val.negate_cmpu_bool.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v (Vfloat Float.zero)); auto.\ndestruct b; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0); auto.\ndestruct b; auto.\nrepeat (destruct vl; auto).\nrepeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v (Vsingle Float32.zero)); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v v0 =\noption_map negb (Val.cmp_bool c v v0).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v v0 =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v v0).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (s : shift) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmp_bool (negate_comparison c) v1 (eval_shift s v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmp_bool c v1 (eval_shift s v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (s : shift) (v v0 : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (eval_shift s v0) =\noption_map negb (Val.cmp_bool c v (eval_shift s v0)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (s : shift) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1\n      (eval_shift s v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil =>\n      Val.cmpu_bool (Mem.valid_pointer m) c v1 (eval_shift s v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (s : shift) (v v0 : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (eval_shift s v0) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (eval_shift s v0)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmp_bool (negate_comparison c) v1 (Vint i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmp_bool c v1 (Vint i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmp_bool."},{"statement":"(c : comparison) (i : int) (v : val) (m : mem) : Val.cmp_bool (negate_comparison c) v (Vint i) =\noption_map negb (Val.cmp_bool c v (Vint i)).","proofString":"apply Val.negate_cmp_bool."},{"statement":"(c : comparison) (i : int) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil =>\n    Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v1 (Vint i)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpu_bool (Mem.valid_pointer m) c v1 (Vint i)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\napply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (i : int) (v : val) (m : mem) : Val.cmpu_bool (Mem.valid_pointer m) (negate_comparison c) v (Vint i) =\noption_map negb (Val.cmpu_bool (Mem.valid_pointer m) c v (Vint i)).","proofString":"apply Val.negate_cmpu_bool."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpf_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpf_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpf_bool c v v0 =\noption_map negb (option_map negb (Val.cmpf_bool c v v0)).","proofString":"destruct (Val.cmpf_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) (b : bool) : Some b = option_map negb (option_map negb (Some b)).","proofString":"destruct b; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.cmpf_bool c v1 (Vfloat Float.zero))\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpf_bool c v1 (Vfloat Float.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpf_bool c v1 (Vfloat Float.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.cmpf_bool c v1 (Vfloat Float.zero))\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpf_bool c v (Vfloat Float.zero)); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v : val) (m : mem) : Val.cmpf_bool c v (Vfloat Float.zero) =\noption_map negb (option_map negb (Val.cmpf_bool c v (Vfloat Float.zero))).","proofString":"destruct (Val.cmpf_bool c v (Vfloat Float.zero)); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v : val) (m : mem) (b : bool) : Some b = option_map negb (option_map negb (Some b)).","proofString":"destruct b; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => None\n| v1 :: v2 :: nil => Val.cmpfs_bool c v1 v2\n| v1 :: v2 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => None\n  | v1 :: v2 :: nil => option_map negb (Val.cmpfs_bool c v1 v2)\n  | v1 :: v2 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) : Val.cmpfs_bool c v v0 =\noption_map negb (option_map negb (Val.cmpfs_bool c v v0)).","proofString":"destruct (Val.cmpfs_bool c v v0); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v v0 : val) (m : mem) (b : bool) : Some b = option_map negb (option_map negb (Some b)).","proofString":"destruct b; auto."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => option_map negb (Val.cmpfs_bool c v1 (Vsingle Float32.zero))\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => Val.cmpfs_bool c v1 (Vsingle Float32.zero)\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto)."},{"statement":"(c : comparison) (vl : list val) (m : mem) : match vl with\n| nil => None\n| v1 :: nil => Val.cmpfs_bool c v1 (Vsingle Float32.zero)\n| v1 :: _ :: _ => None\nend =\noption_map negb\n  match vl with\n  | nil => None\n  | v1 :: nil => option_map negb (Val.cmpfs_bool c v1 (Vsingle Float32.zero))\n  | v1 :: _ :: _ => None\n  end.","proofString":"repeat (destruct vl; auto).\ndestruct (Val.cmpfs_bool c v (Vsingle Float32.zero)); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v : val) (m : mem) : Val.cmpfs_bool c v (Vsingle Float32.zero) =\noption_map negb (option_map negb (Val.cmpfs_bool c v (Vsingle Float32.zero))).","proofString":"destruct (Val.cmpfs_bool c v (Vsingle Float32.zero)); auto.\ndestruct b; auto."},{"statement":"(c : comparison) (v : val) (m : mem) (b : bool) : Some b = option_map negb (option_map negb (Some b)).","proofString":"destruct b; auto."},{"statement":"(delta : Z) (addr : addressing) : type_of_addressing (shift_stack_addressing delta addr) =\ntype_of_addressing addr.","proofString":"destruct addr; auto."},{"statement":"(delta : Z) (op : operation) : type_of_operation (shift_stack_operation delta op) = type_of_operation op.","proofString":"destruct op; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (addr : addressing) (vl : list val) (delta : Z) : eval_addressing ge (Vptr sp Ptrofs.zero) (shift_stack_addressing delta addr)\n  vl = eval_addressing ge (Vptr sp (Ptrofs.repr delta)) addr vl.","proofString":"destruct addr; simpl; auto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add (Ptrofs.repr delta) i)))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend.","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (op : operation) (vl : list val) (m : mem) (delta : Z) : eval_operation ge (Vptr sp Ptrofs.zero) (shift_stack_operation delta op) vl m =\neval_operation ge (Vptr sp (Ptrofs.repr delta)) op vl m.","proofString":"destruct op; simpl; auto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : block) (i : ptrofs) (vl : list val) (m : mem) (delta : Z) : match vl with\n| nil =>\n    Some\n      (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.add (Ptrofs.repr delta) i)))\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Vptr sp (Ptrofs.add (Ptrofs.repr delta) i))\n| _ :: _ => None\nend.","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(F : Type) (V : Type) (ge : Genv.t F V) (sp : val) (i : int) (v0 : val) (delta : Z) : Some (Val.add v0 (Vint (Int.add i (Int.repr delta)))) =\nSome (Val.add (Val.add v0 (Vint i)) (Vint (Int.repr delta))).","proofString":"rewrite Val.add_assoc; auto."},{"statement":"(c : condition) (args : list val) (m1 m2 : mem) (H : condition_depends_on_memory c = false) : eval_condition c args m1 = eval_condition c args m2.","proofString":"destruct c; simpl; auto; discriminate."},{"statement":"(sp : val) (op : operation) (vl : list val) (m : mem) : eval_operation ge2 sp op vl m = eval_operation ge1 sp op vl m.","proofString":"unfold eval_operation; destruct op; auto.\nunfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (i : ident) (i0 : ptrofs) (vl : list val) (m : mem) : match vl with\n| nil => Some (Genv.symbol_address ge2 i i0)\n| _ :: _ => None\nend =\nmatch vl with\n| nil => Some (Genv.symbol_address ge1 i i0)\n| _ :: _ => None\nend.","proofString":"unfold Genv.symbol_address.\nrewrite agree_on_symbols; auto."},{"statement":"(sp : val) (i : ident) (i0 : ptrofs) (vl : list val) (m : mem) : match vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge2 i with\n      | Some b => Vptr b i0\n      | None => Vundef\n      end\n| _ :: _ => None\nend =\nmatch vl with\n| nil =>\n    Some\n      match Genv.find_symbol ge1 i with\n      | Some b => Vptr b i0\n      | None => Vundef\n      end\n| _ :: _ => None\nend.","proofString":"rewrite agree_on_symbols; auto."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","proofString":"assert (UNUSED: forall (s: ident), Genv.find_symbol ge2 s = Genv.find_symbol ge1 s).\nexact agree_on_symbols.\nunfold eval_addressing; destruct addr; auto."},{"statement":"(sp : val) (addr : addressing) (vl : list val) : forall s : ident, Genv.find_symbol ge2 s = Genv.find_symbol ge1 s.","proofString":"exact agree_on_symbols."},{"statement":"(sp : val) (addr : addressing) (vl : list val) (UNUSED : forall s : ident, Genv.find_symbol ge2 s = Genv.find_symbol ge1 s) : eval_addressing ge2 sp addr vl = eval_addressing ge1 sp addr vl.","proofString":"unfold eval_addressing; destruct addr; auto."},{"statement":"(s : shift) (v v' : val) (H : Val.inject f v v') : Val.inject f (eval_shift s v) (eval_shift s v').","proofString":"inv H; destruct s; simpl; auto; rewrite s_range; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (H : Val.inject_list f vl1 vl2) (H0 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"destruct cond; simpl in H0; FuncInv; InvInject; simpl.\neauto 4 using Val.cmp_bool_inject.\neauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\neauto using Val.cmp_bool_inject, eval_shift_inj.\neauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies, eval_shift_inj.\neauto 4 using Val.cmp_bool_inject.\neauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; inv H2; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto.\ninv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' v'0 = Some b.","proofString":"eauto 4 using Val.cmp_bool_inject."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' v'0 = Some b.","proofString":"eauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (s : shift) (v v0 : val) (b : bool) (H0 : Val.cmp_bool c v (eval_shift s v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmp_bool c v' (eval_shift s v'0) = Some b.","proofString":"eauto using Val.cmp_bool_inject, eval_shift_inj."},{"statement":"(c : comparison) (s : shift) (v v0 : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (eval_shift s v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpu_bool (Mem.valid_pointer m2) c v' (eval_shift s v'0) = Some b.","proofString":"eauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies, eval_shift_inj."},{"statement":"(c : comparison) (i : int) (v : val) (b : bool) (H0 : Val.cmp_bool c v (Vint i) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmp_bool c v' (Vint i) = Some b.","proofString":"eauto 4 using Val.cmp_bool_inject."},{"statement":"(c : comparison) (i : int) (v : val) (b : bool) (H0 : Val.cmpu_bool (Mem.valid_pointer m1) c v (Vint i) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpu_bool (Mem.valid_pointer m2) c v' (Vint i) = Some b.","proofString":"eauto 4 using Val.cmpu_bool_inject, Mem.valid_pointer_implies."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpf_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpf_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpf_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : Val.cmpf_bool c v (Vfloat Float.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpf_bool c v' (Vfloat Float.zero) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : option_map negb (Val.cmpf_bool c v (Vfloat Float.zero)) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.cmpf_bool c v' (Vfloat Float.zero)) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : Val.cmpfs_bool c v v0 = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.cmpfs_bool c v' v'0 = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v v0 : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v v0) = Some b) (v' : val) (H3 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : option_map negb (Val.cmpfs_bool c v' v'0) = Some b.","proofString":"inv H3; inv H2; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : Val.cmpfs_bool c v (Vsingle Float32.zero) = Some b) (v' : val) (H3 : Val.inject f v v') : Val.cmpfs_bool c v' (Vsingle Float32.zero) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(c : comparison) (v : val) (b : bool) (H0 : option_map negb (Val.cmpfs_bool c v (Vsingle Float32.zero)) = Some b) (v' : val) (H3 : Val.inject f v v') : option_map negb (Val.cmpfs_bool c v' (Vsingle Float32.zero)) = Some b.","proofString":"inv H3; simpl in H0; inv H0; auto."},{"statement":"(op : operation) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H1 : eval_operation ge1 sp1 op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation ge2 sp2 op vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct op; simpl in H1; simpl; FuncInv; InvInject; TrivialExists.\napply GL; simpl; auto.\napply Val.offset_ptr_inject; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\napply Val.add_inject; auto.\napply Val.add_inject; auto.\napply eval_shift_inj; auto.\napply Val.add_inject; auto.\napply Val.sub_inject; auto.\napply Val.sub_inject; auto.\napply eval_shift_inj; auto.\napply Val.sub_inject; auto.\napply eval_shift_inj; auto.\napply (@Val.sub_inject f (Vint i) (Vint i) v v'); auto.\ninv H4; inv H2; simpl; auto.\napply Val.add_inject; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists.\ninv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\nexploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\nexploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\nexploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\nexploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto.\ninv H4; simpl; auto.\nexploit (eval_shift_inj s).\neexact H4.\nintros IS.\ninv IS; simpl; auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\ninv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto.\napply eval_shift_inj; auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.ltu i (Int.repr 31)); inv H2.\nTrivialExists.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in *; inv H1.\nTrivialExists.\ninv H4; simpl in *; inv H1.\nTrivialExists.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto.\ninv H4; simpl in *; inv H1.\nTrivialExists.\ninv H4; simpl in *; inv H1.\nTrivialExists.\ninv H4; inv H2; simpl; auto.\ninv H4; simpl; auto.\ninv H4; simpl; auto.\nsubst v1.\ndestruct (eval_condition c vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor.\napply Val.select_inject; auto.\ndestruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(i : ident) (i0 : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddrsymbol i i0)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) : Val.inject f (Genv.symbol_address ge1 i i0) (Genv.symbol_address ge2 i i0).","proofString":"apply GL; simpl; auto."},{"statement":"(i : ptrofs) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddrstack i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 i) (Val.offset_ptr sp2 i).","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast8signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 8 v) (Val.sign_ext 8 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ocast16signed) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.sign_ext 16 v) (Val.sign_ext 16 v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oadd) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v v0) (Val.add v' v'0).","proofString":"apply Val.add_inject; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.add v (eval_shift s v0)) (Val.add v' (eval_shift s v'0)).","proofString":"apply Val.add_inject; auto.\napply eval_shift_inj; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (eval_shift s v0) (eval_shift s v'0).","proofString":"apply eval_shift_inj; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oaddimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.add v (Vint i)) (Val.add v' (Vint i)).","proofString":"apply Val.add_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osub) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v v0) (Val.sub v' v'0).","proofString":"apply Val.sub_inject; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osubshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub v (eval_shift s v0)) (Val.sub v' (eval_shift s v'0)).","proofString":"apply Val.sub_inject; auto.\napply eval_shift_inj; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osubshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (eval_shift s v0) (eval_shift s v'0).","proofString":"apply eval_shift_inj; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Orsubshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.sub (eval_shift s v0) v) (Val.sub (eval_shift s v'0) v').","proofString":"apply Val.sub_inject; auto.\napply eval_shift_inj; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Orsubshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (eval_shift s v0) (eval_shift s v'0).","proofString":"apply eval_shift_inj; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Orsubimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f match v with\n             | Vint n2 => Vint (Int.sub i n2)\n             | _ => Vundef\n             end\n  match v' with\n  | Vint n2 => Vint (Int.sub i n2)\n  | _ => Vundef\n  end.","proofString":"apply (@Val.sub_inject f (Vint i) (Vint i) v v'); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omul) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omla) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.add (Val.mul v v0) v2) (Val.add (Val.mul v' v'0) v'1).","proofString":"apply Val.add_inject; auto.\ninv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 v2 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omla) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (v'1 : val) (H3 : Val.inject f v2 v'1) : Val.inject f (Val.mul v v0) (Val.mul v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhs v v0) (Val.mulhs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulhu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulhu v v0) (Val.mulhu v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divs v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divs v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val, Val.divs (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v1) : exists v2 : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odiv) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divs i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divs i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.divu v v0 = Some v1) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : exists v2 : val, Val.divu v' v'0 = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; inv H3; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val, Val.divu (Vint i) (Vint i0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) (H2 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v1) : exists v2 : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.eq i0 Int.zero); inv H2.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : exists v2 : val,\n  Some (Vint (Int.divu i i0)) = Some v2 /\\\n  Val.inject f (Vint (Int.divu i i0)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oand) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v v0) (Val.and v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (eval_shift s v0)) (Val.and v' (eval_shift s v'0)).","proofString":"exploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (IS : Val.inject f (eval_shift s v0) (eval_shift s v'0)) : Val.inject f (Val.and v (eval_shift s v0)) (Val.and v' (eval_shift s v'0)).","proofString":"inv H4; inv IS; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oandimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.and v (Vint i)) (Val.and v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v v0) (Val.or v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.or v (eval_shift s v0)) (Val.or v' (eval_shift s v'0)).","proofString":"exploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (IS : Val.inject f (eval_shift s v0) (eval_shift s v'0)) : Val.inject f (Val.or v (eval_shift s v0)) (Val.or v' (eval_shift s v'0)).","proofString":"inv H4; inv IS; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oorimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.or v (Vint i)) (Val.or v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oxor) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v v0) (Val.xor v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.xor v (eval_shift s v0)) (Val.xor v' (eval_shift s v'0)).","proofString":"exploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (IS : Val.inject f (eval_shift s v0) (eval_shift s v'0)) : Val.inject f (Val.xor v (eval_shift s v0)) (Val.xor v' (eval_shift s v'0)).","proofString":"inv H4; inv IS; simpl; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oxorimm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.xor v (Vint i)) (Val.xor v' (Vint i)).","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Obic) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (Val.notint v0)) (Val.and v' (Val.notint v'0)).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Obicshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.and v (Val.notint (eval_shift s v0)))\n  (Val.and v' (Val.notint (eval_shift s v'0))).","proofString":"exploit (eval_shift_inj s).\neexact H2.\nintros IS.\ninv H4; inv IS; simpl; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Obicshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) (IS : Val.inject f (eval_shift s v0) (eval_shift s v'0)) : Val.inject f (Val.and v (Val.notint (eval_shift s v0)))\n  (Val.and v' (Val.notint (eval_shift s v'0))).","proofString":"inv H4; inv IS; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onot) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint v) (Val.notint v').","proofString":"inv H4; simpl; auto."},{"statement":"(s : shift) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Onotshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.notint (eval_shift s v)) (Val.notint (eval_shift s v')).","proofString":"exploit (eval_shift_inj s).\neexact H4.\nintros IS.\ninv IS; simpl; auto."},{"statement":"(s : shift) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Onotshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (IS : Val.inject f (eval_shift s v) (eval_shift s v')) : Val.inject f (Val.notint (eval_shift s v)) (Val.notint (eval_shift s v')).","proofString":"inv IS; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shl v v0) (Val.shl v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshl) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shr v v0) (Val.shr v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.shru v v0) (Val.shru v' v'0).","proofString":"inv H4; inv H2; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oshru) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); auto."},{"statement":"(s : shift) (sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (eval_shift s v) (eval_shift s v').","proofString":"apply eval_shift_inj; auto."},{"statement":"(i : int) (sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.shrx v (Vint i) = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.shrx v' (Vint i) = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Int.ltu i (Int.repr 31)); inv H2.\nTrivialExists."},{"statement":"(i : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) (H2 : (if Int.ltu i (Int.repr 31) then Some (Vint (Int.shrx i0 i)) else None) =\nSome v1) : exists v2 : val, Val.shrx (Vint i0) (Vint i) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Int.ltu i (Int.repr 31)); inv H2.\nTrivialExists."},{"statement":"(i : int) (sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) (H2 : (if Int.ltu i (Int.repr 31) then Some (Vint (Int.shrx i0 i)) else None) =\nSome v1) : exists v2 : val,\n  (if Int.ltu i (Int.repr 31) then Some (Vint (Int.shrx i0 i)) else None) =\n  Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Int.ltu i (Int.repr 31)); inv H2.\nTrivialExists."},{"statement":"(i : int) (sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Oshrximm i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i0 : int) : exists v2 : val,\n  Some (Vint (Int.shrx i0 i)) = Some v2 /\\\n  Val.inject f (Vint (Int.shrx i0 i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negf v) (Val.negf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absf v) (Val.absf v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addf v v0) (Val.addf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subf v v0) (Val.subf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulf v v0) (Val.mulf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivf) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divf v v0) (Val.divf v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Onegfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.negfs v) (Val.negfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oabsfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.absfs v) (Val.absfs v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Oaddfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.addfs v v0) (Val.addfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osubfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.subfs v v0) (Val.subfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omulfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.mulfs v v0) (Val.mulfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Odivfs) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.divfs v v0) (Val.divfs v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.singleoffloat v) (Val.singleoffloat v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.floatofsingle v) (Val.floatofsingle v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val, Val.intoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuoffloat v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuoffloat v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val, Val.intuoffloat (Vfloat f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (H2 : option_map Vint (Float.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuoffloat) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in *; inv H1.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_int i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ofloatofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.floatofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.floatofintu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in *; inv H1.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vfloat (Float.of_intu i)) = Some v2 /\\\n  Val.inject f (Vfloat (Float.of_intu i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val, Val.intofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_int f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_int f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_int f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.intuofsingle v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.intuofsingle v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in H1; inv H1.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  Val.intuofsingle (Vsingle f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"simpl.\ndestruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (H2 : option_map Vint (Float32.to_intu f0) = Some v1) : exists v2 : val,\n  option_map Vint (Float32.to_intu f0) = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct (Float32.to_intu f0); simpl in H2; inv H2.\nexists (Vint i); auto."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ointuofsingle) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (f0 : float32) (i : int) : exists v2 : val,\n  option_map Vint (Some i) = Some v2 /\\ Val.inject f (Vint i) v2.","proofString":"exists (Vint i); auto."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofint) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofint v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofint v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in *; inv H1.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_int i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_int i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v sp2 v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Osingleofintu) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H1 : Val.singleofintu v = Some v1) (v' : val) (H4 : Val.inject f v v') : exists v2 : val, Val.singleofintu v' = Some v2 /\\ Val.inject f v1 v2.","proofString":"inv H4; simpl in *; inv H1.\nTrivialExists."},{"statement":"(sp1 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nFalse ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (i : int) : exists v2 : val,\n  Some (Vsingle (Float32.of_intu i)) = Some v2 /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) v2.","proofString":"TrivialExists."},{"statement":"(sp1 v v0 sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Omakelong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (H2 : Val.inject f v0 v'0) : Val.inject f (Val.longofwords v v0) (Val.longofwords v' v'0).","proofString":"inv H4; inv H2; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Olowlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.loword v) (Val.loword v').","proofString":"inv H4; simpl; auto."},{"statement":"(sp1 v sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation Ohighlong) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') : Val.inject f (Val.hiword v) (Val.hiword v').","proofString":"inv H4; simpl; auto."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (H2 : Val.of_optbool (eval_condition c vl1 m1) = v1) : Val.inject f v1 (Val.of_optbool (eval_condition c vl2 m2)).","proofString":"subst v1.\ndestruct (eval_condition c vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) : Val.inject f (Val.of_optbool (eval_condition c vl1 m1))\n  (Val.of_optbool (eval_condition c vl2 m2)).","proofString":"destruct (eval_condition c vl1 m1) eqn:?.\nexploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor.\nsimpl; constructor."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition c vl1 m1 = Some b) : Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition c vl2 m2)).","proofString":"exploit eval_condition_inj; eauto.\nintros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition c vl1 m1 = Some b) : eval_condition c vl2 m2 = Some b ->\nVal.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (eval_condition c vl2 m2)).","proofString":"intros EQ; rewrite EQ.\ndestruct b; simpl; constructor."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (b : bool) (Heqo : eval_condition c vl1 m1 = Some b) (EQ : eval_condition c vl2 m2 = Some b) : Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b)).","proofString":"destruct b; simpl; constructor."},{"statement":"(c : condition) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Ocmp c)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (H0 : Val.inject_list f vl1 vl2) (Heqo : eval_condition c vl1 m1 = None) : Val.inject f (Val.of_optbool None) (Val.of_optbool (eval_condition c vl2 m2)).","proofString":"simpl; constructor."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : Val.inject f (Val.select (eval_condition c vl1 m1) v v0 t)\n  (Val.select (eval_condition c vl'0 m2) v' v'0 t).","proofString":"apply Val.select_inject; auto.\ndestruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) : eval_condition c vl1 m1 = None \\/\neval_condition c vl1 m1 = eval_condition c vl'0 m2.","proofString":"destruct (eval_condition c vl1 m1) eqn:?; auto.\nright; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(c : condition) (t : typ) (sp1 v v0 : val) (vl1 : list val) (sp2 : val) (GL : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation (Osel c t)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H : Val.inject f sp1 sp2) (v' : val) (H4 : Val.inject f v v') (v'0 : val) (vl'0 : list val) (H2 : Val.inject f v0 v'0) (H5 : Val.inject_list f vl1 vl'0) (b : bool) (Heqo : eval_condition c vl1 m1 = Some b) : Some b = None \\/ Some b = eval_condition c vl'0 m2.","proofString":"right; symmetry; eapply eval_condition_inj; eauto."},{"statement":"(addr : addressing) (sp1 : val) (vl1 : list val) (sp2 : val) (vl2 : list val) (v1 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (H1 : Val.inject_list f vl1 vl2) (H2 : eval_addressing ge1 sp1 addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing ge2 sp2 addr vl2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"destruct addr; simpl in H2; simpl; FuncInv; InvInject; TrivialExists.\napply Val.add_inject; auto.\napply Val.add_inject; auto.\napply Val.add_inject; auto.\napply eval_shift_inj; auto.\napply Val.offset_ptr_inject; auto."},{"statement":"(i : int) (sp1 v sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') : Val.inject f (Val.add v (Vint i)) (Val.add v' (Vint i)).","proofString":"apply Val.add_inject; auto."},{"statement":"(sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing Aindexed2) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.add v v0) (Val.add v' v'0).","proofString":"apply Val.add_inject; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed2shift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (Val.add v (eval_shift s v0)) (Val.add v' (eval_shift s v'0)).","proofString":"apply Val.add_inject; auto.\napply eval_shift_inj; auto."},{"statement":"(s : shift) (sp1 v v0 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Aindexed2shift s)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) (v' : val) (H5 : Val.inject f v v') (v'0 : val) (H3 : Val.inject f v0 v'0) : Val.inject f (eval_shift s v0) (eval_shift s v'0).","proofString":"apply eval_shift_inj; auto."},{"statement":"(i : ptrofs) (sp1 sp2 : val) (H : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing (Ainstack i)) ->\nVal.inject f (Genv.symbol_address ge1 id ofs)\n  (Genv.symbol_address ge2 id ofs)) (H0 : Val.inject f sp1 sp2) : Val.inject f (Val.offset_ptr sp1 i) (Val.offset_ptr sp2 i).","proofString":"apply Val.offset_ptr_inject; auto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : Some (b1, 0) = Some (b2, delta)) (H1 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H0.\nrewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","proofString":"rewrite Ptrofs.add_zero.\neapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 m2 : mem) (H : Mem.extends m1 m2) (ofs : ptrofs) (b2 : block) (H1 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"eapply Mem.weak_valid_pointer_extends; eauto."},{"statement":"(m1 : mem) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(m1 : mem) (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"inv H2; inv H3.\nauto."},{"statement":"(m1 : mem) (ofs1 ofs2 : ptrofs) (b1' b2' : block) (H0 : Mem.valid_pointer m1 b1' (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2' (Ptrofs.unsigned ofs2) = true) (H : b1' <> b2') : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr 0)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr 0)).","proofString":"auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := fun b => Some(b, 0)) (m1 := m1).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nrewrite <- val_inject_list_lessdef.\neauto.\nauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.lessdef_list vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_operation genv sp op vl2 m2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_operation_inj with (m1 := m1) (sp1 := sp).\napply valid_pointer_extends; auto.\napply weak_valid_pointer_extends; auto.\napply weak_valid_pointer_no_overflow_extends.\napply valid_different_pointers_extends; auto.\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"apply weak_valid_pointer_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nSome (b1, 0) = Some (b2, delta) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"apply weak_valid_pointer_no_overflow_extends."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nSome (b1, 0) = Some (b1', delta1) ->\nSome (b2, 0) = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"apply valid_different_pointers_extends; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (H2 : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_operation genv sp op vl2 m2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H2 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_operation genv sp op vl2 m2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : Mem.extends m1 m2) (H1 : eval_operation genv sp op vl1 m1 = Some v1) (v2 : val) (A : eval_operation genv sp op vl2 m2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.lessdef_list vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"rewrite val_inject_list_lessdef in H.\nassert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"assert (exists v2 : val,          eval_addressing genv sp addr vl2 = Some v2          /\\ Val.inject (fun b => Some(b, 0)) v1 v2).\neapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto.\ndestruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := sp).\nintros.\nrewrite <- val_inject_lessdef; auto.\nrewrite <- val_inject_lessdef; auto.\neauto.\nauto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) : Val.inject (fun b : block => Some (b, 0)) sp sp.","proofString":"rewrite <- val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (H1 : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\\n  Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v2 : val,\n  eval_addressing genv sp addr vl2 = Some v2 /\\ Val.lessdef v1 v2.","proofString":"destruct H1 as [v2 [A B]].\nexists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : exists v0 : val,\n  eval_addressing genv sp addr vl2 = Some v0 /\\ Val.lessdef v1 v0.","proofString":"exists v2; split; auto.\nrewrite val_inject_lessdef; auto."},{"statement":"(sp : val) (addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list (fun b : block => Some (b, 0)) vl1 vl2) (H0 : eval_addressing genv sp addr vl1 = Some v1) (v2 : val) (A : eval_addressing genv sp addr vl2 = Some v2) (B : Val.inject (fun b : block => Some (b, 0)) v1 v2) : Val.lessdef v1 v2.","proofString":"rewrite val_inject_lessdef; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) : Val.inject f\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol genv id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol genv id) eqn:?; auto.\nexploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"exploit (proj1 globals); eauto.\nintros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) : f b = Some (b, 0) -> Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"intros.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : Val.inject f (Vptr b ofs) (Vptr b ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (Heqo : Genv.find_symbol genv id = Some b) (H : f b = Some (b, 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : eval_condition cond vl2 m2 = Some b.","proofString":"eapply eval_condition_inj with (f := f) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(cond : condition) (vl1 vl2 : list val) (b : bool) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_condition cond vl1 m1 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 Ptrofs.zero)\n    (shift_stack_addressing delta addr) vl2 = Some v2 /\\ \n  Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_addressing.\neapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : exists v2 : val,\n  eval_addressing genv (Vptr sp2 (Ptrofs.repr delta)) addr vl2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_addressing_inj with (sp1 := Vptr sp1 Ptrofs.zero); eauto.\nintros.\napply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros.\napply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) (id : ident) (ofs : ptrofs) (H1 : In id (globals_addressing addr)) : Val.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"apply symbol_address_inject."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(addr : addressing) (vl1 vl2 : list val) (v1 : val) (H : Val.inject_list f vl1 vl2) (H0 : eval_addressing genv (Vptr sp1 Ptrofs.zero) addr vl1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 Ptrofs.zero) (shift_stack_operation delta op)\n    vl2 m2 = Some v2 /\\ Val.inject f v1 v2.","proofString":"rewrite eval_shift_stack_operation.\nsimpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros; apply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"simpl.\neapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros; apply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : exists v2 : val,\n  eval_operation genv (Vptr sp2 (Ptrofs.repr delta)) op vl2 m2 = Some v2 /\\\n  Val.inject f v1 v2.","proofString":"eapply eval_operation_inj with (sp1 := Vptr sp1 Ptrofs.zero) (m1 := m1); eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros; apply symbol_address_inject.\neconstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta0))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nMem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta0) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject f (Genv.symbol_address genv id ofs)\n  (Genv.symbol_address genv id ofs).","proofString":"intros; apply symbol_address_inject."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Val.inject f (Vptr sp1 Ptrofs.zero) (Vptr sp2 (Ptrofs.repr delta)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(op : operation) (vl1 vl2 : list val) (v1 : val) (m1 m2 : mem) (H : Val.inject_list f vl1 vl2) (H0 : Mem.inject f m1 m2) (H1 : eval_operation genv (Vptr sp1 Ptrofs.zero) op vl1 m1 = Some v1) : Ptrofs.repr delta = Ptrofs.add Ptrofs.zero (Ptrofs.repr delta).","proofString":"rewrite Ptrofs.add_zero_l; auto."}]}