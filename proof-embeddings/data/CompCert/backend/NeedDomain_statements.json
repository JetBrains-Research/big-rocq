{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/NeedDomain.v","fileSamples":[{"statement":"(x y : nval) (m m0 : int) : {m = m0} + {m <> m0}.","proofString":"apply Int.eq_dec."},{"statement":"(x y : nval) (m m0 : int64) : {m = m0} + {m <> m0}.","proofString":"apply Int64.eq_dec."},{"statement":"(v : val) (x : nval) : vagree v v x.","proofString":"destruct x; simpl; auto; destruct v; auto; red; auto."},{"statement":"(v w : val) (x : nval) (H : Val.lessdef v w) : vagree v w x.","proofString":"inv H.\napply vagree_same.\ndestruct x; simpl; auto."},{"statement":"(w : val) (x : nval) : vagree w w x.","proofString":"apply vagree_same."},{"statement":"(w : val) (x : nval) : vagree Vundef w x.","proofString":"destruct x; simpl; auto."},{"statement":"(v w : val) (H : vagree v w All) : Val.lessdef v w.","proofString":"simpl in H.\nauto."},{"statement":"(v w : val) (H : Val.lessdef v w) : Val.lessdef v w.","proofString":"auto."},{"statement":"(nvl : list nval) : vagree_list nil nil nvl.","proofString":"constructor."},{"statement":"(v1 v2 : val) (vl1 vl2 : list val) (H : Val.lessdef v1 v2) (H0 : Val.lessdef_list vl1 vl2) (IHlessdef_list : forall nvl0 : list nval, vagree_list vl1 vl2 nvl0) (nvl : list nval) : vagree_list (v1 :: vl1) (v2 :: vl2) nvl.","proofString":"destruct nvl; constructor; auto with na."},{"statement":"(v w : val) (x : nval) : Val.lessdef v w -> vagree v w x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (m1 m2 : int) (H : forall i : Z,\n0 <= i < Int.zwordsize -> Int.testbit m2 i = true -> Int.testbit m1 i = true) : match v with\n| Vint p => match w with\n            | Vint q => iagree p q m1\n            | _ => False\n            end\n| _ => True\nend ->\nmatch v with\n| Vint p => match w with\n            | Vint q => iagree p q m2\n            | _ => False\n            end\n| _ => True\nend.","proofString":"destruct v, w; intuition.\nred; auto."},{"statement":"(i i0 m1 m2 : int) (H : forall i1 : Z,\n0 <= i1 < Int.zwordsize ->\nInt.testbit m2 i1 = true -> Int.testbit m1 i1 = true) (H0 : iagree i i0 m1) : iagree i i0 m2.","proofString":"red; auto."},{"statement":"(v w : val) (m1 m2 : int64) (H : forall i : Z,\n0 <= i < Int64.zwordsize ->\nInt64.testbit m2 i = true -> Int64.testbit m1 i = true) : match v with\n| Vlong p => match w with\n             | Vlong q => lagree p q m1\n             | _ => False\n             end\n| _ => True\nend ->\nmatch v with\n| Vlong p => match w with\n             | Vlong q => lagree p q m2\n             | _ => False\n             end\n| _ => True\nend.","proofString":"destruct v, w; intuition.\nred; auto."},{"statement":"(i i0 m1 m2 : int64) (H : forall i1 : Z,\n0 <= i1 < Int64.zwordsize ->\nInt64.testbit m2 i1 = true -> Int64.testbit m1 i1 = true) (H0 : lagree i i0 m1) : lagree i i0 m2.","proofString":"red; auto."},{"statement":"(x y mask : int) (H : iagree x y mask) : Int.and x mask = Int.and y mask.","proofString":"Int.bit_solve.\nspecialize (H i H0).\ndestruct (Int.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int) (H : iagree x y mask) (i : Z) (H0 : 0 <= i < Int.zwordsize) : Int.testbit x i && Int.testbit mask i = Int.testbit y i && Int.testbit mask i.","proofString":"specialize (H i H0).\ndestruct (Int.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int) (i : Z) (H : Int.testbit mask i = true -> Int.testbit x i = Int.testbit y i) (H0 : 0 <= i < Int.zwordsize) : Int.testbit x i && Int.testbit mask i = Int.testbit y i && Int.testbit mask i.","proofString":"destruct (Int.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int) (i : Z) (H : true = true -> Int.testbit x i = Int.testbit y i) (H0 : 0 <= i < Int.zwordsize) : Int.testbit x i && true = Int.testbit y i && true.","proofString":"rewrite ! andb_true_r; auto."},{"statement":"(x y mask : int) (i : Z) (H : false = true -> Int.testbit x i = Int.testbit y i) (H0 : 0 <= i < Int.zwordsize) : Int.testbit x i && false = Int.testbit y i && false.","proofString":"rewrite ! andb_false_r; auto."},{"statement":"(x y mask : int) (H : Int.and x mask = Int.and y mask) : iagree x y mask.","proofString":"red; intros.\nexploit (eq_same_bits i); eauto; autorewrite with ints; auto.\nrewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int) (H : Int.and x mask = Int.and y mask) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit mask i = true) : Int.testbit x i = Int.testbit y i.","proofString":"exploit (eq_same_bits i); eauto; autorewrite with ints; auto.\nrewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int) (H : Int.and x mask = Int.and y mask) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit mask i = true) : Int.testbit x i && Int.testbit mask i = Int.testbit y i && Int.testbit mask i ->\nInt.testbit x i = Int.testbit y i.","proofString":"rewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int) (H : Int.and x mask = Int.and y mask) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit mask i = true) : Int.testbit x i && true = Int.testbit y i && true ->\nInt.testbit x i = Int.testbit y i.","proofString":"rewrite ! andb_true_r; auto."},{"statement":"(p q : int) (H : iagree p q Int.mone) : p = q.","proofString":"rewrite iagree_and_eq in H.\nrewrite ! Int.and_mone in H.\nauto."},{"statement":"(p q : int) (H : Int.and p Int.mone = Int.and q Int.mone) : p = q.","proofString":"rewrite ! Int.and_mone in H.\nauto."},{"statement":"(p q : int) (H : p = q) : p = q.","proofString":"auto."},{"statement":"(p q : int) : iagree p q Int.zero.","proofString":"rewrite iagree_and_eq.\nrewrite ! Int.and_zero; auto."},{"statement":"(p q : int) : Int.and p Int.zero = Int.and q Int.zero.","proofString":"rewrite ! Int.and_zero; auto."},{"statement":"(x y n m : int) (H : iagree x y (Int.and m n)) : iagree (Int.and x n) (Int.and y n) m.","proofString":"rewrite iagree_and_eq in *.\nrewrite ! Int.and_assoc.\nrewrite (Int.and_commut n).\nauto."},{"statement":"(x y n m : int) (H : Int.and x (Int.and m n) = Int.and y (Int.and m n)) : Int.and (Int.and x n) m = Int.and (Int.and y n) m.","proofString":"rewrite ! Int.and_assoc.\nrewrite (Int.and_commut n).\nauto."},{"statement":"(x y n m : int) (H : Int.and x (Int.and m n) = Int.and y (Int.and m n)) : Int.and x (Int.and n m) = Int.and y (Int.and n m).","proofString":"rewrite (Int.and_commut n).\nauto."},{"statement":"(x y n m : int) (H : Int.and x (Int.and m n) = Int.and y (Int.and m n)) : Int.and x (Int.and m n) = Int.and y (Int.and m n).","proofString":"auto."},{"statement":"(x y m : int) (H : iagree x y m) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : negb (Int.testbit x i) = negb (Int.testbit y i).","proofString":"f_equal; auto."},{"statement":"(x y m : int) (H : iagree (Int.not x) (Int.not y) m) : iagree x y m.","proofString":"rewrite <- (Int.not_involutive x).\nrewrite <- (Int.not_involutive y).\napply iagree_not; auto."},{"statement":"(x y m : int) (H : iagree (Int.not x) (Int.not y) m) : iagree (Int.not (Int.not x)) y m.","proofString":"rewrite <- (Int.not_involutive y).\napply iagree_not; auto."},{"statement":"(x y m : int) (H : iagree (Int.not x) (Int.not y) m) : iagree (Int.not (Int.not x)) (Int.not (Int.not y)) m.","proofString":"apply iagree_not; auto."},{"statement":"(x y n m : int) (H : iagree x y (Int.and m (Int.not n))) : iagree (Int.or x n) (Int.or y n) m.","proofString":"apply iagree_not'.\nrewrite ! Int.not_or_and_not.\napply iagree_and.\napply iagree_not; auto."},{"statement":"(x y n m : int) (H : iagree x y (Int.and m (Int.not n))) : iagree (Int.not (Int.or x n)) (Int.not (Int.or y n)) m.","proofString":"rewrite ! Int.not_or_and_not.\napply iagree_and.\napply iagree_not; auto."},{"statement":"(x y n m : int) (H : iagree x y (Int.and m (Int.not n))) : iagree (Int.and (Int.not x) (Int.not n)) (Int.and (Int.not y) (Int.not n)) m.","proofString":"apply iagree_and.\napply iagree_not; auto."},{"statement":"(x y n m : int) (H : iagree x y (Int.and m (Int.not n))) : iagree (Int.not x) (Int.not y) (Int.and m (Int.not n)).","proofString":"apply iagree_not; auto."},{"statement":"(sem : bool -> bool -> bool) (f : int -> int -> int) (H : forall (x y : int) (i0 : Z),\n0 <= i0 < Int.zwordsize ->\nInt.testbit (f x y) i0 = sem (Int.testbit x i0) (Int.testbit y i0)) (x1 x2 y1 y2 m : int) (H0 : iagree x1 y1 m) (H1 : iagree x2 y2 m) (i : Z) (H2 : 0 <= i < Int.zwordsize) (H3 : Int.testbit m i = true) : Int.testbit (f x1 x2) i = Int.testbit (f y1 y2) i.","proofString":"rewrite ! H by auto.\nf_equal; auto."},{"statement":"(sem : bool -> bool -> bool) (f : int -> int -> int) (H : forall (x y : int) (i0 : Z),\n0 <= i0 < Int.zwordsize ->\nInt.testbit (f x y) i0 = sem (Int.testbit x i0) (Int.testbit y i0)) (x1 x2 y1 y2 m : int) (H0 : iagree x1 y1 m) (H1 : iagree x2 y2 m) (i : Z) (H2 : 0 <= i < Int.zwordsize) (H3 : Int.testbit m i = true) : sem (Int.testbit x1 i) (Int.testbit x2 i) =\nsem (Int.testbit y1 i) (Int.testbit y2 i).","proofString":"f_equal; auto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Int.testbit (Int.shl x n) i = Int.testbit (Int.shl y n) i.","proofString":"autorewrite with ints; auto.\ndestruct (zlt i (Int.unsigned n)).\nauto.\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shru by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : (if zlt i (Int.unsigned n) then false else Int.testbit x (i - Int.unsigned n)) =\n(if zlt i (Int.unsigned n) then false else Int.testbit y (i - Int.unsigned n)).","proofString":"destruct (zlt i (Int.unsigned n)).\nauto.\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shru by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i < Int.unsigned n) : false = false.","proofString":"auto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) : Int.testbit x (i - Int.unsigned n) = Int.testbit y (i - Int.unsigned n).","proofString":"generalize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shru by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit x (i - Int.unsigned n) = Int.testbit y (i - Int.unsigned n).","proofString":"apply H.\nlia.\nrewrite Int.bits_shru by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : 0 <= i - Int.unsigned n < Int.zwordsize.","proofString":"lia."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit (Int.shru m n) (i - Int.unsigned n) = true.","proofString":"rewrite Int.bits_shru by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i - Int.unsigned n + Int.unsigned n) Int.zwordsize\n then Int.testbit m (i - Int.unsigned n + Int.unsigned n)\n else false) = true.","proofString":"replace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt i Int.zwordsize then Int.testbit m i else false) = true.","proofString":"rewrite zlt_true by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shru m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit m i = true.","proofString":"auto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Int.testbit (Int.shru x n) i = Int.testbit (Int.shru y n) i.","proofString":"autorewrite with ints; auto.\ndestruct (zlt (i + Int.unsigned n) Int.zwordsize).\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shl by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : (if zlt (i + Int.unsigned n) Int.zwordsize\n then Int.testbit x (i + Int.unsigned n)\n else false) =\n(if zlt (i + Int.unsigned n) Int.zwordsize\n then Int.testbit y (i + Int.unsigned n)\n else false).","proofString":"destruct (zlt (i + Int.unsigned n) Int.zwordsize).\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shl by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) : Int.testbit x (i + Int.unsigned n) = Int.testbit y (i + Int.unsigned n).","proofString":"generalize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int.bits_shl by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit x (i + Int.unsigned n) = Int.testbit y (i + Int.unsigned n).","proofString":"apply H.\nlia.\nrewrite Int.bits_shl by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : 0 <= i + Int.unsigned n < Int.zwordsize.","proofString":"lia."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit (Int.shl m n) (i + Int.unsigned n) = true.","proofString":"rewrite Int.bits_shl by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int.testbit m (i + Int.unsigned n - Int.unsigned n)) = true.","proofString":"replace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i + Int.unsigned n) (Int.unsigned n) then false else Int.testbit m i) =\ntrue.","proofString":"rewrite zlt_false by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i + Int.unsigned n < Int.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit m i = true.","proofString":"auto."},{"statement":"(x y m n : int) (H : iagree x y (Int.shl m n)) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i + Int.unsigned n >= Int.zwordsize) : false = false.","proofString":"auto."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (H2 : Int.testbit m i = true) : Int.testbit (Int.shr x n) i = Int.testbit (Int.shr y n) i.","proofString":"rewrite <- H in H2.\nrewrite Int.bits_shru in H2 by auto.\nrewrite ! Int.bits_shr by auto.\ndestruct (zlt (i + Int.unsigned n) Int.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (H2 : Int.testbit (Int.shru (Int.shl m n) n) i = true) : Int.testbit (Int.shr x n) i = Int.testbit (Int.shr y n) i.","proofString":"rewrite Int.bits_shru in H2 by auto.\nrewrite ! Int.bits_shr by auto.\ndestruct (zlt (i + Int.unsigned n) Int.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (H2 : (if zlt (i + Int.unsigned n) Int.zwordsize\n then Int.testbit (Int.shl m n) (i + Int.unsigned n)\n else false) = true) : Int.testbit (Int.shr x n) i = Int.testbit (Int.shr y n) i.","proofString":"rewrite ! Int.bits_shr by auto.\ndestruct (zlt (i + Int.unsigned n) Int.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (H2 : (if zlt (i + Int.unsigned n) Int.zwordsize\n then Int.testbit (Int.shl m n) (i + Int.unsigned n)\n else false) = true) : Int.testbit x\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit y\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1).","proofString":"destruct (zlt (i + Int.unsigned n) Int.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (l : i + Int.unsigned n < Int.zwordsize) (H2 : Int.testbit (Int.shl m n) (i + Int.unsigned n) = true) : Int.testbit x (i + Int.unsigned n) = Int.testbit y (i + Int.unsigned n).","proofString":"apply H0; auto.\ngeneralize (Int.unsigned_range n); lia."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (l : i + Int.unsigned n < Int.zwordsize) (H2 : Int.testbit (Int.shl m n) (i + Int.unsigned n) = true) : 0 <= i + Int.unsigned n < Int.zwordsize.","proofString":"generalize (Int.unsigned_range n); lia."},{"statement":"(x y m n : int) (H : Int.shru (Int.shl m n) n = m) (H0 : iagree x y (Int.shl m n)) (i : Z) (H1 : 0 <= i < Int.zwordsize) (g : i + Int.unsigned n >= Int.zwordsize) (H2 : false = true) : Int.testbit x (Int.zwordsize - 1) = Int.testbit y (Int.zwordsize - 1).","proofString":"discriminate."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Int.testbit (Int.shr x n) i = Int.testbit (Int.shr y n) i.","proofString":"rewrite ! Int.bits_shr by auto.\ngeneralize (Int.unsigned_range n); intros.\nset (j := if zlt (i + Int.unsigned n) Int.zwordsize            then i + Int.unsigned n            else Int.zwordsize - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Int.testbit x\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit y\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1).","proofString":"generalize (Int.unsigned_range n); intros.\nset (j := if zlt (i + Int.unsigned n) Int.zwordsize            then i + Int.unsigned n            else Int.zwordsize - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int.testbit x\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1) =\nInt.testbit y\n  (if zlt (i + Int.unsigned n) Int.zwordsize\n   then i + Int.unsigned n\n   else Int.zwordsize - 1).","proofString":"set (j := if zlt (i + Int.unsigned n) Int.zwordsize            then i + Int.unsigned n            else Int.zwordsize - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int.testbit m (i + Int.unsigned n - Int.unsigned n)) = true \\/\nInt.testbit (Int.repr Int.min_signed) (i + Int.unsigned n) = true.","proofString":"left.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int.testbit m (i + Int.unsigned n - Int.unsigned n)) = true.","proofString":"rewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : Int.testbit m (i + Int.unsigned n - Int.unsigned n) = true.","proofString":"replace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : Int.testbit m i = true.","proofString":"auto."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (g : i + Int.unsigned n >= Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (Int.zwordsize - 1) (Int.unsigned n)\n then false\n else Int.testbit m (Int.zwordsize - 1 - Int.unsigned n)) = true \\/\nInt.testbit (Int.repr Int.min_signed) (Int.zwordsize - 1) = true.","proofString":"right.\nreflexivity."},{"statement":"(x y m n : int) (H : iagree x y (Int.or (Int.shl m n) (Int.repr Int.min_signed))) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (g : i + Int.unsigned n >= Int.zwordsize) (j : Z) (H3 : 0 <= j < Int.zwordsize) : Int.testbit (Int.repr Int.min_signed) (Int.zwordsize - 1) = true.","proofString":"reflexivity."},{"statement":"(p q m amount : int) (H : iagree p q (Int.rol m amount)) : iagree (Int.ror p amount) (Int.ror q amount) m.","proofString":"rewrite ! Int.ror_rol_neg by apply int_wordsize_divides_modulus.\napply iagree_rol.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_involutive; auto."},{"statement":"(p q m amount : int) (H : iagree p q (Int.rol m amount)) : iagree (Int.rol p (Int.neg amount)) (Int.rol q (Int.neg amount)) m.","proofString":"apply iagree_rol.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_involutive; auto."},{"statement":"(p q m amount : int) (H : iagree p q (Int.rol m amount)) : iagree p q (Int.ror m (Int.neg amount)).","proofString":"rewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_involutive; auto."},{"statement":"(p q m amount : int) (H : iagree p q (Int.rol m amount)) : iagree p q (Int.rol m (Int.neg (Int.neg amount))).","proofString":"rewrite Int.neg_involutive; auto."},{"statement":"(m : int) (x y : Z) (H : eqmod (two_p (Int.size m)) x y) : iagree (Int.repr x) (Int.repr y) m.","proofString":"set (p := Z.to_nat (Int.size m)).\ngeneralize (Int.size_range m); intros RANGE.\nassert (EQ: Int.size m = Z.of_nat p).\nsymmetry; apply Z2Nat.id.\nlia.\nrewrite EQ in H; rewrite <- two_power_nat_two_p in H.\nred; intros.\nrewrite ! Int.testbit_repr by auto.\ndestruct (zlt i (Int.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (H : eqmod (two_p (Int.size m)) x y) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) : 0 <= Int.size m.","proofString":"lia."},{"statement":"(m : int) (x y : Z) (H : eqmod (two_p (Int.size m)) x y) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) : iagree (Int.repr x) (Int.repr y) m.","proofString":"rewrite EQ in H; rewrite <- two_power_nat_two_p in H.\nred; intros.\nrewrite ! Int.testbit_repr by auto.\ndestruct (zlt i (Int.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) : iagree (Int.repr x) (Int.repr y) m.","proofString":"red; intros.\nrewrite ! Int.testbit_repr by auto.\ndestruct (zlt i (Int.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Int.testbit (Int.repr x) i = Int.testbit (Int.repr y) i.","proofString":"rewrite ! Int.testbit_repr by auto.\ndestruct (zlt i (Int.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) : Z.testbit x i = Z.testbit y i.","proofString":"destruct (zlt i (Int.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i < Int.size m) : Z.testbit x i = Z.testbit y i.","proofString":"eapply same_bits_eqmod; eauto.\nlia."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (l : i < Int.size m) : 0 <= i < Z.of_nat p.","proofString":"lia."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.size m) : Z.testbit x i = Z.testbit y i.","proofString":"assert (Int.testbit m i = false) by (eapply Int.bits_size_2; lia).\ncongruence."},{"statement":"(m : int) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int.zwordsize) (H1 : Int.testbit m i = true) (g : i >= Int.size m) (H2 : Int.testbit m i = false) : Z.testbit x i = Z.testbit y i.","proofString":"congruence."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y).","proofString":"set (p := Z.to_nat (Int.size m)).\ngeneralize (Int.size_range m); intros RANGE.\nassert (EQ: Int.size m = Z.of_nat p).\nsymmetry; apply Z2Nat.id.\nlia.\nrewrite EQ; rewrite <- two_power_nat_two_p.\napply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) : 0 <= Int.size m.","proofString":"lia."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) : eqmod (two_p (Int.size m)) (Int.unsigned x) (Int.unsigned y).","proofString":"rewrite EQ; rewrite <- two_power_nat_two_p.\napply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) : eqmod (two_power_nat p) (Int.unsigned x) (Int.unsigned y).","proofString":"apply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) : forall i : Z,\n0 <= i < Z.of_nat p ->\nZ.testbit (Int.unsigned x) i = Z.testbit (Int.unsigned y) i.","proofString":"intros.\napply H.\nlia.\nunfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Z.testbit (Int.unsigned x) i = Z.testbit (Int.unsigned y) i.","proofString":"apply H.\nlia.\nunfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : 0 <= i < Int.zwordsize.","proofString":"lia."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int.testbit (complete_mask m) i = true.","proofString":"unfold complete_mask.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int.testbit (Int.zero_ext (Int.size m) Int.mone) i = true.","proofString":"rewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : (if zlt i (Int.size m) then Int.testbit Int.mone i else false) = true.","proofString":"rewrite zlt_true by lia.\nrewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int.testbit Int.mone i = true.","proofString":"rewrite Int.bits_mone by lia.\nauto."},{"statement":"(x y m : int) (H : iagree x y (complete_mask m)) (p : nat) (RANGE : 0 <= Int.size m <= Int.zwordsize) (EQ : Int.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : true = true.","proofString":"auto."},{"statement":"(m : int) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"destruct (Int.eq_dec m Int.zero).\nsubst m; reflexivity.\nassert (Int.unsigned m <> 0).\nred; intros; elim n.\nrewrite <- (Int.repr_unsigned m).\nrewrite H; auto.\nassert (0 < Int.size m).\napply Zsize_pos'.\ngeneralize (Int.unsigned_range m); lia.\ngeneralize (Int.size_range m); intros.\nf_equal.\napply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (e : m = Int.zero) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"subst m; reflexivity."},{"statement":"(m : int) (n : m <> Int.zero) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"assert (Int.unsigned m <> 0).\nred; intros; elim n.\nrewrite <- (Int.repr_unsigned m).\nrewrite H; auto.\nassert (0 < Int.size m).\napply Zsize_pos'.\ngeneralize (Int.unsigned_range m); lia.\ngeneralize (Int.size_range m); intros.\nf_equal.\napply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) : Int.unsigned m <> 0.","proofString":"red; intros; elim n.\nrewrite <- (Int.repr_unsigned m).\nrewrite H; auto."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m = 0) : m = Int.zero.","proofString":"rewrite <- (Int.repr_unsigned m).\nrewrite H; auto."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m = 0) : Int.repr (Int.unsigned m) = Int.zero.","proofString":"rewrite H; auto."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"assert (0 < Int.size m).\napply Zsize_pos'.\ngeneralize (Int.unsigned_range m); lia.\ngeneralize (Int.size_range m); intros.\nf_equal.\napply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) : 0 < Int.size m.","proofString":"apply Zsize_pos'.\ngeneralize (Int.unsigned_range m); lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) : 0 < Int.unsigned m.","proofString":"generalize (Int.unsigned_range m); lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"generalize (Int.size_range m); intros.\nf_equal.\napply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : Int.zero_ext (Int.size (Int.zero_ext (Int.size m) Int.mone)) Int.mone =\nInt.zero_ext (Int.size m) Int.mone.","proofString":"f_equal.\napply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : Int.size (Int.zero_ext (Int.size m) Int.mone) = Int.size m.","proofString":"apply Int.bits_size_4.\ntauto.\nrewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia.\nintros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : 0 <= Int.size m.","proofString":"tauto."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : Int.testbit (Int.zero_ext (Int.size m) Int.mone) (Z.pred (Int.size m)) = true.","proofString":"rewrite Int.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int.bits_mone; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : (if zlt (Z.pred (Int.size m)) (Int.size m)\n then Int.testbit Int.mone (Z.pred (Int.size m))\n else false) = true.","proofString":"rewrite zlt_true by lia.\napply Int.bits_mone; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : Int.testbit Int.mone (Z.pred (Int.size m)) = true.","proofString":"apply Int.bits_mone; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) : forall i : Z,\nInt.size m <= i < Int.zwordsize ->\nInt.testbit (Int.zero_ext (Int.size m) Int.mone) i = false.","proofString":"intros.\nrewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) (i : Z) (H2 : Int.size m <= i < Int.zwordsize) : Int.testbit (Int.zero_ext (Int.size m) Int.mone) i = false.","proofString":"rewrite Int.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int) (n : m <> Int.zero) (H : Int.unsigned m <> 0) (H0 : 0 < Int.size m) (H1 : 0 <= Int.size m <= Int.zwordsize) (i : Z) (H2 : Int.size m <= i < Int.zwordsize) : (if zlt i (Int.size m) then Int.testbit Int.mone i else false) = false.","proofString":"apply zlt_false; lia."},{"statement":"(x y mask : int64) (H : lagree x y mask) : Int64.and x mask = Int64.and y mask.","proofString":"Int64.bit_solve.\nspecialize (H i H0).\ndestruct (Int64.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int64) (H : lagree x y mask) (i : Z) (H0 : 0 <= i < Int64.zwordsize) : Int64.testbit x i && Int64.testbit mask i =\nInt64.testbit y i && Int64.testbit mask i.","proofString":"specialize (H i H0).\ndestruct (Int64.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int64) (i : Z) (H : Int64.testbit mask i = true -> Int64.testbit x i = Int64.testbit y i) (H0 : 0 <= i < Int64.zwordsize) : Int64.testbit x i && Int64.testbit mask i =\nInt64.testbit y i && Int64.testbit mask i.","proofString":"destruct (Int64.testbit mask i).\nrewrite ! andb_true_r; auto.\nrewrite ! andb_false_r; auto."},{"statement":"(x y mask : int64) (i : Z) (H : true = true -> Int64.testbit x i = Int64.testbit y i) (H0 : 0 <= i < Int64.zwordsize) : Int64.testbit x i && true = Int64.testbit y i && true.","proofString":"rewrite ! andb_true_r; auto."},{"statement":"(x y mask : int64) (i : Z) (H : false = true -> Int64.testbit x i = Int64.testbit y i) (H0 : 0 <= i < Int64.zwordsize) : Int64.testbit x i && false = Int64.testbit y i && false.","proofString":"rewrite ! andb_false_r; auto."},{"statement":"(x y mask : int64) (H : Int64.and x mask = Int64.and y mask) : lagree x y mask.","proofString":"red; intros.\nexploit (eq_same_bits64 i); eauto; autorewrite with ints; auto.\nrewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int64) (H : Int64.and x mask = Int64.and y mask) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit mask i = true) : Int64.testbit x i = Int64.testbit y i.","proofString":"exploit (eq_same_bits64 i); eauto; autorewrite with ints; auto.\nrewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int64) (H : Int64.and x mask = Int64.and y mask) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit mask i = true) : Int64.testbit x i && Int64.testbit mask i =\nInt64.testbit y i && Int64.testbit mask i ->\nInt64.testbit x i = Int64.testbit y i.","proofString":"rewrite H1.\nrewrite ! andb_true_r; auto."},{"statement":"(x y mask : int64) (H : Int64.and x mask = Int64.and y mask) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit mask i = true) : Int64.testbit x i && true = Int64.testbit y i && true ->\nInt64.testbit x i = Int64.testbit y i.","proofString":"rewrite ! andb_true_r; auto."},{"statement":"(p q : int64) (H : lagree p q Int64.mone) : p = q.","proofString":"rewrite lagree_and_eq in H.\nrewrite ! Int64.and_mone in H.\nauto."},{"statement":"(p q : int64) (H : Int64.and p Int64.mone = Int64.and q Int64.mone) : p = q.","proofString":"rewrite ! Int64.and_mone in H.\nauto."},{"statement":"(p q : int64) (H : p = q) : p = q.","proofString":"auto."},{"statement":"(p q : int64) : lagree p q Int64.zero.","proofString":"rewrite lagree_and_eq.\nrewrite ! Int64.and_zero; auto."},{"statement":"(p q : int64) : Int64.and p Int64.zero = Int64.and q Int64.zero.","proofString":"rewrite ! Int64.and_zero; auto."},{"statement":"(x y n m : int64) (H : lagree x y (Int64.and m n)) : lagree (Int64.and x n) (Int64.and y n) m.","proofString":"rewrite lagree_and_eq in *.\nrewrite ! Int64.and_assoc.\nrewrite (Int64.and_commut n).\nauto."},{"statement":"(x y n m : int64) (H : Int64.and x (Int64.and m n) = Int64.and y (Int64.and m n)) : Int64.and (Int64.and x n) m = Int64.and (Int64.and y n) m.","proofString":"rewrite ! Int64.and_assoc.\nrewrite (Int64.and_commut n).\nauto."},{"statement":"(x y n m : int64) (H : Int64.and x (Int64.and m n) = Int64.and y (Int64.and m n)) : Int64.and x (Int64.and n m) = Int64.and y (Int64.and n m).","proofString":"rewrite (Int64.and_commut n).\nauto."},{"statement":"(x y n m : int64) (H : Int64.and x (Int64.and m n) = Int64.and y (Int64.and m n)) : Int64.and x (Int64.and m n) = Int64.and y (Int64.and m n).","proofString":"auto."},{"statement":"(x y m : int64) (H : lagree x y m) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : negb (Int64.testbit x i) = negb (Int64.testbit y i).","proofString":"f_equal; auto."},{"statement":"(x y m : int64) (H : lagree (Int64.not x) (Int64.not y) m) : lagree x y m.","proofString":"rewrite <- (Int64.not_involutive x).\nrewrite <- (Int64.not_involutive y).\napply lagree_not; auto."},{"statement":"(x y m : int64) (H : lagree (Int64.not x) (Int64.not y) m) : lagree (Int64.not (Int64.not x)) y m.","proofString":"rewrite <- (Int64.not_involutive y).\napply lagree_not; auto."},{"statement":"(x y m : int64) (H : lagree (Int64.not x) (Int64.not y) m) : lagree (Int64.not (Int64.not x)) (Int64.not (Int64.not y)) m.","proofString":"apply lagree_not; auto."},{"statement":"(x y n m : int64) (H : lagree x y (Int64.and m (Int64.not n))) : lagree (Int64.or x n) (Int64.or y n) m.","proofString":"apply lagree_not'.\nrewrite ! Int64.not_or_and_not.\napply lagree_and.\napply lagree_not; auto."},{"statement":"(x y n m : int64) (H : lagree x y (Int64.and m (Int64.not n))) : lagree (Int64.not (Int64.or x n)) (Int64.not (Int64.or y n)) m.","proofString":"rewrite ! Int64.not_or_and_not.\napply lagree_and.\napply lagree_not; auto."},{"statement":"(x y n m : int64) (H : lagree x y (Int64.and m (Int64.not n))) : lagree (Int64.and (Int64.not x) (Int64.not n))\n  (Int64.and (Int64.not y) (Int64.not n)) m.","proofString":"apply lagree_and.\napply lagree_not; auto."},{"statement":"(x y n m : int64) (H : lagree x y (Int64.and m (Int64.not n))) : lagree (Int64.not x) (Int64.not y) (Int64.and m (Int64.not n)).","proofString":"apply lagree_not; auto."},{"statement":"(sem : bool -> bool -> bool) (f : int64 -> int64 -> int64) (H : forall (x y : int64) (i0 : Z),\n0 <= i0 < Int64.zwordsize ->\nInt64.testbit (f x y) i0 = sem (Int64.testbit x i0) (Int64.testbit y i0)) (x1 x2 y1 y2 m : int64) (H0 : lagree x1 y1 m) (H1 : lagree x2 y2 m) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (H3 : Int64.testbit m i = true) : Int64.testbit (f x1 x2) i = Int64.testbit (f y1 y2) i.","proofString":"rewrite ! H by auto.\nf_equal; auto."},{"statement":"(sem : bool -> bool -> bool) (f : int64 -> int64 -> int64) (H : forall (x y : int64) (i0 : Z),\n0 <= i0 < Int64.zwordsize ->\nInt64.testbit (f x y) i0 = sem (Int64.testbit x i0) (Int64.testbit y i0)) (x1 x2 y1 y2 m : int64) (H0 : lagree x1 y1 m) (H1 : lagree x2 y2 m) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (H3 : Int64.testbit m i = true) : sem (Int64.testbit x1 i) (Int64.testbit x2 i) =\nsem (Int64.testbit y1 i) (Int64.testbit y2 i).","proofString":"f_equal; auto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Int64.testbit (Int64.shl' x n) i = Int64.testbit (Int64.shl' y n) i.","proofString":"rewrite ! Int64.bits_shl'; auto.\ndestruct (zlt i (Int.unsigned n)).\nauto.\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shru' by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : (if zlt i (Int.unsigned n)\n then false\n else Int64.testbit x (i - Int.unsigned n)) =\n(if zlt i (Int.unsigned n)\n then false\n else Int64.testbit y (i - Int.unsigned n)).","proofString":"destruct (zlt i (Int.unsigned n)).\nauto.\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shru' by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i < Int.unsigned n) : false = false.","proofString":"auto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) : Int64.testbit x (i - Int.unsigned n) = Int64.testbit y (i - Int.unsigned n).","proofString":"generalize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shru' by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit x (i - Int.unsigned n) = Int64.testbit y (i - Int.unsigned n).","proofString":"apply H.\nlia.\nrewrite Int64.bits_shru' by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : 0 <= i - Int.unsigned n < Int64.zwordsize.","proofString":"lia."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit (Int64.shru' m n) (i - Int.unsigned n) = true.","proofString":"rewrite Int64.bits_shru' by lia.\nreplace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i - Int.unsigned n + Int.unsigned n) Int64.zwordsize\n then Int64.testbit m (i - Int.unsigned n + Int.unsigned n)\n else false) = true.","proofString":"replace (i - Int.unsigned n + Int.unsigned n) with i by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt i Int64.zwordsize then Int64.testbit m i else false) = true.","proofString":"rewrite zlt_true by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shru' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int.unsigned n) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit m i = true.","proofString":"auto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Int64.testbit (Int64.shru' x n) i = Int64.testbit (Int64.shru' y n) i.","proofString":"rewrite ! Int64.bits_shru'; auto.\ndestruct (zlt (i + Int.unsigned n) Int64.zwordsize).\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shl' by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : (if zlt (i + Int.unsigned n) Int64.zwordsize\n then Int64.testbit x (i + Int.unsigned n)\n else false) =\n(if zlt (i + Int.unsigned n) Int64.zwordsize\n then Int64.testbit y (i + Int.unsigned n)\n else false).","proofString":"destruct (zlt (i + Int.unsigned n) Int64.zwordsize).\ngeneralize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shl' by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) : Int64.testbit x (i + Int.unsigned n) = Int64.testbit y (i + Int.unsigned n).","proofString":"generalize (Int.unsigned_range n); intros.\napply H.\nlia.\nrewrite Int64.bits_shl' by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit x (i + Int.unsigned n) = Int64.testbit y (i + Int.unsigned n).","proofString":"apply H.\nlia.\nrewrite Int64.bits_shl' by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : 0 <= i + Int.unsigned n < Int64.zwordsize.","proofString":"lia."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit (Int64.shl' m n) (i + Int.unsigned n) = true.","proofString":"rewrite Int64.bits_shl' by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int64.testbit m (i + Int.unsigned n - Int.unsigned n)) = true.","proofString":"replace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nrewrite zlt_false by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int64.testbit m i) = true.","proofString":"rewrite zlt_false by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit m i = true.","proofString":"auto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.shl' m n)) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i + Int.unsigned n >= Int64.zwordsize) : false = false.","proofString":"auto."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) : Int64.testbit (Int64.shr' x n) i = Int64.testbit (Int64.shr' y n) i.","proofString":"rewrite <- H in H2.\nrewrite Int64.bits_shru' in H2 by auto.\nrewrite ! Int64.bits_shr' by auto.\ndestruct (zlt (i + Int.unsigned n) Int64.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit (Int64.shru' (Int64.shl' m n) n) i = true) : Int64.testbit (Int64.shr' x n) i = Int64.testbit (Int64.shr' y n) i.","proofString":"rewrite Int64.bits_shru' in H2 by auto.\nrewrite ! Int64.bits_shr' by auto.\ndestruct (zlt (i + Int.unsigned n) Int64.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : (if zlt (i + Int.unsigned n) Int64.zwordsize\n then Int64.testbit (Int64.shl' m n) (i + Int.unsigned n)\n else false) = true) : Int64.testbit (Int64.shr' x n) i = Int64.testbit (Int64.shr' y n) i.","proofString":"rewrite ! Int64.bits_shr' by auto.\ndestruct (zlt (i + Int.unsigned n) Int64.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : (if zlt (i + Int.unsigned n) Int64.zwordsize\n then Int64.testbit (Int64.shl' m n) (i + Int.unsigned n)\n else false) = true) : Int64.testbit x\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1) =\nInt64.testbit y\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1).","proofString":"destruct (zlt (i + Int.unsigned n) Int64.zwordsize).\napply H0; auto.\ngeneralize (Int.unsigned_range n); lia.\ndiscriminate."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : Int64.testbit (Int64.shl' m n) (i + Int.unsigned n) = true) : Int64.testbit x (i + Int.unsigned n) = Int64.testbit y (i + Int.unsigned n).","proofString":"apply H0; auto.\ngeneralize (Int.unsigned_range n); lia."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (l : i + Int.unsigned n < Int64.zwordsize) (H2 : Int64.testbit (Int64.shl' m n) (i + Int.unsigned n) = true) : 0 <= i + Int.unsigned n < Int64.zwordsize.","proofString":"generalize (Int.unsigned_range n); lia."},{"statement":"(x y m : int64) (n : int) (H : Int64.shru' (Int64.shl' m n) n = m) (H0 : lagree x y (Int64.shl' m n)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (g : i + Int.unsigned n >= Int64.zwordsize) (H2 : false = true) : Int64.testbit x (Int64.zwordsize - 1) = Int64.testbit y (Int64.zwordsize - 1).","proofString":"discriminate."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Int64.testbit (Int64.shr' x n) i = Int64.testbit (Int64.shr' y n) i.","proofString":"rewrite ! Int64.bits_shr' by auto.\ngeneralize (Int.unsigned_range n); intros.\nset (j := if zlt (i + Int.unsigned n) Int64.zwordsize            then i + Int.unsigned n            else Int64.zwordsize - 1).\nassert (0 <= j < Int64.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\nrewrite ! Int64.bits_shl'; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Int64.testbit x\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1) =\nInt64.testbit y\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1).","proofString":"generalize (Int.unsigned_range n); intros.\nset (j := if zlt (i + Int.unsigned n) Int64.zwordsize            then i + Int.unsigned n            else Int64.zwordsize - 1).\nassert (0 <= j < Int64.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\nrewrite ! Int64.bits_shl'; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) : Int64.testbit x\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1) =\nInt64.testbit y\n  (if zlt (i + Int.unsigned n) Int64.zwordsize\n   then i + Int.unsigned n\n   else Int64.zwordsize - 1).","proofString":"set (j := if zlt (i + Int.unsigned n) Int64.zwordsize            then i + Int.unsigned n            else Int64.zwordsize - 1).\nassert (0 <= j < Int64.zwordsize).\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize); lia.\napply H; auto.\nautorewrite with ints; auto.\nrewrite ! Int64.bits_shl'; auto.\napply orb_true_intro.\nunfold j; destruct (zlt (i + Int.unsigned n) Int64.zwordsize).\nleft.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto.\nright.\nreflexivity."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int64.testbit m (i + Int.unsigned n - Int.unsigned n)) = true \\/\nInt64.testbit (Int64.repr Int64.min_signed) (i + Int.unsigned n) = true.","proofString":"left.\nrewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : (if zlt (i + Int.unsigned n) (Int.unsigned n)\n then false\n else Int64.testbit m (i + Int.unsigned n - Int.unsigned n)) = true.","proofString":"rewrite zlt_false by lia.\nreplace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : Int64.testbit m (i + Int.unsigned n - Int.unsigned n) = true.","proofString":"replace (i + Int.unsigned n - Int.unsigned n) with i by lia.\nauto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (l : i + Int.unsigned n < Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : Int64.testbit m i = true.","proofString":"auto."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (g : i + Int.unsigned n >= Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : (if zlt (Int64.zwordsize - 1) (Int.unsigned n)\n then false\n else Int64.testbit m (Int64.zwordsize - 1 - Int.unsigned n)) = true \\/\nInt64.testbit (Int64.repr Int64.min_signed) (Int64.zwordsize - 1) = true.","proofString":"right.\nreflexivity."},{"statement":"(x y m : int64) (n : int) (H : lagree x y (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (H2 : 0 <= Int.unsigned n < Int.modulus) (g : i + Int.unsigned n >= Int64.zwordsize) (j : Z) (H3 : 0 <= j < Int64.zwordsize) : Int64.testbit (Int64.repr Int64.min_signed) (Int64.zwordsize - 1) = true.","proofString":"reflexivity."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) : lagree (Int64.ror' p amount) (Int64.ror' q amount) m.","proofString":"assert (Z.divide (Z.of_nat Int64.wordsize) Int64.modulus) by (exists (two_p (64-6)); reflexivity).\nunfold Int64.ror'.\nrewrite ! Int64.ror_rol_neg by auto.\napply lagree_rol.\nrewrite Int64.ror_rol_neg by auto.\nrewrite Int64.neg_involutive; auto."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) (H0 : (Z.of_nat Int64.wordsize | Int64.modulus)) : lagree (Int64.ror' p amount) (Int64.ror' q amount) m.","proofString":"unfold Int64.ror'.\nrewrite ! Int64.ror_rol_neg by auto.\napply lagree_rol.\nrewrite Int64.ror_rol_neg by auto.\nrewrite Int64.neg_involutive; auto."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) (H0 : (Z.of_nat Int64.wordsize | Int64.modulus)) : lagree (Int64.ror p (Int64.repr (Int.unsigned amount)))\n  (Int64.ror q (Int64.repr (Int.unsigned amount))) m.","proofString":"rewrite ! Int64.ror_rol_neg by auto.\napply lagree_rol.\nrewrite Int64.ror_rol_neg by auto.\nrewrite Int64.neg_involutive; auto."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) (H0 : (Z.of_nat Int64.wordsize | Int64.modulus)) : lagree (Int64.rol p (Int64.neg (Int64.repr (Int.unsigned amount))))\n  (Int64.rol q (Int64.neg (Int64.repr (Int.unsigned amount)))) m.","proofString":"apply lagree_rol.\nrewrite Int64.ror_rol_neg by auto.\nrewrite Int64.neg_involutive; auto."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) (H0 : (Z.of_nat Int64.wordsize | Int64.modulus)) : lagree p q (Int64.ror m (Int64.neg (Int64.repr (Int.unsigned amount)))).","proofString":"rewrite Int64.ror_rol_neg by auto.\nrewrite Int64.neg_involutive; auto."},{"statement":"(p q m : int64) (amount : int) (H : lagree p q (Int64.rol' m amount)) (H0 : (Z.of_nat Int64.wordsize | Int64.modulus)) : lagree p q\n  (Int64.rol m (Int64.neg (Int64.neg (Int64.repr (Int.unsigned amount))))).","proofString":"rewrite Int64.neg_involutive; auto."},{"statement":"(m : int64) (x y : Z) (H : eqmod (two_p (Int64.size m)) x y) : lagree (Int64.repr x) (Int64.repr y) m.","proofString":"set (p := Z.to_nat (Int64.size m)).\ngeneralize (Int64.size_range m); intros RANGE.\nassert (EQ: Int64.size m = Z.of_nat p).\nsymmetry; apply Z2Nat.id.\nlia.\nrewrite EQ in H; rewrite <- two_power_nat_two_p in H.\nred; intros.\nrewrite ! Int64.testbit_repr by auto.\ndestruct (zlt i (Int64.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (H : eqmod (two_p (Int64.size m)) x y) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) : 0 <= Int64.size m.","proofString":"lia."},{"statement":"(m : int64) (x y : Z) (H : eqmod (two_p (Int64.size m)) x y) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) : lagree (Int64.repr x) (Int64.repr y) m.","proofString":"rewrite EQ in H; rewrite <- two_power_nat_two_p in H.\nred; intros.\nrewrite ! Int64.testbit_repr by auto.\ndestruct (zlt i (Int64.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) : lagree (Int64.repr x) (Int64.repr y) m.","proofString":"red; intros.\nrewrite ! Int64.testbit_repr by auto.\ndestruct (zlt i (Int64.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Int64.testbit (Int64.repr x) i = Int64.testbit (Int64.repr y) i.","proofString":"rewrite ! Int64.testbit_repr by auto.\ndestruct (zlt i (Int64.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) : Z.testbit x i = Z.testbit y i.","proofString":"destruct (zlt i (Int64.size m)).\neapply same_bits_eqmod; eauto.\nlia.\nassert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i < Int64.size m) : Z.testbit x i = Z.testbit y i.","proofString":"eapply same_bits_eqmod; eauto.\nlia."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (l : i < Int64.size m) : 0 <= i < Z.of_nat p.","proofString":"lia."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int64.size m) : Z.testbit x i = Z.testbit y i.","proofString":"assert (Int64.testbit m i = false) by (eapply Int64.bits_size_2; lia).\ncongruence."},{"statement":"(m : int64) (x y : Z) (p : nat) (H : eqmod (two_power_nat p) x y) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Int64.zwordsize) (H1 : Int64.testbit m i = true) (g : i >= Int64.size m) (H2 : Int64.testbit m i = false) : Z.testbit x i = Z.testbit y i.","proofString":"congruence."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) : eqmod (two_p (Int64.size m)) (Int64.unsigned x) (Int64.unsigned y).","proofString":"set (p := Z.to_nat (Int64.size m)).\ngeneralize (Int64.size_range m); intros RANGE.\nassert (EQ: Int64.size m = Z.of_nat p).\nsymmetry; apply Z2Nat.id.\nlia.\nrewrite EQ; rewrite <- two_power_nat_two_p.\napply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) : 0 <= Int64.size m.","proofString":"lia."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) : eqmod (two_p (Int64.size m)) (Int64.unsigned x) (Int64.unsigned y).","proofString":"rewrite EQ; rewrite <- two_power_nat_two_p.\napply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) : eqmod (two_power_nat p) (Int64.unsigned x) (Int64.unsigned y).","proofString":"apply eqmod_same_bits.\nintros.\napply H.\nlia.\nunfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) : forall i : Z,\n0 <= i < Z.of_nat p ->\nZ.testbit (Int64.unsigned x) i = Z.testbit (Int64.unsigned y) i.","proofString":"intros.\napply H.\nlia.\nunfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Z.testbit (Int64.unsigned x) i = Z.testbit (Int64.unsigned y) i.","proofString":"apply H.\nlia.\nunfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : 0 <= i < Int64.zwordsize.","proofString":"lia."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int64.testbit (complete_mask64 m) i = true.","proofString":"unfold complete_mask64.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int64.testbit (Int64.zero_ext (Int64.size m) Int64.mone) i = true.","proofString":"rewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : (if zlt i (Int64.size m) then Int64.testbit Int64.mone i else false) = true.","proofString":"rewrite zlt_true by lia.\nrewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : Int64.testbit Int64.mone i = true.","proofString":"rewrite Int64.bits_mone by lia.\nauto."},{"statement":"(x y m : int64) (H : lagree x y (complete_mask64 m)) (p : nat) (RANGE : 0 <= Int64.size m <= Int64.zwordsize) (EQ : Int64.size m = Z.of_nat p) (i : Z) (H0 : 0 <= i < Z.of_nat p) : true = true.","proofString":"auto."},{"statement":"(m : int64) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"destruct (Int64.eq_dec m Int64.zero).\nsubst m; reflexivity.\nassert (Int64.unsigned m <> 0).\nred; intros; elim n.\nrewrite <- (Int64.repr_unsigned m).\nrewrite H; auto.\nassert (0 < Int64.size m).\napply Zsize_pos'.\ngeneralize (Int64.unsigned_range m); lia.\ngeneralize (Int64.size_range m); intros.\nf_equal.\napply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (e : m = Int64.zero) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"subst m; reflexivity."},{"statement":"(m : int64) (n : m <> Int64.zero) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"assert (Int64.unsigned m <> 0).\nred; intros; elim n.\nrewrite <- (Int64.repr_unsigned m).\nrewrite H; auto.\nassert (0 < Int64.size m).\napply Zsize_pos'.\ngeneralize (Int64.unsigned_range m); lia.\ngeneralize (Int64.size_range m); intros.\nf_equal.\napply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) : Int64.unsigned m <> 0.","proofString":"red; intros; elim n.\nrewrite <- (Int64.repr_unsigned m).\nrewrite H; auto."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m = 0) : m = Int64.zero.","proofString":"rewrite <- (Int64.repr_unsigned m).\nrewrite H; auto."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m = 0) : Int64.repr (Int64.unsigned m) = Int64.zero.","proofString":"rewrite H; auto."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"assert (0 < Int64.size m).\napply Zsize_pos'.\ngeneralize (Int64.unsigned_range m); lia.\ngeneralize (Int64.size_range m); intros.\nf_equal.\napply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) : 0 < Int64.size m.","proofString":"apply Zsize_pos'.\ngeneralize (Int64.unsigned_range m); lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) : 0 < Int64.unsigned m.","proofString":"generalize (Int64.unsigned_range m); lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"generalize (Int64.size_range m); intros.\nf_equal.\napply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : Int64.zero_ext (Int64.size (Int64.zero_ext (Int64.size m) Int64.mone))\n  Int64.mone = Int64.zero_ext (Int64.size m) Int64.mone.","proofString":"f_equal.\napply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : Int64.size (Int64.zero_ext (Int64.size m) Int64.mone) = Int64.size m.","proofString":"apply Int64.bits_size_4.\ntauto.\nrewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia.\nintros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : 0 <= Int64.size m.","proofString":"tauto."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : Int64.testbit (Int64.zero_ext (Int64.size m) Int64.mone)\n  (Z.pred (Int64.size m)) = true.","proofString":"rewrite Int64.bits_zero_ext by lia.\nrewrite zlt_true by lia.\napply Int64.bits_mone; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : (if zlt (Z.pred (Int64.size m)) (Int64.size m)\n then Int64.testbit Int64.mone (Z.pred (Int64.size m))\n else false) = true.","proofString":"rewrite zlt_true by lia.\napply Int64.bits_mone; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : Int64.testbit Int64.mone (Z.pred (Int64.size m)) = true.","proofString":"apply Int64.bits_mone; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) : forall i : Z,\nInt64.size m <= i < Int64.zwordsize ->\nInt64.testbit (Int64.zero_ext (Int64.size m) Int64.mone) i = false.","proofString":"intros.\nrewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) (i : Z) (H2 : Int64.size m <= i < Int64.zwordsize) : Int64.testbit (Int64.zero_ext (Int64.size m) Int64.mone) i = false.","proofString":"rewrite Int64.bits_zero_ext by lia.\napply zlt_false; lia."},{"statement":"(m : int64) (n : m <> Int64.zero) (H : Int64.unsigned m <> 0) (H0 : 0 < Int64.size m) (H1 : 0 <= Int64.size m <= Int64.zwordsize) (i : Z) (H2 : Int64.size m <= i < Int64.zwordsize) : (if zlt i (Int64.size m) then Int64.testbit Int64.mone i else false) = false.","proofString":"apply zlt_false; lia."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply iagree_and; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.and m n)) : iagree (Int.and i n) (Int.and i0 n) m.","proofString":"apply iagree_and; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q n\n            | _ => False\n            end\n| _ => True\nend) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.and n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.and n1 n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\nrewrite iagree_and_eq in H.\nrewrite H; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 n) : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n)).","proofString":"rewrite iagree_and_eq in H.\nrewrite H; auto."},{"statement":"(i i0 n : int) (H : Int.and i n = Int.and i0 n) : Val.lessdef (Vint (Int.and i n)) (Vint (Int.and i0 n)).","proofString":"rewrite H; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.and m (Int.not n))\n    | _ => False\n    end\n| _ => True\nend) : match Val.or v (Vint n) with\n| Vint p =>\n    match Val.or w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.or; InvAgree.\napply iagree_or; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.and m (Int.not n))) : iagree (Int.or i n) (Int.or i0 n) m.","proofString":"apply iagree_or; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q (Int.not n)\n            | _ => False\n            end\n| _ => True\nend) : match Val.or v (Vint n) with\n| Vlong p =>\n    match Val.or w (Vint n) with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q (Int.not n)\n            | _ => False\n            end\n| _ => True\nend) : Val.lessdef (Val.or v (Vint n)) (Val.or w (Vint n)).","proofString":"InvAgree.\nsimpl.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : Val.lessdef (Val.or (Vint i) (Vint n)) (Val.or (Vint i0) (Vint n)).","proofString":"simpl.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : Val.lessdef (Vint (Int.or i n)) (Vint (Int.or i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : Vint (Int.or i n) = Vint (Int.or i0 n).","proofString":"f_equal.\napply iagree_mone.\napply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : Int.or i n = Int.or i0 n.","proofString":"apply iagree_mone.\napply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : iagree (Int.or i n) (Int.or i0 n) Int.mone.","proofString":"apply iagree_or.\nrewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : iagree i i0 (Int.and Int.mone (Int.not n)).","proofString":"rewrite Int.and_commut.\nrewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : iagree i i0 (Int.and (Int.not n) Int.mone).","proofString":"rewrite Int.and_mone.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.not n)) : iagree i i0 (Int.not n).","proofString":"auto."},{"statement":"(v w : val) (n : int64) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (n : int64) (H : match v with\n| Vlong p => match w with\n             | Vlong q => lagree p q n\n             | _ => False\n             end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m n : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.and m n)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.and n1 n)\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.and n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply lagree_and; auto."},{"statement":"(i i0 m n : int64) (H : lagree i i0 (Int64.and m n)) : lagree (Int64.and i n) (Int64.and i0 n) m.","proofString":"apply lagree_and; auto."},{"statement":"(v w : val) (n : int64) (H : match v with\n| Vlong p => match w with\n             | Vlong q => lagree p q n\n             | _ => False\n             end\n| _ => True\nend) : Val.lessdef\n  match v with\n  | Vlong n1 => Vlong (Int64.and n1 n)\n  | _ => Vundef\n  end match w with\n      | Vlong n1 => Vlong (Int64.and n1 n)\n      | _ => Vundef\n      end.","proofString":"InvAgree.\nrewrite lagree_and_eq in H.\nrewrite H; auto."},{"statement":"(i i0 n : int64) (H : lagree i i0 n) : Val.lessdef (Vlong (Int64.and i n)) (Vlong (Int64.and i0 n)).","proofString":"rewrite lagree_and_eq in H.\nrewrite H; auto."},{"statement":"(i i0 n : int64) (H : Int64.and i n = Int64.and i0 n) : Val.lessdef (Vlong (Int64.and i n)) (Vlong (Int64.and i0 n)).","proofString":"rewrite H; auto."},{"statement":"(v w : val) (n : int64) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (n : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.not n)\n    | _ => False\n    end\n| _ => True\nend) : match Val.orl v (Vlong n) with\n| Vint p =>\n    match Val.orl w (Vlong n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m n : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.and m (Int64.not n))\n    | _ => False\n    end\n| _ => True\nend) : match Val.orl v (Vlong n) with\n| Vlong p =>\n    match Val.orl w (Vlong n) with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\nunfold Val.orl; InvAgree.\napply lagree_or; auto."},{"statement":"(i i0 m n : int64) (H : lagree i i0 (Int64.and m (Int64.not n))) : match Val.orl (Vlong i) (Vlong n) with\n| Vlong p =>\n    match Val.orl (Vlong i0) (Vlong n) with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.orl; InvAgree.\napply lagree_or; auto."},{"statement":"(i i0 m n : int64) (H : lagree i i0 (Int64.and m (Int64.not n))) : lagree (Int64.or i n) (Int64.or i0 n) m.","proofString":"apply lagree_or; auto."},{"statement":"(v w : val) (n : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.not n)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef (Val.orl v (Vlong n)) (Val.orl w (Vlong n)).","proofString":"InvAgree.\nsimpl.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : Val.lessdef (Val.orl (Vlong i) (Vlong n)) (Val.orl (Vlong i0) (Vlong n)).","proofString":"simpl.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : Val.lessdef (Vlong (Int64.or i n)) (Vlong (Int64.or i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : Vlong (Int64.or i n) = Vlong (Int64.or i0 n).","proofString":"f_equal.\napply lagree_mone.\napply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : Int64.or i n = Int64.or i0 n.","proofString":"apply lagree_mone.\napply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : lagree (Int64.or i n) (Int64.or i0 n) Int64.mone.","proofString":"apply lagree_or.\nrewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : lagree i i0 (Int64.and Int64.mone (Int64.not n)).","proofString":"rewrite Int64.and_commut.\nrewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : lagree i i0 (Int64.and (Int64.not n) Int64.mone).","proofString":"rewrite Int64.and_mone.\nauto."},{"statement":"(i i0 n : int64) (H : lagree i i0 (Int64.not n)) : lagree i i0 (Int64.not n).","proofString":"auto."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m : int,\niagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (x : nval) (H0 : vagree v1 w1 x) (H1 : vagree v2 w2 x) : vagree\n  match v1 with\n  | Vint i1 => match v2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 => match w2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\ninv H0; auto.\ninv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m : int,\niagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (H0 H1 : True) : True.","proofString":"auto."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m0 : int,\niagree p1 q1 m0 -> iagree p2 q2 m0 -> iagree (f p1 p2) (f q1 q2) m0) (v1 w1 v2 w2 : val) (m : int) (H0 : match v1 with\n| Vint p => match w1 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) (H1 : match v2 with\n| Vint p => match w2 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) : match\n  match v1 with\n  | Vint i1 => match v2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m0 : int,\niagree p1 q1 m0 -> iagree p2 q2 m0 -> iagree (f p1 p2) (f q1 q2) m0) (v1 w1 v2 w2 : val) (m : int64) (H0 : match v1 with\n| Vlong p => match w1 with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) (H1 : match v2 with\n| Vlong p => match w2 with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) : match\n  match v1 with\n  | Vint i1 => match v2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w1 with\n      | Vint i1 =>\n          match w2 with\n          | Vint i2 => Vint (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m : int,\niagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (H0 : Val.lessdef v1 w1) (H1 : Val.lessdef v2 w2) : Val.lessdef\n  match v1 with\n  | Vint i1 => match v2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 => match w2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end.","proofString":"inv H0; auto.\ninv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m : int,\niagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) (w1 v2 w2 : val) (H1 : Val.lessdef v2 w2) : Val.lessdef\n  match w1 with\n  | Vint i1 => match v2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint i1 => match w2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end.","proofString":"inv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int -> int -> int) (H : forall p1 p2 q1 q2 m : int,\niagree p1 q1 m -> iagree p2 q2 m -> iagree (f p1 p2) (f q1 q2) m) (w1 w2 : val) : Val.lessdef match w1 with\n            | Vundef | _ => Vundef\n            end\n  match w1 with\n  | Vint i1 => match w2 with\n               | Vint i2 => Vint (f i1 i2)\n               | _ => Vundef\n               end\n  | _ => Vundef\n  end.","proofString":"destruct w1; auto."},{"statement":"(v w : val) (x : nval) (H : vagree v w (bitwise x)) : vagree (Val.notint v) (Val.notint w) x.","proofString":"rewrite ! Val.not_xor.\napply xor_sound; auto with na."},{"statement":"(v w : val) (x : nval) (H : vagree v w (bitwise x)) : vagree (Val.xor v (Vint Int.mone)) (Val.xor w (Vint Int.mone)) x.","proofString":"apply xor_sound; auto with na."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m : int64,\nlagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (x : nval) (H0 : vagree v1 w1 x) (H1 : vagree v2 w2 x) : vagree\n  match v1 with\n  | Vlong i1 => match v2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vlong i1 => match w2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\ninv H0; auto.\ninv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m : int64,\nlagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (H0 H1 : True) : True.","proofString":"auto."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m0 : int64,\nlagree p1 q1 m0 -> lagree p2 q2 m0 -> lagree (f p1 p2) (f q1 q2) m0) (v1 w1 v2 w2 : val) (m : int) (H0 : match v1 with\n| Vint p => match w1 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) (H1 : match v2 with\n| Vint p => match w2 with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) : match\n  match v1 with\n  | Vlong i1 => match v2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vlong i1 =>\n          match w2 with\n          | Vlong i2 => Vlong (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m0 : int64,\nlagree p1 q1 m0 -> lagree p2 q2 m0 -> lagree (f p1 p2) (f q1 q2) m0) (v1 w1 v2 w2 : val) (m : int64) (H0 : match v1 with\n| Vlong p => match w1 with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) (H1 : match v2 with\n| Vlong p => match w2 with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) : match\n  match v1 with\n  | Vlong i1 => match v2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w1 with\n      | Vlong i1 =>\n          match w2 with\n          | Vlong i2 => Vlong (f i1 i2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m : int64,\nlagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) (v1 w1 v2 w2 : val) (H0 : Val.lessdef v1 w1) (H1 : Val.lessdef v2 w2) : Val.lessdef\n  match v1 with\n  | Vlong i1 => match v2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vlong i1 => match w2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"inv H0; auto.\ninv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m : int64,\nlagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) (w1 v2 w2 : val) (H1 : Val.lessdef v2 w2) : Val.lessdef\n  match w1 with\n  | Vlong i1 => match v2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vlong i1 => match w2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"inv H1; auto.\ndestruct w1; auto."},{"statement":"(f : int64 -> int64 -> int64) (H : forall p1 p2 q1 q2 m : int64,\nlagree p1 q1 m -> lagree p2 q2 m -> lagree (f p1 p2) (f q1 q2) m) (w1 w2 : val) : Val.lessdef match w1 with\n            | Vundef | _ => Vundef\n            end\n  match w1 with\n  | Vlong i1 => match w2 with\n                | Vlong i2 => Vlong (f i1 i2)\n                | _ => Vundef\n                end\n  | _ => Vundef\n  end.","proofString":"destruct w1; auto."},{"statement":"(v w : val) (x : nval) (H : vagree v w (bitwise x)) : vagree (Val.notl v) (Val.notl w) x.","proofString":"rewrite ! Val.notl_xorl.\napply xorl_sound; auto with na."},{"statement":"(v w : val) (x : nval) (H : vagree v w (bitwise x)) : vagree (Val.xorl v (Vlong Int64.mone)) (Val.xorl w (Vlong Int64.mone)) x.","proofString":"apply xorl_sound; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | _ => I (Int.shru Int.mone n)\n  end) : vagree (Val.shl v (Vint n)) (Val.shl w (Vint n)) x.","proofString":"unfold Val.shl.\ndestruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shl; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shl; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | _ => I (Int.shru Int.mone n)\n  end) : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shl n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shl; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shl; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | _ => I (Int.shru Int.mone n)\n  end) : vagree match v with\n       | Vint n1 => Vint (Int.shl n1 n)\n       | _ => Vundef\n       end match w with\n           | Vint n1 => Vint (Int.shl n1 n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shl; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shl; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shru m n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply iagree_shl; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.shru m n)) : iagree (Int.shl i n) (Int.shl i0 n) m.","proofString":"apply iagree_shl; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shru Int.mone n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shl n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shru Int.mone n)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.shl n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.shl n1 n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shl; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shru Int.mone n)) : Val.lessdef (Vint (Int.shl i n)) (Vint (Int.shl i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shl; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shru Int.mone n)) : Vint (Int.shl i n) = Vint (Int.shl i0 n).","proofString":"f_equal.\napply iagree_mone.\napply iagree_shl; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shru Int.mone n)) : Int.shl i n = Int.shl i0 n.","proofString":"apply iagree_mone.\napply iagree_shl; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shru Int.mone n)) : iagree (Int.shl i n) (Int.shl i0 n) Int.mone.","proofString":"apply iagree_shl; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shru m n)\n  | _ => I (Int.shru Int.mone n)\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | _ => I (Int.shl Int.mone n)\n  end) : vagree (Val.shru v (Vint n)) (Val.shru w (Vint n)) x.","proofString":"unfold Val.shru.\ndestruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shru; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shru; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | _ => I (Int.shl Int.mone n)\n  end) : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shru n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shru; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shru; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | _ => I (Int.shl Int.mone n)\n  end) : vagree match v with\n       | Vint n1 => Vint (Int.shru n1 n)\n       | _ => Vundef\n       end match w with\n           | Vint n1 => Vint (Int.shru n1 n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_shru; auto.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shru; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shl m n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply iagree_shru; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.shl m n)) : iagree (Int.shru i n) (Int.shru i0 n) m.","proofString":"apply iagree_shru; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shl Int.mone n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shru n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.shl Int.mone n)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.shru n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.shru n1 n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shru; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shl Int.mone n)) : Val.lessdef (Vint (Int.shru i n)) (Vint (Int.shru i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shru; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shl Int.mone n)) : Vint (Int.shru i n) = Vint (Int.shru i0 n).","proofString":"f_equal.\napply iagree_mone.\napply iagree_shru; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shl Int.mone n)) : Int.shru i n = Int.shru i0 n.","proofString":"apply iagree_mone.\napply iagree_shru; auto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.shl Int.mone n)) : iagree (Int.shru i n) (Int.shru i0 n) Int.mone.","proofString":"apply iagree_shru; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.shl m n)\n  | _ => I (Int.shl Int.mone n)\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | _ => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end) : vagree (Val.shr v (Vint n)) (Val.shr w (Vint n)) x.","proofString":"unfold Val.shr.\ndestruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\ndestruct (Int.eq_dec (Int.shru (Int.shl m n) n) m).\napply iagree_shr_1; auto.\napply iagree_shr; auto.\ndestruct v; auto with na.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shr.\nauto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | _ => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end) : vagree\n  match v with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vint n1 =>\n      if Int.ltu n Int.iwordsize then Vint (Int.shr n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int.iwordsize).\ndestruct x; simpl in *.\nauto.\nInvAgree.\ndestruct (Int.eq_dec (Int.shru (Int.shl m n) n) m).\napply iagree_shr_1; auto.\napply iagree_shr; auto.\ndestruct v; auto with na.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shr.\nauto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | _ => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end) : vagree match v with\n       | Vint n1 => Vint (Int.shr n1 n)\n       | _ => Vundef\n       end match w with\n           | Vint n1 => Vint (Int.shr n1 n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\ndestruct (Int.eq_dec (Int.shru (Int.shl m n) n) m).\napply iagree_shr_1; auto.\napply iagree_shr; auto.\ndestruct v; auto with na.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shr.\nauto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n           then Int.shl m n\n           else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\ndestruct (Int.eq_dec (Int.shru (Int.shl m n) n) m).\napply iagree_shr_1; auto.\napply iagree_shr; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0\n  (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n   then Int.shl m n\n   else Int.or (Int.shl m n) (Int.repr Int.min_signed))) : iagree (Int.shr i n) (Int.shr i0 n) m.","proofString":"destruct (Int.eq_dec (Int.shru (Int.shl m n) n) m).\napply iagree_shr_1; auto.\napply iagree_shr; auto."},{"statement":"(i i0 m n : int) (e : Int.shru (Int.shl m n) n = m) (H : iagree i i0 (Int.shl m n)) : iagree (Int.shr i n) (Int.shr i0 n) m.","proofString":"apply iagree_shr_1; auto."},{"statement":"(i i0 m n : int) (n0 : Int.shru (Int.shl m n) n <> m) (H : iagree i i0 (Int.or (Int.shl m n) (Int.repr Int.min_signed))) : iagree (Int.shr i n) (Int.shr i0 n) m.","proofString":"apply iagree_shr; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.shr n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.shr n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.shr n1 n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shr.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))) : Val.lessdef (Vint (Int.shr i n)) (Vint (Int.shr i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\napply iagree_shr.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))) : Vint (Int.shr i n) = Vint (Int.shr i0 n).","proofString":"f_equal.\napply iagree_mone.\napply iagree_shr.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))) : Int.shr i n = Int.shr i0 n.","proofString":"apply iagree_mone.\napply iagree_shr.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))) : iagree (Int.shr i n) (Int.shr i0 n) Int.mone.","proofString":"apply iagree_shr.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))) : iagree i i0 (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed)).","proofString":"auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m =>\n      I\n        (if Int.eq_dec (Int.shru (Int.shl m n) n) m\n         then Int.shl m n\n         else Int.or (Int.shl m n) (Int.repr Int.min_signed))\n  | _ => I (Int.or (Int.shl Int.mone n) (Int.repr Int.min_signed))\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.ror m n)\n  | _ => All\n  end) : vagree match v with\n       | Vint n1 => Vint (Int.rol n1 n)\n       | _ => Vundef\n       end match w with\n           | Vint n1 => Vint (Int.rol n1 n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_rol; auto.\ndestruct v; auto.\ninv H; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.ror m n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply iagree_rol; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.ror m n)) : iagree (Int.rol i n) (Int.rol i0 n) m.","proofString":"apply iagree_rol; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : Val.lessdef v w) : match match v with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.rol n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; auto."},{"statement":"(v w : val) (n : int) (H : Val.lessdef v w) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.rol n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.rol n1 n)\n  | _ => Vundef\n  end.","proofString":"inv H; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.rol m n)\n  | _ => All\n  end) : vagree match v with\n       | Vint n1 => Vint (Int.ror n1 n)\n       | _ => Vundef\n       end match w with\n           | Vint n1 => Vint (Int.ror n1 n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\napply iagree_ror; auto.\ndestruct v; auto.\ninv H; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.rol m n)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply iagree_ror; auto."},{"statement":"(i i0 m n : int) (H : iagree i i0 (Int.rol m n)) : iagree (Int.ror i n) (Int.ror i0 n) m.","proofString":"apply iagree_ror; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : Val.lessdef v w) : match match v with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vint n1 => Vint (Int.ror n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; auto."},{"statement":"(v w : val) (n : int) (H : Val.lessdef v w) : Val.lessdef match v with\n            | Vint n1 => Vint (Int.ror n1 n)\n            | _ => Vundef\n            end\n  match w with\n  | Vint n1 => Vint (Int.ror n1 n)\n  | _ => Vundef\n  end.","proofString":"inv H; auto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x.","proofString":"assert (X: forall u, Val.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask)).\ndestruct u; auto.\nrewrite ! X.\napply andimm_sound.\napply rol_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) : forall u : val,\nVal.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask).","proofString":"destruct u; auto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) (X : forall u : val,\nVal.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask)) : vagree (Val.rolm v amount mask) (Val.rolm w amount mask) x.","proofString":"rewrite ! X.\napply andimm_sound.\napply rol_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) (X : forall u : val,\nVal.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask)) : vagree (Val.and (Val.rol v (Vint amount)) (Vint mask))\n  (Val.and (Val.rol w (Vint amount)) (Vint mask)) x.","proofString":"apply andimm_sound.\napply rol_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) (X : forall u : val,\nVal.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask)) : vagree (Val.rol v (Vint amount)) (Val.rol w (Vint amount)) (andimm x mask).","proofString":"apply rol_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H : vagree v w (rol (andimm x mask) amount)) (X : forall u : val,\nVal.rolm u amount mask = Val.and (Val.rol u (Vint amount)) (Vint mask)) : vagree v w (rol (andimm x mask) amount).","proofString":"auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shru' m n)\n  | _ => L (Int64.shru' Int64.mone n)\n  end) : vagree (Val.shll v (Vint n)) (Val.shll w (Vint n)) x.","proofString":"unfold Val.shll.\ndestruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shl; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shl; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shru' m n)\n  | _ => L (Int64.shru' Int64.mone n)\n  end) : vagree\n  match v with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shl; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shl; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shru' m n)\n  | _ => L (Int64.shru' Int64.mone n)\n  end) : vagree match v with\n       | Vlong n1 => Vlong (Int64.shl' n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vlong n1 => Vlong (Int64.shl' n1 n)\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shl; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shl; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shru' Int64.mone n)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shl' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shl' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shru' m n)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shl' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shl' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply lagree_shl; auto."},{"statement":"(i i0 m : int64) (n : int) (H : lagree i i0 (Int64.shru' m n)) : lagree (Int64.shl' i n) (Int64.shl' i0 n) m.","proofString":"apply lagree_shl; auto."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shru' Int64.mone n)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef\n  match v with\n  | Vlong n1 => Vlong (Int64.shl' n1 n)\n  | _ => Vundef\n  end match w with\n      | Vlong n1 => Vlong (Int64.shl' n1 n)\n      | _ => Vundef\n      end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shl; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shru' Int64.mone n)) : Val.lessdef (Vlong (Int64.shl' i n)) (Vlong (Int64.shl' i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shl; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shru' Int64.mone n)) : Vlong (Int64.shl' i n) = Vlong (Int64.shl' i0 n).","proofString":"f_equal.\napply lagree_mone.\napply lagree_shl; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shru' Int64.mone n)) : Int64.shl' i n = Int64.shl' i0 n.","proofString":"apply lagree_mone.\napply lagree_shl; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shru' Int64.mone n)) : lagree (Int64.shl' i n) (Int64.shl' i0 n) Int64.mone.","proofString":"apply lagree_shl; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shru' m n)\n  | _ => L (Int64.shru' Int64.mone n)\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shl' m n)\n  | _ => L (Int64.shl' Int64.mone n)\n  end) : vagree (Val.shrlu v (Vint n)) (Val.shrlu w (Vint n)) x.","proofString":"unfold Val.shrlu.\ndestruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shru; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shru; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shl' m n)\n  | _ => L (Int64.shl' Int64.mone n)\n  end) : vagree\n  match v with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shru; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shru; auto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shl' m n)\n  | _ => L (Int64.shl' Int64.mone n)\n  end) : vagree match v with\n       | Vlong n1 => Vlong (Int64.shru' n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vlong n1 => Vlong (Int64.shru' n1 n)\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\napply lagree_shru; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shru; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shl' Int64.mone n)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shru' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shru' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shl' m n)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shru' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shru' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply lagree_shru; auto."},{"statement":"(i i0 m : int64) (n : int) (H : lagree i i0 (Int64.shl' m n)) : lagree (Int64.shru' i n) (Int64.shru' i0 n) m.","proofString":"apply lagree_shru; auto."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.shl' Int64.mone n)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef\n  match v with\n  | Vlong n1 => Vlong (Int64.shru' n1 n)\n  | _ => Vundef\n  end match w with\n      | Vlong n1 => Vlong (Int64.shru' n1 n)\n      | _ => Vundef\n      end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shru; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shl' Int64.mone n)) : Val.lessdef (Vlong (Int64.shru' i n)) (Vlong (Int64.shru' i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shru; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shl' Int64.mone n)) : Vlong (Int64.shru' i n) = Vlong (Int64.shru' i0 n).","proofString":"f_equal.\napply lagree_mone.\napply lagree_shru; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shl' Int64.mone n)) : Int64.shru' i n = Int64.shru' i0 n.","proofString":"apply lagree_mone.\napply lagree_shru; auto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0 (Int64.shl' Int64.mone n)) : lagree (Int64.shru' i n) (Int64.shru' i0 n) Int64.mone.","proofString":"apply lagree_shru; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.shl' m n)\n  | _ => L (Int64.shl' Int64.mone n)\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m =>\n      L\n        (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n         then Int64.shl' m n\n         else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))\n  | _ => L (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n  end) : vagree (Val.shrl v (Vint n)) (Val.shrl w (Vint n)) x.","proofString":"unfold Val.shrl.\ndestruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\ndestruct (Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m).\napply lagree_shr_1; auto.\napply lagree_shr; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shr.\nauto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m =>\n      L\n        (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n         then Int64.shl' m n\n         else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))\n  | _ => L (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n  end) : vagree\n  match v with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' n1 n) else Vundef\n  | _ => Vundef\n  end\n  match w with\n  | Vlong n1 =>\n      if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' n1 n) else Vundef\n  | _ => Vundef\n  end x.","proofString":"destruct (Int.ltu n Int64.iwordsize').\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\ndestruct (Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m).\napply lagree_shr_1; auto.\napply lagree_shr; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shr.\nauto.\ndestruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m =>\n      L\n        (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n         then Int64.shl' m n\n         else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))\n  | _ => L (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n  end) : vagree match v with\n       | Vlong n1 => Vlong (Int64.shr' n1 n)\n       | _ => Vundef\n       end\n  match w with\n  | Vlong n1 => Vlong (Int64.shr' n1 n)\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\ndestruct (Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m).\napply lagree_shr_1; auto.\napply lagree_shr; auto.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shr.\nauto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q =>\n        lagree p q\n          (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shr' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shr' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q =>\n        lagree p q\n          (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n           then Int64.shl' m n\n           else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.shr' n1 n)\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.shr' n1 n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\ndestruct (Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m).\napply lagree_shr_1; auto.\napply lagree_shr; auto."},{"statement":"(i i0 m : int64) (n : int) (H : lagree i i0\n  (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n   then Int64.shl' m n\n   else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) : lagree (Int64.shr' i n) (Int64.shr' i0 n) m.","proofString":"destruct (Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m).\napply lagree_shr_1; auto.\napply lagree_shr; auto."},{"statement":"(i i0 m : int64) (n : int) (e : Int64.shru' (Int64.shl' m n) n = m) (H : lagree i i0 (Int64.shl' m n)) : lagree (Int64.shr' i n) (Int64.shr' i0 n) m.","proofString":"apply lagree_shr_1; auto."},{"statement":"(i i0 m : int64) (n : int) (n0 : Int64.shru' (Int64.shl' m n) n <> m) (H : lagree i i0 (Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))) : lagree (Int64.shr' i n) (Int64.shr' i0 n) m.","proofString":"apply lagree_shr; auto."},{"statement":"(v w : val) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q =>\n        lagree p q\n          (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef\n  match v with\n  | Vlong n1 => Vlong (Int64.shr' n1 n)\n  | _ => Vundef\n  end match w with\n      | Vlong n1 => Vlong (Int64.shr' n1 n)\n      | _ => Vundef\n      end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shr.\nauto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))) : Val.lessdef (Vlong (Int64.shr' i n)) (Vlong (Int64.shr' i0 n)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply lagree_mone.\napply lagree_shr.\nauto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))) : Vlong (Int64.shr' i n) = Vlong (Int64.shr' i0 n).","proofString":"f_equal.\napply lagree_mone.\napply lagree_shr.\nauto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))) : Int64.shr' i n = Int64.shr' i0 n.","proofString":"apply lagree_mone.\napply lagree_shr.\nauto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))) : lagree (Int64.shr' i n) (Int64.shr' i0 n) Int64.mone.","proofString":"apply lagree_shr.\nauto."},{"statement":"(i i0 : int64) (n : int) (H : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))) : lagree i i0\n  (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed)).","proofString":"auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m =>\n      L\n        (if Int64.eq_dec (Int64.shru' (Int64.shl' m n) n) m\n         then Int64.shl' m n\n         else Int64.or (Int64.shl' m n) (Int64.repr Int64.min_signed))\n  | _ => L (Int64.or (Int64.shl' Int64.mone n) (Int64.repr Int64.min_signed))\n  end) : vagree match v with\n       | Vundef | _ => Vundef\n       end match w with\n           | Vundef | _ => Vundef\n           end x.","proofString":"destruct v; auto with na."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.ror m (Int64.repr (Int.unsigned n)))\n  | _ => All\n  end) : vagree\n  match v with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end\n  match w with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\ndestruct v; auto.\nInvAgree.\napply lagree_rol'; auto.\ninv H; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : Val.lessdef v w) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ror m (Int64.repr (Int.unsigned n)))\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply lagree_rol'; auto."},{"statement":"(i i0 m : int64) (n : int) (H : lagree i i0 (Int64.ror m (Int64.repr (Int.unsigned n)))) : lagree (Int64.rol i (Int64.repr (Int.unsigned n)))\n  (Int64.rol i0 (Int64.repr (Int.unsigned n))) m.","proofString":"apply lagree_rol'; auto."},{"statement":"(v w : val) (n : int) (H : Val.lessdef v w) : Val.lessdef\n  match v with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end\n  match w with\n  | Vlong n1 => Vlong (Int64.rol n1 (Int64.repr (Int.unsigned n)))\n  | _ => Vundef\n  end.","proofString":"inv H; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : vagree v w (rorl x n)) : vagree (Val.rorl v (Vint n)) (Val.rorl w (Vint n)) x.","proofString":"destruct x; simpl in *.\nauto.\ndestruct v; simpl; auto.\nInvAgree.\napply lagree_ror; auto.\ninv H; auto."},{"statement":"(v w : val) (n : int) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H : Val.lessdef v w) : match Val.rorl v (Vint n) with\n| Vint p =>\n    match Val.rorl w (Vint n) with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; simpl; auto."},{"statement":"(v w : val) (m : int64) (n : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.rol' m n)\n    | _ => False\n    end\n| _ => True\nend) : match Val.rorl v (Vint n) with\n| Vlong p =>\n    match Val.rorl w (Vint n) with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree.\napply lagree_ror; auto."},{"statement":"(i i0 m : int64) (n : int) (H : lagree i i0 (Int64.rol' m n)) : match Val.rorl (Vlong i) (Vint n) with\n| Vlong p =>\n    match Val.rorl (Vlong i0) (Vint n) with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"apply lagree_ror; auto."},{"statement":"(v w : val) (n : int) (H : Val.lessdef v w) : Val.lessdef (Val.rorl v (Vint n)) (Val.rorl w (Vint n)).","proofString":"inv H; auto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) : vagree (Val.rolml v amount mask) (Val.rolml w amount mask) x.","proofString":"assert (X: forall u, Val.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask)).\ndestruct u; auto.\nrewrite ! X.\napply andlimm_sound.\napply roll_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) : forall u : val,\nVal.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask).","proofString":"destruct u; auto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) (X : forall u : val,\nVal.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask)) : vagree (Val.rolml v amount mask) (Val.rolml w amount mask) x.","proofString":"rewrite ! X.\napply andlimm_sound.\napply roll_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) (X : forall u : val,\nVal.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask)) : vagree (Val.andl (Val.roll v (Vint amount)) (Vlong mask))\n  (Val.andl (Val.roll w (Vint amount)) (Vlong mask)) x.","proofString":"apply andlimm_sound.\napply roll_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) (X : forall u : val,\nVal.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask)) : vagree (Val.roll v (Vint amount)) (Val.roll w (Vint amount)) (andlimm x mask).","proofString":"apply roll_sound.\nauto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H : vagree v w (roll (andlimm x mask) amount)) (X : forall u : val,\nVal.rolml u amount mask = Val.andl (Val.roll u (Vint amount)) (Vlong mask)) : vagree v w (roll (andlimm x mask) amount).","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) : vagree (Val.add v1 v2) (Val.add w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.add; InvAgree.\napply eqmod_iagree.\napply eqmod_add; apply iagree_eqmod; auto.\ndestruct Archi.ptr64 eqn:?; unfold Val.add; rewrite Heqb; InvAgree.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.add v1 v2 with\n| Vint p =>\n    match Val.add w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.add; InvAgree.\napply eqmod_iagree.\napply eqmod_add; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) : iagree (Int.add i1 i) (Int.add i2 i0) m.","proofString":"apply eqmod_iagree.\napply eqmod_add; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) : eqmod (two_p (Int.size m)) (Int.unsigned i1 + Int.unsigned i)\n  (Int.unsigned i2 + Int.unsigned i0).","proofString":"apply eqmod_add; apply iagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.add v1 v2 with\n| Vlong p =>\n    match Val.add w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct Archi.ptr64 eqn:?; unfold Val.add; rewrite Heqb; InvAgree."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.add v1 v2) (Val.add w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.add w1 v2) (Val.add w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) : Val.lessdef (Val.add w1 Vundef) (Val.add w1 w2).","proofString":"destruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H1 : Archi.ptr64 = true) : vagree (Val.sub v1 v2) (Val.sub w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.sub; rewrite H1; InvAgree.\napply eqmod_iagree.\napply eqmod_sub; apply iagree_eqmod; auto.\nunfold Val.sub.\nrewrite H1.\ndestruct v1, v2; simpl; auto.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) (H1 : Archi.ptr64 = true) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = true) : match Val.sub v1 v2 with\n| Vint p =>\n    match Val.sub w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.sub; rewrite H1; InvAgree.\napply eqmod_iagree.\napply eqmod_sub; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) (H1 : Archi.ptr64 = true) : iagree (Int.sub i1 i) (Int.sub i2 i0) m.","proofString":"apply eqmod_iagree.\napply eqmod_sub; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) (H1 : Archi.ptr64 = true) : eqmod (two_p (Int.size m)) (Int.unsigned i1 - Int.unsigned i)\n  (Int.unsigned i2 - Int.unsigned i0).","proofString":"apply eqmod_sub; apply iagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = true) : match Val.sub v1 v2 with\n| Vlong p =>\n    match Val.sub w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.sub.\nrewrite H1.\ndestruct v1, v2; simpl; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = true) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr b1 ofs1 =>\n      match v2 with\n      | Vint n2 =>\n          if Archi.ptr64\n          then Vundef\n          else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n      | Vptr b2 ofs2 =>\n          if Archi.ptr64\n          then Vundef\n          else\n           if eq_block b1 b2\n           then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n           else Vundef\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr b1 ofs1 =>\n          match w2 with\n          | Vint n2 =>\n              if Archi.ptr64\n              then Vundef\n              else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))\n          | Vptr b2 ofs2 =>\n              if Archi.ptr64\n              then Vundef\n              else\n               if eq_block b1 b2\n               then Vint (Ptrofs.to_int (Ptrofs.sub ofs1 ofs2))\n               else Vundef\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"rewrite H1.\ndestruct v1, v2; simpl; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = true) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vint (Int.sub n1 n2)\n      | _ => Vundef\n      end\n  | Vptr _ _ => match v2 with\n                | Vundef | _ => Vundef\n                end\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vint (Int.sub n1 n2)\n          | _ => Vundef\n          end\n      | Vptr _ _ => match w2 with\n                    | Vundef | _ => Vundef\n                    end\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v1, v2; simpl; auto."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) (H1 : Archi.ptr64 = true) : Val.lessdef (Val.sub v1 v2) (Val.sub w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) (H1 : Archi.ptr64 = true) : Val.lessdef (Val.sub w1 v2) (Val.sub w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) (H1 : Archi.ptr64 = true) : Val.lessdef (Val.sub w1 Vundef) (Val.sub w1 w2).","proofString":"destruct w1; auto."},{"statement":"(m : int) : I (complete_mask (complete_mask m)) = I (complete_mask m).","proofString":"f_equal; apply complete_mask_idem."},{"statement":"(m : int64) : L (complete_mask64 (complete_mask64 m)) = L (complete_mask64 m).","proofString":"f_equal; apply complete_mask64_idem."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1 (modarith x)) (H0 : vagree v2 w2 (modarith x)) : vagree (Val.mul v1 v2) (Val.mul w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.mul; InvAgree.\napply eqmod_iagree.\napply eqmod_mult; apply iagree_eqmod; auto.\nInvAgree.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.mul v1 v2 with\n| Vint p =>\n    match Val.mul w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.mul; InvAgree.\napply eqmod_iagree.\napply eqmod_mult; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) : iagree (Int.mul i1 i) (Int.mul i2 i0) m.","proofString":"apply eqmod_iagree.\napply eqmod_mult; apply iagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int) (H : iagree i1 i2 (complete_mask m)) (H0 : iagree i i0 (complete_mask m)) : eqmod (two_p (Int.size m)) (Int.unsigned i1 * Int.unsigned i)\n  (Int.unsigned i2 * Int.unsigned i0).","proofString":"apply eqmod_mult; apply iagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.mul v1 v2 with\n| Vlong p =>\n    match Val.mul w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.mul v1 v2) (Val.mul w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.mul w1 v2) (Val.mul w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) : Val.lessdef (Val.mul w1 Vundef) (Val.mul w1 w2).","proofString":"destruct w1; auto."},{"statement":"(v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.neg v with\n| Vint p => match Val.neg w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend.","proofString":"unfold Val.neg; InvAgree.\napply eqmod_iagree.\napply eqmod_neg.\napply iagree_eqmod; auto."},{"statement":"(i i0 m : int) (H : iagree i i0 (complete_mask m)) : iagree (Int.neg i) (Int.neg i0) m.","proofString":"apply eqmod_iagree.\napply eqmod_neg.\napply iagree_eqmod; auto."},{"statement":"(i i0 m : int) (H : iagree i i0 (complete_mask m)) : eqmod (two_p (Int.size m)) (- Int.unsigned i) (- Int.unsigned i0).","proofString":"apply eqmod_neg.\napply iagree_eqmod; auto."},{"statement":"(i i0 m : int) (H : iagree i i0 (complete_mask m)) : eqmod (two_p (Int.size m)) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (m : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.neg v with\n| Vlong p => match Val.neg w with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (H : Val.lessdef v w) : Val.lessdef (Val.neg v) (Val.neg w).","proofString":"inv H; simpl; auto."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) : vagree (Val.addl v1 v2) (Val.addl w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\ndestruct Archi.ptr64 eqn:?; unfold Val.addl; rewrite Heqb; InvAgree.\nunfold Val.addl; InvAgree.\napply eqmod_lagree.\napply eqmod_add; apply lagree_eqmod; auto.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.addl v1 v2 with\n| Vint p =>\n    match Val.addl w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct Archi.ptr64 eqn:?; unfold Val.addl; rewrite Heqb; InvAgree."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.addl v1 v2 with\n| Vlong p =>\n    match Val.addl w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.addl; InvAgree.\napply eqmod_lagree.\napply eqmod_add; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) : lagree (Int64.add i1 i) (Int64.add i2 i0) m.","proofString":"apply eqmod_lagree.\napply eqmod_add; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) : eqmod (two_p (Int64.size m)) (Int64.unsigned i1 + Int64.unsigned i)\n  (Int64.unsigned i2 + Int64.unsigned i0).","proofString":"apply eqmod_add; apply lagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.addl v1 v2) (Val.addl w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.addl w1 v2) (Val.addl w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) : Val.lessdef (Val.addl w1 Vundef) (Val.addl w1 w2).","proofString":"destruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | I m => I (complete_mask m)\n  | L m => L (complete_mask64 m)\n  | All => All\n  end) (H1 : Archi.ptr64 = false) : vagree (Val.subl v1 v2) (Val.subl w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree; simpl; rewrite H1; auto.\nunfold Val.subl; rewrite H1; InvAgree.\napply eqmod_lagree.\napply eqmod_sub; apply lagree_eqmod; auto.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) (H1 : Archi.ptr64 = false) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = false) : match Val.subl v1 v2 with\n| Vint p =>\n    match Val.subl w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree; simpl; rewrite H1; auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H1 : Archi.ptr64 = false) : match Val.subl v1 v2 with\n| Vlong p =>\n    match Val.subl w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.subl; rewrite H1; InvAgree.\napply eqmod_lagree.\napply eqmod_sub; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) (H1 : Archi.ptr64 = false) : lagree (Int64.sub i1 i) (Int64.sub i2 i0) m.","proofString":"apply eqmod_lagree.\napply eqmod_sub; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) (H1 : Archi.ptr64 = false) : eqmod (two_p (Int64.size m)) (Int64.unsigned i1 - Int64.unsigned i)\n  (Int64.unsigned i2 - Int64.unsigned i0).","proofString":"apply eqmod_sub; apply lagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) (H1 : Archi.ptr64 = false) : Val.lessdef (Val.subl v1 v2) (Val.subl w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) (H1 : Archi.ptr64 = false) : Val.lessdef (Val.subl w1 v2) (Val.subl w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) (H1 : Archi.ptr64 = false) : Val.lessdef (Val.subl w1 Vundef) (Val.subl w1 w2).","proofString":"destruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1 (modarith x)) (H0 : vagree v2 w2 (modarith x)) : vagree (Val.mull v1 v2) (Val.mull w1 w2) x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nunfold Val.mull; InvAgree.\napply eqmod_lagree.\napply eqmod_mult; apply lagree_eqmod; auto.\ninv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(v1 w1 v2 w2 : val) (H H0 : True) : True.","proofString":"auto."},{"statement":"(v1 w1 v2 w2 : val) (m : int) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.mull v1 v2 with\n| Vint p =>\n    match Val.mull w1 w2 with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vlong p =>\n    match w1 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vlong p =>\n    match w2 with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.mull v1 v2 with\n| Vlong p =>\n    match Val.mull w1 w2 with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.mull; InvAgree.\napply eqmod_lagree.\napply eqmod_mult; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) : lagree (Int64.mul i1 i) (Int64.mul i2 i0) m.","proofString":"apply eqmod_lagree.\napply eqmod_mult; apply lagree_eqmod; auto."},{"statement":"(i1 i2 i i0 m : int64) (H : lagree i1 i2 (complete_mask64 m)) (H0 : lagree i i0 (complete_mask64 m)) : eqmod (two_p (Int64.size m)) (Int64.unsigned i1 * Int64.unsigned i)\n  (Int64.unsigned i2 * Int64.unsigned i0).","proofString":"apply eqmod_mult; apply lagree_eqmod; auto."},{"statement":"(v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.mull v1 v2) (Val.mull w1 w2).","proofString":"inv H; auto.\ninv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 v2 w2 : val) (H0 : Val.lessdef v2 w2) : Val.lessdef (Val.mull w1 v2) (Val.mull w1 w2).","proofString":"inv H0; auto.\ndestruct w1; auto."},{"statement":"(w1 w2 : val) : Val.lessdef (Val.mull w1 Vundef) (Val.mull w1 w2).","proofString":"destruct w1; auto."},{"statement":"(v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (complete_mask m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.negl v with\n| Vint p => match Val.negl w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (m : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (complete_mask64 m)\n    | _ => False\n    end\n| _ => True\nend) : match Val.negl v with\n| Vlong p => match Val.negl w with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend.","proofString":"unfold Val.negl; InvAgree.\napply eqmod_lagree.\napply eqmod_neg.\napply lagree_eqmod; auto."},{"statement":"(i i0 m : int64) (H : lagree i i0 (complete_mask64 m)) : lagree (Int64.neg i) (Int64.neg i0) m.","proofString":"apply eqmod_lagree.\napply eqmod_neg.\napply lagree_eqmod; auto."},{"statement":"(i i0 m : int64) (H : lagree i i0 (complete_mask64 m)) : eqmod (two_p (Int64.size m)) (- Int64.unsigned i) (- Int64.unsigned i0).","proofString":"apply eqmod_neg.\napply lagree_eqmod; auto."},{"statement":"(i i0 m : int64) (H : lagree i i0 (complete_mask64 m)) : eqmod (two_p (Int64.size m)) (Int64.unsigned i) (Int64.unsigned i0).","proofString":"apply lagree_eqmod; auto."},{"statement":"(v w : val) (H : Val.lessdef v w) : Val.lessdef (Val.negl v) (Val.negl w).","proofString":"inv H; simpl; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.zero_ext n m)\n  | _ => I (Int.zero_ext n Int.mone)\n  end) (H0 : 0 <= n) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.zero_ext; InvAgree.\nred; intros.\nautorewrite with ints; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto.\nInvAgree.\nunfold Val.zero_ext; InvAgree; auto.\napply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(v w : val) (n : Z) (H : True) (H0 : 0 <= n) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 <= n) : match Val.zero_ext n v with\n| Vint p =>\n    match Val.zero_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.zero_ext; InvAgree.\nred; intros.\nautorewrite with ints; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) : iagree (Int.zero_ext n i) (Int.zero_ext n i0) m.","proofString":"red; intros.\nautorewrite with ints; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit (Int.zero_ext n i) i1 = Int.testbit (Int.zero_ext n i0) i1.","proofString":"autorewrite with ints; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : (if zlt i1 n then Int.testbit i i1 else false) =\n(if zlt i1 n then Int.testbit i0 i1 else false).","proofString":"destruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (l : i1 < n) : Int.testbit i i1 = Int.testbit i0 i1.","proofString":"apply H; auto.\nautorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (l : i1 < n) : Int.testbit (Int.zero_ext n m) i1 = true.","proofString":"autorewrite with ints; try lia.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.zero_ext n m)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (l : i1 < n) : (if zlt i1 n then Int.testbit m i1 else false) = true.","proofString":"rewrite zlt_true; auto."},{"statement":"(v w : val) (m : int64) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 <= n) : match Val.zero_ext n v with\n| Vlong p =>\n    match Val.zero_ext n w with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 <= n) : Val.lessdef (Val.zero_ext n v) (Val.zero_ext n w).","proofString":"unfold Val.zero_ext; InvAgree; auto.\napply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) : Val.lessdef (Vint (Int.zero_ext n i)) (Vint (Int.zero_ext n i0)).","proofString":"apply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) : Vint (Int.zero_ext n i) = Vint (Int.zero_ext n i0).","proofString":"f_equal.\nInt.bit_solve; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) : Int.zero_ext n i = Int.zero_ext n i0.","proofString":"Int.bit_solve; try lia.\ndestruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) : (if zlt i1 n then Int.testbit i i1 else false) =\n(if zlt i1 n then Int.testbit i0 i1 else false).","proofString":"destruct (zlt i1 n); auto.\napply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (l : i1 < n) : Int.testbit i i1 = Int.testbit i0 i1.","proofString":"apply H; auto.\nautorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (l : i1 < n) : Int.testbit (Int.zero_ext n Int.mone) i1 = true.","proofString":"autorewrite with ints; try lia.\napply zlt_true; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 <= n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (l : i1 < n) : (if zlt i1 n then true else false) = true.","proofString":"apply zlt_true; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))\n  | _ => I (Int.zero_ext n Int.mone)\n  end) (H0 : 0 < n) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.sign_ext; InvAgree.\nred; intros.\nautorewrite with ints; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nautorewrite with ints; try lia.\napply orb_true_intro.\nunfold j; destruct (zlt i1 n).\nleft.\nrewrite zlt_true; auto.\nright.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia.\nInvAgree.\nunfold Val.sign_ext; InvAgree; auto.\napply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(v w : val) (n : Z) (H : True) (H0 : 0 < n) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q\n          (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 < n) : match Val.sign_ext n v with\n| Vint p =>\n    match Val.sign_ext n w with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.sign_ext; InvAgree.\nred; intros.\nautorewrite with ints; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nautorewrite with ints; try lia.\napply orb_true_intro.\nunfold j; destruct (zlt i1 n).\nleft.\nrewrite zlt_true; auto.\nright.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) : iagree (Int.sign_ext n i) (Int.sign_ext n i0) m.","proofString":"red; intros.\nautorewrite with ints; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nautorewrite with ints; try lia.\napply orb_true_intro.\nunfold j; destruct (zlt i1 n).\nleft.\nrewrite zlt_true; auto.\nright.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit (Int.sign_ext n i) i1 = Int.testbit (Int.sign_ext n i0) i1.","proofString":"autorewrite with ints; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nautorewrite with ints; try lia.\napply orb_true_intro.\nunfold j; destruct (zlt i1 n).\nleft.\nrewrite zlt_true; auto.\nright.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit i (if zlt i1 n then i1 else n - 1) =\nInt.testbit i0 (if zlt i1 n then i1 else n - 1).","proofString":"set (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nautorewrite with ints; try lia.\napply orb_true_intro.\nunfold j; destruct (zlt i1 n).\nleft.\nrewrite zlt_true; auto.\nright.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (l : i1 < n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt i1 n then Int.testbit m i1 else false) = true \\/\n(if zlt i1 (Int.unsigned (Int.repr (n - 1)))\n then false\n else Int.testbit Int.one (i1 - Int.unsigned (Int.repr (n - 1)))) = true.","proofString":"left.\nrewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (l : i1 < n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt i1 n then Int.testbit m i1 else false) = true.","proofString":"rewrite zlt_true; auto."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (n - 1) n then Int.testbit m (n - 1) else false) = true \\/\n(if zlt (n - 1) (Int.unsigned (Int.repr (n - 1)))\n then false\n else Int.testbit Int.one (n - 1 - Int.unsigned (Int.repr (n - 1)))) = true.","proofString":"right.\nrewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (n - 1) (Int.unsigned (Int.repr (n - 1)))\n then false\n else Int.testbit Int.one (n - 1 - Int.unsigned (Int.repr (n - 1)))) = true.","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : (if zlt (n - 1) (n - 1) then false else Int.testbit Int.one (n - 1 - (n - 1))) =\ntrue.","proofString":"rewrite zlt_false by lia.\nreplace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : Int.testbit Int.one (n - 1 - (n - 1)) = true.","proofString":"replace (n - 1 - (n - 1)) with 0 by lia.\nreflexivity."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : Int.testbit Int.one 0 = true.","proofString":"reflexivity."},{"statement":"(i i0 m : int) (n : Z) (H : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (g : i1 >= n) (j : Z) (H3 : 0 <= j < Int.zwordsize) : 0 <= n - 1 <= Int.max_unsigned.","proofString":"generalize Int.wordsize_max_unsigned; lia."},{"statement":"(v w : val) (m : int64) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 < n) : match Val.sign_ext n v with\n| Vlong p =>\n    match Val.sign_ext n w with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(v w : val) (n : Z) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int.zero_ext n Int.mone)\n    | _ => False\n    end\n| _ => True\nend) (H0 : 0 < n) : Val.lessdef (Val.sign_ext n v) (Val.sign_ext n w).","proofString":"unfold Val.sign_ext; InvAgree; auto.\napply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) : Val.lessdef (Vint (Int.sign_ext n i)) (Vint (Int.sign_ext n i0)).","proofString":"apply Val.lessdef_same.\nf_equal.\nInt.bit_solve; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) : Vint (Int.sign_ext n i) = Vint (Int.sign_ext n i0).","proofString":"f_equal.\nInt.bit_solve; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) : Int.sign_ext n i = Int.sign_ext n i0.","proofString":"Int.bit_solve; try lia.\nset (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) : Int.testbit i (if zlt i1 n then i1 else n - 1) =\nInt.testbit i0 (if zlt i1 n then i1 else n - 1).","proofString":"set (j := if zlt i1 n then i1 else n - 1).\nassert (0 <= j < Int.zwordsize).\nunfold j; destruct (zlt i1 n); lia.\napply H; auto.\nrewrite Int.bits_zero_ext; try lia.\nrewrite zlt_true.\napply Int.bits_mone; auto.\nunfold j.\ndestruct (zlt i1 n); lia."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (j : Z) (H2 : 0 <= j < Int.zwordsize) : Int.testbit Int.mone j = true.","proofString":"apply Int.bits_mone; auto."},{"statement":"(i i0 : int) (n : Z) (H : iagree i i0 (Int.zero_ext n Int.mone)) (H0 : 0 < n) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (j : Z) (H2 : 0 <= j < Int.zwordsize) : (if zlt i1 n then i1 else n - 1) < n.","proofString":"destruct (zlt i1 n); lia."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) : forall (v w : val) (x : nval),\nvagree v w (loword x) -> vagree (Val.loword v) (Val.loword w) x.","proofString":"assert (B: forall i j m,             lagree i j (Int64.ofwords Int.zero m) ->             iagree (Int64.loword i) (Int64.loword j) m).\nred; intros.\nrewrite ! Int64.bits_loword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_true by lia.\nassumption.\nunfold loword, Val.loword; intros.\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i) (Int64.loword j) m.","proofString":"red; intros.\nrewrite ! Int64.bits_loword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_true by lia.\nassumption."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords Int.zero m)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int.testbit (Int64.loword i) i0 = Int.testbit (Int64.loword j) i0.","proofString":"rewrite ! Int64.bits_loword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_true by lia.\nassumption."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords Int.zero m)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int64.testbit i i0 = Int64.testbit j i0.","proofString":"apply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_true by lia.\nassumption."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords Int.zero m)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : 0 <= i0 < Int64.zwordsize.","proofString":"lia."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords Int.zero m)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int64.testbit (Int64.ofwords Int.zero m) i0 = true.","proofString":"rewrite Int64.bits_ofwords, zlt_true by lia.\nassumption."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords Int.zero m)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int.testbit m i0 = true.","proofString":"assumption."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i) (Int64.loword j) m) : forall (v w : val) (x : nval),\nvagree v w (loword x) -> vagree (Val.loword v) (Val.loword w) x.","proofString":"unfold loword, Val.loword; intros.\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i) (Int64.loword j) m) (v w : val) (x : nval) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => L (Int64.ofwords Int.zero m)\n  | _ => L (Int64.ofwords Int.zero Int.mone)\n  end) : vagree match v with\n       | Vlong n => Vint (Int64.loword n)\n       | _ => Vundef\n       end match w with\n           | Vlong n => Vint (Int64.loword n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i) (Int64.loword j) m) (v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m0 : int),\nlagree i j (Int64.ofwords Int.zero m0) ->\niagree (Int64.loword i) (Int64.loword j) m0) (v w : val) (m : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords Int.zero m)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vlong n => Vint (Int64.loword n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vlong n => Vint (Int64.loword n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m0 : int),\nlagree i j (Int64.ofwords Int.zero m0) ->\niagree (Int64.loword i) (Int64.loword j) m0) (v w : val) (m : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords Int.zero Int.mone)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vlong n => Vint (Int64.loword n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vlong n => Vint (Int64.loword n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i) (Int64.loword j) m) (v w : val) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords Int.zero Int.mone)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef match v with\n            | Vlong n => Vint (Int64.loword n)\n            | _ => Vundef\n            end\n  match w with\n  | Vlong n => Vint (Int64.loword n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i1) (Int64.loword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.zero Int.mone)) : Val.lessdef (Vint (Int64.loword i)) (Vint (Int64.loword i0)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i1) (Int64.loword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.zero Int.mone)) : Vint (Int64.loword i) = Vint (Int64.loword i0).","proofString":"f_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i1) (Int64.loword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.zero Int.mone)) : Int64.loword i = Int64.loword i0.","proofString":"apply iagree_mone.\nauto."},{"statement":"(A : Int.zwordsize < Int64.zwordsize) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords Int.zero m) ->\niagree (Int64.loword i1) (Int64.loword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.zero Int.mone)) : iagree (Int64.loword i) (Int64.loword i0) Int.mone.","proofString":"auto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) : forall (v w : val) (x : nval),\nvagree v w (hiword x) -> vagree (Val.hiword v) (Val.hiword w) x.","proofString":"assert (B: forall i j m,             lagree i j (Int64.ofwords m Int.zero) ->             iagree (Int64.hiword i) (Int64.hiword j) m).\nred; intros.\nrewrite ! Int64.bits_hiword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_false by lia.\nreplace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption.\nunfold hiword, Val.hiword; intros.\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m.","proofString":"red; intros.\nrewrite ! Int64.bits_hiword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_false by lia.\nreplace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int.testbit (Int64.hiword i) i0 = Int.testbit (Int64.hiword j) i0.","proofString":"rewrite ! Int64.bits_hiword by auto.\napply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_false by lia.\nreplace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int64.testbit i (i0 + Int.zwordsize) = Int64.testbit j (i0 + Int.zwordsize).","proofString":"apply H.\nlia.\nrewrite Int64.bits_ofwords, zlt_false by lia.\nreplace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : 0 <= i0 + Int.zwordsize < Int64.zwordsize.","proofString":"lia."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int64.testbit (Int64.ofwords m Int.zero) (i0 + Int.zwordsize) = true.","proofString":"rewrite Int64.bits_ofwords, zlt_false by lia.\nreplace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int.testbit m (i0 + Int.zwordsize - Int.zwordsize) = true.","proofString":"replace (i0 + Int.zwordsize - Int.zwordsize) with i0 by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i j : int64) (m : int) (H : lagree i j (Int64.ofwords m Int.zero)) (i0 : Z) (H0 : 0 <= i0 < Int.zwordsize) (H1 : Int.testbit m i0 = true) : Int.testbit m i0 = true.","proofString":"assumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m) : forall (v w : val) (x : nval),\nvagree v w (hiword x) -> vagree (Val.hiword v) (Val.hiword w) x.","proofString":"unfold hiword, Val.hiword; intros.\ndestruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m) (v w : val) (x : nval) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => L (Int64.ofwords m Int.zero)\n  | _ => L (Int64.ofwords Int.mone Int.zero)\n  end) : vagree match v with\n       | Vlong n => Vint (Int64.hiword n)\n       | _ => Vundef\n       end match w with\n           | Vlong n => Vint (Int64.hiword n)\n           | _ => Vundef\n           end x.","proofString":"destruct x; simpl in *.\nauto.\nInvAgree.\nInvAgree.\nInvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m) (v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i j : int64) (m0 : int),\nlagree i j (Int64.ofwords m0 Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m0) (v w : val) (m : int) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords m Int.zero)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vlong n => Vint (Int64.hiword n)\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vlong n => Vint (Int64.hiword n)\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i j : int64) (m0 : int),\nlagree i j (Int64.ofwords m0 Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m0) (v w : val) (m : int64) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords Int.mone Int.zero)\n    | _ => False\n    end\n| _ => True\nend) : match match v with\n      | Vlong n => Vint (Int64.hiword n)\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vlong n => Vint (Int64.hiword n)\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i j : int64) (m : int),\nlagree i j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i) (Int64.hiword j) m) (v w : val) (H : match v with\n| Vlong p =>\n    match w with\n    | Vlong q => lagree p q (Int64.ofwords Int.mone Int.zero)\n    | _ => False\n    end\n| _ => True\nend) : Val.lessdef match v with\n            | Vlong n => Vint (Int64.hiword n)\n            | _ => Vundef\n            end\n  match w with\n  | Vlong n => Vint (Int64.hiword n)\n  | _ => Vundef\n  end.","proofString":"InvAgree.\napply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i1) (Int64.hiword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.mone Int.zero)) : Val.lessdef (Vint (Int64.hiword i)) (Vint (Int64.hiword i0)).","proofString":"apply Val.lessdef_same.\nf_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i1) (Int64.hiword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.mone Int.zero)) : Vint (Int64.hiword i) = Vint (Int64.hiword i0).","proofString":"f_equal.\napply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i1) (Int64.hiword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.mone Int.zero)) : Int64.hiword i = Int64.hiword i0.","proofString":"apply iagree_mone.\nauto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j : int64) (m : int),\nlagree i1 j (Int64.ofwords m Int.zero) ->\niagree (Int64.hiword i1) (Int64.hiword j) m) (i i0 : int64) (H : lagree i i0 (Int64.ofwords Int.mone Int.zero)) : iagree (Int64.hiword i) (Int64.hiword i0) Int.mone.","proofString":"auto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) : forall (v1 w1 v2 w2 : val) (x : nval),\nvagree v1 w1 (makelong_hi x) ->\nvagree v2 w2 (makelong_lo x) ->\nvagree (Val.longofwords v1 v2) (Val.longofwords w1 w2) x.","proofString":"assert (B: forall i1 j1 i2 j2 m,            iagree i1 j1 (Int64.hiword m) -> iagree i2 j2 (Int64.loword m) ->            lagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m).\nred; intros.\nrewrite ! Int64.bits_ofwords by lia.\ndestruct (zlt i Int.zwordsize).\napply H0.\nlia.\nrewrite Int64.bits_loword by lia.\nassumption.\napply H.\nlia.\nrewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption.\nunfold makelong_hi, makelong_lo, Val.longofwords; intros.\ndestruct x; simpl in *.\nauto.\ninv H; auto; inv H0; auto; destruct w1, w2; auto with na.\nInvAgree.\napply Val.longofwords_lessdef; auto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) : forall (i1 j1 i2 j2 : int) (m : int64),\niagree i1 j1 (Int64.hiword m) ->\niagree i2 j2 (Int64.loword m) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m.","proofString":"red; intros.\nrewrite ! Int64.bits_ofwords by lia.\ndestruct (zlt i Int.zwordsize).\napply H0.\nlia.\nrewrite Int64.bits_loword by lia.\nassumption.\napply H.\nlia.\nrewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) : Int64.testbit (Int64.ofwords i1 i2) i = Int64.testbit (Int64.ofwords j1 j2) i.","proofString":"rewrite ! Int64.bits_ofwords by lia.\ndestruct (zlt i Int.zwordsize).\napply H0.\nlia.\nrewrite Int64.bits_loword by lia.\nassumption.\napply H.\nlia.\nrewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) : (if zlt i Int.zwordsize\n then Int.testbit i2 i\n else Int.testbit i1 (i - Int.zwordsize)) =\n(if zlt i Int.zwordsize\n then Int.testbit j2 i\n else Int.testbit j1 (i - Int.zwordsize)).","proofString":"destruct (zlt i Int.zwordsize).\napply H0.\nlia.\nrewrite Int64.bits_loword by lia.\nassumption.\napply H.\nlia.\nrewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (l : i < Int.zwordsize) : Int.testbit i2 i = Int.testbit j2 i.","proofString":"apply H0.\nlia.\nrewrite Int64.bits_loword by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (l : i < Int.zwordsize) : 0 <= i < Int.zwordsize.","proofString":"lia."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (l : i < Int.zwordsize) : Int.testbit (Int64.loword m) i = true.","proofString":"rewrite Int64.bits_loword by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (l : i < Int.zwordsize) : Int64.testbit m i = true.","proofString":"assumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (g : i >= Int.zwordsize) : Int.testbit i1 (i - Int.zwordsize) = Int.testbit j1 (i - Int.zwordsize).","proofString":"apply H.\nlia.\nrewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (g : i >= Int.zwordsize) : 0 <= i - Int.zwordsize < Int.zwordsize.","proofString":"lia."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (g : i >= Int.zwordsize) : Int.testbit (Int64.hiword m) (i - Int.zwordsize) = true.","proofString":"rewrite Int64.bits_hiword by lia.\nreplace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (g : i >= Int.zwordsize) : Int64.testbit m (i - Int.zwordsize + Int.zwordsize) = true.","proofString":"replace (i - Int.zwordsize + Int.zwordsize) with i by lia.\nassumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (i1 j1 i2 j2 : int) (m : int64) (H : iagree i1 j1 (Int64.hiword m)) (H0 : iagree i2 j2 (Int64.loword m)) (i : Z) (H1 : 0 <= i < Int64.zwordsize) (H2 : Int64.testbit m i = true) (g : i >= Int.zwordsize) : Int64.testbit m i = true.","proofString":"assumption."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (B : forall (i1 j1 i2 j2 : int) (m : int64),\niagree i1 j1 (Int64.hiword m) ->\niagree i2 j2 (Int64.loword m) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m) : forall (v1 w1 v2 w2 : val) (x : nval),\nvagree v1 w1 (makelong_hi x) ->\nvagree v2 w2 (makelong_lo x) ->\nvagree (Val.longofwords v1 v2) (Val.longofwords w1 w2) x.","proofString":"unfold makelong_hi, makelong_lo, Val.longofwords; intros.\ndestruct x; simpl in *.\nauto.\ninv H; auto; inv H0; auto; destruct w1, w2; auto with na.\nInvAgree.\napply Val.longofwords_lessdef; auto."},{"statement":"(A : Int64.zwordsize = 2 * Int.zwordsize) (B : forall (i1 j1 i2 j2 : int) (m : int64),\niagree i1 j1 (Int64.hiword m) ->\niagree i2 j2 (Int64.loword m) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m) (v1 w1 v2 w2 : val) (x : nval) (H : vagree v1 w1\n  match x with\n  | Nothing => Nothing\n  | L m => I (Int64.hiword m)\n  | _ => All\n  end) (H0 : vagree v2 w2\n  match x with\n  | Nothing => Nothing\n  | L m => I (Int64.loword m)\n  | _ => All\n  end) : vagree\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint n1 =>\n      match w2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\ninv H; auto; inv H0; auto; destruct w1, w2; auto with na.\nInvAgree.\napply Val.longofwords_lessdef; auto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j1 i2 j2 : int) (m : int64),\niagree i1 j1 (Int64.hiword m) ->\niagree i2 j2 (Int64.loword m) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m) (v1 w1 v2 w2 : val) (H H0 : True) : True.","proofString":"auto."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j1 i2 j2 : int) (m0 : int64),\niagree i1 j1 (Int64.hiword m0) ->\niagree i2 j2 (Int64.loword m0) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m0) (v1 w1 v2 w2 : val) (m : int) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vlong (Int64.ofwords n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"inv H; auto; inv H0; auto; destruct w1, w2; auto with na."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j1 i2 j2 : int) (m0 : int64),\niagree i1 j1 (Int64.hiword m0) ->\niagree i2 j2 (Int64.loword m0) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m0) (v1 w1 v2 w2 : val) (m : int64) (H : match v1 with\n| Vint p =>\n    match w1 with\n    | Vint q => iagree p q (Int64.hiword m)\n    | _ => False\n    end\n| _ => True\nend) (H0 : match v2 with\n| Vint p =>\n    match w2 with\n    | Vint q => iagree p q (Int64.loword m)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w1 with\n      | Vint n1 =>\n          match w2 with\n          | Vint n2 => Vlong (Int64.ofwords n1 n2)\n          | _ => Vundef\n          end\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(A : Int64.zwordsize = 64) (B : forall (i1 j1 i2 j2 : int) (m : int64),\niagree i1 j1 (Int64.hiword m) ->\niagree i2 j2 (Int64.loword m) ->\nlagree (Int64.ofwords i1 i2) (Int64.ofwords j1 j2) m) (v1 w1 v2 w2 : val) (H : Val.lessdef v1 w1) (H0 : Val.lessdef v2 w2) : Val.lessdef\n  match v1 with\n  | Vint n1 =>\n      match v2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end\n  match w1 with\n  | Vint n1 =>\n      match w2 with\n      | Vint n2 => Vlong (Int64.ofwords n1 n2)\n      | _ => Vundef\n      end\n  | _ => Vundef\n  end.","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"forall (i j : int) (m : int64),\niagree i j (Int64.loword m) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m.","proofString":"red; intros.\nrewrite ! Int64.testbit_repr by auto.\nchange (Int.testbit i i0 = Int.testbit j i0).\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int64.bits_loword by lia.\nauto.\nrewrite ! Int.bits_above by auto.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Int64.testbit (Int64.repr (Int.unsigned i)) i0 =\nInt64.testbit (Int64.repr (Int.unsigned j)) i0.","proofString":"rewrite ! Int64.testbit_repr by auto.\nchange (Int.testbit i i0 = Int.testbit j i0).\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int64.bits_loword by lia.\nauto.\nrewrite ! Int.bits_above by auto.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Z.testbit (Int.unsigned i) i0 = Z.testbit (Int.unsigned j) i0.","proofString":"change (Int.testbit i i0 = Int.testbit j i0).\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int64.bits_loword by lia.\nauto.\nrewrite ! Int.bits_above by auto.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Int.testbit i i0 = Int.testbit j i0.","proofString":"destruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int64.bits_loword by lia.\nauto.\nrewrite ! Int.bits_above by auto.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit j i0.","proofString":"apply H.\nlia.\nrewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : 0 <= i0 < Int.zwordsize.","proofString":"lia."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit (Int64.loword m) i0 = true.","proofString":"rewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int64.testbit m i0 = true.","proofString":"auto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) : Int.testbit i i0 = Int.testbit j i0.","proofString":"rewrite ! Int.bits_above by auto.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int64.loword m)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) : false = false.","proofString":"auto."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int64.loword m) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m) : forall (v w : val) (x : nval),\nvagree v w (longofintu x) -> vagree (Val.longofintu v) (Val.longofintu w) x.","proofString":"unfold longofintu, Val.longofintu; intros.\ndestruct x; simpl in *.\nauto.\ninv H; auto.\ndestruct w; auto with na.\nInvAgree.\ninv H; auto."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int64.loword m) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m) (v w : val) (x : nval) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => I (Int64.loword m)\n  | _ => All\n  end) : vagree\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\ninv H; auto.\ndestruct w; auto with na.\nInvAgree.\ninv H; auto."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int64.loword m) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m) (v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int64.loword m0) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m0) (v w : val) (m : int) (H : Val.lessdef v w) : match\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.unsigned n))\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"inv H; auto.\ndestruct w; auto with na."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int64.loword m0) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m0) (w : val) (m : int) : match\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.unsigned n))\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct w; auto with na."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int64.loword m0) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m0) (v w : val) (m : int64) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q => iagree p q (Int64.loword m)\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.unsigned n))\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int64.loword m) ->\nlagree (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned j)) m) (v w : val) (H : Val.lessdef v w) : Val.lessdef\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end.","proofString":"inv H; auto."},{"statement":"forall (i j : int) (m : int64),\niagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m.","proofString":"red; intros.\nrewrite ! Int64.testbit_repr by auto.\nrewrite ! Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto.\nassert (0 <= Int.zwordsize - 1 < Int.zwordsize) by (change Int.zwordsize with 32; lia).\napply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Int64.testbit (Int64.repr (Int.signed i)) i0 =\nInt64.testbit (Int64.repr (Int.signed j)) i0.","proofString":"rewrite ! Int64.testbit_repr by auto.\nrewrite ! Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto.\nassert (0 <= Int.zwordsize - 1 < Int.zwordsize) by (change Int.zwordsize with 32; lia).\napply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Z.testbit (Int.signed i) i0 = Z.testbit (Int.signed j) i0.","proofString":"rewrite ! Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto.\nassert (0 <= Int.zwordsize - 1 < Int.zwordsize) by (change Int.zwordsize with 32; lia).\napply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) : Int.testbit i (if zlt i0 Int.zwordsize then i0 else Int.zwordsize - 1) =\nInt.testbit j (if zlt i0 Int.zwordsize then i0 else Int.zwordsize - 1).","proofString":"destruct (zlt i0 Int.zwordsize).\napply H.\nlia.\nrewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto.\nassert (0 <= Int.zwordsize - 1 < Int.zwordsize) by (change Int.zwordsize with 32; lia).\napply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit j i0.","proofString":"apply H.\nlia.\nrewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : 0 <= i0 < Int.zwordsize.","proofString":"lia."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) i0 =\ntrue.","proofString":"rewrite Int.bits_or by lia.\napply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit (Int64.loword m) i0\n|| Int.testbit (Int.shl Int.one (Int.repr 31)) i0 = true.","proofString":"apply orb_true_intro; left.\nrewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int.testbit (Int64.loword m) i0 = true.","proofString":"rewrite Int64.bits_loword by lia.\nauto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (l : i0 < Int.zwordsize) : Int64.testbit m i0 = true.","proofString":"auto."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) : Int.testbit i (Int.zwordsize - 1) = Int.testbit j (Int.zwordsize - 1).","proofString":"assert (0 <= Int.zwordsize - 1 < Int.zwordsize) by (change Int.zwordsize with 32; lia).\napply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) (H2 : 0 <= Int.zwordsize - 1 < Int.zwordsize) : Int.testbit i (Int.zwordsize - 1) = Int.testbit j (Int.zwordsize - 1).","proofString":"apply H; auto.\nrewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) (H2 : 0 <= Int.zwordsize - 1 < Int.zwordsize) : Int.testbit (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))\n  (Int.zwordsize - 1) = true.","proofString":"rewrite Int.bits_or by lia.\napply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) (H2 : 0 <= Int.zwordsize - 1 < Int.zwordsize) : Int.testbit (Int64.loword m) (Int.zwordsize - 1)\n|| Int.testbit (Int.shl Int.one (Int.repr 31)) (Int.zwordsize - 1) = true.","proofString":"apply orb_true_intro; right.\nreflexivity."},{"statement":"(i j : int) (m : int64) (H : iagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (H1 : Int64.testbit m i0 = true) (g : i0 >= Int.zwordsize) (H2 : 0 <= Int.zwordsize - 1 < Int.zwordsize) : Int.testbit (Int.shl Int.one (Int.repr 31)) (Int.zwordsize - 1) = true.","proofString":"reflexivity."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m) : forall (v w : val) (x : nval),\nvagree v w (longofint x) -> vagree (Val.longofint v) (Val.longofint w) x.","proofString":"unfold longofint, Val.longofint; intros.\ndestruct x; simpl in *.\nauto.\ninv H; auto.\ndestruct w; auto with na.\nInvAgree.\ninv H; auto."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m) (v w : val) (x : nval) (H : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => I (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))\n  | _ => All\n  end) : vagree\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end x.","proofString":"destruct x; simpl in *.\nauto.\ninv H; auto.\ndestruct w; auto with na.\nInvAgree.\ninv H; auto."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m) (v w : val) (H : True) : True.","proofString":"auto."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int.or (Int64.loword m0) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m0) (v w : val) (m : int) (H : Val.lessdef v w) : match\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.signed n))\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"inv H; auto.\ndestruct w; auto with na."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int.or (Int64.loword m0) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m0) (w : val) (m : int) : match\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.signed n))\n      | _ => Vundef\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct w; auto with na."},{"statement":"(B : forall (i j : int) (m0 : int64),\niagree i j (Int.or (Int64.loword m0) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m0) (v w : val) (m : int64) (H : match v with\n| Vint p =>\n    match w with\n    | Vint q =>\n        iagree p q (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31)))\n    | _ => False\n    end\n| _ => True\nend) : match\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vint n => Vlong (Int64.repr (Int.signed n))\n      | _ => Vundef\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"InvAgree."},{"statement":"(B : forall (i j : int) (m : int64),\niagree i j (Int.or (Int64.loword m) (Int.shl Int.one (Int.repr 31))) ->\nlagree (Int64.repr (Int.signed i)) (Int64.repr (Int.signed j)) m) (v w : val) (H : Val.lessdef v w) : Val.lessdef\n  match v with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end\n  match w with\n  | Vint n => Vlong (Int64.repr (Int.signed n))\n  | _ => Vundef\n  end.","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) : list_forall2 memval_lessdef (encode_val chunk v) (encode_val chunk w).","proofString":"assert (UNDEF: list_forall2 memval_lessdef                     (List.repeat Undef (size_chunk_nat chunk))                     (encode_val chunk w)).\nrewrite <- (encode_val_length chunk w).\napply repeat_Undef_inject_any.\nassert (SAME: forall vl1 vl2,                vl1 = vl2 ->                list_forall2 memval_lessdef vl1 vl2).\nintros.\nsubst vl2.\nrevert vl1.\ninduction vl1; constructor; auto.\napply memval_lessdef_refl.\nintros.\nunfold store_argument in H; destruct chunk.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w).","proofString":"rewrite <- (encode_val_length chunk w).\napply repeat_Undef_inject_any."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) : list_forall2 memval_lessdef\n  (repeat Undef (Datatypes.length (encode_val chunk w))) \n  (encode_val chunk w).","proofString":"apply repeat_Undef_inject_any."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) : list_forall2 memval_lessdef (encode_val chunk v) (encode_val chunk w).","proofString":"assert (SAME: forall vl1 vl2,                vl1 = vl2 ->                list_forall2 memval_lessdef vl1 vl2).\nintros.\nsubst vl2.\nrevert vl1.\ninduction vl1; constructor; auto.\napply memval_lessdef_refl.\nintros.\nunfold store_argument in H; destruct chunk.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2.","proofString":"intros.\nsubst vl2.\nrevert vl1.\ninduction vl1; constructor; auto.\napply memval_lessdef_refl."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) (vl1 vl2 : list memval) (H0 : vl1 = vl2) : list_forall2 memval_lessdef vl1 vl2.","proofString":"subst vl2.\nrevert vl1.\ninduction vl1; constructor; auto.\napply memval_lessdef_refl."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) (vl1 : list memval) : list_forall2 memval_lessdef vl1 vl1.","proofString":"revert vl1.\ninduction vl1; constructor; auto.\napply memval_lessdef_refl."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) : forall vl1 : list memval, list_forall2 memval_lessdef vl1 vl1.","proofString":"induction vl1; constructor; auto.\napply memval_lessdef_refl."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) (a : memval) (vl1 : list memval) (IHvl1 : list_forall2 memval_lessdef vl1 vl1) : memval_lessdef a a.","proofString":"apply memval_lessdef_refl."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val chunk v) (encode_val chunk w).","proofString":"intros.\nunfold store_argument in H; destruct chunk.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(chunk : memory_chunk) (v w : val) (H : vagree v w (store_argument chunk)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val chunk v) (encode_val chunk w).","proofString":"unfold store_argument in H; destruct chunk.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\nInvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto.\napply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w (I (Int.repr 255))) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mbool v) (encode_val Mbool w).","proofString":"InvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mbool (Vint i))\n  (encode_val Mbool (Vint i0)).","proofString":"apply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_val Mbool (Vint i) = encode_val Mbool (Vint i0).","proofString":"simpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_int 1 (Int.unsigned i) = encode_int 1 (Int.unsigned i0).","proofString":"apply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p 8) (Int.unsigned i) (Int.unsigned i0).","proofString":"change 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mbool))\n  (encode_val Mbool (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p (Int.size (Int.repr 255))) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (H : vagree v w (I (Int.repr 255))) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint8signed v)\n  (encode_val Mint8signed w).","proofString":"InvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint8signed (Vint i))\n  (encode_val Mint8signed (Vint i0)).","proofString":"apply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_val Mint8signed (Vint i) = encode_val Mint8signed (Vint i0).","proofString":"simpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_int 1 (Int.unsigned i) = encode_int 1 (Int.unsigned i0).","proofString":"apply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p 8) (Int.unsigned i) (Int.unsigned i0).","proofString":"change 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8signed))\n  (encode_val Mint8signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p (Int.size (Int.repr 255))) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (H : vagree v w (I (Int.repr 255))) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint8unsigned v)\n  (encode_val Mint8unsigned w).","proofString":"InvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint8unsigned (Vint i))\n  (encode_val Mint8unsigned (Vint i0)).","proofString":"apply SAME.\nsimpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_val Mint8unsigned (Vint i) = encode_val Mint8unsigned (Vint i0).","proofString":"simpl; f_equal.\napply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_int 1 (Int.unsigned i) = encode_int 1 (Int.unsigned i0).","proofString":"apply encode_int_8_mod.\nchange 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p 8) (Int.unsigned i) (Int.unsigned i0).","proofString":"change 8 with (Int.size (Int.repr 255)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint8unsigned))\n  (encode_val Mint8unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p (Int.size (Int.repr 255))) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (H : vagree v w (I (Int.repr 65535))) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint16signed v)\n  (encode_val Mint16signed w).","proofString":"InvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint16signed (Vint i))\n  (encode_val Mint16signed (Vint i0)).","proofString":"apply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_val Mint16signed (Vint i) = encode_val Mint16signed (Vint i0).","proofString":"simpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_int 2 (Int.unsigned i) = encode_int 2 (Int.unsigned i0).","proofString":"apply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p 16) (Int.unsigned i) (Int.unsigned i0).","proofString":"change 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16signed))\n  (encode_val Mint16signed (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p (Int.size (Int.repr 65535))) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (H : vagree v w (I (Int.repr 65535))) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint16unsigned v)\n  (encode_val Mint16unsigned w).","proofString":"InvAgree.\napply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint16unsigned (Vint i))\n  (encode_val Mint16unsigned (Vint i0)).","proofString":"apply SAME.\nsimpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_val Mint16unsigned (Vint i) = encode_val Mint16unsigned (Vint i0).","proofString":"simpl; f_equal.\napply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : encode_int 2 (Int.unsigned i) = encode_int 2 (Int.unsigned i0).","proofString":"apply encode_int_16_mod.\nchange 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p 16) (Int.unsigned i) (Int.unsigned i0).","proofString":"change 16 with (Int.size (Int.repr 65535)).\napply iagree_eqmod; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint16unsigned))\n  (encode_val Mint16unsigned (Vint i0))) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : eqmod (two_p (Int.size (Int.repr 65535))) (Int.unsigned i) (Int.unsigned i0).","proofString":"apply iagree_eqmod; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint32))\n  (encode_val Mint32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint32 v) (encode_val Mint32 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint32))\n  (encode_val Mint32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint64))\n  (encode_val Mint64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mint64 v) (encode_val Mint64 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mint64))\n  (encode_val Mint64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mfloat32))\n  (encode_val Mfloat32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mfloat32 v) (encode_val Mfloat32 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mfloat32))\n  (encode_val Mfloat32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mfloat64))\n  (encode_val Mfloat64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Mfloat64 v) (encode_val Mfloat64 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Mfloat64))\n  (encode_val Mfloat64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Many32))\n  (encode_val Many32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Many32 v) (encode_val Many32 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Many32))\n  (encode_val Many32 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Many64))\n  (encode_val Many64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : list_forall2 memval_lessdef (encode_val Many64 v) (encode_val Many64 w).","proofString":"apply encode_val_inject.\nrewrite val_inject_id; auto."},{"statement":"(v w : val) (H : vagree v w All) (UNDEF : list_forall2 memval_lessdef (repeat Undef (size_chunk_nat Many64))\n  (encode_val Many64 w)) (SAME : forall vl1 vl2 : list memval,\nvl1 = vl2 -> list_forall2 memval_lessdef vl1 vl2) : Val.inject inject_id v w.","proofString":"rewrite val_inject_id; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : Val.lessdef (Val.norm_bool (Vint (Int.zero_ext 8 i)))\n  (Val.norm_bool (Vint (Int.zero_ext 8 i0))).","proofString":"apply Val.norm_bool_lessdef.\napply zero_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 8).\nauto.\nlia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : Val.lessdef (Vint (Int.zero_ext 8 i)) (Vint (Int.zero_ext 8 i0)).","proofString":"apply zero_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 8).\nauto.\nlia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : vagree (Vint i) (Vint i0) (zero_ext 8 All).","proofString":"auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : 0 <= 8.","proofString":"lia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : Val.lessdef (Vint (Int.sign_ext 8 i)) (Vint (Int.sign_ext 8 i0)).","proofString":"apply sign_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 8).\nauto.\ncompute; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : vagree (Vint i) (Vint i0) (sign_ext 8 All).","proofString":"auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : 0 < 8.","proofString":"compute; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : Val.lessdef (Vint (Int.zero_ext 8 i)) (Vint (Int.zero_ext 8 i0)).","proofString":"apply zero_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 8).\nauto.\nlia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : vagree (Vint i) (Vint i0) (zero_ext 8 All).","proofString":"auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 255)) : 0 <= 8.","proofString":"lia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : Val.lessdef (Vint (Int.sign_ext 16 i)) (Vint (Int.sign_ext 16 i0)).","proofString":"apply sign_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 16).\nauto.\ncompute; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : vagree (Vint i) (Vint i0) (sign_ext 16 All).","proofString":"auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : 0 < 16.","proofString":"compute; auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : Val.lessdef (Vint (Int.zero_ext 16 i)) (Vint (Int.zero_ext 16 i0)).","proofString":"apply zero_ext_sound with (v := Vint i) (w := Vint i0) (x := All) (n := 16).\nauto.\nlia."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : vagree (Vint i) (Vint i0) (zero_ext 16 All).","proofString":"auto."},{"statement":"(i i0 : int) (H : iagree i i0 (Int.repr 65535)) : 0 <= 16.","proofString":"lia."},{"statement":"(v w : val) (n : int) (b : bool) (H : vagree v w (I n)) (H0 : Val.maskzero_bool v n = Some b) : Val.maskzero_bool w n = Some b.","proofString":"unfold Val.maskzero_bool; InvAgree; try discriminate.\ninv H0.\nrewrite iagree_and_eq in H.\nrewrite H.\nauto."},{"statement":"(i i0 n : int) (b : bool) (H : iagree i i0 n) (H0 : Val.maskzero_bool (Vint i) n = Some b) : Some (Int.eq (Int.and i0 n) Int.zero) = Some b.","proofString":"inv H0.\nrewrite iagree_and_eq in H.\nrewrite H.\nauto."},{"statement":"(i i0 n : int) (H : iagree i i0 n) : Some (Int.eq (Int.and i0 n) Int.zero) = Some (Int.eq (Int.and i n) Int.zero).","proofString":"rewrite iagree_and_eq in H.\nrewrite H.\nauto."},{"statement":"(i i0 n : int) (H : Int.and i n = Int.and i0 n) : Some (Int.eq (Int.and i0 n) Int.zero) = Some (Int.eq (Int.and i n) Int.zero).","proofString":"rewrite H.\nauto."},{"statement":"(i i0 n : int) (H : Int.and i n = Int.and i0 n) : Some (Int.eq (Int.and i0 n) Int.zero) = Some (Int.eq (Int.and i0 n) Int.zero).","proofString":"auto."},{"statement":"(v w : val) (x : nval) (ty : typ) (H : vagree v w x) : vagree (Val.normalize v ty) (Val.normalize w ty) x.","proofString":"destruct x; simpl in *.\nauto.\nunfold Val.normalize.\ndestruct v.\nauto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto.\nunfold Val.normalize.\ndestruct v; auto.\ndestruct ty; auto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto.\napply Val.normalize_lessdef; auto."},{"statement":"(v w : val) (ty : typ) (H : True) : True.","proofString":"auto."},{"statement":"(v w : val) (m : int) (ty : typ) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) : match Val.normalize v ty with\n| Vint p =>\n    match Val.normalize w ty with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.normalize.\ndestruct v.\nauto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto."},{"statement":"(v w : val) (m : int) (ty : typ) (H : match v with\n| Vint p => match w with\n            | Vint q => iagree p q m\n            | _ => False\n            end\n| _ => True\nend) : match\n  match v with\n  | Vundef => Vundef\n  | Vint _ => match ty with\n              | Tfloat | Tlong | Tsingle => Vundef\n              | _ => v\n              end\n  | Vlong _ => match ty with\n               | Tlong | Tany64 => v\n               | _ => Vundef\n               end\n  | Vfloat _ => match ty with\n                | Tfloat | Tany64 => v\n                | _ => Vundef\n                end\n  | Vsingle _ => match ty with\n                 | Tint | Tfloat | Tlong => Vundef\n                 | _ => v\n                 end\n  | Vptr _ _ =>\n      match ty with\n      | Tlong => if Archi.ptr64 then v else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => v\n      | _ => if Archi.ptr64 then Vundef else v\n      end\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v.\nauto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto."},{"statement":"(w : val) (m : int) (ty : typ) (H : True) : True.","proofString":"auto."},{"statement":"(i : int) (w : val) (m : int) (ty : typ) (H : match w with\n| Vint q => iagree i q m\n| _ => False\nend) : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct w; try contradiction.\ndestruct ty; auto."},{"statement":"(i i0 m : int) (ty : typ) (H : iagree i i0 m) : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vint p =>\n    match\n      match ty with\n      | Tfloat | Tlong | Tsingle => Vundef\n      | _ => Vint i0\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(i : int64) (w : val) (m : int) (ty : typ) (H : True) : match match ty with\n      | Tlong | Tany64 => Vlong i\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(f : float) (w : val) (m : int) (ty : typ) (H : True) : match match ty with\n      | Tfloat | Tany64 => Vfloat f\n      | _ => Vundef\n      end with\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(f : float32) (w : val) (m : int) (ty : typ) (H : True) : match\n  match ty with\n  | Tint | Tfloat | Tlong => Vundef\n  | _ => Vsingle f\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(b : block) (i : ptrofs) (w : val) (m : int) (ty : typ) (H : True) : match\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end\nwith\n| Vint p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vint q => iagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; destruct Archi.ptr64; auto."},{"statement":"(v w : val) (m : int64) (ty : typ) (H : match v with\n| Vlong p => match w with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) : match Val.normalize v ty with\n| Vlong p =>\n    match Val.normalize w ty with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"unfold Val.normalize.\ndestruct v; auto.\ndestruct ty; auto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto."},{"statement":"(v w : val) (m : int64) (ty : typ) (H : match v with\n| Vlong p => match w with\n             | Vlong q => lagree p q m\n             | _ => False\n             end\n| _ => True\nend) : match\n  match v with\n  | Vundef => Vundef\n  | Vint _ => match ty with\n              | Tfloat | Tlong | Tsingle => Vundef\n              | _ => v\n              end\n  | Vlong _ => match ty with\n               | Tlong | Tany64 => v\n               | _ => Vundef\n               end\n  | Vfloat _ => match ty with\n                | Tfloat | Tany64 => v\n                | _ => Vundef\n                end\n  | Vsingle _ => match ty with\n                 | Tint | Tfloat | Tlong => Vundef\n                 | _ => v\n                 end\n  | Vptr _ _ =>\n      match ty with\n      | Tlong => if Archi.ptr64 then v else Vundef\n      | Tfloat | Tsingle => Vundef\n      | Tany64 => v\n      | _ => if Archi.ptr64 then Vundef else v\n      end\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct v; auto.\ndestruct ty; auto.\ndestruct w; try contradiction.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; auto.\ndestruct ty; destruct Archi.ptr64; auto."},{"statement":"(i : int) (w : val) (m : int64) (ty : typ) (H : True) : match\n  match ty with\n  | Tfloat | Tlong | Tsingle => Vundef\n  | _ => Vint i\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(i : int64) (w : val) (m : int64) (ty : typ) (H : match w with\n| Vlong q => lagree i q m\n| _ => False\nend) : match match ty with\n      | Tlong | Tany64 => Vlong i\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct w; try contradiction.\ndestruct ty; auto."},{"statement":"(i i0 m : int64) (ty : typ) (H : lagree i i0 m) : match match ty with\n      | Tlong | Tany64 => Vlong i\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match match ty with\n          | Tlong | Tany64 => Vlong i0\n          | _ => Vundef\n          end with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(f : float) (w : val) (m : int64) (ty : typ) (H : True) : match match ty with\n      | Tfloat | Tany64 => Vfloat f\n      | _ => Vundef\n      end with\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(f : float32) (w : val) (m : int64) (ty : typ) (H : True) : match\n  match ty with\n  | Tint | Tfloat | Tlong => Vundef\n  | _ => Vsingle f\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; auto."},{"statement":"(b : block) (i : ptrofs) (w : val) (m : int64) (ty : typ) (H : True) : match\n  match ty with\n  | Tlong => if Archi.ptr64 then Vptr b i else Vundef\n  | Tfloat | Tsingle => Vundef\n  | Tany64 => Vptr b i\n  | _ => if Archi.ptr64 then Vundef else Vptr b i\n  end\nwith\n| Vlong p =>\n    match\n      match w with\n      | Vundef => Vundef\n      | Vint _ =>\n          match ty with\n          | Tfloat | Tlong | Tsingle => Vundef\n          | _ => w\n          end\n      | Vlong _ => match ty with\n                   | Tlong | Tany64 => w\n                   | _ => Vundef\n                   end\n      | Vfloat _ => match ty with\n                    | Tfloat | Tany64 => w\n                    | _ => Vundef\n                    end\n      | Vsingle _ =>\n          match ty with\n          | Tint | Tfloat | Tlong => Vundef\n          | _ => w\n          end\n      | Vptr _ _ =>\n          match ty with\n          | Tlong => if Archi.ptr64 then w else Vundef\n          | Tfloat | Tsingle => Vundef\n          | Tany64 => w\n          | _ => if Archi.ptr64 then Vundef else w\n          end\n      end\n    with\n    | Vlong q => lagree p q m\n    | _ => False\n    end\n| _ => True\nend.","proofString":"destruct ty; destruct Archi.ptr64; auto."},{"statement":"(v w : val) (ty : typ) (H : Val.lessdef v w) : Val.lessdef (Val.normalize v ty) (Val.normalize w ty).","proofString":"apply Val.normalize_lessdef; auto."},{"statement":"(ob : option bool) (v1 v2 w1 w2 : val) (ty : typ) (x : nval) (H : vagree v1 w1 x) (H0 : vagree v2 w2 x) : vagree\n  match ob with\n  | Some b => Val.normalize (if b then v1 else v2) ty\n  | None => Vundef\n  end\n  match ob with\n  | Some b => Val.normalize (if b then w1 else w2) ty\n  | None => Vundef\n  end x.","proofString":"destruct ob as [b|]; auto with na.\napply normalize_sound.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v2 w1 w2 : val) (ty : typ) (x : nval) (H : vagree v1 w1 x) (H0 : vagree v2 w2 x) : vagree (Val.normalize (if b then v1 else v2) ty)\n  (Val.normalize (if b then w1 else w2) ty) x.","proofString":"apply normalize_sound.\ndestruct b; auto."},{"statement":"(b : bool) (v1 v2 w1 w2 : val) (ty : typ) (x : nval) (H : vagree v1 w1 x) (H0 : vagree v2 w2 x) : vagree (if b then v1 else v2) (if b then w1 else w2) x.","proofString":"destruct b; auto."},{"statement":"(b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H.\nrewrite Ptrofs.add_zero.\nrewrite Mem.valid_pointer_nonempty_perm in *.\neauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) =\ntrue.","proofString":"rewrite Ptrofs.add_zero.\nrewrite Mem.valid_pointer_nonempty_perm in *.\neauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"rewrite Mem.valid_pointer_nonempty_perm in *.\neauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.perm m1 b2 (Ptrofs.unsigned ofs) Cur Nonempty) : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty.","proofString":"eauto."},{"statement":"(b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"inv H.\nrewrite Ptrofs.add_zero.\nrewrite Mem.weak_valid_pointer_spec in *.\nrewrite ! Mem.valid_pointer_nonempty_perm in *.\ndestruct H0; [left|right]; eauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr 0))) = true.","proofString":"rewrite Ptrofs.add_zero.\nrewrite Mem.weak_valid_pointer_spec in *.\nrewrite ! Mem.valid_pointer_nonempty_perm in *.\ndestruct H0; [left|right]; eauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true.","proofString":"rewrite Mem.weak_valid_pointer_spec in *.\nrewrite ! Mem.valid_pointer_nonempty_perm in *.\ndestruct H0; [left|right]; eauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true \\/\nMem.valid_pointer m1 b2 (Ptrofs.unsigned ofs - 1) = true) : Mem.valid_pointer m2 b2 (Ptrofs.unsigned ofs) = true \\/\nMem.valid_pointer m2 b2 (Ptrofs.unsigned ofs - 1) = true.","proofString":"rewrite ! Mem.valid_pointer_nonempty_perm in *.\ndestruct H0; [left|right]; eauto."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.perm m1 b2 (Ptrofs.unsigned ofs) Cur Nonempty \\/\nMem.perm m1 b2 (Ptrofs.unsigned ofs - 1) Cur Nonempty) : Mem.perm m2 b2 (Ptrofs.unsigned ofs) Cur Nonempty \\/\nMem.perm m2 b2 (Ptrofs.unsigned ofs - 1) Cur Nonempty.","proofString":"destruct H0; [left|right]; eauto."},{"statement":"(b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H : Some (b1, 0) = Some (b2, delta)) (H0 : Mem.weak_valid_pointer m1 b1 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"inv H.\nrewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr 0) <=\nPtrofs.max_unsigned.","proofString":"rewrite Z.add_0_r.\napply Ptrofs.unsigned_range_2."},{"statement":"(ofs : ptrofs) (b2 : block) (H0 : Mem.weak_valid_pointer m1 b2 (Ptrofs.unsigned ofs) = true) : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned.","proofString":"apply Ptrofs.unsigned_range_2."},{"statement":"(b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs) (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z) (H : b1 <> b2) (H0 : Mem.valid_pointer m1 b1 (Ptrofs.unsigned ofs1) = true) (H1 : Mem.valid_pointer m1 b2 (Ptrofs.unsigned ofs2) = true) (H2 : Some (b1, 0) = Some (b1', delta1)) (H3 : Some (b2, 0) = Some (b2', delta2)) : b1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"left; congruence."},{"statement":"(cond : condition) (args1 : list val) (b : bool) (args2 : list val) (H : eval_condition cond args1 m1 = Some b) (H0 : vagree_list args1 args2 nil) : eval_condition cond args2 m2 = Some b.","proofString":"apply eval_condition_inj with (f := inject_id) (m1 := m1) (vl1 := args1); auto.\napply val_inject_list_lessdef.\napply lessdef_vagree_list.\nauto."},{"statement":"(cond : condition) (args1 : list val) (b : bool) (args2 : list val) (H : eval_condition cond args1 m1 = Some b) (H0 : vagree_list args1 args2 nil) : Val.inject_list inject_id args1 args2.","proofString":"apply val_inject_list_lessdef.\napply lessdef_vagree_list.\nauto."},{"statement":"(cond : condition) (args1 : list val) (b : bool) (args2 : list val) (H : eval_condition cond args1 m1 = Some b) (H0 : vagree_list args1 args2 nil) : Val.lessdef_list args1 args2.","proofString":"apply lessdef_vagree_list.\nauto."},{"statement":"(cond : condition) (args1 : list val) (b : bool) (args2 : list val) (H : eval_condition cond args1 m1 = Some b) (H0 : vagree_list args1 args2 nil) : vagree_list args1 args2 nil.","proofString":"auto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (default nv :: nil) \\/\nvagree_list args1 args2 (default nv :: default nv :: nil) \\/\nvagree_list args1 args2 (default nv :: default nv :: default nv :: nil)) (H1 : nv <> Nothing) : exists v2 : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2 /\\\n  vagree v1 v2 nv.","proofString":"assert (default nv = All) by (destruct nv; simpl; congruence).\nrewrite H2 in H0.\nassert (Val.lessdef_list args1 args2).\ndestruct H0.\nauto with na.\ndestruct H0.\ninv H0; constructor; auto with na.\ndestruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na.\nexploit (@eval_operation_inj _ _ _ _ ge ge inject_id).\neassumption.\nauto.\nauto.\nauto.\ninstantiate (1 := op).\nintros.\napply val_inject_lessdef; auto.\napply val_inject_lessdef.\ninstantiate (1 := Vptr sp Ptrofs.zero).\ninstantiate (1 := Vptr sp Ptrofs.zero).\nauto.\napply val_inject_list_lessdef; eauto.\neauto.\nintros (v2 & A & B).\nexists v2; split; auto.\napply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (default nv :: nil) \\/\nvagree_list args1 args2 (default nv :: default nv :: nil) \\/\nvagree_list args1 args2 (default nv :: default nv :: default nv :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : exists v2 : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2 /\\\n  vagree v1 v2 nv.","proofString":"rewrite H2 in H0.\nassert (Val.lessdef_list args1 args2).\ndestruct H0.\nauto with na.\ndestruct H0.\ninv H0; constructor; auto with na.\ndestruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na.\nexploit (@eval_operation_inj _ _ _ _ ge ge inject_id).\neassumption.\nauto.\nauto.\nauto.\ninstantiate (1 := op).\nintros.\napply val_inject_lessdef; auto.\napply val_inject_lessdef.\ninstantiate (1 := Vptr sp Ptrofs.zero).\ninstantiate (1 := Vptr sp Ptrofs.zero).\nauto.\napply val_inject_list_lessdef; eauto.\neauto.\nintros (v2 & A & B).\nexists v2; split; auto.\napply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : exists v2 : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2 /\\\n  vagree v1 v2 nv.","proofString":"assert (Val.lessdef_list args1 args2).\ndestruct H0.\nauto with na.\ndestruct H0.\ninv H0; constructor; auto with na.\ndestruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na.\nexploit (@eval_operation_inj _ _ _ _ ge ge inject_id).\neassumption.\nauto.\nauto.\nauto.\ninstantiate (1 := op).\nintros.\napply val_inject_lessdef; auto.\napply val_inject_lessdef.\ninstantiate (1 := Vptr sp Ptrofs.zero).\ninstantiate (1 := Vptr sp Ptrofs.zero).\nauto.\napply val_inject_list_lessdef; eauto.\neauto.\nintros (v2 & A & B).\nexists v2; split; auto.\napply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"destruct H0.\nauto with na.\ndestruct H0.\ninv H0; constructor; auto with na.\ndestruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"destruct H0.\ninv H0; constructor; auto with na.\ndestruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 (All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"inv H0; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"destruct H0.\ninv H0.\nconstructor.\ninv H8; constructor; auto with na.\ninv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 (All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"inv H0.\nconstructor.\ninv H8; constructor; auto with na."},{"statement":"(op : operation) (v1 : val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op nil m1 = Some v1) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list nil nil.","proofString":"constructor."},{"statement":"(op : operation) (v1 : val) (nv : nval) (v0 : val) (vl1 : list val) (H : eval_operation ge (Vptr sp Ptrofs.zero) op (v0 :: vl1) m1 = Some v1) (H1 : nv <> Nothing) (H2 : default nv = All) (v2 : val) (vl2 : list val) (H7 : vagree v0 v2 All) (H8 : vagree_list vl1 vl2 (All :: nil)) : Val.lessdef_list (v0 :: vl1) (v2 :: vl2).","proofString":"inv H8; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) : Val.lessdef_list args1 args2.","proofString":"inv H0; constructor; auto with na.\ninv H8; constructor; auto with na.\ninv H9; constructor; auto with na."},{"statement":"(op : operation) (v1 : val) (nv : nval) (v0 : val) (vl1 : list val) (H : eval_operation ge (Vptr sp Ptrofs.zero) op (v0 :: vl1) m1 = Some v1) (H1 : nv <> Nothing) (H2 : default nv = All) (v2 : val) (vl2 : list val) (H7 : vagree v0 v2 All) (H8 : vagree_list vl1 vl2 (All :: All :: nil)) : Val.lessdef_list vl1 vl2.","proofString":"inv H8; constructor; auto with na.\ninv H9; constructor; auto with na."},{"statement":"(op : operation) (v1 : val) (nv : nval) (v0 v3 : val) (vl0 : list val) (H : eval_operation ge (Vptr sp Ptrofs.zero) op (v0 :: v3 :: vl0) m1 = Some v1) (H1 : nv <> Nothing) (H2 : default nv = All) (v2 : val) (H7 : vagree v0 v2 All) (v4 : val) (vl3 : list val) (H6 : vagree v3 v4 All) (H9 : vagree_list vl0 vl3 (All :: nil)) : Val.lessdef_list vl0 vl3.","proofString":"inv H9; constructor; auto with na."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) : exists v2 : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2 /\\\n  vagree v1 v2 nv.","proofString":"exploit (@eval_operation_inj _ _ _ _ ge ge inject_id).\neassumption.\nauto.\nauto.\nauto.\ninstantiate (1 := op).\nintros.\napply val_inject_lessdef; auto.\napply val_inject_lessdef.\ninstantiate (1 := Vptr sp Ptrofs.zero).\ninstantiate (1 := Vptr sp Ptrofs.zero).\nauto.\napply val_inject_list_lessdef; eauto.\neauto.\nintros (v2 & A & B).\nexists v2; split; auto.\napply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs).","proofString":"intros.\napply val_inject_lessdef; auto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) (id : ident) (ofs : ptrofs) (H4 : In id (globals_operation op)) : Val.inject inject_id (Genv.symbol_address ge id ofs)\n  (Genv.symbol_address ge id ofs).","proofString":"apply val_inject_lessdef; auto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) : Val.lessdef (Vptr sp Ptrofs.zero) (Vptr sp Ptrofs.zero).","proofString":"auto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) (v2 : val) (A : eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2) (B : Val.inject inject_id v1 v2) : exists v0 : val,\n  eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v0 /\\\n  vagree v1 v0 nv.","proofString":"exists v2; split; auto.\napply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) (v2 : val) (A : eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2) (B : Val.inject inject_id v1 v2) : vagree v1 v2 nv.","proofString":"apply vagree_lessdef.\napply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) (v2 : val) (A : eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2) (B : Val.inject inject_id v1 v2) : Val.lessdef v1 v2.","proofString":"apply val_inject_lessdef.\nauto."},{"statement":"(op : operation) (args1 : list val) (v1 : val) (args2 : list val) (nv : nval) (H : eval_operation ge (Vptr sp Ptrofs.zero) op args1 m1 = Some v1) (H0 : vagree_list args1 args2 nil \\/\nvagree_list args1 args2 (All :: nil) \\/\nvagree_list args1 args2 (All :: All :: nil) \\/\nvagree_list args1 args2 (All :: All :: All :: nil)) (H1 : nv <> Nothing) (H2 : default nv = All) (H3 : Val.lessdef_list args1 args2) (v2 : val) (A : eval_operation ge (Vptr sp Ptrofs.zero) op args2 m2 = Some v2) (B : Val.inject inject_id v1 v2) : Val.inject (fun b : block => Some (b, 0)) v1 v2.","proofString":"auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : match x with\n| Nothing => true\n| I m => Int.eq_dec (Int.and m (Int.not n)) Int.zero\n| _ => false\nend = true) (H0 : vagree v w (andimm x n)) : vagree (Val.and v (Vint n)) w x.","proofString":"destruct x; try discriminate.\nsimpl; auto.\nInvBooleans.\nsimpl in *; unfold Val.and; InvAgree.\nred; intros.\nexploit (eq_same_bits i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(v w : val) (n : int) (H : true = true) (H0 : vagree v w (andimm Nothing n)) : vagree (Val.and v (Vint n)) w Nothing.","proofString":"simpl; auto."},{"statement":"(v w : val) (m n : int) (H0 : vagree v w (andimm (I m) n)) (H : Int.and m (Int.not n) = Int.zero) : vagree (Val.and v (Vint n)) w (I m).","proofString":"simpl in *; unfold Val.and; InvAgree.\nred; intros.\nexploit (eq_same_bits i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) : iagree (Int.and i n) i0 m.","proofString":"red; intros.\nexploit (eq_same_bits i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit (Int.and i n) i1 = Int.testbit i0 i1.","proofString":"exploit (eq_same_bits i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit (Int.and m (Int.not n)) i1 = Int.testbit Int.zero i1 ->\nInt.testbit (Int.and i n) i1 = Int.testbit i0 i1.","proofString":"autorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) : Int.testbit m i1 && negb (Int.testbit n i1) = false ->\nInt.testbit i i1 && Int.testbit n i1 = Int.testbit i0 i1.","proofString":"rewrite H2; simpl; intros.\ndestruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (H3 : negb (Int.testbit n i1) = false) : Int.testbit i i1 && Int.testbit n i1 = Int.testbit i0 i1.","proofString":"destruct (Int.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (N : Int.testbit n i1 = true) (H3 : negb true = false) : Int.testbit i i1 && true = Int.testbit i0 i1.","proofString":"rewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (N : Int.testbit n i1 = true) (H3 : negb true = false) : Int.testbit i i1 = Int.testbit i0 i1.","proofString":"apply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (N : Int.testbit n i1 = true) (H3 : negb true = false) : Int.testbit (Int.and m n) i1 = true.","proofString":"autorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m n)) (H : Int.and m (Int.not n) = Int.zero) (i1 : Z) (H1 : 0 <= i1 < Int.zwordsize) (H2 : Int.testbit m i1 = true) (N : Int.testbit n i1 = true) (H3 : negb true = false) : Int.testbit m i1 && Int.testbit n i1 = true.","proofString":"rewrite H2, N; auto."},{"statement":"(v w : val) (x : nval) (n : int) (H : match x with\n| Nothing => true\n| I m => Int.eq_dec (Int.and m n) Int.zero\n| _ => false\nend = true) (H0 : vagree v w (orimm x n)) : vagree (Val.or v (Vint n)) w x.","proofString":"destruct x; try discriminate.\nauto.\nInvBooleans.\nsimpl in *; unfold Val.or; InvAgree.\napply iagree_not'.\nrewrite Int.not_or_and_not.\napply (andimm_redundant_sound (Vint (Int.not i)) (Vint (Int.not i0)) (I m) (Int.not n)).\nsimpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply iagree_not; auto."},{"statement":"(v w : val) (n : int) (H : true = true) (H0 : vagree v w (orimm Nothing n)) : vagree (Val.or v (Vint n)) w Nothing.","proofString":"auto."},{"statement":"(v w : val) (m n : int) (H0 : vagree v w (orimm (I m) n)) (H : Int.and m n = Int.zero) : vagree (Val.or v (Vint n)) w (I m).","proofString":"simpl in *; unfold Val.or; InvAgree.\napply iagree_not'.\nrewrite Int.not_or_and_not.\napply (andimm_redundant_sound (Vint (Int.not i)) (Vint (Int.not i0)) (I m) (Int.not n)).\nsimpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply iagree_not; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : iagree (Int.or i n) i0 m.","proofString":"apply iagree_not'.\nrewrite Int.not_or_and_not.\napply (andimm_redundant_sound (Vint (Int.not i)) (Vint (Int.not i0)) (I m) (Int.not n)).\nsimpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply iagree_not; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : iagree (Int.not (Int.or i n)) (Int.not i0) m.","proofString":"rewrite Int.not_or_and_not.\napply (andimm_redundant_sound (Vint (Int.not i)) (Vint (Int.not i0)) (I m) (Int.not n)).\nsimpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply iagree_not; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : iagree (Int.and (Int.not i) (Int.not n)) (Int.not i0) m.","proofString":"apply (andimm_redundant_sound (Vint (Int.not i)) (Vint (Int.not i0)) (I m) (Int.not n)).\nsimpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply iagree_not; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : andimm_redundant (I m) (Int.not n) = true.","proofString":"simpl.\nrewrite Int.not_involutive.\napply proj_sumbool_is_true.\nauto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : Int.and m n = Int.zero.","proofString":"auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : vagree (Vint (Int.not i)) (Vint (Int.not i0)) (andimm (I m) (Int.not n)).","proofString":"simpl.\napply iagree_not; auto."},{"statement":"(i i0 m n : int) (H0 : iagree i i0 (Int.and m (Int.not n))) (H : Int.and m n = Int.zero) : iagree (Int.not i) (Int.not i0) (Int.and m (Int.not n)).","proofString":"apply iagree_not; auto."},{"statement":"(v w : val) (x : nval) (amount mask : int) (H0 : vagree v w (rolm x amount mask)) (H2 : andimm_redundant x mask = true) (H : amount = Int.zero) : vagree (Val.rolm v amount mask) w x.","proofString":"subst amount.\nrewrite Val.rolm_zero.\napply andimm_redundant_sound; auto.\nassert (forall n, Int.ror n Int.zero = n).\nintros.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero.\nunfold rolm, rol, andimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) : vagree (Val.rolm v Int.zero mask) w x.","proofString":"rewrite Val.rolm_zero.\napply andimm_redundant_sound; auto.\nassert (forall n, Int.ror n Int.zero = n).\nintros.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero.\nunfold rolm, rol, andimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) : vagree (Val.and v (Vint mask)) w x.","proofString":"apply andimm_redundant_sound; auto.\nassert (forall n, Int.ror n Int.zero = n).\nintros.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero.\nunfold rolm, rol, andimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) : vagree v w (andimm x mask).","proofString":"assert (forall n, Int.ror n Int.zero = n).\nintros.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero.\nunfold rolm, rol, andimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) : forall n : int, Int.ror n Int.zero = n.","proofString":"intros.\nrewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) (n : int) : Int.ror n Int.zero = n.","proofString":"rewrite Int.ror_rol_neg by apply int_wordsize_divides_modulus.\nrewrite Int.neg_zero.\napply Int.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) (n : int) : Int.rol n (Int.neg Int.zero) = n.","proofString":"rewrite Int.neg_zero.\napply Int.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) (n : int) : Int.rol n Int.zero = n.","proofString":"apply Int.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w (rolm x Int.zero mask)) (H2 : andimm_redundant x mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (andimm x mask).","proofString":"unfold rolm, rol, andimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int) (H0 : vagree v w\n  match\n    match x with\n    | Nothing => Nothing\n    | I m => I (Int.and m mask)\n    | _ => I mask\n    end\n  with\n  | Nothing => Nothing\n  | I m => I (Int.ror m Int.zero)\n  | _ => All\n  end) (H2 : andimm_redundant x mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w\n  match x with\n  | Nothing => Nothing\n  | I m => I (Int.and m mask)\n  | _ => I mask\n  end.","proofString":"destruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (m mask : int) (H0 : vagree v w (I (Int.ror (Int.and m mask) Int.zero))) (H2 : andimm_redundant (I m) mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I (Int.and m mask)).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (m mask : int) (H0 : vagree v w (I (Int.and m mask))) (H2 : andimm_redundant (I m) mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I (Int.and m mask)).","proofString":"auto."},{"statement":"(v w : val) (m : int64) (mask : int) (H0 : vagree v w (I (Int.ror mask Int.zero))) (H2 : andimm_redundant (L m) mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I mask).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (m : int64) (mask : int) (H0 : vagree v w (I mask)) (H2 : andimm_redundant (L m) mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I mask).","proofString":"auto."},{"statement":"(v w : val) (mask : int) (H0 : vagree v w (I (Int.ror mask Int.zero))) (H2 : andimm_redundant All mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I mask).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (mask : int) (H0 : vagree v w (I mask)) (H2 : andimm_redundant All mask = true) (H : forall n : int, Int.ror n Int.zero = n) : vagree v w (I mask).","proofString":"auto."},{"statement":"(v w : val) (x : nval) (n : Z) (H : match x with\n| Nothing => true\n| I m => Int.eq_dec (Int.zero_ext n m) m\n| _ => false\nend = true) (H0 : vagree v w (zero_ext n x)) (H1 : 0 <= n) : vagree (Val.zero_ext n v) w x.","proofString":"destruct x; try discriminate.\nauto.\nsimpl in *; InvAgree.\nsimpl.\nInvBooleans.\nrewrite <- H.\nred; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(v w : val) (n : Z) (H : true = true) (H0 : vagree v w (zero_ext n Nothing)) (H1 : 0 <= n) : vagree (Val.zero_ext n v) w Nothing.","proofString":"auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) : iagree (Int.zero_ext n i) i0 m.","proofString":"rewrite <- H.\nred; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) : iagree (Int.zero_ext n i) i0 (Int.zero_ext n m).","proofString":"red; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) : (if zlt i1 n then Int.testbit i i1 else false) = Int.testbit i0 i1.","proofString":"destruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (l : i1 < n) : Int.testbit i i1 = Int.testbit i0 i1.","proofString":"apply H0; auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (g : i1 >= n) : false = Int.testbit i0 i1.","proofString":"rewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : (if zlt i1 n then Int.testbit m i1 else false) = true) (g : i1 >= n) : false = Int.testbit i0 i1.","proofString":"rewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.zero_ext n m)) (H1 : 0 <= n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : false = true) (g : i1 >= n) : false = Int.testbit i0 i1.","proofString":"discriminate."},{"statement":"(v w : val) (x : nval) (n : Z) (H : match x with\n| Nothing => true\n| I m => Int.eq_dec (Int.zero_ext n m) m\n| _ => false\nend = true) (H0 : vagree v w (sign_ext n x)) (H1 : 0 < n) : vagree (Val.sign_ext n v) w x.","proofString":"destruct x; try discriminate.\nauto.\nsimpl in *; InvAgree.\nsimpl.\nInvBooleans.\nrewrite <- H.\nred; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_or; auto.\nrewrite H3; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(v w : val) (n : Z) (H : true = true) (H0 : vagree v w (sign_ext n Nothing)) (H1 : 0 < n) : vagree (Val.sign_ext n v) w Nothing.","proofString":"auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) : iagree (Int.sign_ext n i) i0 m.","proofString":"rewrite <- H.\nred; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_or; auto.\nrewrite H3; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) : iagree (Int.sign_ext n i) i0 (Int.zero_ext n m).","proofString":"red; intros; autorewrite with ints; try lia.\ndestruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_or; auto.\nrewrite H3; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) : Int.testbit i (if zlt i1 n then i1 else n - 1) = Int.testbit i0 i1.","proofString":"destruct (zlt i1 n).\napply H0; auto.\nrewrite Int.bits_or; auto.\nrewrite H3; auto.\nrewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (l : i1 < n) : Int.testbit i i1 = Int.testbit i0 i1.","proofString":"apply H0; auto.\nrewrite Int.bits_or; auto.\nrewrite H3; auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (l : i1 < n) : Int.testbit (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))\n  i1 = true.","proofString":"rewrite Int.bits_or; auto.\nrewrite H3; auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (l : i1 < n) : Int.testbit (Int.zero_ext n m) i1\n|| Int.testbit (Int.shl Int.one (Int.repr (n - 1))) i1 = true.","proofString":"rewrite H3; auto."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : Int.testbit (Int.zero_ext n m) i1 = true) (g : i1 >= n) : Int.testbit i (n - 1) = Int.testbit i0 i1.","proofString":"rewrite Int.bits_zero_ext in H3 by lia.\nrewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : (if zlt i1 n then Int.testbit m i1 else false) = true) (g : i1 >= n) : Int.testbit i (n - 1) = Int.testbit i0 i1.","proofString":"rewrite zlt_false in H3 by auto.\ndiscriminate."},{"statement":"(i i0 m : int) (n : Z) (H0 : iagree i i0 (Int.or (Int.zero_ext n m) (Int.shl Int.one (Int.repr (n - 1))))) (H1 : 0 < n) (H : Int.zero_ext n m = m) (i1 : Z) (H2 : 0 <= i1 < Int.zwordsize) (H3 : false = true) (g : i1 >= n) : Int.testbit i (n - 1) = Int.testbit i0 i1.","proofString":"discriminate."},{"statement":"(v w : val) (x : nval) (n : int64) (H : match x with\n| Nothing => true\n| L m => Int64.eq_dec (Int64.and m (Int64.not n)) Int64.zero\n| _ => false\nend = true) (H0 : vagree v w (andlimm x n)) : vagree (Val.andl v (Vlong n)) w x.","proofString":"destruct x; try discriminate.\nsimpl; auto.\nInvBooleans.\nsimpl in *; unfold Val.andl; InvAgree.\nred; intros.\nexploit (eq_same_bits64 i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(v w : val) (n : int64) (H : true = true) (H0 : vagree v w (andlimm Nothing n)) : vagree (Val.andl v (Vlong n)) w Nothing.","proofString":"simpl; auto."},{"statement":"(v w : val) (m n : int64) (H0 : vagree v w (andlimm (L m) n)) (H : Int64.and m (Int64.not n) = Int64.zero) : vagree (Val.andl v (Vlong n)) w (L m).","proofString":"simpl in *; unfold Val.andl; InvAgree.\nred; intros.\nexploit (eq_same_bits64 i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) : lagree (Int64.and i n) i0 m.","proofString":"red; intros.\nexploit (eq_same_bits64 i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) : Int64.testbit (Int64.and i n) i1 = Int64.testbit i0 i1.","proofString":"exploit (eq_same_bits64 i1); eauto.\nautorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) : Int64.testbit (Int64.and m (Int64.not n)) i1 = Int64.testbit Int64.zero i1 ->\nInt64.testbit (Int64.and i n) i1 = Int64.testbit i0 i1.","proofString":"autorewrite with ints; auto.\nrewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) : Int64.testbit m i1 && negb (Int64.testbit n i1) = false ->\nInt64.testbit i i1 && Int64.testbit n i1 = Int64.testbit i0 i1.","proofString":"rewrite H2; simpl; intros.\ndestruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) (H3 : negb (Int64.testbit n i1) = false) : Int64.testbit i i1 && Int64.testbit n i1 = Int64.testbit i0 i1.","proofString":"destruct (Int64.testbit n i1) eqn:N; try discriminate.\nrewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) (N : Int64.testbit n i1 = true) (H3 : negb true = false) : Int64.testbit i i1 && true = Int64.testbit i0 i1.","proofString":"rewrite andb_true_r.\napply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) (N : Int64.testbit n i1 = true) (H3 : negb true = false) : Int64.testbit i i1 = Int64.testbit i0 i1.","proofString":"apply H0; auto.\nautorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) (N : Int64.testbit n i1 = true) (H3 : negb true = false) : Int64.testbit (Int64.and m n) i1 = true.","proofString":"autorewrite with ints; auto.\nrewrite H2, N; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m n)) (H : Int64.and m (Int64.not n) = Int64.zero) (i1 : Z) (H1 : 0 <= i1 < Int64.zwordsize) (H2 : Int64.testbit m i1 = true) (N : Int64.testbit n i1 = true) (H3 : negb true = false) : Int64.testbit m i1 && Int64.testbit n i1 = true.","proofString":"rewrite H2, N; auto."},{"statement":"(v w : val) (x : nval) (n : int64) (H : match x with\n| Nothing => true\n| L m => Int64.eq_dec (Int64.and m n) Int64.zero\n| _ => false\nend = true) (H0 : vagree v w (orlimm x n)) : vagree (Val.orl v (Vlong n)) w x.","proofString":"destruct x; try discriminate.\nauto.\nInvBooleans.\nsimpl in *; unfold Val.orl; InvAgree.\napply lagree_not'.\nrewrite Int64.not_or_and_not.\napply (andlimm_redundant_sound (Vlong (Int64.not i)) (Vlong (Int64.not i0)) (L m) (Int64.not n)).\nsimpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply lagree_not; auto."},{"statement":"(v w : val) (n : int64) (H : true = true) (H0 : vagree v w (orlimm Nothing n)) : vagree (Val.orl v (Vlong n)) w Nothing.","proofString":"auto."},{"statement":"(v w : val) (m n : int64) (H0 : vagree v w (orlimm (L m) n)) (H : Int64.and m n = Int64.zero) : vagree (Val.orl v (Vlong n)) w (L m).","proofString":"simpl in *; unfold Val.orl; InvAgree.\napply lagree_not'.\nrewrite Int64.not_or_and_not.\napply (andlimm_redundant_sound (Vlong (Int64.not i)) (Vlong (Int64.not i0)) (L m) (Int64.not n)).\nsimpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply lagree_not; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : lagree (Int64.or i n) i0 m.","proofString":"apply lagree_not'.\nrewrite Int64.not_or_and_not.\napply (andlimm_redundant_sound (Vlong (Int64.not i)) (Vlong (Int64.not i0)) (L m) (Int64.not n)).\nsimpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply lagree_not; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : lagree (Int64.not (Int64.or i n)) (Int64.not i0) m.","proofString":"rewrite Int64.not_or_and_not.\napply (andlimm_redundant_sound (Vlong (Int64.not i)) (Vlong (Int64.not i0)) (L m) (Int64.not n)).\nsimpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply lagree_not; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : lagree (Int64.and (Int64.not i) (Int64.not n)) (Int64.not i0) m.","proofString":"apply (andlimm_redundant_sound (Vlong (Int64.not i)) (Vlong (Int64.not i0)) (L m) (Int64.not n)).\nsimpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto.\nsimpl.\napply lagree_not; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : andlimm_redundant (L m) (Int64.not n) = true.","proofString":"simpl.\nrewrite Int64.not_involutive.\napply proj_sumbool_is_true.\nauto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : Int64.and m n = Int64.zero.","proofString":"auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : vagree (Vlong (Int64.not i)) (Vlong (Int64.not i0))\n  (andlimm (L m) (Int64.not n)).","proofString":"simpl.\napply lagree_not; auto."},{"statement":"(i i0 m n : int64) (H0 : lagree i i0 (Int64.and m (Int64.not n))) (H : Int64.and m n = Int64.zero) : lagree (Int64.not i) (Int64.not i0) (Int64.and m (Int64.not n)).","proofString":"apply lagree_not; auto."},{"statement":"(v w : val) (x : nval) (amount : int) (mask : int64) (H0 : vagree v w (rolml x amount mask)) (H2 : andlimm_redundant x mask = true) (H : amount = Int.zero) : vagree (Val.rolml v amount mask) w x.","proofString":"subst amount.\nrewrite Val.rolml_zero.\napply andlimm_redundant_sound; auto.\nassert (forall n, Int64.ror n Int64.zero = n).\nintros.\nrewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero.\nunfold rolml, roll, andlimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) : vagree (Val.rolml v Int.zero mask) w x.","proofString":"rewrite Val.rolml_zero.\napply andlimm_redundant_sound; auto.\nassert (forall n, Int64.ror n Int64.zero = n).\nintros.\nrewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero.\nunfold rolml, roll, andlimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) : vagree (Val.andl v (Vlong mask)) w x.","proofString":"apply andlimm_redundant_sound; auto.\nassert (forall n, Int64.ror n Int64.zero = n).\nintros.\nrewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero.\nunfold rolml, roll, andlimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) : vagree v w (andlimm x mask).","proofString":"assert (forall n, Int64.ror n Int64.zero = n).\nintros.\nrewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero.\nunfold rolml, roll, andlimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) : forall n : int64, Int64.ror n Int64.zero = n.","proofString":"intros.\nrewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) (n : int64) : Int64.ror n Int64.zero = n.","proofString":"rewrite Int64.ror_rol_neg by (exists (two_p (64-6)); reflexivity).\nrewrite Int64.neg_zero.\napply Int64.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) (n : int64) : Int64.rol n (Int64.neg Int64.zero) = n.","proofString":"rewrite Int64.neg_zero.\napply Int64.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) (n : int64) : Int64.rol n Int64.zero = n.","proofString":"apply Int64.rol_zero."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w (rolml x Int.zero mask)) (H2 : andlimm_redundant x mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (andlimm x mask).","proofString":"unfold rolml, roll, andlimm in *.\ndestruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (x : nval) (mask : int64) (H0 : vagree v w\n  match\n    match x with\n    | Nothing => Nothing\n    | L m => L (Int64.and m mask)\n    | _ => L mask\n    end\n  with\n  | Nothing => Nothing\n  | L m => L (Int64.ror m (Int64.repr (Int.unsigned Int.zero)))\n  | _ => All\n  end) (H2 : andlimm_redundant x mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w\n  match x with\n  | Nothing => Nothing\n  | L m => L (Int64.and m mask)\n  | _ => L mask\n  end.","proofString":"destruct x; auto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto.\nrewrite H in H0.\nauto."},{"statement":"(v w : val) (m : int) (mask : int64) (H0 : vagree v w (L (Int64.ror mask (Int64.repr (Int.unsigned Int.zero))))) (H2 : andlimm_redundant (I m) mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L mask).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (m : int) (mask : int64) (H0 : vagree v w (L mask)) (H2 : andlimm_redundant (I m) mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L mask).","proofString":"auto."},{"statement":"(v w : val) (m mask : int64) (H0 : vagree v w\n  (L (Int64.ror (Int64.and m mask) (Int64.repr (Int.unsigned Int.zero))))) (H2 : andlimm_redundant (L m) mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L (Int64.and m mask)).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (m mask : int64) (H0 : vagree v w (L (Int64.and m mask))) (H2 : andlimm_redundant (L m) mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L (Int64.and m mask)).","proofString":"auto."},{"statement":"(v w : val) (mask : int64) (H0 : vagree v w (L (Int64.ror mask (Int64.repr (Int.unsigned Int.zero))))) (H2 : andlimm_redundant All mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L mask).","proofString":"rewrite H in H0.\nauto."},{"statement":"(v w : val) (mask : int64) (H0 : vagree v w (L mask)) (H2 : andlimm_redundant All mask = true) (H : forall n : int64, Int64.ror n Int64.zero = n) : vagree v w (L mask).","proofString":"auto."},{"statement":"(x y : t) (H : x = y) : eq x y.","proofString":"auto."},{"statement":"(x y : t) (H : x = y) : nge x y.","proofString":"subst y.\napply nge_refl."},{"statement":"(x : t) : nge x x.","proofString":"apply nge_refl."},{"statement":"(x y z : nval) (H : nge x y) (H0 : nge y z) : nge x z.","proofString":"eapply nge_trans; eauto."},{"statement":"(x : nval) : ge x bot.","proofString":"constructor."},{"statement":"(rs1 rs2 : regset) (ne : nenv) (r : positive) (H : eagree rs1 rs2 ne) : vagree rs1 # r rs2 # r (nreg ne r).","proofString":"apply H."},{"statement":"(e1 e2 : regset) (ne : nenv) (ne' : NE.t) (H : eagree e1 e2 ne) (H0 : NE.ge ne ne') (r : positive) : vagree e1 # r e2 # r (NE.get r ne').","proofString":"apply nge_agree with (NE.get r ne); auto.\napply H0."},{"statement":"(e1 e2 : regset) (ne : nenv) (ne' : NE.t) (H : eagree e1 e2 ne) (H0 : NE.ge ne ne') (r : positive) : nge (NE.get r ne) (NE.get r ne').","proofString":"apply H0."},{"statement":"(e1 e2 : regset) (r : positive) : vagree e1 # r e2 # r (NE.get r NE.bot).","proofString":"rewrite NE.get_bot.\nexact Logic.I."},{"statement":"(e1 e2 : regset) (r : positive) : vagree e1 # r e2 # r NVal.bot.","proofString":"exact Logic.I."},{"statement":"(e : regset) (ne : nenv) (r : positive) : vagree e # r e # r (NE.get r ne).","proofString":"apply vagree_same."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (nv : nval) (r : positive) (H : eagree e1 e2 ne) (H0 : vagree v1 v2 nv) (r0 : positive) : vagree (e1 # r <- v1) # r0 (e2 # r <- v2) # r0 (NE.get r0 (NE.set r nv ne)).","proofString":"rewrite NE.gsspec.\nrewrite ! PMap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (nv : nval) (r : positive) (H : eagree e1 e2 ne) (H0 : vagree v1 v2 nv) (r0 : positive) : vagree (e1 # r <- v1) # r0 (e2 # r <- v2) # r0\n  (if peq r0 r then nv else NE.get r0 ne).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (nv : nval) (r : positive) (H : eagree e1 e2 ne) (H0 : vagree v1 v2 nv) (r0 : positive) : vagree (if peq r0 r then v1 else e1 # r0) (if peq r0 r then v2 else e2 # r0)\n  (if peq r0 r then nv else NE.get r0 ne).","proofString":"destruct (peq r0 r); auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (H0 : eagree e1 e2 (NE.set r Nothing ne)) (r0 : positive) : vagree (e1 # r <- v1) # r0 (e2 # r <- v2) # r0 (NE.get r0 ne).","proofString":"specialize (H0 r0).\nrewrite NE.gsspec in H0.\nrewrite ! PMap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (r0 : positive) (H0 : vagree e1 # r0 e2 # r0 (NE.get r0 (NE.set r Nothing ne))) : vagree (e1 # r <- v1) # r0 (e2 # r <- v2) # r0 (NE.get r0 ne).","proofString":"rewrite NE.gsspec in H0.\nrewrite ! PMap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (r0 : positive) (H0 : vagree e1 # r0 e2 # r0 (if peq r0 r then Nothing else NE.get r0 ne)) : vagree (e1 # r <- v1) # r0 (e2 # r <- v2) # r0 (NE.get r0 ne).","proofString":"rewrite ! PMap.gsspec.\ndestruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (r0 : positive) (H0 : vagree e1 # r0 e2 # r0 (if peq r0 r then Nothing else NE.get r0 ne)) : vagree (if peq r0 r then v1 else e1 # r0) (if peq r0 r then v2 else e2 # r0)\n  (NE.get r0 ne).","proofString":"destruct (peq r0 r).\nsubst r0.\nauto.\nauto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (r0 : positive) (e : r0 = r) (H0 : vagree e1 # r0 e2 # r0 Nothing) : vagree v1 v2 (NE.get r0 ne).","proofString":"subst r0.\nauto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (H0 : vagree e1 # r e2 # r Nothing) : vagree v1 v2 (NE.get r ne).","proofString":"auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 v2 : val) (r : reg) (H : vagree v1 v2 (nreg ne r)) (r0 : positive) (n : r0 <> r) (H0 : vagree e1 # r0 e2 # r0 (NE.get r0 ne)) : vagree e1 # r0 e2 # r0 (NE.get r0 ne).","proofString":"auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : nreg ne r = Nothing) (H0 : eagree e1 e2 ne) (r0 : positive) : vagree (e1 # r <- v1) # r0 e2 # r0 (NE.get r0 ne).","proofString":"rewrite PMap.gsspec.\ndestruct (peq r0 r); auto.\nsubst.\nunfold nreg in H.\nrewrite H.\nred; auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : nreg ne r = Nothing) (H0 : eagree e1 e2 ne) (r0 : positive) : vagree (if peq r0 r then v1 else e1 # r0) e2 # r0 (NE.get r0 ne).","proofString":"destruct (peq r0 r); auto.\nsubst.\nunfold nreg in H.\nrewrite H.\nred; auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : nreg ne r = Nothing) (H0 : eagree e1 e2 ne) (r0 : positive) (e : r0 = r) : vagree v1 e2 # r0 (NE.get r0 ne).","proofString":"subst.\nunfold nreg in H.\nrewrite H.\nred; auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : nreg ne r = Nothing) (H0 : eagree e1 e2 ne) : vagree v1 e2 # r (NE.get r ne).","proofString":"unfold nreg in H.\nrewrite H.\nred; auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : NE.get r ne = Nothing) (H0 : eagree e1 e2 ne) : vagree v1 e2 # r (NE.get r ne).","proofString":"rewrite H.\nred; auto."},{"statement":"(e1 e2 : regset) (ne : nenv) (v1 : val) (r : reg) (H : NE.get r ne = Nothing) (H0 : eagree e1 e2 ne) : vagree v1 e2 # r Nothing.","proofString":"red; auto."},{"statement":"(b : block) (ofs : Z) (H : b = sp) : ~ ISet.In ofs ISet.empty.","proofString":"apply ISet.In_empty."},{"statement":"(b : block) (ofs : Z) (id : ident) (iv : ISet.t) (H : Genv.find_symbol ge id = Some b) (H0 : (PTree.empty ISet.t) ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (nm : nmem) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : nlive (nmem_add nm p sz) b i.","proofString":"unfold nmem_add.\ndestruct nm.\napply nlive_all.\ninv H1; try (apply nlive_all).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:NG.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence.\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence.\nconstructor; simpl; intros.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence.\nconstructor; simpl; intros.\napply ISet.In_empty.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (nm : nmem) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : nlive\n  match nm with\n  | NMemDead => nmem_all\n  | NMem stk gl =>\n      match p with\n      | Gl id ofs0 =>\n          match gl ! id with\n          | Some iv =>\n              NMem stk\n                (PTree.set id\n                   (ISet.remove (Ptrofs.unsigned ofs0)\n                      (Ptrofs.unsigned ofs0 + sz) iv) gl)\n          | None => nm\n          end\n      | Glo id => NMem stk (PTree.remove id gl)\n      | Stk ofs0 =>\n          NMem\n            (ISet.remove (Ptrofs.unsigned ofs0) (Ptrofs.unsigned ofs0 + sz)\n               stk) gl\n      | Stack => NMem ISet.empty gl\n      | _ => nmem_all\n      end\n  end b i.","proofString":"destruct nm.\napply nlive_all.\ninv H1; try (apply nlive_all).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:NG.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence.\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence.\nconstructor; simpl; intros.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence.\nconstructor; simpl; intros.\napply ISet.In_empty.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : nlive nmem_all b i.","proofString":"apply nlive_all."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : nlive\n  match p with\n  | Gl id ofs0 =>\n      match gl ! id with\n      | Some iv =>\n          NMem stk\n            (PTree.set id\n               (ISet.remove (Ptrofs.unsigned ofs0)\n                  (Ptrofs.unsigned ofs0 + sz) iv) gl)\n      | None => NMem stk gl\n      end\n  | Glo id => NMem stk (PTree.remove id gl)\n  | Stk ofs0 =>\n      NMem\n        (ISet.remove (Ptrofs.unsigned ofs0) (Ptrofs.unsigned ofs0 + sz) stk)\n        gl\n  | Stack => NMem ISet.empty gl\n  | _ => nmem_all\n  end b i.","proofString":"inv H1; try (apply nlive_all).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:NG.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence.\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence.\nconstructor; simpl; intros.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence.\nconstructor; simpl; intros.\napply ISet.In_empty.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) : nlive\n  match gl ! id with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n           gl)\n  | None => NMem stk gl\n  end b i.","proofString":"assert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:NG.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) : nlive\n  match gl ! id with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n           gl)\n  | None => NMem stk gl\n  end b i.","proofString":"destruct gl!id as [iv|] eqn:NG.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl))\n  b i.","proofString":"constructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (H4 : b = sp) : ~ ISet.In i stk.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (id0 : ident) (iv0 : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : (PTree.set id\n   (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl)\n! id0 = Some iv0) : ~ ISet.In i iv0.","proofString":"assert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (id0 : ident) (iv0 : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : (PTree.set id\n   (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl)\n! id0 = Some iv0) (H6 : id0 = id) : ~ ISet.In i iv0.","proofString":"subst id0.\nrewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (iv0 : ISet.t) (H5 : (PTree.set id\n   (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl) ! id =\nSome iv0) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i iv0.","proofString":"rewrite PTree.gss in H5.\ninv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (iv0 : ISet.t) (H5 : Some (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) =\nSome iv0) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i iv0.","proofString":"inv H5.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv).","proofString":"rewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (H4 : Genv.find_symbol ge id = Some b) : ~ (~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz /\\ ISet.In i iv).","proofString":"intros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (NG : gl ! id = Some iv) (H4 : Genv.find_symbol ge id = Some b) (A : ~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (B : ISet.In i iv) : False.","proofString":"elim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (NG : gl ! id = None) : nlive (NMem stk gl) b i.","proofString":"constructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (NG : gl ! id = None) (H4 : b = sp) : ~ ISet.In i stk.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (NG : gl ! id = None) (id0 : ident) (iv : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : gl ! id0 = Some iv) : ~ ISet.In i iv.","proofString":"assert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (NG : gl ! id = None) (id0 : ident) (iv : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : gl ! id0 = Some iv) (H6 : id0 = id) : ~ ISet.In i iv.","proofString":"subst id0.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (NG : gl ! id = None) (iv : ISet.t) (H5 : gl ! id = Some iv) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i iv.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) : nlive (NMem stk (PTree.remove id gl)) b i.","proofString":"assert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nconstructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) : nlive (NMem stk (PTree.remove id gl)) b i.","proofString":"constructor; simpl; intros.\ncongruence.\nassert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (H4 : b = sp) : ~ ISet.In i stk.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (id0 : ident) (iv : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : (PTree.remove id gl) ! id0 = Some iv) : ~ ISet.In i iv.","proofString":"assert (id0 = id) by (eapply Genv.genv_vars_inj; eauto).\nsubst id0.\nrewrite PTree.grs in H5.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (id0 : ident) (iv : ISet.t) (H4 : Genv.find_symbol ge id0 = Some b) (H5 : (PTree.remove id gl) ! id0 = Some iv) (H6 : id0 = id) : ~ ISet.In i iv.","proofString":"subst id0.\nrewrite PTree.grs in H5.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (H5 : (PTree.remove id gl) ! id = Some iv) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i iv.","proofString":"rewrite PTree.grs in H5.\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (id : ident) (H3 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (iv : ISet.t) (H5 : None = Some iv) (H4 : Genv.find_symbol ge id = Some b) : ~ ISet.In i iv.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) : nlive\n  (NMem (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) gl)\n  b i.","proofString":"constructor; simpl; intros.\nrewrite ISet.In_remove.\nintros [A B].\nelim A; auto.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (H1 : b = sp) : ~\nISet.In i (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk).","proofString":"rewrite ISet.In_remove.\nintros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (H1 : b = sp) : ~ (~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz /\\ ISet.In i stk).","proofString":"intros [A B].\nelim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (H1 : b = sp) (A : ~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (B : ISet.In i stk) : False.","proofString":"elim A; auto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (id : ident) (iv : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H4 : gl ! id = Some iv) : ~ ISet.In i iv.","proofString":"assert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (id : ident) (iv : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H4 : gl ! id = Some iv) (H5 : bc b = BCglob id) : ~ ISet.In i iv.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) : nlive (NMem ISet.empty gl) b i.","proofString":"constructor; simpl; intros.\napply ISet.In_empty.\nassert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (H1 : b = sp) : ~ ISet.In i ISet.empty.","proofString":"apply ISet.In_empty."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (id : ident) (iv : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H4 : gl ! id = Some iv) : ~ ISet.In i iv.","proofString":"assert (bc b = BCglob id) by (eapply H; eauto).\ncongruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (stk : ISet.t) (gl : PTree.t ISet.t) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (H3 : bc b = BCstack) (id : ident) (iv : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H4 : gl ! id = Some iv) (H5 : bc b = BCglob id) : ~ ISet.In i iv.","proofString":"congruence."},{"statement":"(nm : nmem) (b : block) (i : Z) (p : aptr) (sz : Z) (H : nlive nm b i) : nlive (nmem_add nm p sz) b i.","proofString":"inversion H; subst.\nunfold nmem_add; destruct p; try (apply nlive_all).\ndestruct gl!id as [iv|] eqn:NG.\nsplit; simpl; intros.\nauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto.\nauto.\nsplit; simpl; intros.\nauto.\nrewrite PTree.grspec in H1.\ndestruct (PTree.elt_eq id0 id).\ncongruence.\neauto.\nsplit; simpl; intros.\nrewrite ISet.In_remove.\nintros [P Q].\neelim STK; eauto.\neauto.\nsplit; simpl; intros.\napply ISet.In_empty.\neauto."},{"statement":"(b : block) (i : Z) (p : aptr) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (nmem_add (NMem stk gl) p sz) b i.","proofString":"unfold nmem_add; destruct p; try (apply nlive_all).\ndestruct gl!id as [iv|] eqn:NG.\nsplit; simpl; intros.\nauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto.\nauto.\nsplit; simpl; intros.\nauto.\nrewrite PTree.grspec in H1.\ndestruct (PTree.elt_eq id0 id).\ncongruence.\neauto.\nsplit; simpl; intros.\nrewrite ISet.In_remove.\nintros [P Q].\neelim STK; eauto.\neauto.\nsplit; simpl; intros.\napply ISet.In_empty.\neauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) : nlive\n  match gl ! id with\n  | Some iv =>\n      NMem stk\n        (PTree.set id\n           (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n           gl)\n  | None => NMem stk gl\n  end b i.","proofString":"destruct gl!id as [iv|] eqn:NG.\nsplit; simpl; intros.\nauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto.\nauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (iv : ISet.t) (NG : gl ! id = Some iv) : nlive\n  (NMem stk\n     (PTree.set id\n        (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl))\n  b i.","proofString":"split; simpl; intros.\nauto.\nrewrite PTree.gsspec in H1.\ndestruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (iv : ISet.t) (NG : gl ! id = Some iv) (H0 : b = sp) : ~ ISet.In i stk.","proofString":"auto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv1 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv1 -> ~ ISet.In i iv1) (iv : ISet.t) (NG : gl ! id = Some iv) (id0 : ident) (iv0 : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (H1 : (PTree.set id\n   (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) gl)\n! id0 = Some iv0) : ~ ISet.In i iv0.","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv1 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv1 -> ~ ISet.In i iv1) (iv : ISet.t) (NG : gl ! id = Some iv) (id0 : ident) (iv0 : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (H1 : (if peq id0 id\n then Some (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n else gl ! id0) = Some iv0) : ~ ISet.In i iv0.","proofString":"destruct (peq id0 id); eauto.\ninv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv1 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv1 -> ~ ISet.In i iv1) (iv : ISet.t) (NG : gl ! id = Some iv) (id0 : ident) (iv0 : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (e : id0 = id) (H1 : Some (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) =\nSome iv0) : ~ ISet.In i iv0.","proofString":"inv H1.\nrewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (iv : ISet.t) (NG : gl ! id = Some iv) (H0 : Genv.find_symbol ge id = Some b) : ~ ISet.In i (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv).","proofString":"rewrite ISet.In_remove.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (iv : ISet.t) (NG : gl ! id = Some iv) (H0 : Genv.find_symbol ge id = Some b) : ~ (~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz /\\ ISet.In i iv).","proofString":"intros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (iv : ISet.t) (NG : gl ! id = Some iv) (H0 : Genv.find_symbol ge id = Some b) (P : ~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (Q : ISet.In i iv) : False.","proofString":"eelim GL; eauto."},{"statement":"(b : block) (i : Z) (id : ident) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (NG : gl ! id = None) : nlive (NMem stk gl) b i.","proofString":"auto."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) : nlive (NMem stk (PTree.remove id gl)) b i.","proofString":"split; simpl; intros.\nauto.\nrewrite PTree.grspec in H1.\ndestruct (PTree.elt_eq id0 id).\ncongruence.\neauto."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ ISet.In i stk.","proofString":"auto."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv0 -> ~ ISet.In i iv0) (id0 : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (H1 : (PTree.remove id gl) ! id0 = Some iv) : ~ ISet.In i iv.","proofString":"rewrite PTree.grspec in H1.\ndestruct (PTree.elt_eq id0 id).\ncongruence.\neauto."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv0 -> ~ ISet.In i iv0) (id0 : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (H1 : (if PTree.elt_eq id0 id then None else gl ! id0) = Some iv) : ~ ISet.In i iv.","proofString":"destruct (PTree.elt_eq id0 id).\ncongruence.\neauto."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv0 -> ~ ISet.In i iv0) (id0 : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (e : id0 = id) (H1 : None = Some iv) : ~ ISet.In i iv.","proofString":"congruence."},{"statement":"(b : block) (i : Z) (id : ident) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id1 = Some b -> gl ! id1 = Some iv0 -> ~ ISet.In i iv0) (id0 : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id0 = Some b) (n : id0 <> id) (H1 : gl ! id0 = Some iv) : ~ ISet.In i iv.","proofString":"eauto."},{"statement":"(b : block) (i : Z) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive\n  (NMem (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) gl)\n  b i.","proofString":"split; simpl; intros.\nrewrite ISet.In_remove.\nintros [P Q].\neelim STK; eauto.\neauto."},{"statement":"(b : block) (i : Z) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~\nISet.In i (ISet.remove (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk).","proofString":"rewrite ISet.In_remove.\nintros [P Q].\neelim STK; eauto."},{"statement":"(b : block) (i : Z) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ (~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz /\\ ISet.In i stk).","proofString":"intros [P Q].\neelim STK; eauto."},{"statement":"(b : block) (i : Z) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) (P : ~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (Q : ISet.In i stk) : False.","proofString":"eelim STK; eauto."},{"statement":"(b : block) (i : Z) (ofs : ptrofs) (sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : gl ! id = Some iv) : ~ ISet.In i iv.","proofString":"eauto."},{"statement":"(b : block) (i sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (NMem ISet.empty gl) b i.","proofString":"split; simpl; intros.\napply ISet.In_empty.\neauto."},{"statement":"(b : block) (i sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ ISet.In i ISet.empty.","proofString":"apply ISet.In_empty."},{"statement":"(b : block) (i sz : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : gl ! id = Some iv) : ~ ISet.In i iv.","proofString":"eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (nm : nmem) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : nlive nm b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) : nlive (nmem_remove nm p sz) b' i.","proofString":"inversion H2; subst.\nunfold nmem_remove; inv H1; auto.\nset (iv' := match gl!id with                  | Some iv =>                      ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv                  | None =>                      ISet.interval (Ptrofs.unsigned ofs)                        (Ptrofs.unsigned ofs + sz)              end).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\ndestruct H3.\ncongruence.\ndestruct gl!id as [iv0|] eqn:NG.\nunfold iv'; rewrite ISet.In_add.\nintros [P|P].\nlia.\neelim GL; eauto.\nunfold iv'; rewrite ISet.In_interval.\nlia.\neauto.\nsplit; simpl; auto; intros.\ndestruct H3.\nelim H3.\nsubst b'.\neapply bc_stack; eauto.\nrewrite ISet.In_add.\nintros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (nmem_remove (NMem stk gl) p sz) b' i.","proofString":"unfold nmem_remove; inv H1; auto.\nset (iv' := match gl!id with                  | Some iv =>                      ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv                  | None =>                      ISet.interval (Ptrofs.unsigned ofs)                        (Ptrofs.unsigned ofs + sz)              end).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\ndestruct H3.\ncongruence.\ndestruct gl!id as [iv0|] eqn:NG.\nunfold iv'; rewrite ISet.In_add.\nintros [P|P].\nlia.\neelim GL; eauto.\nunfold iv'; rewrite ISet.In_interval.\nlia.\neauto.\nsplit; simpl; auto; intros.\ndestruct H3.\nelim H3.\nsubst b'.\neapply bc_stack; eauto.\nrewrite ISet.In_add.\nintros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) : nlive\n  (NMem stk\n     (PTree.set id\n        match gl ! id with\n        | Some iv =>\n            ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv\n        | None =>\n            ISet.interval (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz)\n        end gl)) b' i.","proofString":"set (iv' := match gl!id with                  | Some iv =>                      ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv                  | None =>                      ISet.interval (Ptrofs.unsigned ofs)                        (Ptrofs.unsigned ofs + sz)              end).\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\nsplit; simpl; auto; intros.\nrewrite PTree.gsspec in H6.\ndestruct (peq id0 id).\ninv H6.\ndestruct H3.\ncongruence.\ndestruct gl!id as [iv0|] eqn:NG.\nunfold iv'; rewrite ISet.In_add.\nintros [P|P].\nlia.\neelim GL; eauto.\nunfold iv'; rewrite ISet.In_interval.\nlia.\neauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H5 : Genv.find_symbol ge id = Some b') : ~ ISet.In i iv'.","proofString":"congruence."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) (iv0 : ISet.t) (NG : gl ! id = Some iv0) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H5 : Genv.find_symbol ge id = Some b') : ~ (Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz \\/ ISet.In i iv0).","proofString":"intros [P|P].\nlia.\neelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) (iv0 : ISet.t) (NG : gl ! id = Some iv0) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H5 : Genv.find_symbol ge id = Some b') (P : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : False.","proofString":"lia."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) (iv0 : ISet.t) (NG : gl ! id = Some iv0) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H5 : Genv.find_symbol ge id = Some b') (P : ISet.In i iv0) : False.","proofString":"eelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b' -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H4 : bc b = BCglob id) (NG : gl ! id = None) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (H5 : Genv.find_symbol ge id = Some b') : ~ Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz.","proofString":"lia."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id1 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id1 = Some b' -> gl ! id1 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (H4 : bc b = BCglob id) (iv' : ISet.t) (H1 : Genv.find_symbol ge id = Some b) (id0 : ident) (iv : ISet.t) (H5 : Genv.find_symbol ge id0 = Some b') (n : id0 <> id) (H6 : gl ! id0 = Some iv) : ~ ISet.In i iv.","proofString":"eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) : nlive\n  (NMem (ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) gl)\n  b' i.","proofString":"split; simpl; auto; intros.\ndestruct H3.\nelim H3.\nsubst b'.\neapply bc_stack; eauto.\nrewrite ISet.In_add.\nintros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b \\/ i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) : ~ ISet.In i (ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk).","proofString":"destruct H3.\nelim H3.\nsubst b'.\neapply bc_stack; eauto.\nrewrite ISet.In_add.\nintros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) : ~ ISet.In i (ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk).","proofString":"elim H3.\nsubst b'.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : b' <> b) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) : b' = b.","proofString":"subst b'.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some sp -> gl ! id = Some iv -> ~ ISet.In i iv) (STK : sp = sp -> ~ ISet.In i stk) (H3 : sp <> b) (H2 : nlive (NMem stk gl) sp i) (H4 : bc b = BCstack) : sp = b.","proofString":"eapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) : ~ ISet.In i (ISet.add (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk).","proofString":"rewrite ISet.In_add.\nintros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) : ~ (Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz \\/ ISet.In i stk).","proofString":"intros [P|P].\nlia.\neapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) (P : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : False.","proofString":"lia."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz : Z) (b' : block) (i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : nlive (NMem stk gl) b' i) (H3 : i < Ptrofs.unsigned ofs \\/ Ptrofs.unsigned ofs + sz <= i) (STK : b' = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b' -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) (H1 : b' = sp) (P : ISet.In i stk) : False.","proofString":"eapply STK; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (nm : nmem) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (H2 : match nm with\n| NMemDead => false\n| NMem stk gl =>\n    match p with\n    | Gl id ofs0 =>\n        match gl ! id with\n        | Some iv =>\n            negb\n              (ISet.contains (Ptrofs.unsigned ofs0)\n                 (Ptrofs.unsigned ofs0 + sz) iv)\n        | None => true\n        end\n    | Stk ofs0 =>\n        negb\n          (ISet.contains (Ptrofs.unsigned ofs0) (Ptrofs.unsigned ofs0 + sz)\n             stk)\n    | _ => true\n    end\nend = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) : ~ nlive nm b i.","proofString":"red; intros L; inv L.\ninv H1; try discriminate.\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:HG; inv H2.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim GL; eauto.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim STK; eauto.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (p : aptr) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (H1 : pmatch bc b ofs p) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : match p with\n| Gl id ofs0 =>\n    match gl ! id with\n    | Some iv =>\n        negb\n          (ISet.contains (Ptrofs.unsigned ofs0) (Ptrofs.unsigned ofs0 + sz)\n             iv)\n    | None => true\n    end\n| Stk ofs0 =>\n    negb\n      (ISet.contains (Ptrofs.unsigned ofs0) (Ptrofs.unsigned ofs0 + sz) stk)\n| _ => true\nend = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : False.","proofString":"inv H1; try discriminate.\nassert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:HG; inv H2.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim GL; eauto.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim STK; eauto.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (id : ident) (H2 : match gl ! id with\n| Some iv =>\n    negb (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n| None => true\nend = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCglob id) : False.","proofString":"assert (Genv.find_symbol ge id = Some b) by (eapply H; eauto).\ndestruct gl!id as [iv|] eqn:HG; inv H2.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (id : ident) (H2 : match gl ! id with\n| Some iv =>\n    negb (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv)\n| None => true\nend = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) : False.","proofString":"destruct gl!id as [iv|] eqn:HG; inv H2.\ndestruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (id : ident) (iv : ISet.t) (HG : gl ! id = Some iv) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (H4 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (H6 : negb (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) =\nfalse) : False.","proofString":"destruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (id : ident) (iv : ISet.t) (HG : gl ! id = Some iv) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (H4 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (IC : ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) iv = true) (H6 : negb true = false) : False.","proofString":"rewrite ISet.contains_spec in IC.\neelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (id : ident) (iv : ISet.t) (HG : gl ! id = Some iv) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (H4 : bc b = BCglob id) (H1 : Genv.find_symbol ge id = Some b) (IC : forall x : Z,\nPtrofs.unsigned ofs <= x < Ptrofs.unsigned ofs + sz -> ISet.In x iv) (H6 : negb true = false) : False.","proofString":"eelim GL; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (H2 : negb (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) =\nfalse) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) : False.","proofString":"destruct (ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk) eqn:IC; try discriminate.\nrewrite ISet.contains_spec in IC.\neelim STK; eauto.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (IC : ISet.contains (Ptrofs.unsigned ofs) (Ptrofs.unsigned ofs + sz) stk = true) (H2 : negb true = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) : False.","proofString":"rewrite ISet.contains_spec in IC.\neelim STK; eauto.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (IC : forall x : Z,\nPtrofs.unsigned ofs <= x < Ptrofs.unsigned ofs + sz -> ISet.In x stk) (H2 : negb true = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) : False.","proofString":"eelim STK; eauto.\neapply bc_stack; eauto."},{"statement":"(bc : block_classification) (b : block) (ofs : ptrofs) (sz i : Z) (H : genv_match bc ge) (H0 : bc sp = BCstack) (stk : ISet.t) (gl : PTree.tree ISet.t) (IC : forall x : Z,\nPtrofs.unsigned ofs <= x < Ptrofs.unsigned ofs + sz -> ISet.In x stk) (H2 : negb true = false) (H3 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + sz) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H4 : bc b = BCstack) : b = sp.","proofString":"eapply bc_stack; eauto."},{"statement":"(sz : Z) (b' : block) (i : Z) (H : b' <> sp \\/ ~ 0 <= i < sz) (H0 : b' = sp) : ~ ISet.In i (ISet.interval 0 sz).","proofString":"rewrite ISet.In_interval.\nintuition."},{"statement":"(sz : Z) (b' : block) (i : Z) (H : b' <> sp \\/ ~ 0 <= i < sz) (H0 : b' = sp) : ~ 0 <= i < sz.","proofString":"intuition."},{"statement":"(sz : Z) (b' : block) (i : Z) (H : b' <> sp \\/ ~ 0 <= i < sz) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b') (H1 : (PTree.empty ISet.t) ! id = Some iv) : ~ ISet.In i iv.","proofString":"rewrite PTree.gempty in H1; discriminate."},{"statement":"(nm1 nm2 : nmem) (b : block) (i : Z) (H : nlive nm1 b i) : nlive (nmem_lub nm1 nm2) b i.","proofString":"inversion H; subst.\ndestruct nm2; simpl.\nauto.\nconstructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl!id as [iv1|] eqn:NG1; try discriminate;  destruct gl0!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(nm2 : nmem) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (nmem_lub (NMem stk gl) nm2) b i.","proofString":"destruct nm2; simpl.\nauto.\nconstructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl!id as [iv1|] eqn:NG1; try discriminate;  destruct gl0!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (NMem stk gl) b i.","proofString":"auto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive\n  (NMem (ISet.inter stk stk0)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl gl0)) b i.","proofString":"constructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl!id as [iv1|] eqn:NG1; try discriminate;  destruct gl0!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ ISet.In i (ISet.inter stk stk0).","proofString":"rewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ (ISet.In i stk /\\ ISet.In i stk0).","proofString":"intros [P Q].\neelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) (P : ISet.In i stk) (Q : ISet.In i stk0) : False.","proofString":"eelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : (PTree.combine\n   (fun o1 o2 : option ISet.t =>\n    match o1 with\n    | Some iv1 =>\n        match o2 with\n        | Some iv2 => Some (ISet.inter iv1 iv2)\n        | None => None\n        end\n    | None => None\n    end) gl gl0) ! id = Some iv) : ~ ISet.In i iv.","proofString":"rewrite PTree.gcombine in H1 by auto.\ndestruct gl!id as [iv1|] eqn:NG1; try discriminate;  destruct gl0!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : match gl ! id with\n| Some iv1 =>\n    match gl0 ! id with\n    | Some iv2 => Some (ISet.inter iv1 iv2)\n    | None => None\n    end\n| None => None\nend = Some iv) : ~ ISet.In i iv.","proofString":"destruct gl!id as [iv1|] eqn:NG1; try discriminate;  destruct gl0!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl0 ! id = Some iv2) : ~ ISet.In i (ISet.inter iv1 iv2).","proofString":"rewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl0 ! id = Some iv2) : ~ (ISet.In i iv1 /\\ ISet.In i iv2).","proofString":"intros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl0 ! id = Some iv2) (P : ISet.In i iv1) (Q : ISet.In i iv2) : False.","proofString":"eelim GL; eauto."},{"statement":"(nm1 nm2 : nmem) (b : block) (i : Z) (H : nlive nm2 b i) : nlive (nmem_lub nm1 nm2) b i.","proofString":"inversion H; subst.\ndestruct nm1; simpl.\nauto.\nconstructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl0!id as [iv1|] eqn:NG1; try discriminate;  destruct gl!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(nm1 : nmem) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (nmem_lub nm1 (NMem stk gl)) b i.","proofString":"destruct nm1; simpl.\nauto.\nconstructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl0!id as [iv1|] eqn:NG1; try discriminate;  destruct gl!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive (NMem stk gl) b i.","proofString":"auto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) : nlive\n  (NMem (ISet.inter stk0 stk)\n     (PTree.combine\n        (fun o1 o2 : option ISet.t =>\n         match o1 with\n         | Some iv1 =>\n             match o2 with\n             | Some iv2 => Some (ISet.inter iv1 iv2)\n             | None => None\n             end\n         | None => None\n         end) gl0 gl)) b i.","proofString":"constructor; simpl; intros.\nrewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto.\nrewrite PTree.gcombine in H1 by auto.\ndestruct gl0!id as [iv1|] eqn:NG1; try discriminate;  destruct gl!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ ISet.In i (ISet.inter stk0 stk).","proofString":"rewrite ISet.In_inter.\nintros [P Q].\neelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) : ~ (ISet.In i stk0 /\\ ISet.In i stk).","proofString":"intros [P Q].\neelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl ! id = Some iv -> ~ ISet.In i iv) (H0 : b = sp) (P : ISet.In i stk0) (Q : ISet.In i stk) : False.","proofString":"eelim STK; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : (PTree.combine\n   (fun o1 o2 : option ISet.t =>\n    match o1 with\n    | Some iv1 =>\n        match o2 with\n        | Some iv2 => Some (ISet.inter iv1 iv2)\n        | None => None\n        end\n    | None => None\n    end) gl0 gl) ! id = Some iv) : ~ ISet.In i iv.","proofString":"rewrite PTree.gcombine in H1 by auto.\ndestruct gl0!id as [iv1|] eqn:NG1; try discriminate;  destruct gl!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv0 -> ~ ISet.In i iv0) (id : ident) (iv : ISet.t) (H0 : Genv.find_symbol ge id = Some b) (H1 : match gl0 ! id with\n| Some iv1 =>\n    match gl ! id with\n    | Some iv2 => Some (ISet.inter iv1 iv2)\n    | None => None\n    end\n| None => None\nend = Some iv) : ~ ISet.In i iv.","proofString":"destruct gl0!id as [iv1|] eqn:NG1; try discriminate;  destruct gl!id as [iv2|] eqn:NG2; inv H1.\nrewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl0 ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl ! id = Some iv2) : ~ ISet.In i (ISet.inter iv1 iv2).","proofString":"rewrite ISet.In_inter.\nintros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl0 ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl ! id = Some iv2) : ~ (ISet.In i iv1 /\\ ISet.In i iv2).","proofString":"intros [P Q].\neelim GL; eauto."},{"statement":"(stk0 : ISet.t) (gl0 : PTree.t ISet.t) (b : block) (i : Z) (stk : ISet.t) (gl : PTree.tree ISet.t) (H : nlive (NMem stk gl) b i) (STK : b = sp -> ~ ISet.In i stk) (GL : forall (id0 : ident) (iv : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl ! id0 = Some iv -> ~ ISet.In i iv) (id : ident) (H0 : Genv.find_symbol ge id = Some b) (iv1 : ISet.t) (NG1 : gl0 ! id = Some iv1) (iv2 : ISet.t) (NG2 : gl ! id = Some iv2) (P : ISet.In i iv1) (Q : ISet.In i iv2) : False.","proofString":"eelim GL; eauto."},{"statement":"(nm1 nm2 : nmem) (b : block) (ofs : Z) (H : match nm1 with\n| NMemDead => match nm2 with\n              | NMemDead => true\n              | NMem _ _ => false\n              end\n| NMem stk1 gl1 =>\n    match nm2 with\n    | NMemDead => false\n    | NMem stk2 gl2 => ISet.beq stk1 stk2 && PTree.beq ISet.beq gl1 gl2\n    end\nend = true) : nlive nm1 b ofs <-> nlive nm2 b ofs.","proofString":"destruct nm1 as [ | stk1 gl1]; destruct nm2 as [ | stk2 gl2]; try discriminate.\nsplit; intros L; inv L.\nInvBooleans.\nrewrite ISet.beq_spec in H0.\nrewrite PTree.beq_correct in H1.\nsplit; intros L; inv L; constructor; intros.\nrewrite <- H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto.\nrewrite H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(b : block) (ofs : Z) (H : true = true) : nlive NMemDead b ofs <-> nlive NMemDead b ofs.","proofString":"split; intros L; inv L."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H : ISet.beq stk1 stk2 && PTree.beq ISet.beq gl1 gl2 = true) : nlive (NMem stk1 gl1) b ofs <-> nlive (NMem stk2 gl2) b ofs.","proofString":"InvBooleans.\nrewrite ISet.beq_spec in H0.\nrewrite PTree.beq_correct in H1.\nsplit; intros L; inv L; constructor; intros.\nrewrite <- H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto.\nrewrite H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : ISet.beq stk1 stk2 = true) (H1 : PTree.beq ISet.beq gl1 gl2 = true) : nlive (NMem stk1 gl1) b ofs <-> nlive (NMem stk2 gl2) b ofs.","proofString":"rewrite ISet.beq_spec in H0.\nrewrite PTree.beq_correct in H1.\nsplit; intros L; inv L; constructor; intros.\nrewrite <- H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto.\nrewrite H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : PTree.beq ISet.beq gl1 gl2 = true) : nlive (NMem stk1 gl1) b ofs <-> nlive (NMem stk2 gl2) b ofs.","proofString":"rewrite PTree.beq_correct in H1.\nsplit; intros L; inv L; constructor; intros.\nrewrite <- H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto.\nrewrite H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) : nlive (NMem stk1 gl1) b ofs <-> nlive (NMem stk2 gl2) b ofs.","proofString":"split; intros L; inv L; constructor; intros.\nrewrite <- H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto.\nrewrite H0.\neauto.\nspecialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl1 ! id = Some iv -> ~ ISet.In ofs iv) (H : b = sp) : ~ ISet.In ofs stk2.","proofString":"rewrite <- H0.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl1 ! id = Some iv -> ~ ISet.In ofs iv) (H : b = sp) : ~ ISet.In ofs stk1.","proofString":"eauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (id : ident) (iv : ISet.t) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"specialize (H1 id).\nrewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (H1 : match gl1 ! id with\n| Some y1 =>\n    match gl2 ! id with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (iv : ISet.t) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite H2 in H1.\ndestruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv : ISet.t) (H1 : match gl1 ! id with\n| Some y1 => ISet.beq y1 iv = true\n| None => False\nend) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"destruct gl1!id as [iv1|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv1 : ISet.t) (NG : gl1 ! id = Some iv1) (H1 : ISet.beq iv1 iv = true) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite ISet.beq_spec in H1.\nrewrite <- H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv1 : ISet.t) (NG : gl1 ! id = Some iv1) (H1 : forall x : Z, ISet.In x iv1 <-> ISet.In x iv) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite <- H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv1 : ISet.t) (NG : gl1 ! id = Some iv1) (H1 : forall x : Z, ISet.In x iv1 <-> ISet.In x iv) (STK : b = sp -> ~ ISet.In ofs stk1) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl1 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl2 ! id = Some iv) : ~ ISet.In ofs iv1.","proofString":"eauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl2 ! id = Some iv -> ~ ISet.In ofs iv) (H : b = sp) : ~ ISet.In ofs stk1.","proofString":"rewrite H0.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id : ident) (iv : ISet.t),\nGenv.find_symbol ge id = Some b -> gl2 ! id = Some iv -> ~ ISet.In ofs iv) (H : b = sp) : ~ ISet.In ofs stk2.","proofString":"eauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (H1 : forall x : PTree.elt,\nmatch gl1 ! x with\n| Some y1 =>\n    match gl2 ! x with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! x with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (id : ident) (iv : ISet.t) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"specialize (H1 id).\nrewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (H1 : match gl1 ! id with\n| Some y1 =>\n    match gl2 ! id with\n    | Some y2 => ISet.beq y1 y2 = true\n    | None => False\n    end\n| None => match gl2 ! id with\n          | Some _ => False\n          | None => True\n          end\nend) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (iv : ISet.t) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite H2 in H1.\ndestruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv : ISet.t) (H1 : match gl2 ! id with\n| Some y2 => ISet.beq iv y2 = true\n| None => False\nend) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"destruct gl2!id as [iv2|] eqn: NG; try contradiction.\nrewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv2 : ISet.t) (NG : gl2 ! id = Some iv2) (H1 : ISet.beq iv iv2 = true) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite ISet.beq_spec in H1.\nrewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv2 : ISet.t) (NG : gl2 ! id = Some iv2) (H1 : forall x : Z, ISet.In x iv <-> ISet.In x iv2) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv.","proofString":"rewrite H1.\neauto."},{"statement":"(stk1 : ISet.t) (gl1 : PTree.t ISet.t) (stk2 : ISet.t) (gl2 : PTree.t ISet.t) (b : block) (ofs : Z) (H0 : forall x : Z, ISet.In x stk1 <-> ISet.In x stk2) (id : ident) (iv iv2 : ISet.t) (NG : gl2 ! id = Some iv2) (H1 : forall x : Z, ISet.In x iv <-> ISet.In x iv2) (STK : b = sp -> ~ ISet.In ofs stk2) (GL : forall (id0 : ident) (iv0 : ISet.t),\nGenv.find_symbol ge id0 = Some b -> gl2 ! id0 = Some iv0 -> ~ ISet.In ofs iv0) (H : Genv.find_symbol ge id = Some b) (H2 : gl1 ! id = Some iv) : ~ ISet.In ofs iv2.","proofString":"eauto."},{"statement":"(n : nenv) (n0 : nmem) : NE.eq n n.","proofString":"apply NE.eq_refl."},{"statement":"(n : nenv) (n0 : nmem) : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n0 b ofs.","proofString":"tauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : NE.eq n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) ->\nNE.eq n1 n /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n2 b ofs <-> nlive ge sp n0 b ofs).","proofString":"intros [A B].\nsplit.\napply NE.eq_sym; auto.\nintros.\nrewrite B.\ntauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) : NE.eq n1 n /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n2 b ofs <-> nlive ge sp n0 b ofs).","proofString":"split.\napply NE.eq_sym; auto.\nintros.\nrewrite B.\ntauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) : NE.eq n1 n.","proofString":"apply NE.eq_sym; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n2 b ofs <-> nlive ge sp n0 b ofs.","proofString":"intros.\nrewrite B.\ntauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge0 : genv) (sp0 b0 : block) (ofs0 : Z),\nnlive ge0 sp0 n0 b0 ofs0 <-> nlive ge0 sp0 n2 b0 ofs0) (ge : genv) (sp b : block) (ofs : Z) : nlive ge sp n2 b ofs <-> nlive ge sp n0 b ofs.","proofString":"rewrite B.\ntauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge0 : genv) (sp0 b0 : block) (ofs0 : Z),\nnlive ge0 sp0 n0 b0 ofs0 <-> nlive ge0 sp0 n2 b0 ofs0) (ge : genv) (sp b : block) (ofs : Z) : nlive ge sp n2 b ofs <-> nlive ge sp n2 b ofs.","proofString":"tauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) : NE.eq n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) ->\nNE.eq n1 n3 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n2 b ofs <-> nlive ge sp n4 b ofs) ->\nNE.eq n n3 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n4 b ofs).","proofString":"intros [A B] [C D]; split.\neapply NE.eq_trans; eauto.\nintros.\nrewrite B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) (A : NE.eq n n1) (B : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) (C : NE.eq n1 n3) (D : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n2 b ofs <-> nlive ge sp n4 b ofs) : NE.eq n n3.","proofString":"eapply NE.eq_trans; eauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) (A : NE.eq n n1) (B : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) (C : NE.eq n1 n3) (D : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n2 b ofs <-> nlive ge sp n4 b ofs) : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n4 b ofs.","proofString":"intros.\nrewrite B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) (A : NE.eq n n1) (B : forall (ge0 : genv) (sp0 b0 : block) (ofs0 : Z),\nnlive ge0 sp0 n0 b0 ofs0 <-> nlive ge0 sp0 n2 b0 ofs0) (C : NE.eq n1 n3) (D : forall (ge0 : genv) (sp0 b0 : block) (ofs0 : Z),\nnlive ge0 sp0 n2 b0 ofs0 <-> nlive ge0 sp0 n4 b0 ofs0) (ge : genv) (sp b : block) (ofs : Z) : nlive ge sp n0 b ofs <-> nlive ge sp n4 b ofs.","proofString":"rewrite B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (H : NE.beq n n1 && nmem_beq n0 n2 = true) : NE.eq n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs).","proofString":"InvBooleans.\nsplit.\napply NE.beq_correct; auto.\nintros.\napply nmem_beq_sound; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (H0 : NE.beq n n1 = true) (H1 : nmem_beq n0 n2 = true) : NE.eq n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs).","proofString":"split.\napply NE.beq_correct; auto.\nintros.\napply nmem_beq_sound; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (H0 : NE.beq n n1 = true) (H1 : nmem_beq n0 n2 = true) : NE.eq n n1.","proofString":"apply NE.beq_correct; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (H0 : NE.beq n n1 = true) (H1 : nmem_beq n0 n2 = true) : forall (ge : genv) (sp b : block) (ofs : Z),\nnlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs.","proofString":"intros.\napply nmem_beq_sound; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (H0 : NE.beq n n1 = true) (H1 : nmem_beq n0 n2 = true) (ge : genv) (sp b : block) (ofs : Z) : nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs.","proofString":"apply nmem_beq_sound; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : NE.eq n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n0 b ofs <-> nlive ge sp n2 b ofs) ->\nNE.ge n n1 /\\\n(forall (ge0 : genv) (sp b : block) (ofs : Z),\n nlive ge0 sp n2 b ofs -> nlive ge0 sp n0 b ofs).","proofString":"intros [A B]; split.\napply NE.ge_refl; auto.\nintros.\napply B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n0 b ofs <-> nlive ge0 sp n2 b ofs) : NE.ge n n1.","proofString":"apply NE.ge_refl; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n0 b ofs <-> nlive ge0 sp n2 b ofs) : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n2 b ofs -> nlive ge0 sp n0 b ofs.","proofString":"intros.\napply B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (A : NE.eq n n1) (B : forall (ge1 : genv) (sp0 b0 : block) (ofs0 : Z),\nnlive ge1 sp0 n0 b0 ofs0 <-> nlive ge1 sp0 n2 b0 ofs0) (ge0 : genv) (sp b : block) (ofs : Z) (H : nlive ge0 sp n2 b ofs) : nlive ge0 sp n0 b ofs.","proofString":"apply B; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) : NE.ge n n1 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n2 b ofs -> nlive ge sp n0 b ofs) ->\nNE.ge n1 n3 /\\\n(forall (ge : genv) (sp b : block) (ofs : Z),\n nlive ge sp n4 b ofs -> nlive ge sp n2 b ofs) ->\nNE.ge n n3 /\\\n(forall (ge0 : genv) (sp b : block) (ofs : Z),\n nlive ge0 sp n4 b ofs -> nlive ge0 sp n0 b ofs).","proofString":"intros [A B] [C D]; split.\neapply NE.ge_trans; eauto.\nauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) (A : NE.ge n n1) (B : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n2 b ofs -> nlive ge0 sp n0 b ofs) (C : NE.ge n1 n3) (D : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n4 b ofs -> nlive ge0 sp n2 b ofs) : NE.ge n n3.","proofString":"eapply NE.ge_trans; eauto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) (n3 : nenv) (n4 : nmem) (A : NE.ge n n1) (B : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n2 b ofs -> nlive ge0 sp n0 b ofs) (C : NE.ge n1 n3) (D : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n4 b ofs -> nlive ge0 sp n2 b ofs) : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n4 b ofs -> nlive ge0 sp n0 b ofs.","proofString":"auto."},{"statement":"(n : nenv) (n0 : nmem) : NE.ge n NE.bot /\\\n(forall (ge0 : genv) (sp b : block) (ofs : Z),\n nlive ge0 sp NMemDead b ofs -> nlive ge0 sp n0 b ofs).","proofString":"split.\napply NE.ge_bot.\nintros.\ninv H."},{"statement":"(n : nenv) (n0 : nmem) : NE.ge n NE.bot.","proofString":"apply NE.ge_bot."},{"statement":"(n : nenv) (n0 : nmem) : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp NMemDead b ofs -> nlive ge0 sp n0 b ofs.","proofString":"intros.\ninv H."},{"statement":"(n : nenv) (n0 : nmem) (ge0 : genv) (sp b : block) (ofs : Z) (H : nlive ge0 sp NMemDead b ofs) : nlive ge0 sp n0 b ofs.","proofString":"inv H."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : NE.ge (NE.lub n n1) n.","proofString":"apply NE.ge_lub_left."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n0 b ofs -> nlive ge0 sp (nmem_lub n0 n2) b ofs.","proofString":"intros; apply nlive_lub_l; auto."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : NE.ge (NE.lub n n1) n1.","proofString":"apply NE.ge_lub_right."},{"statement":"(n : nenv) (n0 : nmem) (n1 : nenv) (n2 : nmem) : forall (ge0 : genv) (sp b : block) (ofs : Z),\nnlive ge0 sp n2 b ofs -> nlive ge0 sp (nmem_lub n0 n2) b ofs.","proofString":"intros; apply nlive_lub_r; auto."}]}