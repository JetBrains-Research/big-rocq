{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/SplitLongproof.v","fileSamples":[{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : eval_expr ge sp e m le (Eexternal id sg args) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg args) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"red in H0.\napply Genv.find_def_symbol in H0.\ndestruct H0 as (b & P & Q).\nrewrite <- Genv.find_funct_ptr_iff in Q.\neconstructor; eauto.\nsimpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : eval_expr ge sp e m le (Eexternal id sg args) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg args) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : (prog_defmap prog) ! id = Some (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"apply Genv.find_def_symbol in H0.\ndestruct H0 as (b & P & Q).\nrewrite <- Genv.find_funct_ptr_iff in Q.\neconstructor; eauto.\nsimpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : eval_expr ge sp e m le (Eexternal id sg args) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg args) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (H0 : exists b : block,\n  Genv.find_symbol (Genv.globalenv prog) id = Some b /\\\n  Genv.find_def (Genv.globalenv prog) b =\n  Some (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"destruct H0 as (b & P & Q).\nrewrite <- Genv.find_funct_ptr_iff in Q.\neconstructor; eauto.\nsimpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : eval_expr ge sp e m le (Eexternal id sg args) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg args) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_def (Genv.globalenv prog) b =\nSome (Gfun (External (EF_runtime name sg)))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"rewrite <- Genv.find_funct_ptr_iff in Q.\neconstructor; eauto.\nsimpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : eval_expr ge sp e m le (Eexternal id sg args) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg args) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"econstructor; eauto.\nsimpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : external_call (EF_runtime name sg) ge vargs m E0 vres m.","conclusion":"external_call (EF_runtime name sg) ge vargs m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"simpl.\nred.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : builtin_or_external_sem name sg ge vargs m E0 vres m.","conclusion":"builtin_or_external_sem name sg ge vargs m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"red.\nrewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge vargs m E0 vres m.","conclusion":"match lookup_builtin_function name sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem name sg\nend ge vargs m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"rewrite H1.\nconstructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres) : known_builtin_sem bf ge vargs m E0 vres m.","conclusion":"known_builtin_sem bf ge vargs m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (args : exprlist) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m le args vargs) (b : block) (P : Genv.find_symbol (Genv.globalenv prog) id = Some b) (Q : Genv.find_funct_ptr (Genv.globalenv prog) b =\nSome (External (EF_runtime name sg))) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf vargs = Some vres)","proofString":"constructor; auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres) : eval_expr ge sp e m le (Eexternal id sg (arg1 ::: Enil)) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg (arg1 ::: Enil)) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"eapply eval_helper; eauto.\nconstructor; auto.\nconstructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres) : eval_exprlist ge sp e m le (arg1 ::: Enil) (varg1 :: nil).","conclusion":"eval_exprlist ge sp e m le (arg1 ::: Enil) (varg1 :: nil)","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"constructor; auto.\nconstructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres) : eval_exprlist ge sp e m le Enil nil.","conclusion":"eval_exprlist ge sp e m le Enil nil","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : helper_declared prog id name sg) (H1 : lookup_builtin_function name sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"constructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : eval_expr ge sp e m le (Eexternal id sg (arg1 ::: arg2 ::: Enil)) vres.","conclusion":"eval_expr ge sp e m le (Eexternal id sg (arg1 ::: arg2 ::: Enil)) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"eapply eval_helper; eauto.\nconstructor; auto.\nconstructor; auto.\nconstructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : eval_exprlist ge sp e m le (arg1 ::: arg2 ::: Enil) (varg1 :: varg2 :: nil).","conclusion":"eval_exprlist ge sp e m le (arg1 ::: arg2 ::: Enil) (varg1 :: varg2 :: nil)","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"constructor; auto.\nconstructor; auto.\nconstructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : eval_exprlist ge sp e m le (arg2 ::: Enil) (varg2 :: nil).","conclusion":"eval_exprlist ge sp e m le (arg2 ::: Enil) (varg2 :: nil)","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"constructor; auto.\nconstructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : eval_exprlist ge sp e m le Enil nil.","conclusion":"eval_exprlist ge sp e m le Enil nil","hypotheses":"(bf : builtin_function) (le : letenv) (id : ident) (name : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : helper_declared prog id name sg) (H2 : lookup_builtin_function name sg = Some bf) (H3 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"constructor."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres) : eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres.","conclusion":"eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: Enil)) vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"econstructor.\neconstructor.\neauto.\nconstructor.\nsimpl.\nred.\nrewrite H0.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres) : builtin_or_external_sem id sg ge (varg1 :: nil) m E0 vres m.","conclusion":"builtin_or_external_sem id sg ge (varg1 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"red.\nrewrite H0.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres) : match lookup_builtin_function id sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem id sg\nend ge (varg1 :: nil) m E0 vres m.","conclusion":"match lookup_builtin_function id sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem id sg\nend ge (varg1 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"rewrite H0.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres) : known_builtin_sem bf ge (varg1 :: nil) m E0 vres m.","conclusion":"known_builtin_sem bf ge (varg1 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"constructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres) : builtin_function_sem bf (varg1 :: nil) = Some vres.","conclusion":"builtin_function_sem bf (varg1 :: nil) = Some vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 : expr) (varg1 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : lookup_builtin_function id sg = Some bf) (H1 : builtin_function_sem bf (varg1 :: nil) = Some vres)","proofString":"auto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 ::: Enil))\n  vres.","conclusion":"eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (arg1 ::: arg2 ::: Enil))\n  vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"econstructor.\nconstructor; eauto.\nconstructor; eauto.\nconstructor.\nsimpl.\nred.\nrewrite H1.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : builtin_or_external_sem id sg ge (varg1 :: varg2 :: nil) m E0 vres m.","conclusion":"builtin_or_external_sem id sg ge (varg1 :: varg2 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"red.\nrewrite H1.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : match lookup_builtin_function id sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem id sg\nend ge (varg1 :: varg2 :: nil) m E0 vres m.","conclusion":"match lookup_builtin_function id sg with\n| Some bf0 => known_builtin_sem bf0\n| None => external_functions_sem id sg\nend ge (varg1 :: varg2 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"rewrite H1.\nconstructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : known_builtin_sem bf ge (varg1 :: varg2 :: nil) m E0 vres m.","conclusion":"known_builtin_sem bf ge (varg1 :: varg2 :: nil) m E0 vres m","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"constructor.\nauto."},{"statement":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres) : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres.","conclusion":"builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres","hypotheses":"(bf : builtin_function) (le : letenv) (id : string) (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val) (H : eval_expr ge sp e m le arg1 varg1) (H0 : eval_expr ge sp e m le arg2 varg2) (H1 : lookup_builtin_function id sg = Some bf) (H2 : builtin_function_sem bf (varg1 :: varg2 :: nil) = Some vres)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) : eval_expr ge sp e m le a v ->\nexists v' : val,\n  eval_expr ge sp e m le (splitlong a f) v' /\\ Val.lessdef (sem v) v'.","conclusion":"eval_expr ge sp e m le a v ->\nexists v' : val,\n  eval_expr ge sp e m le (splitlong a f) v' /\\ Val.lessdef (sem v) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend)","proofString":"unfold splitlong.\ncase (splitlong_match a); intros.\nInvEval; subst.\nexploit EXEC.\neexact H2.\neexact H3.\nintros [v' [A B]].\nexists v'; split.\nauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto.\nexploit (EXEC (v :: le) (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nintros [v' [A B]].\nexists v'; split.\neconstructor; eauto.\ndestruct v; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) : eval_expr ge sp e m le a v ->\nexists v' : val,\n  eval_expr ge sp e m le\n    match splitlong_match a with\n    | splitlong_case1 h l => f h l\n    | splitlong_default e0 =>\n        Elet e0\n          (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)))\n    end v' /\\ Val.lessdef (sem v) v'.","conclusion":"eval_expr ge sp e m le a v ->\nexists v' : val,\n  eval_expr ge sp e m le\n    match splitlong_match a with\n    | splitlong_case1 h l => f h l\n    | splitlong_default e0 =>\n        Elet e0\n          (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)))\n    end v' /\\ Val.lessdef (sem v) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend)","proofString":"case (splitlong_match a); intros.\nInvEval; subst.\nexploit EXEC.\neexact H2.\neexact H3.\nintros [v' [A B]].\nexists v'; split.\nauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto.\nexploit (EXEC (v :: le) (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nintros [v' [A B]].\nexists v'; split.\neconstructor; eauto.\ndestruct v; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (h l : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h ::: l ::: Enil)) v) : exists v' : val, eval_expr ge sp e m le (f h l) v' /\\ Val.lessdef (sem v) v'.","conclusion":"exists v' : val, eval_expr ge sp e m le (f h l) v' /\\ Val.lessdef (sem v) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (h l : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h ::: l ::: Enil)) v)","proofString":"InvEval; subst.\nexploit EXEC.\neexact H2.\neexact H3.\nintros [v' [A B]].\nexists v'; split.\nauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) : exists v' : val,\n  eval_expr ge sp e m le (f h l) v' /\\\n  Val.lessdef (sem (Val.longofwords v1 v0)) v'.","conclusion":"exists v' : val,\n  eval_expr ge sp e m le (f h l) v' /\\\n  Val.lessdef (sem (Val.longofwords v1 v0)) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0)","proofString":"exploit EXEC.\neexact H2.\neexact H3.\nintros [v' [A B]].\nexists v'; split.\nauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : exists v'0 : val,\n  eval_expr ge sp e m le (f h l) v'0 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0)) v'0.","conclusion":"exists v'0 : val,\n  eval_expr ge sp e m le (f h l) v'0 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0)) v'0","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"exists v'; split.\nauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : eval_expr ge sp e m le (f h l) v'.","conclusion":"eval_expr ge sp e m le (f h l) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem (Val.longofwords v1 v0)) v'.","conclusion":"Val.lessdef (sem (Val.longofwords v1 v0)) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Val.longofwords v1 v0) = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h v1) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nv1 = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"destruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (i : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h (Vint i)) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nVint i = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'.","conclusion":"Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (i : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end = Vundef\nend) (h l : expr) (H2 : eval_expr ge sp e m le h (Vint i)) (H3 : eval_expr ge sp e m le l v0) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nVint i = Vint p -> v0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"destruct v0; simpl in *; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (i i0 : int) (UNDEF : True) (h l : expr) (H2 : eval_expr ge sp e m le h (Vint i)) (H3 : eval_expr ge sp e m le l (Vint i0)) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nVint i = Vint p -> Vint i0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'.","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (i i0 : int) (UNDEF : True) (h l : expr) (H2 : eval_expr ge sp e m le h (Vint i)) (H3 : eval_expr ge sp e m le l (Vint i0)) (v' : val) (A : eval_expr ge sp e m le (f h l) v') (B : forall p q : int,\nVint i = Vint p -> Vint i0 = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"erewrite B; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) : exists v' : val,\n  eval_expr ge sp e m le\n    (Elet e0\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v' /\\ \n  Val.lessdef (sem v) v'.","conclusion":"exists v' : val,\n  eval_expr ge sp e m le\n    (Elet e0\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v' /\\ \n  Val.lessdef (sem v) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v)","proofString":"exploit (EXEC (v :: le) (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nintros [v' [A B]].\nexists v'; split.\neconstructor; eauto.\ndestruct v; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : exists v'0 : val,\n  eval_expr ge sp e m le\n    (Elet e0\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v'0 /\\\n  Val.lessdef (sem v) v'0.","conclusion":"exists v'0 : val,\n  eval_expr ge sp e m le\n    (Elet e0\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v'0 /\\\n  Val.lessdef (sem v) v'0","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"exists v'; split.\neconstructor; eauto.\ndestruct v; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v'.","conclusion":"eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"econstructor; eauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem v) v'.","conclusion":"Val.lessdef (sem v) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a0 b) v0 /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v0 = sem (Vlong (Int64.ofwords p q)))) (UNDEF : match v with\n| Vlong _ => True\n| _ => sem v = Vundef\nend) (e0 : expr) (H : eval_expr ge sp e m le e0 v) (v' : val) (A : eval_expr ge sp e m (v :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword v = Vint p ->\nVal.loword v = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"destruct v; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem (Vlong i)) v'.","conclusion":"Val.lessdef (sem (Vlong i)) v'","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"erewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))).","conclusion":"Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i))))","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q))) : Val.lessdef (sem (Vlong i)) (sem (Vlong i)).","conclusion":"Val.lessdef (sem (Vlong i)) (sem (Vlong i))","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (i : int64) (sem : val -> val) (EXEC : forall (le0 : letenv) (a0 b : expr) (x y : val),\neval_expr ge sp e m le0 a0 x ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a0 b) v /\\\n  (forall p q : int,\n   x = Vint p -> y = Vint q -> v = sem (Vlong (Int64.ofwords p q)))) (UNDEF : True) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong i)) (v' : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v') (B : forall p q : int,\nVal.hiword (Vlong i) = Vint p ->\nVal.loword (Vlong i) = Vint q -> v' = sem (Vlong (Int64.ofwords p q)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) : eval_expr ge sp e m le a (Vlong va) ->\n(forall (le0 : letenv) (a1 a2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 (f a1 a2) v) ->\neval_expr ge sp e m le (splitlong a f) v.","conclusion":"eval_expr ge sp e m le a (Vlong va) ->\n(forall (le0 : letenv) (a1 a2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 (f a1 a2) v) ->\neval_expr ge sp e m le (splitlong a f) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val)","proofString":"unfold splitlong.\ncase (splitlong_match a); intros.\nInvEval.\ndestruct v1; simpl in H; try discriminate.\ndestruct v0; inv H.\napply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto.\nEvalOp.\napply H0; EvalOp."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) : eval_expr ge sp e m le a (Vlong va) ->\n(forall (le0 : letenv) (a1 a2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 (f a1 a2) v) ->\neval_expr ge sp e m le\n  match splitlong_match a with\n  | splitlong_case1 h l => f h l\n  | splitlong_default e0 =>\n      Elet e0\n        (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)))\n  end v.","conclusion":"eval_expr ge sp e m le a (Vlong va) ->\n(forall (le0 : letenv) (a1 a2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 (f a1 a2) v) ->\neval_expr ge sp e m le\n  match splitlong_match a with\n  | splitlong_case1 h l => f h l\n  | splitlong_default e0 =>\n      Elet e0\n        (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)))\n  end v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val)","proofString":"case (splitlong_match a); intros.\nInvEval.\ndestruct v1; simpl in H; try discriminate.\ndestruct v0; inv H.\napply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto.\nEvalOp.\napply H0; EvalOp."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h ::: l ::: Enil)) (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) : eval_expr ge sp e m le (f h l) v.","conclusion":"eval_expr ge sp e m le (f h l) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h ::: l ::: Enil)) (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v)","proofString":"InvEval.\ndestruct v1; simpl in H; try discriminate.\ndestruct v0; inv H.\napply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) (v1 v0 : val) (H3 : eval_expr ge sp e m le h v1) (H4 : eval_expr ge sp e m le l v0) (H : Val.longofwords v1 v0 = Vlong va) : eval_expr ge sp e m le (f h l) v.","conclusion":"eval_expr ge sp e m le (f h l) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) (v1 v0 : val) (H3 : eval_expr ge sp e m le h v1) (H4 : eval_expr ge sp e m le l v0) (H : Val.longofwords v1 v0 = Vlong va)","proofString":"destruct v1; simpl in H; try discriminate.\ndestruct v0; inv H.\napply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) (i : int) (v0 : val) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l v0) (H : match v0 with\n| Vint n2 => Vlong (Int64.ofwords i n2)\n| _ => Vundef\nend = Vlong va) : eval_expr ge sp e m le (f h l) v.","conclusion":"eval_expr ge sp e m le (f h l) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (h l : expr) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) (i : int) (v0 : val) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l v0) (H : match v0 with\n| Vint n2 => Vlong (Int64.ofwords i n2)\n| _ => Vundef\nend = Vlong va)","proofString":"destruct v0; inv H.\napply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0)) : eval_expr ge sp e m le (f h l) v.","conclusion":"eval_expr ge sp e m le (f h l) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0))","proofString":"apply H0.\nrewrite Int64.hi_ofwords; auto.\nrewrite Int64.lo_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0)) : eval_expr ge sp e m le h (Vint (Int64.hiword (Int64.ofwords i i0))).","conclusion":"eval_expr ge sp e m le h (Vint (Int64.hiword (Int64.ofwords i i0)))","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0))","proofString":"rewrite Int64.hi_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0)) : eval_expr ge sp e m le l (Vint (Int64.loword (Int64.ofwords i i0))).","conclusion":"eval_expr ge sp e m le l (Vint (Int64.loword (Int64.ofwords i i0)))","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (v : val) (h l : expr) (i i0 : int) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword (Int64.ofwords i i0))) ->\neval_expr ge sp e m le0 (f a1 a2) v) (H3 : eval_expr ge sp e m le h (Vint i)) (H4 : eval_expr ge sp e m le l (Vint i0))","proofString":"rewrite Int64.lo_ofwords; auto."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v)","proofString":"EvalOp.\napply H0; EvalOp."},{"statement":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v) : eval_expr ge sp e m (Vlong va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v.","conclusion":"eval_expr ge sp e m (Vlong va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v","hypotheses":"(le : letenv) (a : expr) (f : expr -> expr -> expr) (va : int64) (v : val) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vlong va)) (H0 : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 (f a1 a2) v)","proofString":"apply H0; EvalOp."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) : eval_expr ge sp e m le a va ->\neval_expr ge sp e m le b vb ->\nexists v : val,\n  eval_expr ge sp e m le (splitlong2 a b f) v /\\ Val.lessdef (sem va vb) v.","conclusion":"eval_expr ge sp e m le a va ->\neval_expr ge sp e m le b vb ->\nexists v : val,\n  eval_expr ge sp e m le (splitlong2 a b f) v /\\ Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend)","proofString":"unfold splitlong2.\ncase (splitlong2_match a b); intros.\nInvEval; subst.\nexploit (EXEC le h1 l1 h2 l2); eauto.\nintros [v [A B]].\nexists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto.\nInvEval; subst.\nexploit (EXEC (vb :: le) (lift h1) (lift l1)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto.\nInvEval; subst.\nexploit (EXEC (va :: le)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))                (lift h2) (lift l2)).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto.\nexploit (EXEC (vb :: va :: le)                (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\nEvalOp.\ndestruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) : eval_expr ge sp e m le a va ->\neval_expr ge sp e m le b vb ->\nexists v : val,\n  eval_expr ge sp e m le\n    match splitlong2_match a b with\n    | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n    | splitlong2_case2 h1 l1 t2 =>\n        Elet t2\n          (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)))\n    | splitlong2_case3 t1 h2 l2 =>\n        Elet t1\n          (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n             (lift l2))\n    | splitlong2_default e1 e2 =>\n        Elet e1\n          (Elet (lift e2)\n             (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n                (Eop Olowlong (Eletvar 1 ::: Enil))\n                (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (Eop Olowlong (Eletvar 0 ::: Enil))))\n    end v /\\ Val.lessdef (sem va vb) v.","conclusion":"eval_expr ge sp e m le a va ->\neval_expr ge sp e m le b vb ->\nexists v : val,\n  eval_expr ge sp e m le\n    match splitlong2_match a b with\n    | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n    | splitlong2_case2 h1 l1 t2 =>\n        Elet t2\n          (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)))\n    | splitlong2_case3 t1 h2 l2 =>\n        Elet t1\n          (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n             (lift l2))\n    | splitlong2_default e1 e2 =>\n        Elet e1\n          (Elet (lift e2)\n             (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n                (Eop Olowlong (Eletvar 1 ::: Enil))\n                (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (Eop Olowlong (Eletvar 0 ::: Enil))))\n    end v /\\ Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend)","proofString":"case (splitlong2_match a b); intros.\nInvEval; subst.\nexploit (EXEC le h1 l1 h2 l2); eauto.\nintros [v [A B]].\nexists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto.\nInvEval; subst.\nexploit (EXEC (vb :: le) (lift h1) (lift l1)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto.\nInvEval; subst.\nexploit (EXEC (va :: le)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))                (lift h2) (lift l2)).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto.\nexploit (EXEC (vb :: va :: le)                (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\nEvalOp.\ndestruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (h1 l1 h2 l2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) va) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) vb) : exists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\ Val.lessdef (sem va vb) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\ Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (h1 l1 h2 l2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) va) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) vb)","proofString":"InvEval; subst.\nexploit (EXEC le h1 l1 h2 l2); eauto.\nintros [v [A B]].\nexists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) : exists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3)","proofString":"exploit (EXEC le h1 l1 h2 l2); eauto.\nintros [v [A B]].\nexists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) : (exists v : val,\n   eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n   (forall p1 p2 q1 q2 : int,\n    v1 = Vint p1 ->\n    v0 = Vint p2 ->\n    v2 = Vint q1 ->\n    v3 = Vint q2 ->\n    v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) ->\nexists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n   (forall p1 p2 q1 q2 : int,\n    v1 = Vint p1 ->\n    v0 = Vint p2 ->\n    v2 = Vint q1 ->\n    v3 = Vint q2 ->\n    v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) ->\nexists v : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3)","proofString":"intros [v [A B]].\nexists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v4 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v4 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v4 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : exists v4 : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v4 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v4.","conclusion":"exists v4 : val,\n  eval_expr ge sp e m le (f h1 l1 h2 l2) v4 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v4","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v4 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v4 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v4 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"exists v; split; auto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v4 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v4 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v4 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v.","conclusion":"Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v4 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v4 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v4 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 v2 v3 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 v1) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i : int) (v0 v2 v3 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        sem\n          match v0 with\n          | Vint n2 => Vlong (Int64.ofwords i n2)\n          | _ => Vundef\n          end (Val.longofwords v2 v3) = Vundef\n    end\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v.","conclusion":"Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i : int) (v0 v2 v3 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        sem\n          match v0 with\n          | Vint n2 => Vlong (Int64.ofwords i n2)\n          | _ => Vundef\n          end (Val.longofwords v2 v3) = Vundef\n    end\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 v0) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nv0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v0; try (rewrite UNDEF; auto).\ndestruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (v2 v3 : val) (UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ => sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3)) v.","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (v2 v3 : val) (UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ => sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3) = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 v2) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nv2 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v2; simpl in *; try (rewrite UNDEF; auto).\ndestruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 i1 : int) (v3 : val) (UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem (Vlong (Int64.ofwords i i0))\n      match v3 with\n      | Vint n2 => Vlong (Int64.ofwords i1 n2)\n      | _ => Vundef\n      end = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 (Vint i1)) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVint i1 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v.","conclusion":"Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 i1 : int) (v3 : val) (UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem (Vlong (Int64.ofwords i i0))\n      match v3 with\n      | Vint n2 => Vlong (Int64.ofwords i1 n2)\n      | _ => Vundef\n      end = Vundef\nend) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 (Vint i1)) (H4 : eval_expr ge sp e m le l2 v3) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVint i1 = Vint q1 ->\nv3 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v3; try (rewrite UNDEF; auto).\nerewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 i1 i2 : int) (UNDEF : True) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 (Vint i1)) (H4 : eval_expr ge sp e m le l2 (Vint i2)) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVint i1 = Vint q1 ->\nVint i2 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2)))\n  v.","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2)))\n  v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 i1 i2 : int) (UNDEF : True) (h1 l1 h2 l2 : expr) (H2 : eval_expr ge sp e m le h1 (Vint i)) (H3 : eval_expr ge sp e m le l1 (Vint i0)) (H5 : eval_expr ge sp e m le h2 (Vint i1)) (H4 : eval_expr ge sp e m le l2 (Vint i2)) (v : val) (A : eval_expr ge sp e m le (f h1 l1 h2 l2) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVint i1 = Vint q1 ->\nVint i2 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"erewrite B; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (h1 l1 t2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) va) (H0 : eval_expr ge sp e m le t2 vb) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (sem va vb) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (h1 l1 t2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) va) (H0 : eval_expr ge sp e m le t2 vb)","proofString":"InvEval; subst.\nexploit (EXEC (vb :: le) (lift h1) (lift l1)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) vb) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0)","proofString":"exploit (EXEC (vb :: le) (lift h1) (lift l1)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : exists v2 : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v2 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) vb) v2.","conclusion":"exists v2 : val,\n  eval_expr ge sp e m le\n    (Elet t2\n       (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v2 /\\\n  Val.lessdef (sem (Val.longofwords v1 v0) vb) v2","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"exists v; split.\neconstructor; eauto.\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"econstructor; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Val.longofwords v1 v0) vb) v.","conclusion":"Val.lessdef (sem (Val.longofwords v1 v0) vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => sem (Val.longofwords v1 v0) vb = Vundef\n    end\n| _ => sem (Val.longofwords v1 v0) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nv1 = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        sem\n          match v0 with\n          | Vint n2 => Vlong (Int64.ofwords i n2)\n          | _ => Vundef\n          end vb = Vundef\n    end\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v.","conclusion":"Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        sem\n          match v0 with\n          | Vint n2 => Vlong (Int64.ofwords i n2)\n          | _ => Vundef\n          end vb = Vundef\n    end\n| _ =>\n    sem\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i n2)\n      | _ => Vundef\n      end vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 v0) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nv0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v0; try (rewrite UNDEF; auto).\ndestruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : match vb with\n| Vlong _ => True\n| _ => sem (Vlong (Int64.ofwords i i0)) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v.","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : match vb with\n| Vlong _ => True\n| _ => sem (Vlong (Int64.ofwords i i0)) vb = Vundef\nend) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 vb) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (vb :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v.","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"erewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) (Int64.loword i1)))).","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) (Int64.loword i1))))","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)).","conclusion":"Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i1 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i i0 : int) (UNDEF : True) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong i1)) (H3 : eval_expr ge sp e m le h1 (Vint i)) (H4 : eval_expr ge sp e m le l1 (Vint i0)) (v : val) (A : eval_expr ge sp e m (Vlong i1 :: le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n     (Eop Olowlong (Eletvar 0 ::: Enil))) v) (B : forall p1 p2 q1 q2 : int,\nVint i = Vint p1 ->\nVint i0 = Vint p2 ->\nVal.hiword (Vlong i1) = Vint q1 ->\nVal.loword (Vlong i1) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) vb) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v /\\ Val.lessdef (sem va vb) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v /\\ Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) vb)","proofString":"InvEval; subst.\nexploit (EXEC (va :: le)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))                (lift h2) (lift l2)).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v /\\ Val.lessdef (sem va (Val.longofwords v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v /\\ Val.lessdef (sem va (Val.longofwords v1 v0)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0)","proofString":"exploit (EXEC (va :: le)                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))                (lift h2) (lift l2)).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\ndestruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : exists v2 : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v2 /\\ Val.lessdef (sem va (Val.longofwords v1 v0)) v2.","conclusion":"exists v2 : val,\n  eval_expr ge sp e m le\n    (Elet t1\n       (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n          (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n          (lift l2))) v2 /\\ Val.lessdef (sem va (Val.longofwords v1 v0)) v2","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"exists v; split.\neconstructor; eauto.\ndestruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"econstructor; eauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem va (Val.longofwords v1 v0)) v.","conclusion":"Val.lessdef (sem va (Val.longofwords v1 v0)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => sem va (Val.longofwords v1 v0) = Vundef\n    end\n| _ => sem va (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 va) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (va :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct va; try (rewrite UNDEF; auto).\ndestruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Vlong i) (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v.","conclusion":"Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v2 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v2 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v2 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (v1 v0 : val) (UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => sem (Vlong i) (Val.longofwords v1 v0) = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 v1) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nv1 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v1; simpl in *; try (rewrite UNDEF; auto).\ndestruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem (Vlong i)\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i0 n2)\n      | _ => Vundef\n      end = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v.","conclusion":"Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v1 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v1 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v1 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 : int) (v0 : val) (UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    sem (Vlong i)\n      match v0 with\n      | Vint n2 => Vlong (Int64.ofwords i0 n2)\n      | _ => Vundef\n      end = Vundef\nend) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 v0) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nv0 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct v0; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v.","conclusion":"Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"erewrite B; simpl; eauto.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 i1))).","conclusion":"Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 i1)))","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))).","conclusion":"Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (i0 i1 : int) (UNDEF : True) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong i)) (H3 : eval_expr ge sp e m le h2 (Vint i0)) (H4 : eval_expr ge sp e m le l2 (Vint i1)) (v : val) (A : eval_expr ge sp e m (Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))\n     (lift h2) (lift l2)) v) (B : forall p1 p2 q1 q2 : int,\nVint (Int64.hiword i) = Vint p1 ->\nVint (Int64.loword i) = Vint p2 ->\nVint i0 = Vint q1 ->\nVint i1 = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet e1\n       (Elet (lift e2)\n          (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n             (Eop Olowlong (Eletvar 1 ::: Enil))\n             (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v /\\\n  Val.lessdef (sem va vb) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet e1\n       (Elet (lift e2)\n          (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n             (Eop Olowlong (Eletvar 1 ::: Enil))\n             (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v /\\\n  Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb)","proofString":"exploit (EXEC (vb :: va :: le)                (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))                (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil))).\nEvalOp.\nEvalOp.\nEvalOp.\nEvalOp.\nintros [v [A B]].\nexists v; split.\nEvalOp.\ndestruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : exists v0 : val,\n  eval_expr ge sp e m le\n    (Elet e1\n       (Elet (lift e2)\n          (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n             (Eop Olowlong (Eletvar 1 ::: Enil))\n             (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v0 /\\\n  Val.lessdef (sem va vb) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le\n    (Elet e1\n       (Elet (lift e2)\n          (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n             (Eop Olowlong (Eletvar 1 ::: Enil))\n             (Eop Ohighlong (Eletvar 0 ::: Enil))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v0 /\\\n  Val.lessdef (sem va vb) v0","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"exists v; split.\nEvalOp.\ndestruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n           (Eop Olowlong (Eletvar 1 ::: Enil))\n           (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil))))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n           (Eop Olowlong (Eletvar 1 ::: Enil))\n           (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil))))) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem va vb) v.","conclusion":"Val.lessdef (sem va vb) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : val) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : match va with\n| Vlong _ => match vb with\n             | Vlong _ => True\n             | _ => sem va vb = Vundef\n             end\n| _ => sem va vb = Vundef\nend) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 va) (H0 : eval_expr ge sp e m le e2 vb) (v : val) (A : eval_expr ge sp e m (vb :: va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword va = Vint p1 ->\nVal.loword va = Vint p2 ->\nVal.hiword vb = Vint q1 ->\nVal.loword vb = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"destruct va; try (rewrite UNDEF; auto); destruct vb; try (rewrite UNDEF; auto).\nerewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i i0 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : True) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong i)) (H0 : eval_expr ge sp e m le e2 (Vlong i0)) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nVal.hiword (Vlong i0) = Vint q1 ->\nVal.loword (Vlong i0) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Vlong i0)) v.","conclusion":"Val.lessdef (sem (Vlong i) (Vlong i0)) v","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i i0 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : True) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong i)) (H0 : eval_expr ge sp e m le e2 (Vlong i0)) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nVal.hiword (Vlong i0) = Vint q1 ->\nVal.loword (Vlong i0) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"erewrite B; simpl; eauto.\nrewrite ! Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i i0 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : True) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong i)) (H0 : eval_expr ge sp e m le e2 (Vlong i0)) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nVal.hiword (Vlong i0) = Vint q1 ->\nVal.loword (Vlong i0) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))) : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) (Int64.loword i0)))).","conclusion":"Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) (Int64.loword i0))))","hypotheses":"(le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (i i0 : int64) (sem : val -> val -> val) (EXEC : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v0 : val,\n  eval_expr ge sp e m le0 (f a1 a2 b1 b2) v0 /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v0 = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))) (UNDEF : True) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong i)) (H0 : eval_expr ge sp e m le e2 (Vlong i0)) (v : val) (A : eval_expr ge sp e m (Vlong i0 :: Vlong i :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v) (B : forall p1 p2 q1 q2 : int,\nVal.hiword (Vlong i) = Vint p1 ->\nVal.loword (Vlong i) = Vint p2 ->\nVal.hiword (Vlong i0) = Vint q1 ->\nVal.loword (Vlong i0) = Vint q2 ->\nv = sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","proofString":"rewrite ! Int64.ofwords_recompose; auto."},{"statement":"forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n).","conclusion":"forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)","hypotheses":"","proofString":"intros.\ndestruct v1; simpl in H; try discriminate.\ndestruct v2; inv H.\nrewrite Int64.hi_ofwords; rewrite Int64.lo_ofwords; auto."},{"statement":"(v1 v2 : val) (n : int64) (H : Val.longofwords v1 v2 = Vlong n) : v1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n).","conclusion":"v1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)","hypotheses":"(v1 v2 : val) (n : int64) (H : Val.longofwords v1 v2 = Vlong n)","proofString":"destruct v1; simpl in H; try discriminate.\ndestruct v2; inv H.\nrewrite Int64.hi_ofwords; rewrite Int64.lo_ofwords; auto."},{"statement":"(i : int) (v2 : val) (n : int64) (H : match v2 with\n| Vint n2 => Vlong (Int64.ofwords i n2)\n| _ => Vundef\nend = Vlong n) : Vint i = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n).","conclusion":"Vint i = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)","hypotheses":"(i : int) (v2 : val) (n : int64) (H : match v2 with\n| Vint n2 => Vlong (Int64.ofwords i n2)\n| _ => Vundef\nend = Vlong n)","proofString":"destruct v2; inv H.\nrewrite Int64.hi_ofwords; rewrite Int64.lo_ofwords; auto."},{"statement":"(i i0 : int) : Vint i = Vint (Int64.hiword (Int64.ofwords i i0)) /\\\nVint i0 = Vint (Int64.loword (Int64.ofwords i i0)).","conclusion":"Vint i = Vint (Int64.hiword (Int64.ofwords i i0)) /\\\nVint i0 = Vint (Int64.loword (Int64.ofwords i i0))","hypotheses":"(i i0 : int)","proofString":"rewrite Int64.hi_ofwords; rewrite Int64.lo_ofwords; auto."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) : forall (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr)\n  (va vb : int64) (v : val),\neval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le (splitlong2 a b f) v.","conclusion":"forall (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr)\n  (va vb : int64) (v : val),\neval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le (splitlong2 a b f) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n))","proofString":"intros until v.\nunfold splitlong2.\ncase (splitlong2_match a b); intros.\nInvEval.\nexploit INV.\neexact H.\nintros [EQ1 EQ2].\nexploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nEvalOp.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) : eval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le (splitlong2 a b f) v.","conclusion":"eval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le (splitlong2 a b f) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val)","proofString":"unfold splitlong2.\ncase (splitlong2_match a b); intros.\nInvEval.\nexploit INV.\neexact H.\nintros [EQ1 EQ2].\nexploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nEvalOp.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) : eval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le\n  match splitlong2_match a b with\n  | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n  | splitlong2_case2 h1 l1 t2 =>\n      Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)))\n  | splitlong2_case3 t1 h2 l2 =>\n      Elet t1\n        (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n           (lift l2))\n  | splitlong2_default e1 e2 =>\n      Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n              (Eop Olowlong (Eletvar 1 ::: Enil))\n              (Eop Ohighlong (Eletvar 0 ::: Enil))\n              (Eop Olowlong (Eletvar 0 ::: Enil))))\n  end v.","conclusion":"eval_expr ge sp e m le a (Vlong va) ->\neval_expr ge sp e m le b (Vlong vb) ->\n(forall (le0 : letenv) (a1 a2 b1 b2 : expr),\n eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\n eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\n eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\n eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\n eval_expr ge sp e m le0 (f a1 a2 b1 b2) v) ->\neval_expr ge sp e m le\n  match splitlong2_match a b with\n  | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n  | splitlong2_case2 h1 l1 t2 =>\n      Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)))\n  | splitlong2_case3 t1 h2 l2 =>\n      Elet t1\n        (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n           (lift l2))\n  | splitlong2_default e1 e2 =>\n      Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n              (Eop Olowlong (Eletvar 1 ::: Enil))\n              (Eop Ohighlong (Eletvar 0 ::: Enil))\n              (Eop Olowlong (Eletvar 0 ::: Enil))))\n  end v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val)","proofString":"case (splitlong2_match a b); intros.\nInvEval.\nexploit INV.\neexact H.\nintros [EQ1 EQ2].\nexploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nInvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp.\nEvalOp.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) (Vlong va)) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) : eval_expr ge sp e m le (f h1 l1 h2 l2) v.","conclusion":"eval_expr ge sp e m le (f h1 l1 h2 l2) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) (Vlong va)) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v)","proofString":"InvEval.\nexploit INV.\neexact H.\nintros [EQ1 EQ2].\nexploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto."},{"statement":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb) : eval_expr ge sp e m le (f h1 l1 h2 l2) v.","conclusion":"eval_expr ge sp e m le (f h1 l1 h2 l2) v","hypotheses":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb)","proofString":"exploit INV.\neexact H.\nintros [EQ1 EQ2].\nexploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto."},{"statement":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va)) : eval_expr ge sp e m le (f h1 l1 h2 l2) v.","conclusion":"eval_expr ge sp e m le (f h1 l1 h2 l2) v","hypotheses":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va))","proofString":"exploit INV.\neexact H0.\nintros [EQ3 EQ4].\nsubst.\nauto."},{"statement":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va)) (EQ3 : v2 = Vint (Int64.hiword vb)) (EQ4 : v3 = Vint (Int64.loword vb)) : eval_expr ge sp e m le (f h1 l1 h2 l2) v.","conclusion":"eval_expr ge sp e m le (f h1 l1 h2 l2) v","hypotheses":"(INV : forall (v4 v5 : val) (n : int64),\nVal.longofwords v4 v5 = Vlong n ->\nv4 = Vint (Int64.hiword n) /\\ v5 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v2 v3 v1 v0 : val) (H3 : eval_expr ge sp e m le h1 v1) (H4 : eval_expr ge sp e m le l1 v0) (H6 : eval_expr ge sp e m le h2 v2) (H5 : eval_expr ge sp e m le l2 v3) (H : Val.longofwords v1 v0 = Vlong va) (H0 : Val.longofwords v2 v3 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va)) (EQ3 : v2 = Vint (Int64.hiword vb)) (EQ4 : v3 = Vint (Int64.loword vb))","proofString":"subst.\nauto."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H3 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))) (H4 : eval_expr ge sp e m le l1 (Vint (Int64.loword va))) (H6 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))) (H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb))) (H : Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)) = Vlong va) (H0 : Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)) = Vlong vb) : eval_expr ge sp e m le (f h1 l1 h2 l2) v.","conclusion":"eval_expr ge sp e m le (f h1 l1 h2 l2) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 h2 l2 : expr) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H3 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))) (H4 : eval_expr ge sp e m le l1 (Vint (Int64.loword va))) (H6 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))) (H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb))) (H : Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)) = Vlong va) (H0 : Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)) = Vlong vb)","proofString":"auto."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) (Vlong va)) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (h1 ::: l1 ::: Enil)) (Vlong va)) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v)","proofString":"InvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va) : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va)","proofString":"exploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va) : v1 = Vint (Int64.hiword va) /\\ v0 = Vint (Int64.loword va) ->\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"v1 = Vint (Int64.hiword va) /\\ v0 = Vint (Int64.loword va) ->\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va)","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va)) : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h1 v1) (H5 : eval_expr ge sp e m le l1 v0) (H : Val.longofwords v1 v0 = Vlong va) (EQ1 : v1 = Vint (Int64.hiword va)) (EQ2 : v0 = Vint (Int64.loword va))","proofString":"subst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H4 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))) (H : Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)) = Vlong va) (H5 : eval_expr ge sp e m le l1 (Vint (Int64.loword va))) : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)))) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (h1 l1 t2 : expr) (H0 : eval_expr ge sp e m le t2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H4 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))) (H : Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)) = Vlong va) (H5 : eval_expr ge sp e m le l1 (Vint (Int64.loword va)))","proofString":"econstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H0 : eval_expr ge sp e m le (Eop Omakelong (h2 ::: l2 ::: Enil)) (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v)","proofString":"InvEval.\nexploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb) : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb)","proofString":"exploit INV; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb) : v1 = Vint (Int64.hiword vb) /\\ v0 = Vint (Int64.loword vb) ->\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"v1 = Vint (Int64.hiword vb) /\\ v0 = Vint (Int64.loword vb) ->\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb)","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword vb)) (EQ2 : v0 = Vint (Int64.loword vb)) : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(INV : forall (v2 v3 : val) (n : int64),\nVal.longofwords v2 v3 = Vlong n ->\nv2 = Vint (Int64.hiword n) /\\ v3 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (v1 v0 : val) (H4 : eval_expr ge sp e m le h2 v1) (H5 : eval_expr ge sp e m le l2 v0) (H0 : Val.longofwords v1 v0 = Vlong vb) (EQ1 : v1 = Vint (Int64.hiword vb)) (EQ2 : v0 = Vint (Int64.loword vb))","proofString":"subst.\neconstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H4 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))) (H0 : Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)) = Vlong vb) (H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb))) : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Eletvar 0 ::: Enil))\n        (Eop Olowlong (Eletvar 0 ::: Enil)) (lift h2) \n        (lift l2))) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (t1 h2 l2 : expr) (H : eval_expr ge sp e m le t1 (Vlong va)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) (H4 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))) (H0 : Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)) = Vlong vb) (H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb)))","proofString":"econstructor.\neauto.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong va)) (H0 : eval_expr ge sp e m le e2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n           (Eop Olowlong (Eletvar 1 ::: Enil))\n           (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil))))) v.","conclusion":"eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Eletvar 1 ::: Enil))\n           (Eop Olowlong (Eletvar 1 ::: Enil))\n           (Eop Ohighlong (Eletvar 0 ::: Enil))\n           (Eop Olowlong (Eletvar 0 ::: Enil))))) v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong va)) (H0 : eval_expr ge sp e m le e2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v)","proofString":"EvalOp.\napply H1; EvalOp."},{"statement":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong va)) (H0 : eval_expr ge sp e m le e2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v) : eval_expr ge sp e m (Vlong vb :: Vlong va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v.","conclusion":"eval_expr ge sp e m (Vlong vb :: Vlong va :: le)\n  (f (Eop Ohighlong (Eletvar 1 ::: Enil)) (Eop Olowlong (Eletvar 1 ::: Enil))\n     (Eop Ohighlong (Eletvar 0 ::: Enil)) (Eop Olowlong (Eletvar 0 ::: Enil)))\n  v","hypotheses":"(INV : forall (v1 v2 : val) (n : int64),\nVal.longofwords v1 v2 = Vlong n ->\nv1 = Vint (Int64.hiword n) /\\ v2 = Vint (Int64.loword n)) (le : letenv) (a b : expr) (f : expr -> expr -> expr -> expr -> expr) (va vb : int64) (v : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 (Vlong va)) (H0 : eval_expr ge sp e m le e2 (Vlong vb)) (H1 : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword va)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword vb)) ->\neval_expr ge sp e m le0 (f a1 a2 b1 b2) v)","proofString":"apply H1; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (LC : match is_longconst_match a with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n) : eval_expr ge sp e m le a x -> x = Vlong n.","conclusion":"eval_expr ge sp e m le a x -> x = Vlong n","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (LC : match is_longconst_match a with\n| is_longconst_case1 h l => Some (Int64.ofwords h l)\n| is_longconst_default _ => None\nend = Some n)","proofString":"destruct (is_longconst_match a); intros.\ninv LC.\nInvEval.\nsimpl in H5.\ninv H5.\nauto.\ndiscriminate."},{"statement":"(le : letenv) (x : val) (n : int64) (h l : int) (LC : Some (Int64.ofwords h l) = Some n) (H : eval_expr ge sp e m le\n  (Eop Omakelong (Eop (Ointconst h) Enil ::: Eop (Ointconst l) Enil ::: Enil))\n  x) : x = Vlong n.","conclusion":"x = Vlong n","hypotheses":"(le : letenv) (x : val) (n : int64) (h l : int) (LC : Some (Int64.ofwords h l) = Some n) (H : eval_expr ge sp e m le\n  (Eop Omakelong (Eop (Ointconst h) Enil ::: Eop (Ointconst l) Enil ::: Enil))\n  x)","proofString":"inv LC.\nInvEval.\nsimpl in H5.\ninv H5.\nauto."},{"statement":"(le : letenv) (x : val) (h l : int) (H : eval_expr ge sp e m le\n  (Eop Omakelong (Eop (Ointconst h) Enil ::: Eop (Ointconst l) Enil ::: Enil))\n  x) : x = Vlong (Int64.ofwords h l).","conclusion":"x = Vlong (Int64.ofwords h l)","hypotheses":"(le : letenv) (x : val) (h l : int) (H : eval_expr ge sp e m le\n  (Eop Omakelong (Eop (Ointconst h) Enil ::: Eop (Ointconst l) Enil ::: Enil))\n  x)","proofString":"InvEval.\nsimpl in H5.\ninv H5.\nauto."},{"statement":"(le : letenv) (x : val) (h l : int) (H5 : eval_operation ge sp Omakelong (Vint h :: Vint l :: nil) m = Some x) : x = Vlong (Int64.ofwords h l).","conclusion":"x = Vlong (Int64.ofwords h l)","hypotheses":"(le : letenv) (x : val) (h l : int) (H5 : eval_operation ge sp Omakelong (Vint h :: Vint l :: nil) m = Some x)","proofString":"simpl in H5.\ninv H5.\nauto."},{"statement":"(le : letenv) (x : val) (h l : int) (H5 : Some (Vlong (Int64.ofwords h l)) = Some x) : x = Vlong (Int64.ofwords h l).","conclusion":"x = Vlong (Int64.ofwords h l)","hypotheses":"(le : letenv) (x : val) (h l : int) (H5 : Some (Vlong (Int64.ofwords h l)) = Some x)","proofString":"inv H5.\nauto."},{"statement":"(le : letenv) (h l : int) : Vlong (Int64.ofwords h l) = Vlong (Int64.ofwords h l).","conclusion":"Vlong (Int64.ofwords h l) = Vlong (Int64.ofwords h l)","hypotheses":"(le : letenv) (h l : int)","proofString":"auto."},{"statement":"(le : letenv) (x : val) (n : int64) (e0 : expr) (LC : None = Some n) (H : eval_expr ge sp e m le e0 x) : x = Vlong n.","conclusion":"x = Vlong n","hypotheses":"(le : letenv) (x : val) (n : int64) (e0 : expr) (LC : None = Some n) (H : eval_expr ge sp e m le e0 x)","proofString":"discriminate."},{"statement":"(le : letenv) (a : expr) (x : val) (H : match is_longconst a with\n| Some n => Int64.eq n Int64.zero\n| None => false\nend = true) (H0 : eval_expr ge sp e m le a x) : x = Vlong Int64.zero.","conclusion":"x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (H : match is_longconst a with\n| Some n => Int64.eq n Int64.zero\n| None => false\nend = true) (H0 : eval_expr ge sp e m le a x)","proofString":"destruct (is_longconst a) as [n|] eqn:E; try discriminate.\nrevert H.\npredSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nsubst.\neapply is_longconst_sound; eauto.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H : Int64.eq n Int64.zero = true) (H0 : eval_expr ge sp e m le a x) : x = Vlong Int64.zero.","conclusion":"x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H : Int64.eq n Int64.zero = true) (H0 : eval_expr ge sp e m le a x)","proofString":"revert H.\npredSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nsubst.\neapply is_longconst_sound; eauto.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) : Int64.eq n Int64.zero = true -> x = Vlong Int64.zero.","conclusion":"Int64.eq n Int64.zero = true -> x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nintros.\nsubst.\neapply is_longconst_sound; eauto.\ncongruence."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n = Int64.zero) : true = true -> x = Vlong Int64.zero.","conclusion":"true = true -> x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n = Int64.zero)","proofString":"intros.\nsubst.\neapply is_longconst_sound; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n = Int64.zero) (H1 : true = true) : x = Vlong Int64.zero.","conclusion":"x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n = Int64.zero) (H1 : true = true)","proofString":"subst.\neapply is_longconst_sound; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (E : is_longconst a = Some Int64.zero) (H0 : eval_expr ge sp e m le a x) (H1 : true = true) : x = Vlong Int64.zero.","conclusion":"x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (E : is_longconst a = Some Int64.zero) (H0 : eval_expr ge sp e m le a x) (H1 : true = true)","proofString":"eapply is_longconst_sound; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n <> Int64.zero) : false = true -> x = Vlong Int64.zero.","conclusion":"false = true -> x = Vlong Int64.zero","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int64) (E : is_longconst a = Some n) (H0 : eval_expr ge sp e m le a x) (H : n <> Int64.zero)","proofString":"congruence."},{"statement":"forall (le : letenv) (a : expr) (x : val),\neval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match lowlong_match a with\n    | lowlong_case1 _ e2 => e2\n    | lowlong_default e0 => Eop Olowlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.loword x) v.","conclusion":"forall (le : letenv) (a : expr) (x : val),\neval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match lowlong_match a with\n    | lowlong_case1 _ e2 => e2\n    | lowlong_default e0 => Eop Olowlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.loword x) v","hypotheses":"","proofString":"intros until x.\ndestruct (lowlong_match a); intros.\nInvEval; subst.\nexists v0; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexists (Val.loword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match lowlong_match a with\n    | lowlong_case1 _ e2 => e2\n    | lowlong_default e0 => Eop Olowlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.loword x) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match lowlong_match a with\n    | lowlong_case1 _ e2 => e2\n    | lowlong_default e0 => Eop Olowlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.loword x) v","hypotheses":"(le : letenv) (a : expr) (x : val)","proofString":"destruct (lowlong_match a); intros.\nInvEval; subst.\nexists v0; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto.\nexists (Val.loword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (x : val) (e1 e2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (e1 ::: e2 ::: Enil)) x) : exists v : val, eval_expr ge sp e m le e2 v /\\ Val.lessdef (Val.loword x) v.","conclusion":"exists v : val, eval_expr ge sp e m le e2 v /\\ Val.lessdef (Val.loword x) v","hypotheses":"(le : letenv) (x : val) (e1 e2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (e1 ::: e2 ::: Enil)) x)","proofString":"InvEval; subst.\nexists v0; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) : exists v : val,\n  eval_expr ge sp e m le e2 v /\\\n  Val.lessdef (Val.loword (Val.longofwords v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le e2 v /\\\n  Val.lessdef (Val.loword (Val.longofwords v1 v0)) v","hypotheses":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"exists v0; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) : Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0.","conclusion":"Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0","hypotheses":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"destruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i : int) (v0 : val) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 v0) : Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0.","conclusion":"Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0","hypotheses":"(le : letenv) (e1 e2 : expr) (i : int) (v0 : val) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"destruct v0; simpl; auto.\nrewrite Int64.lo_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0)) : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0).","conclusion":"Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)","hypotheses":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0))","proofString":"rewrite Int64.lo_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0)) : Val.lessdef (Vint i0) (Vint i0).","conclusion":"Val.lessdef (Vint i0) (Vint i0)","hypotheses":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0))","proofString":"auto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.loword x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.loword x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"exists (Val.loword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) (Val.loword x).","conclusion":"eval_expr ge sp e m le (Eop Olowlong (e0 ::: Enil)) (Val.loword x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"EvalOp."},{"statement":"forall (le : letenv) (a : expr) (x : val),\neval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match highlong_match a with\n    | highlong_case1 e1 _ => e1\n    | highlong_default e0 => Eop Ohighlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.hiword x) v.","conclusion":"forall (le : letenv) (a : expr) (x : val),\neval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match highlong_match a with\n    | highlong_case1 e1 _ => e1\n    | highlong_default e0 => Eop Ohighlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.hiword x) v","hypotheses":"","proofString":"intros until x.\ndestruct (highlong_match a); intros.\nInvEval; subst.\nexists v1; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexists (Val.hiword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match highlong_match a with\n    | highlong_case1 e1 _ => e1\n    | highlong_default e0 => Eop Ohighlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.hiword x) v.","conclusion":"eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match highlong_match a with\n    | highlong_case1 e1 _ => e1\n    | highlong_default e0 => Eop Ohighlong (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.hiword x) v","hypotheses":"(le : letenv) (a : expr) (x : val)","proofString":"destruct (highlong_match a); intros.\nInvEval; subst.\nexists v1; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto.\nexists (Val.hiword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (x : val) (e1 e2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (e1 ::: e2 ::: Enil)) x) : exists v : val, eval_expr ge sp e m le e1 v /\\ Val.lessdef (Val.hiword x) v.","conclusion":"exists v : val, eval_expr ge sp e m le e1 v /\\ Val.lessdef (Val.hiword x) v","hypotheses":"(le : letenv) (x : val) (e1 e2 : expr) (H : eval_expr ge sp e m le (Eop Omakelong (e1 ::: e2 ::: Enil)) x)","proofString":"InvEval; subst.\nexists v1; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) : exists v : val,\n  eval_expr ge sp e m le e1 v /\\\n  Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le e1 v /\\\n  Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v","hypotheses":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"exists v1; split; auto.\ndestruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) : Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1.","conclusion":"Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1","hypotheses":"(le : letenv) (e1 e2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"destruct v1; simpl; auto.\ndestruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i : int) (v0 : val) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 v0) : Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i).","conclusion":"Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)","hypotheses":"(le : letenv) (e1 e2 : expr) (i : int) (v0 : val) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 v0)","proofString":"destruct v0; simpl; auto.\nrewrite Int64.hi_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0)) : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i).","conclusion":"Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)","hypotheses":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0))","proofString":"rewrite Int64.hi_ofwords.\nauto."},{"statement":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0)) : Val.lessdef (Vint i) (Vint i).","conclusion":"Val.lessdef (Vint i) (Vint i)","hypotheses":"(le : letenv) (e1 e2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le e1 (Vint i)) (H3 : eval_expr ge sp e m le e2 (Vint i0))","proofString":"auto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Ohighlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.hiword x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eop Ohighlong (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.hiword x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"exists (Val.hiword x); split; auto.\nEvalOp."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : eval_expr ge sp e m le (Eop Ohighlong (e0 ::: Enil)) (Val.hiword x).","conclusion":"eval_expr ge sp e m le (Eop Ohighlong (e0 ::: Enil)) (Val.hiword x)","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"EvalOp."},{"statement":"(le : letenv) (n : int64) : eval_expr ge sp e m le (longconst n) (Vlong n).","conclusion":"eval_expr ge sp e m le (longconst n) (Vlong n)","hypotheses":"(le : letenv) (n : int64)","proofString":"EvalOp.\nrewrite Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (n : int64) : Some (Vlong (Int64.ofwords (Int64.hiword n) (Int64.loword n))) =\nSome (Vlong n).","conclusion":"Some (Vlong (Int64.ofwords (Int64.hiword n) (Int64.loword n))) =\nSome (Vlong n)","hypotheses":"(le : letenv) (n : int64)","proofString":"rewrite Int64.ofwords_recompose; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (longofintu a) v /\\ Val.lessdef (Val.longofintu x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longofintu a) v /\\ Val.lessdef (Val.longofintu x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold longofintu.\neconstructor; split.\nEvalOp.\nunfold Val.longofintu.\ndestruct x; auto.\nreplace (Int64.repr (Int.unsigned i)) with (Int64.ofwords Int.zero i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a) v /\\\n  Val.lessdef (Val.longofintu x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a) v /\\\n  Val.lessdef (Val.longofintu x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split.\nEvalOp.\nunfold Val.longofintu.\ndestruct x; auto.\nreplace (Int64.repr (Int.unsigned i)) with (Int64.ofwords Int.zero i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef\n  match x with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef\n  match x with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; auto.\nreplace (Int64.repr (Int.unsigned i)) with (Int64.ofwords Int.zero i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i)).","conclusion":"Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i))","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"replace (Int64.repr (Int.unsigned i)) with (Int64.ofwords Int.zero i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Int64.ofwords Int.zero i = Int64.repr (Int.unsigned i).","conclusion":"Int64.ofwords Int.zero i = Int64.repr (Int.unsigned i)","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i))","proofString":"apply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : Int64.testbit (Int64.ofwords Int.zero i) i0 =\nInt64.testbit (Int64.repr (Int.unsigned i)) i0.","conclusion":"Int64.testbit (Int64.ofwords Int.zero i) i0 =\nInt64.testbit (Int64.repr (Int.unsigned i)) i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"rewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : Int64.testbit (Int64.ofwords Int.zero i) i0 = Z.testbit (Int.unsigned i) i0.","conclusion":"Int64.testbit (Int64.ofwords Int.zero i) i0 = Z.testbit (Int.unsigned i) i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"rewrite Int64.bits_ofwords by auto.\nfold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : (if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit Int.zero (i0 - Int.zwordsize)) =\nZ.testbit (Int.unsigned i) i0.","conclusion":"(if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit Int.zero (i0 - Int.zwordsize)) =\nZ.testbit (Int.unsigned i) i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"fold (Int.testbit i i0).\ndestruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : (if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit Int.zero (i0 - Int.zwordsize)) = \nInt.testbit i i0.","conclusion":"(if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit Int.zero (i0 - Int.zwordsize)) = \nInt.testbit i i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"destruct (zlt i0 Int.zwordsize).\nauto.\nrewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (l : i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit i i0.","conclusion":"Int.testbit i i0 = Int.testbit i i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (l : i0 < Int.zwordsize)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) : Int.testbit Int.zero (i0 - Int.zwordsize) = Int.testbit i i0.","conclusion":"Int.testbit Int.zero (i0 - Int.zwordsize) = Int.testbit i i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize)","proofString":"rewrite Int.bits_zero.\nrewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) : false = Int.testbit i i0.","conclusion":"false = Int.testbit i i0","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize)","proofString":"rewrite Int.bits_above by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) : false = false.","conclusion":"false = false","hypotheses":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (longofint a) v /\\ Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longofint a) v /\\ Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold longofint.\ndestruct (longofint_match a).\nInvEval.\neconstructor; split.\napply eval_longconst.\nauto.\nexploit (eval_shrimm ge sp e m (Int.repr 31) (x :: le) (Eletvar 0)).\nEvalOp.\nintros [v1 [A B]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\nsimpl in B.\ninv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    match longofint_match a with\n    | longofint_case1 n => longconst (Int64.repr (Int.signed n))\n    | longofint_default e0 =>\n        Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))\n    end v /\\ Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match longofint_match a with\n    | longofint_case1 n => longconst (Int64.repr (Int.signed n))\n    | longofint_default e0 =>\n        Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))\n    end v /\\ Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct (longofint_match a).\nInvEval.\neconstructor; split.\napply eval_longconst.\nauto.\nexploit (eval_shrimm ge sp e m (Int.repr 31) (x :: le) (Eletvar 0)).\nEvalOp.\nintros [v1 [A B]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\nsimpl in B.\ninv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (x : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (x : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x)","proofString":"InvEval.\neconstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (n : int) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v /\\\n  Val.lessdef (Val.longofint (Vint n)) v","hypotheses":"(le : letenv) (n : int)","proofString":"econstructor; split.\napply eval_longconst.\nauto."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v /\\\n  Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v /\\\n  Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x)","proofString":"exploit (eval_shrimm ge sp e m (Int.repr 31) (x :: le) (Eletvar 0)).\nEvalOp.\nintros [v1 [A B]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\nsimpl in B.\ninv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (v1 : val) (A : eval_expr ge sp e m (x :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef (Val.shr x (Vint (Int.repr 31))) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v /\\\n  Val.lessdef (Val.longofint x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v /\\\n  Val.lessdef (Val.longofint x) v","hypotheses":"(le : letenv) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (v1 : val) (A : eval_expr ge sp e m (x :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef (Val.shr x (Vint (Int.repr 31))) v1)","proofString":"econstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\nsimpl in B.\ninv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (v1 : val) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef (Val.shr (Vint i) (Vint (Int.repr 31))) v1) : Val.lessdef (Vlong (Int64.repr (Int.signed i))) (Val.longofwords v1 (Vint i)).","conclusion":"Val.lessdef (Vlong (Int64.repr (Int.signed i))) (Val.longofwords v1 (Vint i))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (v1 : val) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef (Val.shr (Vint i) (Vint (Int.repr 31))) v1)","proofString":"simpl in B.\ninv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (v1 : val) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef) v1) : Val.lessdef (Vlong (Int64.repr (Int.signed i))) (Val.longofwords v1 (Vint i)).","conclusion":"Val.lessdef (Vlong (Int64.repr (Int.signed i))) (Val.longofwords v1 (Vint i))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (v1 : val) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31)) v1) (B : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef) v1)","proofString":"inv B.\nsimpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i)).","conclusion":"Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef))","proofString":"simpl.\nreplace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i)).","conclusion":"Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef))","proofString":"replace (Int64.repr (Int.signed i))     with (Int64.ofwords (Int.shr i (Int.repr 31)) i); auto.\napply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) : Int64.ofwords (Int.shr i (Int.repr 31)) i = Int64.repr (Int.signed i).","conclusion":"Int64.ofwords (Int.shr i (Int.repr 31)) i = Int64.repr (Int.signed i)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef))","proofString":"apply Int64.same_bits_eq; intros.\nrewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0 =\nInt64.testbit (Int64.repr (Int.signed i)) i0.","conclusion":"Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0 =\nInt64.testbit (Int64.repr (Int.signed i)) i0","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"rewrite Int64.testbit_repr by auto.\nrewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0 =\nZ.testbit (Int.signed i) i0.","conclusion":"Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0 =\nZ.testbit (Int.signed i) i0","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"rewrite Int64.bits_ofwords by auto.\nrewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : (if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize)) =\nZ.testbit (Int.signed i) i0.","conclusion":"(if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize)) =\nZ.testbit (Int.signed i) i0","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"rewrite Int.bits_signed by lia.\ndestruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) : (if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize)) =\nInt.testbit i (if zlt i0 Int.zwordsize then i0 else Int.zwordsize - 1).","conclusion":"(if zlt i0 Int.zwordsize\n then Int.testbit i i0\n else Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize)) =\nInt.testbit i (if zlt i0 Int.zwordsize then i0 else Int.zwordsize - 1)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize)","proofString":"destruct (zlt i0 Int.zwordsize).\nauto.\nassert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (l : i0 < Int.zwordsize) : Int.testbit i i0 = Int.testbit i i0.","conclusion":"Int.testbit i i0 = Int.testbit i i0","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (l : i0 < Int.zwordsize)","proofString":"auto."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) : Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize) =\nInt.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize) =\nInt.testbit i (Int.zwordsize - 1)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize)","proofString":"assert (Int64.zwordsize = 2 * Int.zwordsize) by reflexivity.\nrewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize) : Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize) =\nInt.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit (Int.shr i (Int.repr 31)) (i0 - Int.zwordsize) =\nInt.testbit i (Int.zwordsize - 1)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize)","proofString":"rewrite Int.bits_shr by lia.\nchange (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize) : Int.testbit i\n  (if zlt (i0 - Int.zwordsize + Int.unsigned (Int.repr 31)) Int.zwordsize\n   then i0 - Int.zwordsize + Int.unsigned (Int.repr 31)\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (i0 - Int.zwordsize + Int.unsigned (Int.repr 31)) Int.zwordsize\n   then i0 - Int.zwordsize + Int.unsigned (Int.repr 31)\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize)","proofString":"change (Int.unsigned (Int.repr 31)) with (Int.zwordsize - 1).\nf_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize) : Int.testbit i\n  (if zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize\n   then i0 - Int.zwordsize + (Int.zwordsize - 1)\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1).","conclusion":"Int.testbit i\n  (if zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize\n   then i0 - Int.zwordsize + (Int.zwordsize - 1)\n   else Int.zwordsize - 1) = Int.testbit i (Int.zwordsize - 1)","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize)","proofString":"f_equal.\ndestruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize) : (if zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize\n then i0 - Int.zwordsize + (Int.zwordsize - 1)\n else Int.zwordsize - 1) = Int.zwordsize - 1.","conclusion":"(if zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize\n then i0 - Int.zwordsize + (Int.zwordsize - 1)\n else Int.zwordsize - 1) = Int.zwordsize - 1","hypotheses":"(le : letenv) (i : int) (e0 : expr) (H : eval_expr ge sp e m le e0 (Vint i)) (A : eval_expr ge sp e m (Vint i :: le) (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)) (i0 : Z) (H0 : 0 <= i0 < Int64.zwordsize) (g : i0 >= Int.zwordsize) (H1 : Int64.zwordsize = 2 * Int.zwordsize)","proofString":"destruct (zlt (i0 - Int.zwordsize + (Int.zwordsize - 1)) Int.zwordsize); lia."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n => longconst (Int64.neg n)\n    | None => Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)\n    end v /\\ Val.lessdef (Val.negl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n => longconst (Int64.neg n)\n    | None => Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)\n    end v /\\ Val.lessdef (Val.negl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct (is_longconst a) eqn:E.\neconstructor; split.\napply eval_longconst.\nexploit is_longconst_sound; eauto.\nintros EQ; subst x.\nsimpl.\nauto.\nexists (Val.negl x); split; auto.\neapply (eval_builtin_1 (BI_standard BI_negl)); eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int64) (E : is_longconst a = Some i) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.neg i)) v /\\\n  Val.lessdef (Val.negl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.neg i)) v /\\\n  Val.lessdef (Val.negl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int64) (E : is_longconst a = Some i)","proofString":"econstructor; split.\napply eval_longconst.\nexploit is_longconst_sound; eauto.\nintros EQ; subst x.\nsimpl.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int64) (E : is_longconst a = Some i) : x = Vlong i -> Val.lessdef (Val.negl x) (Vlong (Int64.neg i)).","conclusion":"x = Vlong i -> Val.lessdef (Val.negl x) (Vlong (Int64.neg i))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (i : int64) (E : is_longconst a = Some i)","proofString":"intros EQ; subst x.\nsimpl.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (E : is_longconst a = Some i) : Val.lessdef (Val.negl (Vlong i)) (Vlong (Int64.neg i)).","conclusion":"Val.lessdef (Val.negl (Vlong i)) (Vlong (Int64.neg i))","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (E : is_longconst a = Some i)","proofString":"simpl.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (E : is_longconst a = Some i) : Val.lessdef (Vlong (Int64.neg i)) (Vlong (Int64.neg i)).","conclusion":"Val.lessdef (Vlong (Int64.neg i)) (Vlong (Int64.neg i))","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (E : is_longconst a = Some i)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (E : is_longconst a = None) : exists v : val,\n  eval_expr ge sp e m le\n    (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)) v /\\\n  Val.lessdef (Val.negl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)) v /\\\n  Val.lessdef (Val.negl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (E : is_longconst a = None)","proofString":"exists (Val.negl x); split; auto.\neapply (eval_builtin_1 (BI_standard BI_negl)); eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (E : is_longconst a = None) : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)) \n  (Val.negl x).","conclusion":"eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (a ::: Enil)) \n  (Val.negl x)","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (E : is_longconst a = None)","proofString":"eapply (eval_builtin_1 (BI_standard BI_negl)); eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.notl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (notl a) v /\\ Val.lessdef (Val.notl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"unfold notl.\napply eval_splitlong; auto.\nintros.\nexploit eval_notint.\neexact H0.\nintros [va [A B]].\nexploit eval_notint.\neexact H1.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto.\ndestruct x; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a (fun h l : expr => makelong (notint h) (notint l))) v /\\\n  Val.lessdef (Val.notl x) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a (fun h l : expr => makelong (notint h) (notint l))) v /\\\n  Val.lessdef (Val.notl x) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_splitlong; auto.\nintros.\nexploit eval_notint.\neexact H0.\nintros [va [A B]].\nexploit eval_notint.\neexact H1.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto.\ndestruct x; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q))).","conclusion":"forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q)))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"intros.\nexploit eval_notint.\neexact H0.\nintros [va [A B]].\nexploit eval_notint.\neexact H1.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q)))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y)","proofString":"exploit eval_notint.\neexact H0.\nintros [va [A B]].\nexploit eval_notint.\neexact H1.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q)))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va)","proofString":"exploit eval_notint.\neexact H1.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v /\\\n  (forall p q : int,\n   x0 = Vint p -> y = Vint q -> v = Val.notl (Vlong (Int64.ofwords p q)))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb)","proofString":"exists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb) : eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n  (Val.longofwords va vb).","conclusion":"eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n  (Val.longofwords va vb)","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb)","proofString":"EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb) : forall p q : int,\nx0 = Vint p ->\ny = Vint q -> Val.longofwords va vb = Val.notl (Vlong (Int64.ofwords p q)).","conclusion":"forall p q : int,\nx0 = Vint p ->\ny = Vint q -> Val.longofwords va vb = Val.notl (Vlong (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (x0 y : val) (H0 : eval_expr ge sp e m le0 a0 x0) (H1 : eval_expr ge sp e m le0 b y) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint x0) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint y) vb)","proofString":"intros; subst.\nsimpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint (Vint p)) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint (Vint q)) vb) : Val.longofwords va vb = Val.notl (Vlong (Int64.ofwords p q)).","conclusion":"Val.longofwords va vb = Val.notl (Vlong (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Val.notint (Vint p)) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Val.notint (Vint q)) vb)","proofString":"simpl in *.\ninv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Vint (Int.not p)) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Vint (Int.not q)) vb) : Val.longofwords va vb = Vlong (Int64.not (Int64.ofwords p q)).","conclusion":"Val.longofwords va vb = Vlong (Int64.not (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (va : val) (A : eval_expr ge sp e m le0 (notint a0) va) (B : Val.lessdef (Vint (Int.not p)) va) (vb : val) (C : eval_expr ge sp e m le0 (notint b) vb) (D : Val.lessdef (Vint (Int.not q)) vb)","proofString":"inv B; inv D.\nsimpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q))) : Val.longofwords (Vint (Int.not p)) (Vint (Int.not q)) =\nVlong (Int64.not (Int64.ofwords p q)).","conclusion":"Val.longofwords (Vint (Int.not p)) (Vint (Int.not q)) =\nVlong (Int64.not (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q)))","proofString":"simpl.\nunfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q))) : Vlong (Int64.ofwords (Int.not p) (Int.not q)) =\nVlong (Int64.not (Int64.ofwords p q)).","conclusion":"Vlong (Int64.ofwords (Int.not p) (Int.not q)) =\nVlong (Int64.not (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q)))","proofString":"unfold Int.not.\nrewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q))) : Vlong (Int64.ofwords (Int.xor p Int.mone) (Int.xor q Int.mone)) =\nVlong (Int64.not (Int64.ofwords p q)).","conclusion":"Vlong (Int64.ofwords (Int.xor p Int.mone) (Int.xor q Int.mone)) =\nVlong (Int64.not (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q)))","proofString":"rewrite <- Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q))) : Vlong (Int64.xor (Int64.ofwords p q) (Int64.ofwords Int.mone Int.mone)) =\nVlong (Int64.not (Int64.ofwords p q)).","conclusion":"Vlong (Int64.xor (Int64.ofwords p q) (Int64.ofwords Int.mone Int.mone)) =\nVlong (Int64.not (Int64.ofwords p q))","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (le0 : letenv) (a0 b : expr) (p : int) (H0 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H1 : eval_expr ge sp e m le0 b (Vint q)) (A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))) (C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : match x with\n| Vlong _ => True\n| _ => Val.notl x = Vundef\nend.","conclusion":"match x with\n| Vlong _ => True\n| _ => Val.notl x = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longoffloat x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longoffloat x = Some y)","proofString":"econstructor; split.\neapply (eval_helper_1 (BI_standard BI_i64_dtos)); eauto.\nDeclHelper.\nauto.\nauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuoffloat x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuoffloat x = Some y)","proofString":"econstructor; split.\neapply (eval_helper_1 (BI_standard BI_i64_dtou)); eauto.\nDeclHelper.\nauto.\nauto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y)","proofString":"exists y; split; auto.\neapply (eval_helper_1 (BI_standard BI_i64_stod)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) : eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (a ::: Enil)) y.","conclusion":"eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (a ::: Enil)) y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y)","proofString":"eapply (eval_helper_1 (BI_standard BI_i64_stod)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) : builtin_function_sem (BI_standard BI_i64_stod) (x :: nil) = Some y.","conclusion":"builtin_function_sem (BI_standard BI_i64_stod) (x :: nil) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y)","proofString":"simpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y) : Some match x with\n     | Vlong n => Vfloat (Float.of_long n)\n     | _ => Vundef\n     end = Some y.","conclusion":"Some match x with\n     | Vlong n => Vfloat (Float.of_long n)\n     | _ => Vundef\n     end = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflong x = Some y)","proofString":"destruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y)","proofString":"exists y; split; auto.\neapply (eval_helper_1 (BI_standard BI_i64_utod)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y) : eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (a ::: Enil)) y.","conclusion":"eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (a ::: Enil)) y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y)","proofString":"eapply (eval_helper_1 (BI_standard BI_i64_utod)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y) : builtin_function_sem (BI_standard BI_i64_utod) (x :: nil) = Some y.","conclusion":"builtin_function_sem (BI_standard BI_i64_utod) (x :: nil) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y)","proofString":"simpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y) : Some match x with\n     | Vlong n => Vfloat (Float.of_longu n)\n     | _ => Vundef\n     end = Some y.","conclusion":"Some match x with\n     | Vlong n => Vfloat (Float.of_longu n)\n     | _ => Vundef\n     end = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.floatoflongu x = Some y)","proofString":"destruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longofsingle x = Some y) : exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\ Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\ Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longofsingle x = Some y)","proofString":"destruct x; simpl in H0; inv H0.\ndestruct (Float32.to_long f) as [n|] eqn:EQ; simpl in H2; inv H2.\nexploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H2 : option_map Vlong (Float32.to_long f) = Some y) : exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\ Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\ Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H2 : option_map Vlong (Float32.to_long f) = Some y)","proofString":"destruct (Float32.to_long f) as [n|] eqn:EQ; simpl in H2; inv H2.\nexploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) : exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n)","proofString":"exploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) : (exists v : val,\n   eval_expr ge sp e m le (floatofsingle a) v /\\\n   Val.lessdef (Val.floatofsingle (Vsingle f)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (floatofsingle a) v /\\\n   Val.lessdef (Val.floatofsingle (Vsingle f)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n)","proofString":"intros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Val.floatofsingle (Vsingle f)) v) : exists v0 : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Val.floatofsingle (Vsingle f)) v)","proofString":"simpl in B.\ninv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Vfloat (Float.of_single f)) v) : exists v0 : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Vfloat (Float.of_single f)) v)","proofString":"inv B.\napply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_long f = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"apply Float32.to_long_double in EQ.\neapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"eapply eval_longoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : Val.longoffloat (Vfloat (Float.of_single f)) = Some (Vlong n).","conclusion":"Val.longoffloat (Vfloat (Float.of_single f)) = Some (Vlong n)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"simpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : option_map Vlong (Float.to_long (Float.of_single f)) = Some (Vlong n).","conclusion":"option_map Vlong (Float.to_long (Float.of_single f)) = Some (Vlong n)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_long (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"change (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuofsingle x = Some y) : exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.longuofsingle x = Some y)","proofString":"destruct x; simpl in H0; inv H0.\ndestruct (Float32.to_longu f) as [n|] eqn:EQ; simpl in H2; inv H2.\nexploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H2 : option_map Vlong (Float32.to_longu f) = Some y) : exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (f : float32) (y : val) (H : eval_expr ge sp e m le a (Vsingle f)) (H2 : option_map Vlong (Float32.to_longu f) = Some y)","proofString":"destruct (Float32.to_longu f) as [n|] eqn:EQ; simpl in H2; inv H2.\nexploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) : exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n)","proofString":"exploit eval_floatofsingle; eauto.\nintros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) : (exists v : val,\n   eval_expr ge sp e m le (floatofsingle a) v /\\\n   Val.lessdef (Val.floatofsingle (Vsingle f)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (floatofsingle a) v /\\\n   Val.lessdef (Val.floatofsingle (Vsingle f)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n)","proofString":"intros (v & A & B).\nsimpl in B.\ninv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Val.floatofsingle (Vsingle f)) v) : exists v0 : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Val.floatofsingle (Vsingle f)) v)","proofString":"simpl in B.\ninv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Vfloat (Float.of_single f)) v) : exists v0 : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v0 /\\\n  Val.lessdef (Vlong n) v0","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (v : val) (A : eval_expr ge sp e m le (floatofsingle a) v) (B : Val.lessdef (Vfloat (Float.of_single f)) v)","proofString":"inv B.\napply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float32.to_longu f = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"apply Float32.to_longu_double in EQ.\neapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v /\\\n  Val.lessdef (Vlong n) v","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"eapply eval_longuoffloat; eauto.\nsimpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : Val.longuoffloat (Vfloat (Float.of_single f)) = Some (Vlong n).","conclusion":"Val.longuoffloat (Vfloat (Float.of_single f)) = Some (Vlong n)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"simpl.\nchange (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))) : option_map Vlong (Float.to_longu (Float.of_single f)) = Some (Vlong n).","conclusion":"option_map Vlong (Float.to_longu (Float.of_single f)) = Some (Vlong n)","hypotheses":"(le : letenv) (a : expr) (f : float32) (H : eval_expr ge sp e m le a (Vsingle f)) (n : int64) (EQ : Float.to_longu (Float32.to_double f) = Some n) (A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f)))","proofString":"change (Float.of_single f) with (Float32.to_double f); rewrite EQ; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y)","proofString":"exists y; split; auto.\neapply (eval_helper_1 (BI_standard BI_i64_stof)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) : eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (a ::: Enil)) y.","conclusion":"eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (a ::: Enil)) y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y)","proofString":"eapply (eval_helper_1 (BI_standard BI_i64_stof)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) : builtin_function_sem (BI_standard BI_i64_stof) (x :: nil) = Some y.","conclusion":"builtin_function_sem (BI_standard BI_i64_stof) (x :: nil) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y)","proofString":"simpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y) : Some match x with\n     | Vlong n => Vsingle (Float32.of_long n)\n     | _ => Vundef\n     end = Some y.","conclusion":"Some match x with\n     | Vlong n => Vsingle (Float32.of_long n)\n     | _ => Vundef\n     end = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflong x = Some y)","proofString":"destruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (a ::: Enil)) v /\\\n  Val.lessdef y v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (a ::: Enil)) v /\\\n  Val.lessdef y v","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y)","proofString":"exists y; split; auto.\neapply (eval_helper_1 (BI_standard BI_i64_utof)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y) : eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (a ::: Enil)) y.","conclusion":"eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (a ::: Enil)) y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y)","proofString":"eapply (eval_helper_1 (BI_standard BI_i64_utof)); eauto.\nDeclHelper.\nauto.\nsimpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y) : builtin_function_sem (BI_standard BI_i64_utof) (x :: nil) = Some y.","conclusion":"builtin_function_sem (BI_standard BI_i64_utof) (x :: nil) = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y)","proofString":"simpl.\ndestruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y) : Some match x with\n     | Vlong n => Vsingle (Float32.of_longu n)\n     | _ => Vundef\n     end = Some y.","conclusion":"Some match x with\n     | Vlong n => Vsingle (Float32.of_longu n)\n     | _ => Vundef\n     end = Some y","hypotheses":"(le : letenv) (a : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : Val.singleoflongu x = Some y)","proofString":"destruct x; simpl in H0; inv H0; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (andl a b) v /\\ Val.lessdef (Val.andl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (andl a b) v /\\ Val.lessdef (Val.andl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"unfold andl.\napply eval_splitlong2; auto.\nintros.\nexploit eval_and.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_and.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (and h1 h2) (and l1 l2))) v /\\\n  Val.lessdef (Val.andl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (and h1 h2) (and l1 l2))) v /\\\n  Val.lessdef (Val.andl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"apply eval_splitlong2; auto.\nintros.\nexploit eval_and.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_and.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"intros.\nexploit eval_and.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_and.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2)","proofString":"exploit eval_and.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_and.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va)","proofString":"exploit eval_and.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb)","proofString":"exists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb) : eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n  (Val.longofwords va vb).","conclusion":"eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n  (Val.longofwords va vb)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb)","proofString":"EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb) : forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and x2 y2) vb)","proofString":"intros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb) : Val.longofwords va vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords va vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (and a1 b1) va) (B : Val.lessdef (Val.and (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb)","proofString":"simpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb) : Val.longofwords (Vint (Int.and p1 q1)) vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.and p1 q1)) vb =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (and a2 b2) vb) (D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb)","proofString":"simpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2))) : Val.longofwords (Vint (Int.and p1 q1)) (Vint (Int.and p2 q2)) =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.and p1 q1)) (Vint (Int.and p2 q2)) =\nVal.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2)))","proofString":"simpl.\nf_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2))) : Vlong (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2)) =\nVlong (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Vlong (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2)) =\nVlong (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2)))","proofString":"f_equal.\nrewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2))) : Int64.ofwords (Int.and p1 q1) (Int.and p2 q2) =\nInt64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2).","conclusion":"Int64.ofwords (Int.and p1 q1) (Int.and p2 q2) =\nInt64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2)))","proofString":"rewrite Int64.decompose_and.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2))) : Int64.ofwords (Int.and p1 q1) (Int.and p2 q2) =\nInt64.ofwords (Int.and p1 q1) (Int.and p2 q2).","conclusion":"Int64.ofwords (Int.and p1 q1) (Int.and p2 q2) =\nInt64.ofwords (Int.and p1 q1) (Int.and p2 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))) (C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.andl x y = Vundef\n             end\n| _ => Val.andl x y = Vundef\nend.","conclusion":"match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.andl x y = Vundef\n             end\n| _ => Val.andl x y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y) : match y with\n| Vlong _ => True\n| _ => Val.andl (Vlong i) y = Vundef\nend.","conclusion":"match y with\n| Vlong _ => True\n| _ => Val.andl (Vlong i) y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (orl a b) v /\\ Val.lessdef (Val.orl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (orl a b) v /\\ Val.lessdef (Val.orl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"unfold orl.\napply eval_splitlong2; auto.\nintros.\nexploit eval_or.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_or.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (or h1 h2) (or l1 l2))) v /\\\n  Val.lessdef (Val.orl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (or h1 h2) (or l1 l2))) v /\\\n  Val.lessdef (Val.orl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"apply eval_splitlong2; auto.\nintros.\nexploit eval_or.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_or.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"intros.\nexploit eval_or.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_or.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2)","proofString":"exploit eval_or.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_or.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va)","proofString":"exploit eval_or.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb)","proofString":"exists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb) : eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n  (Val.longofwords va vb).","conclusion":"eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n  (Val.longofwords va vb)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb)","proofString":"EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb) : forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or x2 y2) vb)","proofString":"intros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb) : Val.longofwords va vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords va vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (or a1 b1) va) (B : Val.lessdef (Val.or (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb)","proofString":"simpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb) : Val.longofwords (Vint (Int.or p1 q1)) vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.or p1 q1)) vb =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (or a2 b2) vb) (D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb)","proofString":"simpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2))) : Val.longofwords (Vint (Int.or p1 q1)) (Vint (Int.or p2 q2)) =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.or p1 q1)) (Vint (Int.or p2 q2)) =\nVal.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2)))","proofString":"simpl.\nf_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2))) : Vlong (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2)) =\nVlong (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Vlong (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2)) =\nVlong (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2)))","proofString":"f_equal.\nrewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2))) : Int64.ofwords (Int.or p1 q1) (Int.or p2 q2) =\nInt64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2).","conclusion":"Int64.ofwords (Int.or p1 q1) (Int.or p2 q2) =\nInt64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2)))","proofString":"rewrite Int64.decompose_or.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2))) : Int64.ofwords (Int.or p1 q1) (Int.or p2 q2) =\nInt64.ofwords (Int.or p1 q1) (Int.or p2 q2).","conclusion":"Int64.ofwords (Int.or p1 q1) (Int.or p2 q2) =\nInt64.ofwords (Int.or p1 q1) (Int.or p2 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))) (C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.orl x y = Vundef\n             end\n| _ => Val.orl x y = Vundef\nend.","conclusion":"match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.orl x y = Vundef\n             end\n| _ => Val.orl x y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y) : match y with\n| Vlong _ => True\n| _ => Val.orl (Vlong i) y = Vundef\nend.","conclusion":"match y with\n| Vlong _ => True\n| _ => Val.orl (Vlong i) y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (xorl a b) v /\\ Val.lessdef (Val.xorl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (xorl a b) v /\\ Val.lessdef (Val.xorl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"unfold xorl.\napply eval_splitlong2; auto.\nintros.\nexploit eval_xor.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_xor.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (xor h1 h2) (xor l1 l2))) v /\\\n  Val.lessdef (Val.xorl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr => makelong (xor h1 h2) (xor l1 l2))) v /\\\n  Val.lessdef (Val.xorl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"apply eval_splitlong2; auto.\nintros.\nexploit eval_xor.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_xor.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto.\ndestruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"intros.\nexploit eval_xor.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_xor.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2)","proofString":"exploit eval_xor.\neexact H1.\neexact H3.\nintros [va [A B]].\nexploit eval_xor.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va)","proofString":"exploit eval_xor.\neexact H2.\neexact H4.\nintros [vb [C D]].\nexists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb) : exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb)","proofString":"exists (Val.longofwords va vb); split.\nEvalOp.\nintros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb) : eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n  (Val.longofwords va vb).","conclusion":"eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n  (Val.longofwords va vb)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb)","proofString":"EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb) : forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"forall p1 p2 q1 q2 : int,\nx1 = Vint p1 ->\nx2 = Vint p2 ->\ny1 = Vint q1 ->\ny2 = Vint q2 ->\nVal.longofwords va vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor x1 y1) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor x2 y2) vb)","proofString":"intros; subst.\nsimpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb) : Val.longofwords va vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords va vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (va : val) (A : eval_expr ge sp e m le0 (xor a1 b1) va) (B : Val.lessdef (Val.xor (Vint p1) (Vint q1)) va) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb)","proofString":"simpl in B; inv B.\nsimpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb) : Val.longofwords (Vint (Int.xor p1 q1)) vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.xor p1 q1)) vb =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (vb : val) (C : eval_expr ge sp e m le0 (xor a2 b2) vb) (D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb)","proofString":"simpl in D; inv D.\nsimpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2))) : Val.longofwords (Vint (Int.xor p1 q1)) (Vint (Int.xor p2 q2)) =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords (Vint (Int.xor p1 q1)) (Vint (Int.xor p2 q2)) =\nVal.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2)))","proofString":"simpl.\nf_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2))) : Vlong (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2)) =\nVlong (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Vlong (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2)) =\nVlong (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2)))","proofString":"f_equal.\nrewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2))) : Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2) =\nInt64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2).","conclusion":"Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2) =\nInt64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2)))","proofString":"rewrite Int64.decompose_xor.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2))) : Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2) =\nInt64.ofwords (Int.xor p1 q1) (Int.xor p2 q2).","conclusion":"Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2) =\nInt64.ofwords (Int.xor p1 q1) (Int.xor p2 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))) (C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2)))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.xorl x y = Vundef\n             end\n| _ => Val.xorl x y = Vundef\nend.","conclusion":"match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.xorl x y = Vundef\n             end\n| _ => Val.xorl x y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct x; auto.\ndestruct y; auto."},{"statement":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y) : match y with\n| Vlong _ => True\n| _ => Val.xorl (Vlong i) y = Vundef\nend.","conclusion":"match y with\n| Vlong _ => True\n| _ => Val.xorl (Vlong i) y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (i : int64) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (n : int) (LC : match a with\n| Eop (Ointconst n0) Enil => Some n0\n| Eop (Ointconst n0) (_ ::: _) => None\n| _ => None\nend = Some n) : eval_expr ge sp e m le a x -> x = Vint n.","conclusion":"eval_expr ge sp e m le a x -> x = Vint n","hypotheses":"(le : letenv) (a : expr) (x : val) (n : int) (LC : match a with\n| Eop (Ointconst n0) Enil => Some n0\n| Eop (Ointconst n0) (_ ::: _) => None\n| _ => None\nend = Some n)","proofString":"destruct a; try discriminate.\ndestruct o; try discriminate.\ndestruct e0; try discriminate.\ninv LC.\nintros.\nInvEval.\nauto."},{"statement":"(le : letenv) (o : operation) (e0 : exprlist) (x : val) (n : int) (LC : match o with\n| Ointconst n0 => match e0 with\n                  | Enil => Some n0\n                  | _ ::: _ => None\n                  end\n| _ => None\nend = Some n) : eval_expr ge sp e m le (Eop o e0) x -> x = Vint n.","conclusion":"eval_expr ge sp e m le (Eop o e0) x -> x = Vint n","hypotheses":"(le : letenv) (o : operation) (e0 : exprlist) (x : val) (n : int) (LC : match o with\n| Ointconst n0 => match e0 with\n                  | Enil => Some n0\n                  | _ ::: _ => None\n                  end\n| _ => None\nend = Some n)","proofString":"destruct o; try discriminate.\ndestruct e0; try discriminate.\ninv LC.\nintros.\nInvEval.\nauto."},{"statement":"(le : letenv) (n0 : int) (e0 : exprlist) (x : val) (n : int) (LC : match e0 with\n| Enil => Some n0\n| _ ::: _ => None\nend = Some n) : eval_expr ge sp e m le (Eop (Ointconst n0) e0) x -> x = Vint n.","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n0) e0) x -> x = Vint n","hypotheses":"(le : letenv) (n0 : int) (e0 : exprlist) (x : val) (n : int) (LC : match e0 with\n| Enil => Some n0\n| _ ::: _ => None\nend = Some n)","proofString":"destruct e0; try discriminate.\ninv LC.\nintros.\nInvEval.\nauto."},{"statement":"(le : letenv) (n0 : int) (x : val) (n : int) (LC : Some n0 = Some n) : eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x -> x = Vint n.","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x -> x = Vint n","hypotheses":"(le : letenv) (n0 : int) (x : val) (n : int) (LC : Some n0 = Some n)","proofString":"inv LC.\nintros.\nInvEval.\nauto."},{"statement":"(le : letenv) (x : val) (n : int) : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x -> x = Vint n.","conclusion":"eval_expr ge sp e m le (Eop (Ointconst n) Enil) x -> x = Vint n","hypotheses":"(le : letenv) (x : val) (n : int)","proofString":"intros.\nInvEval.\nauto."},{"statement":"(le : letenv) (x : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x) : x = Vint n.","conclusion":"x = Vint n","hypotheses":"(le : letenv) (x : val) (n : int) (H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x)","proofString":"InvEval.\nauto."},{"statement":"(le : letenv) (n : int) : Vint n = Vint n.","conclusion":"Vint n = Vint n","hypotheses":"(le : letenv) (n : int)","proofString":"auto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) : P\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3).","conclusion":"P\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3)","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\napply A0; auto.\nassert (NZ: Int.unsigned n <> 0).\nred; intros.\nelim H.\nrewrite <- (Int.repr_unsigned n).\nrewrite H0.\nauto.\ndestruct (Int.ltu n Int.iwordsize) eqn:LT.\nexploit Int.ltu_iwordsize_inv; eauto.\nintros RANGE.\nassert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT'.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n = Int.zero) : P a0.","conclusion":"P a0","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n = Int.zero)","proofString":"apply A0; auto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3).","conclusion":"P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero)","proofString":"assert (NZ: Int.unsigned n <> 0).\nred; intros.\nelim H.\nrewrite <- (Int.repr_unsigned n).\nrewrite H0.\nauto.\ndestruct (Int.ltu n Int.iwordsize) eqn:LT.\nexploit Int.ltu_iwordsize_inv; eauto.\nintros RANGE.\nassert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT'.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) : Int.unsigned n <> 0.","conclusion":"Int.unsigned n <> 0","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero)","proofString":"red; intros.\nelim H.\nrewrite <- (Int.repr_unsigned n).\nrewrite H0.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : False.","conclusion":"False","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0)","proofString":"elim H.\nrewrite <- (Int.repr_unsigned n).\nrewrite H0.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : n = Int.zero.","conclusion":"n = Int.zero","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0)","proofString":"rewrite <- (Int.repr_unsigned n).\nrewrite H0.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : Int.repr (Int.unsigned n) = Int.zero.","conclusion":"Int.repr (Int.unsigned n) = Int.zero","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0)","proofString":"rewrite H0.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0) : Int.repr 0 = Int.zero.","conclusion":"Int.repr 0 = Int.zero","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (H0 : Int.unsigned n = 0)","proofString":"auto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3).","conclusion":"P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nInt.ltu n Int.iwordsize = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"destruct (Int.ltu n Int.iwordsize) eqn:LT.\nexploit Int.ltu_iwordsize_inv; eauto.\nintros RANGE.\nassert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia.\ndestruct (Int.ltu n Int64.iwordsize') eqn:LT'.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : P a1.","conclusion":"P a1","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"exploit Int.ltu_iwordsize_inv; eauto.\nintros RANGE.\nassert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : 0 <= Int.unsigned n < Int.zwordsize -> P a1.","conclusion":"0 <= Int.unsigned n < Int.zwordsize -> P a1","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"intros RANGE.\nassert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) : P a1.","conclusion":"P a1","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize)","proofString":"assert (0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) by lia.\napply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : P a1.","conclusion":"P a1","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"apply A1.\nauto.\nauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nunfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : 0 <= Int.unsigned n < Int.zwordsize.","conclusion":"0 <= Int.unsigned n < Int.zwordsize","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"auto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : true = true.","conclusion":"true = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"auto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true.","conclusion":"Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"unfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : (if\n  zlt (Int.unsigned (Int.repr (Int.unsigned Int.iwordsize - Int.unsigned n)))\n    (Int.unsigned Int.iwordsize)\n then true\n else false) = true.","conclusion":"(if\n  zlt (Int.unsigned (Int.repr (Int.unsigned Int.iwordsize - Int.unsigned n)))\n    (Int.unsigned Int.iwordsize)\n then true\n else false) = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"rewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : (if\n  zlt (Int.unsigned (Int.repr (Int.zwordsize - Int.unsigned n)))\n    Int.zwordsize\n then true\n else false) = true.","conclusion":"(if\n  zlt (Int.unsigned (Int.repr (Int.zwordsize - Int.unsigned n)))\n    Int.zwordsize\n then true\n else false) = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : (if zlt (Int.zwordsize - Int.unsigned n) Int.zwordsize then true else false) =\ntrue.","conclusion":"(if zlt (Int.zwordsize - Int.unsigned n) Int.zwordsize then true else false) =\ntrue","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"rewrite zlt_true; auto.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.zwordsize - Int.unsigned n < Int.zwordsize.","conclusion":"Int.zwordsize - Int.unsigned n < Int.zwordsize","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : 0 <= Int.zwordsize - Int.unsigned n <= Int.max_unsigned.","conclusion":"0 <= Int.zwordsize - Int.unsigned n <= Int.max_unsigned","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"generalize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.ltu n Int64.iwordsize' = true.","conclusion":"Int.ltu n Int64.iwordsize' = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"unfold Int.ltu.\nrewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : (if zlt (Int.unsigned n) (Int.unsigned Int64.iwordsize') then true else false) =\ntrue.","conclusion":"(if zlt (Int.unsigned n) (Int.unsigned Int64.iwordsize') then true else false) =\ntrue","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"rewrite zlt_true; auto.\nchange (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.unsigned n < Int.unsigned Int64.iwordsize'.","conclusion":"Int.unsigned n < Int.unsigned Int64.iwordsize'","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"change (Int.unsigned Int64.iwordsize') with 64.\nchange Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.unsigned n < 64.","conclusion":"Int.unsigned n < 64","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"change Int.zwordsize with 32 in RANGE.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < 32) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize) : Int.unsigned n < 64.","conclusion":"Int.unsigned n < 64","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\ntrue = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < 32) (H0 : 0 <= Int.zwordsize - Int.unsigned n < Int.zwordsize)","proofString":"lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : P (if Int.ltu n Int64.iwordsize' then a2 else a3).","conclusion":"P (if Int.ltu n Int64.iwordsize' then a2 else a3)","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nInt.ltu n Int64.iwordsize' = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"destruct (Int.ltu n Int64.iwordsize') eqn:LT'.\nexploit Int.ltu_inv; eauto.\nchange (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia.\nauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : P a2.","conclusion":"P a2","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"exploit Int.ltu_inv; eauto.\nchange (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : 0 <= Int.unsigned n < Int.unsigned Int64.iwordsize' -> P a2.","conclusion":"0 <= Int.unsigned n < Int.unsigned Int64.iwordsize' -> P a2","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"change (Int.unsigned Int64.iwordsize') with (Int.zwordsize * 2).\nintros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : 0 <= Int.unsigned n < Int.zwordsize * 2 -> P a2.","conclusion":"0 <= Int.unsigned n < Int.zwordsize * 2 -> P a2","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"intros RANGE.\nassert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : P a2.","conclusion":"P a2","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"assert (Int.zwordsize <= Int.unsigned n).\nunfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia.\napply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : Int.zwordsize <= Int.unsigned n.","conclusion":"Int.zwordsize <= Int.unsigned n","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"unfold Int.ltu in LT.\nrewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : (if zlt (Int.unsigned n) (Int.unsigned Int.iwordsize) then true else false) =\nfalse) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : Int.zwordsize <= Int.unsigned n.","conclusion":"Int.zwordsize <= Int.unsigned n","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : (if zlt (Int.unsigned n) (Int.unsigned Int.iwordsize) then true else false) =\nfalse) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"rewrite Int.unsigned_repr_wordsize in LT.\ndestruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : (if zlt (Int.unsigned n) Int.zwordsize then true else false) = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : Int.zwordsize <= Int.unsigned n.","conclusion":"Int.zwordsize <= Int.unsigned n","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : (if zlt (Int.unsigned n) Int.zwordsize then true else false) = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"destruct (zlt (Int.unsigned n) Int.zwordsize).\ndiscriminate.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (l : Int.unsigned n < Int.zwordsize) (LT : true = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : Int.zwordsize <= Int.unsigned n.","conclusion":"Int.zwordsize <= Int.unsigned n","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (l : Int.unsigned n < Int.zwordsize) (LT : true = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"discriminate."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (g : Int.unsigned n >= Int.zwordsize) (LT : false = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) : Int.zwordsize <= Int.unsigned n.","conclusion":"Int.zwordsize <= Int.unsigned n","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (g : Int.unsigned n >= Int.zwordsize) (LT : false = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2)","proofString":"lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : P a2.","conclusion":"P a2","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"apply A2.\ntauto.\nunfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : Int.zwordsize <= Int.unsigned n < Int64.zwordsize.","conclusion":"Int.zwordsize <= Int.unsigned n < Int64.zwordsize","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"tauto."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true.","conclusion":"Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"unfold Int.ltu, Int.sub.\nrewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : (if\n  zlt (Int.unsigned (Int.repr (Int.unsigned n - Int.unsigned Int.iwordsize)))\n    (Int.unsigned Int.iwordsize)\n then true\n else false) = true.","conclusion":"(if\n  zlt (Int.unsigned (Int.repr (Int.unsigned n - Int.unsigned Int.iwordsize)))\n    (Int.unsigned Int.iwordsize)\n then true\n else false) = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"rewrite Int.unsigned_repr_wordsize.\nrewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : (if\n  zlt (Int.unsigned (Int.repr (Int.unsigned n - Int.zwordsize)))\n    Int.zwordsize\n then true\n else false) = true.","conclusion":"(if\n  zlt (Int.unsigned (Int.repr (Int.unsigned n - Int.zwordsize)))\n    Int.zwordsize\n then true\n else false) = true","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"rewrite Int.unsigned_repr.\nrewrite zlt_true; auto.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : (if zlt (Int.unsigned n - Int.zwordsize) Int.zwordsize then true else false) =\ntrue.","conclusion":"(if zlt (Int.unsigned n - Int.zwordsize) Int.zwordsize then true else false) =\ntrue","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"rewrite zlt_true; auto.\nlia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : Int.unsigned n - Int.zwordsize < Int.zwordsize.","conclusion":"Int.unsigned n - Int.zwordsize < Int.zwordsize","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n) : 0 <= Int.unsigned n - Int.zwordsize <= Int.max_unsigned.","conclusion":"0 <= Int.unsigned n - Int.zwordsize <= Int.max_unsigned","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = true) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true -> true = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) (RANGE : 0 <= Int.unsigned n < Int.zwordsize * 2) (H0 : Int.zwordsize <= Int.unsigned n)","proofString":"generalize Int.wordsize_max_unsigned; lia."},{"statement":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = false) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nfalse = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0) : P a3.","conclusion":"P a3","hypotheses":"(P : expr -> Prop) (n : int) (a0 a1 a2 a3 : expr) (A0 : n = Int.zero -> P a0) (LT : Int.ltu n Int.iwordsize = false) (LT' : Int.ltu n Int64.iwordsize' = false) (A1 : 0 <= Int.unsigned n < Int.zwordsize ->\nfalse = true ->\nInt.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true ->\nfalse = true -> P a1) (A2 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize ->\nInt.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true -> P a2) (A3 : P a3) (H : n <> Int.zero) (NZ : Int.unsigned n <> 0)","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n            (shlimm l n))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n          (Eop (Ointconst Int.zero) Enil)\n       else\n        Eexternal i64_shl sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n            (shlimm l n))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n          (Eop (Ointconst Int.zero) Enil)\n       else\n        Eexternal i64_shl sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shift_imm; intros.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero.\nauto.\napply eval_splitlong with (sem := fun x => Val.shll x (Vint n)); auto.\nintros.\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto.\ndestruct x; auto.\nexploit eval_lowlong.\neexact H.\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shll x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.shll x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shll x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nchange (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"change (Int64.shl' i Int.zero) with (Int64.shl i Int64.zero).\nrewrite Int64.shl_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl i Int64.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl i Int64.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shl_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i).","conclusion":"Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n          (shlimm l n))) v /\\ Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n          (shlimm l n))) v /\\ Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"apply eval_splitlong with (sem := fun x => Val.shll x (Vint n)); auto.\nintros.\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto.\ndestruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"intros.\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"exploit eval_shlimm.\neexact H4.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : (exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 n) v /\\\n   Val.lessdef (Val.shl x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 n) v /\\\n   Val.lessdef (Val.shl x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"intros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1)","proofString":"exploit eval_shlimm.\neexact H5.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) : (exists v : val,\n   eval_expr ge sp e m le0 (shlimm b n) v /\\\n   Val.lessdef (Val.shl y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shlimm b n) v /\\\n   Val.lessdef (Val.shl y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1)","proofString":"intros [v2 [A2 B2]].\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2)","proofString":"exploit eval_shruimm.\neexact H5.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) : (exists v : val,\n   eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2)","proofString":"intros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3)","proofString":"exploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n       (shlimm b n)) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shll (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"econstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q) : Val.longofwords v4 v2 = Val.shll (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v4 v2 = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl x0 (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl y (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q)","proofString":"subst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl (Vint p) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl (Vint q) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru (Vint q) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v4 v2 = Val.shll (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v4 v2 = Val.shll (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Val.shl (Vint p) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Val.shl (Vint q) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shru (Vint q) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"simpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shl p n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shl q n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shru q (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shl p n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shl q n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shru q (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shru q (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shru q (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v4 v2 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shl' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v4 v2 = Vlong (Int64.shl' (Int64.ofwords p q) n).","conclusion":"Val.longofwords v4 v2 = Vlong (Int64.shl' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1) (B1 : Val.lessdef (Vint (Int.shl p n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shlimm b n) v2) (B2 : Val.lessdef (Vint (Int.shl q n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"inv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shl p n)) (Vint (Int.shru q (Int.sub Int.iwordsize n))))\n  v4) : Val.longofwords v4 (Vint (Int.shl q n)) =\nVlong (Int64.shl' (Int64.ofwords p q) n).","conclusion":"Val.longofwords v4 (Vint (Int.shl q n)) =\nVlong (Int64.shl' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shl p n)) (Vint (Int.shru q (Int.sub Int.iwordsize n))))\n  v4)","proofString":"simpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))) v4) : Val.longofwords v4 (Vint (Int.shl q n)) =\nVlong (Int64.shl' (Int64.ofwords p q) n).","conclusion":"Val.longofwords v4 (Vint (Int.shl q n)) =\nVlong (Int64.shl' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))) v4)","proofString":"inv B4.\nsimpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))) : Val.longofwords\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n  (Vint (Int.shl q n)) = Vlong (Int64.shl' (Int64.ofwords p q) n).","conclusion":"Val.longofwords\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n  (Vint (Int.shl q n)) = Vlong (Int64.shl' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))))","proofString":"simpl.\nrewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))) : Vlong\n  (Int64.ofwords\n     (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n     (Int.shl q n)) = Vlong (Int64.shl' (Int64.ofwords p q) n).","conclusion":"Vlong\n  (Int64.ofwords\n     (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n     (Int.shl q n)) = Vlong (Int64.shl' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))) (A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))) (A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))))","proofString":"rewrite Int64.decompose_shl_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : match x with\n| Vlong _ => True\n| _ => Val.shll x (Vint n) = Vundef\nend.","conclusion":"match x with\n| Vlong _ => True\n| _ => Val.shll x (Vint n) = Vundef\nend","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true)","proofString":"exploit eval_lowlong.\neexact H.\nintros [v1 [A1 B1]].\nexploit eval_shlimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1)","proofString":"exploit eval_shlimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1) : (exists v : val,\n   eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1)","proofString":"intros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n       (Eop (Ointconst Int.zero) Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword x) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"econstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)\n  (Val.longofwords v2 (Vint Int.zero)).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shl' i n) else Vundef)\n  (Val.longofwords v2 (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (lowlong a) v1) (B1 : Val.lessdef (Val.loword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"simpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (Val.shl (Vint (Int64.loword i)) (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (Val.shl (Vint (Int64.loword i)) (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"simpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2) : Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2)","proofString":"rewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n)) (Val.longofwords v2 (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))) v2)","proofString":"inv B2.\nsimpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords\n     (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n     (Vint Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords\n     (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n     (Vint Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))))","proofString":"simpl.\nerewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.ofwords (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n        Int.zero)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.ofwords (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n        Int.zero))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))))","proofString":"erewrite <- Int64.decompose_shl_2.\ninstantiate (1 := Int64.hiword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong (Int64.shl' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong (Int64.shl' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shl' i n)) (Vlong (Int64.shl' i n)).","conclusion":"Val.lessdef (Vlong (Int64.shl' i n)) (Vlong (Int64.shl' i n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))) : Int.zwordsize <= Int.unsigned n < Int64.zwordsize.","conclusion":"Int.zwordsize <= Int.unsigned n < Int64.zwordsize","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))) (A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_shl sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_shl sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shllimm a n\n    | None => Eexternal i64_shl sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shll x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shllimm a n\n    | None => Eexternal i64_shl sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct (is_intconst b) as [n|] eqn:IC.\nexploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shllimm; eauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\ Val.lessdef (Val.shll x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\ Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"exploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shllimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\ Val.lessdef (Val.shll x y) v.","conclusion":"y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\ Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"intros EQ; subst y; clear H0.\neapply eval_shllimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a n) v /\\\n  Val.lessdef (Val.shll x (Vint n)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n)","proofString":"eapply eval_shllimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_shl sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shll x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_shl sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shll x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (shruimm h n)\n            (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        makelong (Eop (Ointconst Int.zero) Enil)\n          (shruimm (highlong a) (Int.sub n Int.iwordsize))\n       else\n        Eexternal i64_shr sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (shruimm h n)\n            (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        makelong (Eop (Ointconst Int.zero) Enil)\n          (shruimm (highlong a) (Int.sub n Int.iwordsize))\n       else\n        Eexternal i64_shr sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shift_imm; intros.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero.\nauto.\napply eval_splitlong with (sem := fun x => Val.shrlu x (Vint n)); auto.\nintros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto.\ndestruct x; auto.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrlu x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.shrlu x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shrlu x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nchange (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"change (Int64.shru' i Int.zero) with (Int64.shru i Int64.zero).\nrewrite Int64.shru_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru i Int64.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru i Int64.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shru_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i).","conclusion":"Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (shruimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (shruimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"apply eval_splitlong with (sem := fun x => Val.shrlu x (Vint n)); auto.\nintros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto.\ndestruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"intros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"exploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : (exists v : val,\n   eval_expr ge sp e m le0 (shruimm b n) v /\\\n   Val.lessdef (Val.shru y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shruimm b n) v /\\\n   Val.lessdef (Val.shru y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"intros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1)","proofString":"exploit eval_shruimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) : (exists v : val,\n   eval_expr ge sp e m le0 (shruimm a0 n) v /\\\n   Val.lessdef (Val.shru x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shruimm a0 n) v /\\\n   Val.lessdef (Val.shru x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1)","proofString":"intros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2)","proofString":"exploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) : (exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2)","proofString":"intros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3)","proofString":"exploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shruimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"econstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q) : Val.longofwords v2 v4 = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v2 v4 = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q)","proofString":"subst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru (Vint p) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v2 v4 = Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Val.shru (Vint p) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"simpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru p n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru p n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shru' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 = Vlong (Int64.shru' (Int64.ofwords p q) n).","conclusion":"Val.longofwords v2 v4 = Vlong (Int64.shru' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shru p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"inv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n)) (Vint (Int.shl p (Int.sub Int.iwordsize n))))\n  v4) : Val.longofwords (Vint (Int.shru p n)) v4 =\nVlong (Int64.shru' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shru p n)) v4 =\nVlong (Int64.shru' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n)) (Vint (Int.shl p (Int.sub Int.iwordsize n))))\n  v4)","proofString":"simpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) v4) : Val.longofwords (Vint (Int.shru p n)) v4 =\nVlong (Int64.shru' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shru p n)) v4 =\nVlong (Int64.shru' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) v4)","proofString":"inv B4.\nsimpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))) : Val.longofwords (Vint (Int.shru p n))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shru' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shru p n))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shru' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))","proofString":"simpl.\nrewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))) : Vlong\n  (Int64.ofwords (Int.shru p n)\n     (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shru' (Int64.ofwords p q) n).","conclusion":"Vlong\n  (Int64.ofwords (Int.shru p n)\n     (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shru' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))","proofString":"rewrite Int64.decompose_shru_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : match x with\n| Vlong _ => True\n| _ => Val.shrlu x (Vint n) = Vundef\nend.","conclusion":"match x with\n| Vlong _ => True\n| _ => Val.shrlu x (Vint n) = Vundef\nend","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true)","proofString":"exploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nexploit eval_shruimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1)","proofString":"exploit eval_shruimm.\neexact A1.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) : (exists v : val,\n   eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1)","proofString":"intros [v2 [A2 B2]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2) : exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (makelong (Eop (Ointconst Int.zero) Enil)\n       (shruimm (highlong a) (Int.sub n Int.iwordsize))) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"econstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shru' i n) else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"simpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (Val.shru (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (Val.shru (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"simpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2) : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2)","proofString":"rewrite H1 in B2.\ninv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))) v2) : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end.","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize)) v2) (B2 : Val.lessdef (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))) v2)","proofString":"inv B2.\nsimpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","proofString":"simpl.\nerewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","proofString":"erewrite <- Int64.decompose_shru_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong (Int64.shru' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n)).","conclusion":"Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong (Int64.shru' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))) : Val.lessdef (Vlong (Int64.shru' i n)) (Vlong (Int64.shru' i n)).","conclusion":"Val.lessdef (Vlong (Int64.shru' i n)) (Vlong (Int64.shru' i n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))) : Int.zwordsize <= Int.unsigned n < Int64.zwordsize.","conclusion":"Int.zwordsize <= Int.unsigned n < Int64.zwordsize","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_shr sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_shr sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shrluimm a n\n    | None => Eexternal i64_shr sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shrlu x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shrluimm a n\n    | None => Eexternal i64_shr sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct (is_intconst b) as [n|] eqn:IC.\nexploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shrluimm; eauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\ Val.lessdef (Val.shrlu x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\ Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"exploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shrluimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\ Val.lessdef (Val.shrlu x y) v.","conclusion":"y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\ Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"intros EQ; subst y; clear H0.\neapply eval_shrluimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrluimm a n) v /\\\n  Val.lessdef (Val.shrlu x (Vint n)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n)","proofString":"eapply eval_shrluimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_shr sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_shr sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shrlu x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (shrimm h n)\n            (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        Elet (highlong a)\n          (makelong (shrimm (Eletvar 0) (Int.repr 31))\n             (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n       else\n        Eexternal i64_sar sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.ltu n Int.iwordsize\n      then\n       splitlong a\n         (fun h l : expr =>\n          makelong (shrimm h n)\n            (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n      else\n       if Int.ltu n Int64.iwordsize'\n       then\n        Elet (highlong a)\n          (makelong (shrimm (Eletvar 0) (Int.repr 31))\n             (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n       else\n        Eexternal i64_sar sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"apply eval_shift_imm; intros.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero.\nauto.\napply eval_splitlong with (sem := fun x => Val.shrl x (Vint n)); auto.\nintros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto.\ndestruct x; auto.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nassert (eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) by EvalOp.\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint Int.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shrl x (Vint Int.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.shrl x (Vint Int.zero)) x.","conclusion":"Val.lessdef (Val.shrl x (Vint Int.zero)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"destruct x; simpl; auto.\nchange (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"change (Int64.shr' i Int.zero) with (Int64.shr i Int64.zero).\nrewrite Int64.shr_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr i Int64.zero)\n   else Vundef) (Vlong i).","conclusion":"Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr i Int64.zero)\n   else Vundef) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.shr_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i).","conclusion":"Val.lessdef (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (shrimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong a\n       (fun h l : expr =>\n        makelong (shrimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"apply eval_splitlong with (sem := fun x => Val.shrl x (Vint n)); auto.\nintros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto.\ndestruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"forall (le0 : letenv) (a0 b : expr) (x0 y : val),\neval_expr ge sp e m le0 a0 x0 ->\neval_expr ge sp e m le0 b y ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"intros.\nexploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"exploit eval_shruimm.\neexact H5.\ninstantiate (1 := n).\nintros [v1 [A1 B1]].\nexploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) : (exists v : val,\n   eval_expr ge sp e m le0 (shruimm b n) v /\\\n   Val.lessdef (Val.shru y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shruimm b n) v /\\\n   Val.lessdef (Val.shru y (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y)","proofString":"intros [v1 [A1 B1]].\nexploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1)","proofString":"exploit eval_shrimm.\neexact H4.\ninstantiate (1 := n).\nintros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) : (exists v : val,\n   eval_expr ge sp e m le0 (shrimm a0 n) v /\\\n   Val.lessdef (Val.shr x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shrimm a0 n) v /\\\n   Val.lessdef (Val.shr x0 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1)","proofString":"intros [v2 [A2 B2]].\nexploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2)","proofString":"exploit eval_shlimm.\neexact H4.\ninstantiate (1 := Int.sub Int.iwordsize n).\nintros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) : (exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v /\\\n   Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v) ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2)","proofString":"intros [v3 [A3 B3]].\nexploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3)","proofString":"exploit eval_or.\neexact A1.\neexact A3.\nintros [v4 [A4 B4]].\neconstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (makelong (shrimm a0 n)\n       (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v /\\\n  (forall p q : int,\n   x0 = Vint p ->\n   y = Vint q -> v = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"econstructor; split.\nEvalOp.\nintros.\nsubst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q) : Val.longofwords v2 v4 = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v2 v4 = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (x0 y : val) (H4 : eval_expr ge sp e m le0 a0 x0) (H5 : eval_expr ge sp e m le0 b y) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru y (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr x0 (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) (p q : int) (H6 : x0 = Vint p) (H7 : y = Vint q)","proofString":"subst.\nsimpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr (Vint p) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n).","conclusion":"Val.longofwords v2 v4 = Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Val.shr (Vint p) (Vint n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"simpl in *.\nrewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shr p n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef)\n  v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (if Int.ltu n Int.iwordsize then Vint (Int.shr p n) else Vundef)\n  v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H1 in *.\nrewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H2 in *.\nrewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef).","conclusion":"Val.longofwords v2 v4 =\n(if Int.ltu n Int64.iwordsize'\n then Vlong (Int64.shr' (Int64.ofwords p q) n)\n else Vundef)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"rewrite H3.\ninv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4) : Val.longofwords v2 v4 = Vlong (Int64.shr' (Int64.ofwords p q) n).","conclusion":"Val.longofwords v2 v4 = Vlong (Int64.shr' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (v1 : val) (A1 : eval_expr ge sp e m le0 (shruimm b n) v1) (B1 : Val.lessdef (Vint (Int.shru q n)) v1) (v2 : val) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2) (B2 : Val.lessdef (Vint (Int.shr p n)) v2) (v3 : val) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3) (B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef (Val.or v1 v3) v4)","proofString":"inv B1; inv B2; inv B3.\nsimpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n)) (Vint (Int.shl p (Int.sub Int.iwordsize n))))\n  v4) : Val.longofwords (Vint (Int.shr p n)) v4 =\nVlong (Int64.shr' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shr p n)) v4 =\nVlong (Int64.shr' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n)) (Vint (Int.shl p (Int.sub Int.iwordsize n))))\n  v4)","proofString":"simpl in B4.\ninv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) v4) : Val.longofwords (Vint (Int.shr p n)) v4 =\nVlong (Int64.shr' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shr p n)) v4 =\nVlong (Int64.shr' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (v4 : val) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4) (B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) v4)","proofString":"inv B4.\nsimpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))) : Val.longofwords (Vint (Int.shr p n))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shr' (Int64.ofwords p q) n).","conclusion":"Val.longofwords (Vint (Int.shr p n))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shr' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))","proofString":"simpl.\nrewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))) : Vlong\n  (Int64.ofwords (Int.shr p n)\n     (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shr' (Int64.ofwords p q) n).","conclusion":"Vlong\n  (Int64.ofwords (Int.shr p n)\n     (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))) =\nVlong (Int64.shr' (Int64.ofwords p q) n)","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) (le0 : letenv) (a0 b : expr) (p : int) (H4 : eval_expr ge sp e m le0 a0 (Vint p)) (q : int) (H5 : eval_expr ge sp e m le0 b (Vint q)) (A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))) (A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))) (A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))) (A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))","proofString":"rewrite Int64.decompose_shr_1; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true) : match x with\n| Vlong _ => True\n| _ => Val.shrl x (Vint n) = Vundef\nend.","conclusion":"match x with\n| Vlong _ => True\n| _ => Val.shrl x (Vint n) = Vundef\nend","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : 0 <= Int.unsigned n < Int.zwordsize) (H1 : Int.ltu n Int.iwordsize = true) (H2 : Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize = true) (H3 : Int.ltu n Int64.iwordsize' = true)","proofString":"destruct x; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true)","proofString":"exploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nassert (eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) by EvalOp.\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1)","proofString":"assert (eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) by EvalOp.\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1)","proofString":"exploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.sub n Int.iwordsize).\nintros [v2 [A2 B2]].\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) : (exists v : val,\n   eval_expr ge sp e m (v1 :: le)\n     (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m (v1 :: le)\n     (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v /\\\n   Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1)","proofString":"intros [v2 [A2 B2]].\nexploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"exploit eval_shrimm.\neexact H2.\ninstantiate (1 := Int.repr 31).\nintros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) : (exists v : val,\n   eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v /\\\n   Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v /\\\n   Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2)","proofString":"intros [v3 [A3 B3]].\neconstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet (highlong a)\n       (makelong (shrimm (Eletvar 0) (Int.repr 31))\n          (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword x) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3)","proofString":"econstructor; split.\nEvalOp.\ndestruct x; simpl; auto.\ndestruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3) : Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)\n  (Val.longofwords v3 v2).","conclusion":"Val.lessdef\n  (if Int.ltu n Int64.iwordsize' then Vlong (Int64.shr' i n) else Vundef)\n  (Val.longofwords v3 v2)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3)","proofString":"destruct (Int.ltu n Int64.iwordsize'); auto.\nsimpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3) : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong i)) v1) (H2 : eval_expr ge sp e m (v1 :: le) (Eletvar 0) v1) (v2 : val) (A2 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  v2) (B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2) (v3 : val) (A3 : eval_expr ge sp e m (v1 :: le) (shrimm (Eletvar 0) (Int.repr 31)) v3) (B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3)","proofString":"simpl in B1; inv B1.\nsimpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef\n  (Val.shr (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3) : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef\n  (Val.shr (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3)","proofString":"simpl in B2.\nrewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3) : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3)","proofString":"rewrite H1 in B2.\ninv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3) : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (v2 : val) (B2 : Val.lessdef (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))) v2) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3)","proofString":"inv B2.\nsimpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (v3 : val) (B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3)","proofString":"simpl in B3.\ninv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (v3 : val) (B3 : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (v3 : val) (B3 : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef) v3) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3)","proofString":"inv B3.\nchange (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"change (Int.ltu (Int.repr 31) Int.iwordsize) with true.\nsimpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if true then Vint (Int.shr (Int64.hiword i) (Int.repr 31)) else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if true then Vint (Int.shr (Int64.hiword i) (Int.repr 31)) else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"simpl.\nerewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.ofwords (Int.shr (Int64.hiword i) (Int.repr 31))\n        (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.ofwords (Int.shr (Int64.hiword i) (Int.repr 31))\n        (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"erewrite <- Int64.decompose_shr_2.\ninstantiate (1 := Int64.loword i).\nrewrite Int64.ofwords_recompose.\nauto.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong (Int64.shr' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n)).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong (Int64.shr' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Val.lessdef (Vlong (Int64.shr' i n)) (Vlong (Int64.shr' i n)).","conclusion":"Val.lessdef (Vlong (Int64.shr' i n)) (Vlong (Int64.shr' i n))","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)) : Int.zwordsize <= Int.unsigned n < Int64.zwordsize.","conclusion":"Int.zwordsize <= Int.unsigned n < Int64.zwordsize","hypotheses":"(n : int) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int.zwordsize <= Int.unsigned n < Int64.zwordsize) (H1 : Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize = true) (H2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le) \n  (Eletvar 0) (Vint (Int64.hiword i))) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))) (A2 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))) (A3 : eval_expr ge sp e m (Vint (Int64.hiword i) :: le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef))","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_sar sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_sar sig_li_l (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nEvalOp.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shrlimm a n\n    | None => Eexternal i64_sar sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shrl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_intconst b with\n    | Some n => shrlimm a n\n    | None => Eexternal i64_sar sig_li_l (a ::: b ::: Enil)\n    end v /\\ Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct (is_intconst b) as [n|] eqn:IC.\nexploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shrlimm; eauto.\neconstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\ Val.lessdef (Val.shrl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\ Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"exploit is_intconst_sound; eauto.\nintros EQ; subst y; clear H0.\neapply eval_shrlimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n) : y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\ Val.lessdef (Val.shrl x y) v.","conclusion":"y = Vint n ->\nexists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\ Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (n : int) (IC : is_intconst b = Some n)","proofString":"intros EQ; subst y; clear H0.\neapply eval_shrlimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n) : exists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shrlimm a n) v /\\\n  Val.lessdef (Val.shrl x (Vint n)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (n : int) (IC : is_intconst b = Some n)","proofString":"eapply eval_shrlimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_sar sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_sar sig_li_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.shrl x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (IC : is_intconst b = None)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\nreflexivity.\nauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add n1 n2)\n        | None =>\n            if Int64.eq n1 Int64.zero\n            then b\n            else\n             Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 =>\n            if Int64.eq n2 Int64.zero\n            then a\n            else\n             Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (a ::: b ::: Enil)\n        end\n    end v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add n1 n2)\n        | None =>\n            if Int64.eq n1 Int64.zero\n            then b\n            else\n             Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 =>\n            if Int64.eq n2 Int64.zero\n            then a\n            else\n             Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (a ::: b ::: Enil)\n        end\n    end v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y)","proofString":"set (default := Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l) (a ::: b ::: Enil)).\nassert (DEFAULT:    exists v, eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v).\neconstructor; split.\neapply eval_builtin_2; eauto.\nreflexivity.\nreflexivity.\nauto.\ndestruct (is_longconst a) as [p|] eqn:LC1;  destruct (is_longconst b) as [q|] eqn:LC2.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto.\npredSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto.\npredSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add n1 n2)\n        | None => if Int64.eq n1 Int64.zero then b else default\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end\n    end v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add n1 n2)\n        | None => if Int64.eq n1 Int64.zero then b else default\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end\n    end v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v)","proofString":"destruct (is_longconst a) as [p|] eqn:LC1;  destruct (is_longconst b) as [q|] eqn:LC2.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto.\npredSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto.\npredSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto.\nauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl x y) v.","conclusion":"x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) y) v.","conclusion":"y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H1 : eval_expr ge sp e m le b (Vlong q)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong p) (Vlong q)) v) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) (Vlong q)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.add p q)) v /\\\n  Val.lessdef (Val.addl (Vlong p) (Vlong q)) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H1 : eval_expr ge sp e m le b (Vlong q)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong p) (Vlong q)) v) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q)","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (if Int64.eq p Int64.zero then b else default) v /\\\n  Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (if Int64.eq p Int64.zero then b else default) v /\\\n  Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"predSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero) : exists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero)","proofString":"subst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : exists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : x = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"x = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"intros EQ; subst x.\nexists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl (Vlong Int64.zero) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le b v /\\ Val.lessdef (Val.addl (Vlong Int64.zero) y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"exists y; split; auto.\nunfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : Val.lessdef (Val.addl (Vlong Int64.zero) y) y.","conclusion":"Val.lessdef (Val.addl (Vlong Int64.zero) y) y","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"unfold Val.addl; rewrite H; destruct y; auto.\nrewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b (Vlong i)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) (Vlong i)) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i)","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (i : int64) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b (Vlong i)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong Int64.zero) (Vlong i)) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"rewrite Int64.add_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (if Int64.eq q Int64.zero then a else default) v /\\\n  Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (if Int64.eq q Int64.zero then a else default) v /\\\n  Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"predSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) (H2 : q = Int64.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) (H2 : q = Int64.zero)","proofString":"subst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : y = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"y = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"intros EQ; subst y.\nexists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.addl x (Vlong Int64.zero)) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"exists x; split; auto.\nunfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : Val.lessdef (Val.addl x (Vlong Int64.zero)) x.","conclusion":"Val.lessdef (Val.addl x (Vlong Int64.zero)) x","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"unfold Val.addl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (i : int64) (b : expr) (H0 : eval_expr ge sp e m le a (Vlong i)) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong i) (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (i : int64) (b : expr) (H0 : eval_expr ge sp e m le a (Vlong i)) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.addl (Vlong i) (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"rewrite Int64.add_zero; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.addl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None)","proofString":"auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub n1 n2)\n        | None =>\n            if Int64.eq n1 Int64.zero\n            then negl b\n            else\n             Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 =>\n            if Int64.eq n2 Int64.zero\n            then a\n            else\n             Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (a ::: b ::: Enil)\n        end\n    end v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub n1 n2)\n        | None =>\n            if Int64.eq n1 Int64.zero\n            then negl b\n            else\n             Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 =>\n            if Int64.eq n2 Int64.zero\n            then a\n            else\n             Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n               (a ::: b ::: Enil)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (a ::: b ::: Enil)\n        end\n    end v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y)","proofString":"set (default := Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l) (a ::: b ::: Enil)).\nassert (DEFAULT:    exists v, eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v).\neconstructor; split.\neapply eval_builtin_2; eauto.\nreflexivity.\nreflexivity.\nauto.\ndestruct (is_longconst a) as [p|] eqn:LC1;  destruct (is_longconst b) as [q|] eqn:LC2.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto.\npredSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nreplace (Val.subl x y) with (Val.negl y).\neapply eval_negl; eauto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto.\npredSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto.\nauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub n1 n2)\n        | None => if Int64.eq n1 Int64.zero then negl b else default\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end\n    end v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub n1 n2)\n        | None => if Int64.eq n1 Int64.zero then negl b else default\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end\n    end v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v)","proofString":"destruct (is_longconst a) as [p|] eqn:LC1;  destruct (is_longconst b) as [q|] eqn:LC2.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto.\npredSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nreplace (Val.subl x y) with (Val.negl y).\neapply eval_negl; eauto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto.\npredSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto.\nauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl x y) v.","conclusion":"x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) y) v.","conclusion":"y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl (Vlong p) y) v) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H1 : eval_expr ge sp e m le b (Vlong q)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong p) (Vlong q)) v) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) (Vlong q)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.sub p q)) v /\\\n  Val.lessdef (Val.subl (Vlong p) (Vlong q)) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (p : int64) (H0 : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H1 : eval_expr ge sp e m le b (Vlong q)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong p) (Vlong q)) v) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q)","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (if Int64.eq p Int64.zero then negl b else default)\n    v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (if Int64.eq p Int64.zero then negl b else default)\n    v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"predSpec Int64.eq Int64.eq_spec p Int64.zero; auto.\nreplace (Val.subl x y) with (Val.negl y).\neapply eval_negl; eauto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (negl b) v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (negl b) v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero)","proofString":"replace (Val.subl x y) with (Val.negl y).\neapply eval_negl; eauto.\nsubst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (negl b) v /\\ Val.lessdef (Val.negl y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (negl b) v /\\ Val.lessdef (Val.negl y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero)","proofString":"eapply eval_negl; eauto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero) : Val.negl y = Val.subl x y.","conclusion":"Val.negl y = Val.subl x y","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) (H2 : p = Int64.zero)","proofString":"subst p.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : Val.negl y = Val.subl x y.","conclusion":"Val.negl y = Val.subl x y","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\ndestruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : x = Vlong Int64.zero -> Val.negl y = Val.subl x y.","conclusion":"x = Vlong Int64.zero -> Val.negl y = Val.subl x y","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"intros EQ; subst x.\ndestruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None) : Val.negl y = Val.subl (Vlong Int64.zero) y.","conclusion":"Val.negl y = Val.subl (Vlong Int64.zero) y","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a b : expr) (y : val) (H0 : eval_expr ge sp e m le a (Vlong Int64.zero)) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong Int64.zero) y) v) (LC1 : is_longconst a = Some Int64.zero) (LC2 : is_longconst b = None)","proofString":"destruct y; simpl; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (if Int64.eq q Int64.zero then a else default) v /\\\n  Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (if Int64.eq q Int64.zero then a else default) v /\\\n  Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"predSpec Int64.eq Int64.eq_spec q Int64.zero; auto.\nsubst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) (H2 : q = Int64.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) (H2 : q = Int64.zero)","proofString":"subst q.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : y = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"y = Vlong Int64.zero ->\nexists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"intros EQ; subst y.\nexists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x (Vlong Int64.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.subl x (Vlong Int64.zero)) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"exists x; split; auto.\nunfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : Val.lessdef (Val.subl x (Vlong Int64.zero)) x.","conclusion":"Val.lessdef (Val.subl x (Vlong Int64.zero)) x","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl x (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"unfold Val.subl; rewrite H; destruct x; simpl; auto.\nrewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (i : int64) (b : expr) (H0 : eval_expr ge sp e m le a (Vlong i)) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong i) (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero) : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (i : int64) (b : expr) (H0 : eval_expr ge sp e m le a (Vlong i)) (H1 : eval_expr ge sp e m le b (Vlong Int64.zero)) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\\n  Val.lessdef (Val.subl (Vlong i) (Vlong Int64.zero)) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some Int64.zero)","proofString":"rewrite Int64.sub_zero_l; auto."},{"statement":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v","hypotheses":"(H : Archi.ptr64 = false) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H0 : eval_expr ge sp e m le a x) (H1 : eval_expr ge sp e m le b y) (default : expr) (DEFAULT : exists v : val,\n  eval_expr ge sp e m le default v /\\ Val.lessdef (Val.subl x y) v) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr =>\n        Elet\n          (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n             (l1 ::: l2 ::: Enil))\n          (makelong\n             (add\n                (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                   (mul (lift l1) (lift h2))) (mul (lift h1) (lift l2)))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v /\\\n  Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (splitlong2 a b\n       (fun h1 l1 h2 l2 : expr =>\n        Elet\n          (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n             (l1 ::: l2 ::: Enil))\n          (makelong\n             (add\n                (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                   (mul (lift l1) (lift h2))) (mul (lift h1) (lift l2)))\n             (Eop Olowlong (Eletvar 0 ::: Enil))))) v /\\\n  Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"apply eval_splitlong2; auto.\nintros.\nset (p := Val.mull' x2 y2).\nset (le1 := p :: le0).\nassert (E1: eval_expr ge sp e m le1 (Eop Olowlong (Eletvar O ::: Enil)) (Val.loword p)) by EvalOp.\nassert (E2: eval_expr ge sp e m le1 (Eop Ohighlong (Eletvar O ::: Enil)) (Val.hiword p)) by EvalOp.\nexploit eval_mul.\napply eval_lift.\neexact H2.\napply eval_lift.\neexact H3.\ninstantiate (1 := p).\nfold le1.\nintros [v3 [E3 L3]].\nexploit eval_mul.\napply eval_lift.\neexact H1.\napply eval_lift.\neexact H4.\ninstantiate (1 := p).\nfold le1.\nintros [v4 [E4 L4]].\nexploit eval_add.\neexact E2.\neexact E3.\nintros [v5 [E5 L5]].\nexploit eval_add.\neexact E5.\neexact E4.\nintros [v6 [E6 L6]].\nexists (Val.longofwords v6 (Val.loword p)); split.\nEvalOp.\neapply eval_builtin_2; eauto.\nreflexivity.\nreflexivity.\nintros.\nunfold le1, p in *; subst; simpl in *.\ninv L3.\ninv L4.\ninv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul.\ndestruct x; auto; destruct y; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (Elet\n       (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l) (a2 ::: b2 ::: Enil))\n       (makelong\n          (add\n             (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val),\neval_expr ge sp e m le0 a1 x1 ->\neval_expr ge sp e m le0 a2 x2 ->\neval_expr ge sp e m le0 b1 y1 ->\neval_expr ge sp e m le0 b2 y2 ->\nexists v : val,\n  eval_expr ge sp e m le0\n    (Elet\n       (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l) (a2 ::: b2 ::: Enil))\n       (makelong\n          (add\n             (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"intros.\nset (p := Val.mull' x2 y2).\nset (le1 := p :: le0).\nassert (E1: eval_expr ge sp e m le1 (Eop Olowlong (Eletvar O ::: Enil)) (Val.loword p)) by EvalOp.\nassert (E2: eval_expr ge sp e m le1 (Eop Ohighlong (Eletvar O ::: Enil)) (Val.hiword p)) by EvalOp.\nexploit eval_mul.\napply eval_lift.\neexact H2.\napply eval_lift.\neexact H3.\ninstantiate (1 := p).\nfold le1.\nintros [v3 [E3 L3]].\nexploit eval_mul.\napply eval_lift.\neexact H1.\napply eval_lift.\neexact H4.\ninstantiate (1 := p).\nfold le1.\nintros [v4 [E4 L4]].\nexploit eval_add.\neexact E2.\neexact E3.\nintros [v5 [E5 L5]].\nexploit eval_add.\neexact E5.\neexact E4.\nintros [v6 [E6 L6]].\nexists (Val.longofwords v6 (Val.loword p)); split.\nEvalOp.\neapply eval_builtin_2; eauto.\nreflexivity.\nreflexivity.\nintros.\nunfold le1, p in *; subst; simpl in *.\ninv L3.\ninv L4.\ninv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2) : exists v : val,\n  eval_expr ge sp e m le0\n    (Elet\n       (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l) (a2 ::: b2 ::: Enil))\n       (makelong\n          (add\n             (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2))).","conclusion":"exists v : val,\n  eval_expr ge sp e m le0\n    (Elet\n       (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l) (a2 ::: b2 ::: Enil))\n       (makelong\n          (add\n             (add (Eop Ohighlong (Eletvar 0 ::: Enil))\n                (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n          (Eop Olowlong (Eletvar 0 ::: Enil)))) v /\\\n  (forall p1 p2 q1 q2 : int,\n   x1 = Vint p1 ->\n   x2 = Vint p2 ->\n   y1 = Vint q1 ->\n   y2 = Vint q2 ->\n   v = Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val) (H1 : eval_expr ge sp e m le0 a1 x1) (H2 : eval_expr ge sp e m le0 a2 x2) (H3 : eval_expr ge sp e m le0 b1 y1) (H4 : eval_expr ge sp e m le0 b2 y2)","proofString":"set (p := Val.mull' x2 y2).\nset (le1 := p :: le0).\nassert (E1: eval_expr ge sp e m le1 (Eop Olowlong (Eletvar O ::: Enil)) (Val.loword p)) by EvalOp.\nassert (E2: eval_expr ge sp e m le1 (Eop Ohighlong (Eletvar O ::: Enil)) (Val.hiword p)) by EvalOp.\nexploit eval_mul.\napply eval_lift.\neexact H2.\napply eval_lift.\neexact H3.\ninstantiate (1 := p).\nfold le1.\nintros [v3 [E3 L3]].\nexploit eval_mul.\napply eval_lift.\neexact H1.\napply eval_lift.\neexact H4.\ninstantiate (1 := p).\nfold le1.\nintros [v4 [E4 L4]].\nexploit eval_add.\neexact E2.\neexact E3.\nintros [v5 [E5 L5]].\nexploit eval_add.\neexact E5.\neexact E4.\nintros [v6 [E6 L6]].\nexists (Val.longofwords v6 (Val.loword p)); split.\nEvalOp.\neapply eval_builtin_2; eauto.\nreflexivity.\nreflexivity.\nintros.\nunfold le1, p in *; subst; simpl in *.\ninv L3.\ninv L4.\ninv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (v3 : val) (L3 : Val.lessdef (Vint (Int.mul p2 q1)) v3) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) v3) (v4 : val) (L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) v4) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  match v3 with\n  | Vint n2 => Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) n2)\n  | Vptr b0 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else\n       Vptr b0\n         (Ptrofs.add ofs2 (Ptrofs.of_int (Int64.hiword (Int64.mul' p2 q2))))\n  | _ => Vundef\n  end v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 v4) v6) : Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (v3 : val) (L3 : Val.lessdef (Vint (Int.mul p2 q1)) v3) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) v3) (v4 : val) (L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) v4) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  match v3 with\n  | Vint n2 => Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) n2)\n  | Vptr b0 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else\n       Vptr b0\n         (Ptrofs.add ofs2 (Ptrofs.of_int (Int64.hiword (Int64.mul' p2 q2))))\n  | _ => Vundef\n  end v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 v4) v6)","proofString":"inv L3.\ninv L4.\ninv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (v4 : val) (L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) v4) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 v4) v6) : Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (v4 : val) (L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) v4) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 v4) v6)","proofString":"inv L4.\ninv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 (Vint (Int.mul p1 q2))) v6) : Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (v5 : val) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1))) v5) (L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef (Val.add v5 (Vint (Int.mul p1 q2))) v6)","proofString":"inv L5.\nsimpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef\n  (Val.add (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))\n     (Vint (Int.mul p1 q2))) v6) : Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef\n  (Val.add (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))\n     (Vint (Int.mul p1 q2))) v6)","proofString":"simpl in L6.\ninv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) v6) : Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (v6 : val) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2))) v6) (L6 : Val.lessdef\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) v6)","proofString":"inv L6.\nsimpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)))) : Val.longofwords\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Val.longofwords\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) (Vint (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))))","proofString":"simpl.\nf_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)))) : Vlong\n  (Int64.ofwords\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)).","conclusion":"Vlong\n  (Int64.ofwords\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2))) =\nVlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))))","proofString":"f_equal.\nsymmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)))) : Int64.ofwords\n  (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n     (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)) =\nInt64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2).","conclusion":"Int64.ofwords\n  (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n     (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)) =\nInt64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))))","proofString":"symmetry.\napply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)))) : Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2) =\nInt64.ofwords\n  (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n     (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)).","conclusion":"Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2) =\nInt64.ofwords\n  (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n     (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2))","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (le0 : letenv) (a1 a2 b1 b2 : expr) (p1 : int) (H1 : eval_expr ge sp e m le0 a1 (Vint p1)) (p2 : int) (H2 : eval_expr ge sp e m le0 a2 (Vint p2)) (q1 : int) (H3 : eval_expr ge sp e m le0 b1 (Vint q1)) (q2 : int) (p : val) (le1 : list val) (E1 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Olowlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))) (E2 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (Eop Ohighlong (Eletvar 0 ::: Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))) (H4 : eval_expr ge sp e m le0 b2 (Vint q2)) (E3 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))) (E4 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))) (E5 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))) (E6 : eval_expr ge sp e m (Vlong (Int64.mul' p2 q2) :: le0)\n  (add (add (Eop Ohighlong (Eletvar 0 ::: Enil)) (mul (lift a2) (lift b1)))\n     (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))))","proofString":"apply Int64.decompose_mul."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.mull x y = Vundef\n             end\n| _ => Val.mull x y = Vundef\nend.","conclusion":"match x with\n| Vlong _ => match y with\n             | Vlong _ => True\n             | _ => Val.mull x y = Vundef\n             end\n| _ => Val.mull x y = Vundef\nend","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct x; auto; destruct y; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then longconst Int64.zero\n     else\n      if Int64.eq n Int64.one\n      then a\n      else\n       match Int64.is_power2' n with\n       | Some l => shllimm a l\n       | None => mull_base a (longconst n)\n       end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.zero\n     then longconst Int64.zero\n     else\n      if Int64.eq n Int64.one\n      then a\n      else\n       match Int64.is_power2' n with\n       | Some l => shllimm a l\n       | None => mull_base a (longconst n)\n       end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.zero.\nsubst n.\neconstructor; split.\napply eval_longconst.\ndestruct x; simpl; auto.\nrewrite Int64.mul_zero.\nauto.\npredSpec Int64.eq Int64.eq_spec n Int64.one.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.mul_one.\nauto.\ndestruct (Int64.is_power2' n) as [l|] eqn:P2.\nexploit eval_shllimm.\neauto.\ninstantiate (1 := l).\nintros [v [A B]].\nexists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B.\napply eval_mull_base; auto.\napply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero) : exists v : val,\n  eval_expr ge sp e m le (longconst Int64.zero) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst Int64.zero) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int64.zero)","proofString":"subst n.\neconstructor; split.\napply eval_longconst.\ndestruct x; simpl; auto.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (longconst Int64.zero) v /\\\n  Val.lessdef (Val.mull x (Vlong Int64.zero)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst Int64.zero) v /\\\n  Val.lessdef (Val.mull x (Vlong Int64.zero)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split.\napply eval_longconst.\ndestruct x; simpl; auto.\nrewrite Int64.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"rewrite Int64.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) : Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero).","conclusion":"Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i))","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.one\n     then a\n     else\n      match Int64.is_power2' n with\n      | Some l => shllimm a l\n      | None => mull_base a (longconst n)\n      end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int64.eq n Int64.one\n     then a\n     else\n      match Int64.is_power2' n with\n      | Some l => shllimm a l\n      | None => mull_base a (longconst n)\n      end) v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero)","proofString":"predSpec Int64.eq Int64.eq_spec n Int64.one.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.mul_one.\nauto.\ndestruct (Int64.is_power2' n) as [l|] eqn:P2.\nexploit eval_shllimm.\neauto.\ninstantiate (1 := l).\nintros [v [A B]].\nexists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B.\napply eval_mull_base; auto.\napply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.one) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n = Int64.one)","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.one <> Int64.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong Int64.one)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mull x (Vlong Int64.one)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.one <> Int64.zero)","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.one <> Int64.zero) : Val.lessdef (Val.mull x (Vlong Int64.one)) x.","conclusion":"Val.lessdef (Val.mull x (Vlong Int64.one)) x","hypotheses":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int64.one <> Int64.zero)","proofString":"destruct x; simpl; auto.\nrewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.one <> Int64.zero) : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i).","conclusion":"Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.one <> Int64.zero)","proofString":"rewrite Int64.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.one <> Int64.zero) : Val.lessdef (Vlong i) (Vlong i).","conclusion":"Val.lessdef (Vlong i) (Vlong i)","hypotheses":"(le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : Int64.one <> Int64.zero)","proofString":"auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) : exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n with\n    | Some l => shllimm a l\n    | None => mull_base a (longconst n)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match Int64.is_power2' n with\n    | Some l => shllimm a l\n    | None => mull_base a (longconst n)\n    end v /\\ Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one)","proofString":"destruct (Int64.is_power2' n) as [l|] eqn:P2.\nexploit eval_shllimm.\neauto.\ninstantiate (1 := l).\nintros [v [A B]].\nexists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B.\napply eval_mull_base; auto.\napply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) : exists v : val,\n  eval_expr ge sp e m le (shllimm a l) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (shllimm a l) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l)","proofString":"exploit eval_shllimm.\neauto.\ninstantiate (1 := l).\nintros [v [A B]].\nexists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) : (exists v : val,\n   eval_expr ge sp e m le (shllimm a l) v /\\\n   Val.lessdef (Val.shll x (Vint l)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (shllimm a l) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"(exists v : val,\n   eval_expr ge sp e m le (shllimm a l) v /\\\n   Val.lessdef (Val.shll x (Vint l)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (shllimm a l) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l)","proofString":"intros [v [A B]].\nexists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll x (Vint l)) v) : exists v0 : val,\n  eval_expr ge sp e m le (shllimm a l) v0 /\\\n  Val.lessdef (Val.mull x (Vlong n)) v0.","conclusion":"exists v0 : val,\n  eval_expr ge sp e m le (shllimm a l) v0 /\\\n  Val.lessdef (Val.mull x (Vlong n)) v0","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll x (Vint l)) v)","proofString":"exists v; split; auto.\ndestruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll x (Vint l)) v) : Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll x (Vint l)) v)","proofString":"destruct x; simpl; auto.\nerewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v) : Val.lessdef (Vlong (Int64.mul i n)) v.","conclusion":"Val.lessdef (Vlong (Int64.mul i n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v)","proofString":"erewrite Int64.mul_pow2' by eauto.\nsimpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v) : Val.lessdef (Vlong (Int64.shl' i l)) v.","conclusion":"Val.lessdef (Vlong (Int64.shl' i l)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v)","proofString":"simpl in B.\nerewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef\n  (if Int.ltu l Int64.iwordsize' then Vlong (Int64.shl' i l) else Vundef) v) : Val.lessdef (Vlong (Int64.shl' i l)) v.","conclusion":"Val.lessdef (Vlong (Int64.shl' i l)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef\n  (if Int.ltu l Int64.iwordsize' then Vlong (Int64.shl' i l) else Vundef) v)","proofString":"erewrite Int64.is_power2'_range in B by eauto.\nexact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Vlong (Int64.shl' i l)) v) : Val.lessdef (Vlong (Int64.shl' i l)) v.","conclusion":"Val.lessdef (Vlong (Int64.shl' i l)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (i : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (l : int) (P2 : Int64.is_power2' n = Some l) (v : val) (A : eval_expr ge sp e m le (shllimm a l) v) (B : Val.lessdef (Vlong (Int64.shl' i l)) v)","proofString":"exact B."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (P2 : Int64.is_power2' n = None) : exists v : val,\n  eval_expr ge sp e m le (mull_base a (longconst n)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mull_base a (longconst n)) v /\\\n  Val.lessdef (Val.mull x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (P2 : Int64.is_power2' n = None)","proofString":"apply eval_mull_base; auto.\napply eval_longconst."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (P2 : Int64.is_power2' n = None) : eval_expr ge sp e m le (longconst n) (Vlong n).","conclusion":"eval_expr ge sp e m le (longconst n) (Vlong n)","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int64.zero) (H1 : n <> Int64.one) (P2 : Int64.is_power2' n = None)","proofString":"apply eval_longconst."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.mul n1 n2)\n        | None => mullimm n1 b\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => mullimm n2 a\n        | None => mull_base a b\n        end\n    end v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    match is_longconst a with\n    | Some n1 =>\n        match is_longconst b with\n        | Some n2 => longconst (Int64.mul n1 n2)\n        | None => mullimm n1 b\n        end\n    | None =>\n        match is_longconst b with\n        | Some n2 => mullimm n2 a\n        | None => mull_base a b\n        end\n    end v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y)","proofString":"destruct (is_longconst a) as [p|] eqn:LC1;  destruct (is_longconst b) as [q|] eqn:LC2.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto.\nexploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nreplace (Val.mull (Vlong p) y) with (Val.mull y (Vlong p)) in *.\neapply eval_mullimm; eauto.\ndestruct y; simpl; auto.\nrewrite Int64.mul_commut; auto.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neapply eval_mullimm; eauto.\napply eval_mull_base; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull x y) v.","conclusion":"x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst x.\nexploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q) : y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v.","conclusion":"y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst y.\neconstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(le : letenv) (a b : expr) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H0 : eval_expr ge sp e m le b (Vlong q)) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) (Vlong q)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (longconst (Int64.mul p q)) v /\\\n  Val.lessdef (Val.mull (Vlong p) (Vlong q)) v","hypotheses":"(le : letenv) (a b : expr) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (q : int64) (H0 : eval_expr ge sp e m le b (Vlong q)) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = Some q)","proofString":"econstructor; split.\napply eval_longconst.\nsimpl; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"exploit (is_longconst_sound le a); eauto.\nintros EQ; subst x.\nreplace (Val.mull (Vlong p) y) with (Val.mull y (Vlong p)) in *.\neapply eval_mullimm; eauto.\ndestruct y; simpl; auto.\nrewrite Int64.mul_commut; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"x = Vlong p ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (p : int64) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"intros EQ; subst x.\nreplace (Val.mull (Vlong p) y) with (Val.mull y (Vlong p)) in *.\neapply eval_mullimm; eauto.\ndestruct y; simpl; auto.\nrewrite Int64.mul_commut; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\\n  Val.lessdef (Val.mull (Vlong p) y) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"replace (Val.mull (Vlong p) y) with (Val.mull y (Vlong p)) in *.\neapply eval_mullimm; eauto.\ndestruct y; simpl; auto.\nrewrite Int64.mul_commut; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\\n  Val.lessdef (Val.mull y (Vlong p)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm p b) v /\\\n  Val.lessdef (Val.mull y (Vlong p)) v","hypotheses":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"eapply eval_mullimm; eauto."},{"statement":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : Val.mull y (Vlong p) = Val.mull (Vlong p) y.","conclusion":"Val.mull y (Vlong p) = Val.mull (Vlong p) y","hypotheses":"(le : letenv) (a b : expr) (y : val) (p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"destruct y; simpl; auto.\nrewrite Int64.mul_commut; auto."},{"statement":"(le : letenv) (a b : expr) (i p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b (Vlong i)) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None) : Vlong (Int64.mul i p) = Vlong (Int64.mul p i).","conclusion":"Vlong (Int64.mul i p) = Vlong (Int64.mul p i)","hypotheses":"(le : letenv) (a b : expr) (i p : int64) (H : eval_expr ge sp e m le a (Vlong p)) (H0 : eval_expr ge sp e m le b (Vlong i)) (LC1 : is_longconst a = Some p) (LC2 : is_longconst b = None)","proofString":"rewrite Int64.mul_commut; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"exploit (is_longconst_sound le b); eauto.\nintros EQ; subst y.\neapply eval_mullimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q) : y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"y = Vlong q ->\nexists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (q : int64) (LC2 : is_longconst b = Some q)","proofString":"intros EQ; subst y.\neapply eval_mullimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (q : int64) (H0 : eval_expr ge sp e m le b (Vlong q)) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some q) : exists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\\n  Val.lessdef (Val.mull x (Vlong q)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mullimm q a) v /\\\n  Val.lessdef (Val.mull x (Vlong q)) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (H : eval_expr ge sp e m le a x) (q : int64) (H0 : eval_expr ge sp e m le b (Vlong q)) (LC1 : is_longconst a = None) (LC2 : is_longconst b = Some q)","proofString":"eapply eval_mullimm; eauto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None) : exists v : val,\n  eval_expr ge sp e m le (mull_base a b) v /\\ Val.lessdef (Val.mull x y) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (mull_base a b) v /\\ Val.lessdef (Val.mull x y) v","hypotheses":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (LC1 : is_longconst a = None) (LC2 : is_longconst b = None)","proofString":"apply eval_mull_base; auto."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_umulh sig_ll_l (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhu x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_umulh sig_ll_l (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhu x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split; eauto.\neapply eval_helper_2; eauto.\napply eval_longconst.\nDeclHelper.\nreflexivity.\nreflexivity."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (a ::: longconst n ::: Enil))\n  (Val.mullhu x (Vlong n)).","conclusion":"eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (a ::: longconst n ::: Enil))\n  (Val.mullhu x (Vlong n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"eapply eval_helper_2; eauto.\napply eval_longconst.\nDeclHelper.\nreflexivity.\nreflexivity."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_smulh sig_ll_l (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhs x (Vlong n)) v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Eexternal i64_smulh sig_ll_l (a ::: longconst n ::: Enil)) v /\\\n  Val.lessdef (Val.mullhs x (Vlong n)) v","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"econstructor; split; eauto.\neapply eval_helper_2; eauto.\napply eval_longconst.\nDeclHelper.\nreflexivity.\nreflexivity."},{"statement":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (a ::: longconst n ::: Enil))\n  (Val.mullhs x (Vlong n)).","conclusion":"eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (a ::: longconst n ::: Enil))\n  (Val.mullhs x (Vlong n))","hypotheses":"(n : int64) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x)","proofString":"eapply eval_helper_2; eauto.\napply eval_longconst.\nDeclHelper.\nreflexivity.\nreflexivity."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : Val.shrxl x (Vint n) = Some z) : exists v : val, eval_expr ge sp e m le (shrxlimm a n) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrxlimm a n) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : Val.shrxl x (Vint n) = Some z)","proofString":"apply Val.shrxl_shrl_2 in H1.\nunfold shrxlimm.\ndestruct (Int.eq n Int.zero).\nsubst z; exists x; auto.\nset (le' := x :: le).\nedestruct (eval_shrlimm (Int.repr 63) le' (Eletvar O)) as (v1 & A1 & B1).\nconstructor.\nreflexivity.\nedestruct (eval_shrluimm (Int.sub (Int.repr 64) n) le') as (v2 & A2 & B2).\neexact A1.\nedestruct (eval_addl H le' (Eletvar 0)) as (v3 & A3 & B3).\nconstructor.\nreflexivity.\neexact A2.\nedestruct (eval_shrlimm n le') as (v4 & A4 & B4).\neexact A3.\nexists v4; split.\neconstructor; eauto.\nassert (X: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))).\nintros.\ninv H2; auto.\nassert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\n(if Int.eq n Int.zero\n then x\n else\n  Val.shrl\n    (Val.addl x\n       (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n))) : exists v : val, eval_expr ge sp e m le (shrxlimm a n) v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le (shrxlimm a n) v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\n(if Int.eq n Int.zero\n then x\n else\n  Val.shrl\n    (Val.addl x\n       (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)))","proofString":"unfold shrxlimm.\ndestruct (Int.eq n Int.zero).\nsubst z; exists x; auto.\nset (le' := x :: le).\nedestruct (eval_shrlimm (Int.repr 63) le' (Eletvar O)) as (v1 & A1 & B1).\nconstructor.\nreflexivity.\nedestruct (eval_shrluimm (Int.sub (Int.repr 64) n) le') as (v2 & A2 & B2).\neexact A1.\nedestruct (eval_addl H le' (Eletvar 0)) as (v3 & A3 & B3).\nconstructor.\nreflexivity.\neexact A2.\nedestruct (eval_shrlimm n le') as (v4 & A4 & B4).\neexact A3.\nexists v4; split.\neconstructor; eauto.\nassert (X: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))).\nintros.\ninv H2; auto.\nassert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\n(if Int.eq n Int.zero\n then x\n else\n  Val.shrl\n    (Val.addl x\n       (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n))) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      Elet a\n        (shrlimm\n           (addl (Eletvar 0)\n              (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                 (Int.sub (Int.repr 64) n))) n)) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      Elet a\n        (shrlimm\n           (addl (Eletvar 0)\n              (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                 (Int.sub (Int.repr 64) n))) n)) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\n(if Int.eq n Int.zero\n then x\n else\n  Val.shrl\n    (Val.addl x\n       (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n          (Vint (Int.sub (Int.repr 64) n)))) (Vint n)))","proofString":"destruct (Int.eq n Int.zero).\nsubst z; exists x; auto.\nset (le' := x :: le).\nedestruct (eval_shrlimm (Int.repr 63) le' (Eletvar O)) as (v1 & A1 & B1).\nconstructor.\nreflexivity.\nedestruct (eval_shrluimm (Int.sub (Int.repr 64) n) le') as (v2 & A2 & B2).\neexact A1.\nedestruct (eval_addl H le' (Eletvar 0)) as (v3 & A3 & B3).\nconstructor.\nreflexivity.\neexact A2.\nedestruct (eval_shrlimm n le') as (v4 & A4 & B4).\neexact A3.\nexists v4; split.\neconstructor; eauto.\nassert (X: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))).\nintros.\ninv H2; auto.\nassert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z = x) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","conclusion":"exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z = x)","proofString":"subst z; exists x; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (shrlimm\n          (addl (Eletvar 0)\n             (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                (Int.sub (Int.repr 64) n))) n)) v /\\ \n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (shrlimm\n          (addl (Eletvar 0)\n             (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                (Int.sub (Int.repr 64) n))) n)) v /\\ \n  Val.lessdef z v","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n))","proofString":"set (le' := x :: le).\nedestruct (eval_shrlimm (Int.repr 63) le' (Eletvar O)) as (v1 & A1 & B1).\nconstructor.\nreflexivity.\nedestruct (eval_shrluimm (Int.sub (Int.repr 64) n) le') as (v2 & A2 & B2).\neexact A1.\nedestruct (eval_addl H le' (Eletvar 0)) as (v3 & A3 & B3).\nconstructor.\nreflexivity.\neexact A2.\nedestruct (eval_shrlimm n le') as (v4 & A4 & B4).\neexact A3.\nexists v4; split.\neconstructor; eauto.\nassert (X: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))).\nintros.\ninv H2; auto.\nassert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) : Val.lessdef z v4.","conclusion":"Val.lessdef z v4","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4)","proofString":"assert (X: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))).\nintros.\ninv H2; auto.\nassert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0)).","conclusion":"forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4)","proofString":"intros.\ninv H2; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (v0 v5 : val) (n0 : int) (H2 : Val.lessdef v0 v5) : Val.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0)).","conclusion":"Val.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (v0 v5 : val) (n0 : int) (H2 : Val.lessdef v0 v5)","proofString":"inv H2; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) : Val.lessdef z v4.","conclusion":"Val.lessdef z v4","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0)))","proofString":"assert (Y: forall v1 v2 n, Val.lessdef v1 v2 -> Val.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))).\nintros.\ninv H2; auto.\nsubst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)).","conclusion":"forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0)))","proofString":"intros.\ninv H2; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v6 v7 : val) (n1 : int),\nVal.lessdef v6 v7 ->\nVal.lessdef (Val.shrl v6 (Vint n1)) (Val.shrl v7 (Vint n1))) (v0 v5 : val) (n0 : int) (H2 : Val.lessdef v0 v5) : Val.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)).","conclusion":"Val.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v6 v7 : val) (n1 : int),\nVal.lessdef v6 v7 ->\nVal.lessdef (Val.shrl v6 (Vint n1)) (Val.shrl v7 (Vint n1))) (v0 v5 : val) (n0 : int) (H2 : Val.lessdef v0 v5)","proofString":"inv H2; auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef z v4.","conclusion":"Val.lessdef z v4","hypotheses":"(le : letenv) (a : expr) (n : int) (x z : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (H1 : z =\nVal.shrl\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"subst z.\neapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) v4.","conclusion":"Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) v4","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"eapply Val.lessdef_trans; [|eexact B4].\napply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n))\n  (Val.shrl v3 (Vint n)).","conclusion":"Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n))\n  (Val.shrl v3 (Vint n))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"apply X.\neapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) v3.","conclusion":"Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) v3","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"eapply Val.lessdef_trans; [|eexact B3].\napply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Val.addl x v2).","conclusion":"Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Val.addl x v2)","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"apply Val.addl_lessdef; auto.\neapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2.","conclusion":"Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"eapply Val.lessdef_trans; [|eexact B2].\napply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n)))\n  (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))).","conclusion":"Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n)))\n  (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n)))","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"apply Y.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))) : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1.","conclusion":"Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1","hypotheses":"(le : letenv) (a : expr) (n : int) (x : val) (H : Archi.ptr64 = false) (H0 : eval_expr ge sp e m le a x) (le' : list val) (v1 : val) (A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1) (B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1) (v2 : val) (A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)) v2) (B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2) (v3 : val) (A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63)) (Int.sub (Int.repr 64) n)))\n  v3) (B3 : Val.lessdef (Val.addl x v2) v3) (v4 : val) (A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4) (B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4) (X : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))) (Y : forall (v0 v5 : val) (n0 : int),\nVal.lessdef v0 v5 ->\nVal.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0)))","proofString":"auto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_udiv sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_udiv sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divlu x y = Some z)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\neassumption.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_umod sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_umod sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modlu x y = Some z)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\neassumption.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_sdiv sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_sdiv sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.divls x y = Some z)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\neassumption.\nauto."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z) : exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_smod sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v.","conclusion":"exists v : val,\n  eval_expr ge sp e m le (Eexternal i64_smod sig_ll_l (a ::: b ::: Enil)) v /\\\n  Val.lessdef z v","hypotheses":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modls x y = Some z)","proofString":"econstructor; split.\neapply eval_helper_2; eauto.\nDeclHelper.\nreflexivity.\neassumption.\nauto."},{"statement":"(h l : int) : Int64.eq (Int64.ofwords h l) Int64.zero = Int.eq (Int.or h l) Int.zero.","conclusion":"Int64.eq (Int64.ofwords h l) Int64.zero = Int.eq (Int.or h l) Int.zero","hypotheses":"(h l : int)","proofString":"assert (Int64.zwordsize = Int.zwordsize * 2) by reflexivity.\npredSpec Int64.eq Int64.eq_spec (Int64.ofwords h l) Int64.zero.\nreplace (Int.or h l) with Int.zero.\nrewrite Int.eq_true.\nauto.\napply Int.same_bits_eq; intros.\nrewrite Int.bits_zero.\nrewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero.\nsymmetry.\napply Int.eq_false.\nred; intros; elim H0.\napply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) : Int64.eq (Int64.ofwords h l) Int64.zero = Int.eq (Int.or h l) Int.zero.","conclusion":"Int64.eq (Int64.ofwords h l) Int64.zero = Int.eq (Int.or h l) Int.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2)","proofString":"predSpec Int64.eq Int64.eq_spec (Int64.ofwords h l) Int64.zero.\nreplace (Int.or h l) with Int.zero.\nrewrite Int.eq_true.\nauto.\napply Int.same_bits_eq; intros.\nrewrite Int.bits_zero.\nrewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero.\nsymmetry.\napply Int.eq_false.\nred; intros; elim H0.\napply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) : true = Int.eq (Int.or h l) Int.zero.","conclusion":"true = Int.eq (Int.or h l) Int.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero)","proofString":"replace (Int.or h l) with Int.zero.\nrewrite Int.eq_true.\nauto.\napply Int.same_bits_eq; intros.\nrewrite Int.bits_zero.\nrewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) : true = Int.eq Int.zero Int.zero.","conclusion":"true = Int.eq Int.zero Int.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero)","proofString":"rewrite Int.eq_true.\nauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) : true = true.","conclusion":"true = true","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero)","proofString":"auto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) : Int.zero = Int.or h l.","conclusion":"Int.zero = Int.or h l","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero)","proofString":"apply Int.same_bits_eq; intros.\nrewrite Int.bits_zero.\nrewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit Int.zero i = Int.testbit (Int.or h l) i.","conclusion":"Int.testbit Int.zero i = Int.testbit (Int.or h l) i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int.bits_zero.\nrewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : false = Int.testbit (Int.or h l) i.","conclusion":"false = Int.testbit (Int.or h l) i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int.bits_or by auto.\nsymmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : false = Int.testbit h i || Int.testbit l i.","conclusion":"false = Int.testbit h i || Int.testbit l i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"symmetry.\napply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit h i || Int.testbit l i = false.","conclusion":"Int.testbit h i || Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"apply orb_false_intro.\ntransitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero.\ntransitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit h i = false.","conclusion":"Int.testbit h i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"transitivity (Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit h i = Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize).","conclusion":"Int.testbit h i = Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize)","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int64.bits_ofwords by lia.\nrewrite zlt_false by lia.\nf_equal; lia."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit h i =\n(if zlt (i + Int.zwordsize) Int.zwordsize\n then Int.testbit l (i + Int.zwordsize)\n else Int.testbit h (i + Int.zwordsize - Int.zwordsize)).","conclusion":"Int.testbit h i =\n(if zlt (i + Int.zwordsize) Int.zwordsize\n then Int.testbit l (i + Int.zwordsize)\n else Int.testbit h (i + Int.zwordsize - Int.zwordsize))","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite zlt_false by lia.\nf_equal; lia."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit h i = Int.testbit h (i + Int.zwordsize - Int.zwordsize).","conclusion":"Int.testbit h i = Int.testbit h (i + Int.zwordsize - Int.zwordsize)","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"f_equal; lia."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize) = false.","conclusion":"Int64.testbit (Int64.ofwords h l) (i + Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int64.testbit Int64.zero (i + Int.zwordsize) = false.","conclusion":"Int64.testbit Int64.zero (i + Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"apply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit l i = false.","conclusion":"Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"transitivity (Int64.testbit (Int64.ofwords h l) i).\nrewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto.\nrewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit l i = Int64.testbit (Int64.ofwords h l) i.","conclusion":"Int.testbit l i = Int64.testbit (Int64.ofwords h l) i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite Int64.bits_ofwords by lia.\nrewrite zlt_true by lia.\nauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit l i =\n(if zlt i Int.zwordsize\n then Int.testbit l i\n else Int.testbit h (i - Int.zwordsize)).","conclusion":"Int.testbit l i =\n(if zlt i Int.zwordsize\n then Int.testbit l i\n else Int.testbit h (i - Int.zwordsize))","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite zlt_true by lia.\nauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int.testbit l i = Int.testbit l i.","conclusion":"Int.testbit l i = Int.testbit l i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"auto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int64.testbit (Int64.ofwords h l) i = false.","conclusion":"Int64.testbit (Int64.ofwords h l) i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"rewrite H0.\napply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize) : Int64.testbit Int64.zero i = false.","conclusion":"Int64.testbit Int64.zero i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l = Int64.zero) (i : Z) (H1 : 0 <= i < Int.zwordsize)","proofString":"apply Int64.bits_zero."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) : false = Int.eq (Int.or h l) Int.zero.","conclusion":"false = Int.eq (Int.or h l) Int.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero)","proofString":"symmetry.\napply Int.eq_false.\nred; intros; elim H0.\napply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) : Int.eq (Int.or h l) Int.zero = false.","conclusion":"Int.eq (Int.or h l) Int.zero = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero)","proofString":"apply Int.eq_false.\nred; intros; elim H0.\napply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) : Int.or h l <> Int.zero.","conclusion":"Int.or h l <> Int.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero)","proofString":"red; intros; elim H0.\napply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) : Int64.ofwords h l = Int64.zero.","conclusion":"Int64.ofwords h l = Int64.zero","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero)","proofString":"apply Int64.same_bits_eq; intros.\nrewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) : Int64.testbit (Int64.ofwords h l) i = Int64.testbit Int64.zero i.","conclusion":"Int64.testbit (Int64.ofwords h l) i = Int64.testbit Int64.zero i","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize)","proofString":"rewrite Int64.bits_zero.\nrewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) : Int64.testbit (Int64.ofwords h l) i = false.","conclusion":"Int64.testbit (Int64.ofwords h l) i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize)","proofString":"rewrite Int64.bits_ofwords by auto.\ndestruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) : (if zlt i Int.zwordsize\n then Int.testbit l i\n else Int.testbit h (i - Int.zwordsize)) = false.","conclusion":"(if zlt i Int.zwordsize\n then Int.testbit l i\n else Int.testbit h (i - Int.zwordsize)) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize)","proofString":"destruct (zlt i Int.zwordsize).\nassert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto.\nassert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) : Int.testbit l i = false.","conclusion":"Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize)","proofString":"assert (Int.testbit (Int.or h l) i = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit (Int.or h l) i = false) : Int.testbit l i = false.","conclusion":"Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit (Int.or h l) i = false)","proofString":"rewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit h i || Int.testbit l i = false) : Int.testbit l i = false.","conclusion":"Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit h i || Int.testbit l i = false)","proofString":"exploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit h i || Int.testbit l i = false) : Int.testbit h i = false /\\ Int.testbit l i = false -> Int.testbit l i = false.","conclusion":"Int.testbit h i = false /\\ Int.testbit l i = false -> Int.testbit l i = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (l0 : i < Int.zwordsize) (H3 : Int.testbit h i || Int.testbit l i = false)","proofString":"tauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) : Int.testbit h (i - Int.zwordsize) = false.","conclusion":"Int.testbit h (i - Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize)","proofString":"assert (Int.testbit (Int.or h l) (i - Int.zwordsize) = false) by (rewrite H1; apply Int.bits_zero).\nrewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit (Int.or h l) (i - Int.zwordsize) = false) : Int.testbit h (i - Int.zwordsize) = false.","conclusion":"Int.testbit h (i - Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit (Int.or h l) (i - Int.zwordsize) = false)","proofString":"rewrite Int.bits_or in H3 by lia.\nexploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit h (i - Int.zwordsize) || Int.testbit l (i - Int.zwordsize) =\nfalse) : Int.testbit h (i - Int.zwordsize) = false.","conclusion":"Int.testbit h (i - Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit h (i - Int.zwordsize) || Int.testbit l (i - Int.zwordsize) =\nfalse)","proofString":"exploit orb_false_elim; eauto.\ntauto."},{"statement":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit h (i - Int.zwordsize) || Int.testbit l (i - Int.zwordsize) =\nfalse) : Int.testbit h (i - Int.zwordsize) = false /\\\nInt.testbit l (i - Int.zwordsize) = false ->\nInt.testbit h (i - Int.zwordsize) = false.","conclusion":"Int.testbit h (i - Int.zwordsize) = false /\\\nInt.testbit l (i - Int.zwordsize) = false ->\nInt.testbit h (i - Int.zwordsize) = false","hypotheses":"(h l : int) (H : Int64.zwordsize = Int.zwordsize * 2) (H0 : Int64.ofwords h l <> Int64.zero) (H1 : Int.or h l = Int.zero) (i : Z) (H2 : 0 <= i < Int64.zwordsize) (g : i >= Int.zwordsize) (H3 : Int.testbit h (i - Int.zwordsize) || Int.testbit l (i - Int.zwordsize) =\nfalse)","proofString":"tauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : eval_expr ge sp e m le (cmpl_eq_zero a) (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero a) (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"unfold cmpl_eq_zero.\neapply eval_splitlong_strict; eauto.\nintros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr => comp Ceq (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr => comp Ceq (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"eapply eval_splitlong_strict; eauto.\nintros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"intros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))","proofString":"exploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (v1 : val) (A1 : eval_expr ge sp e m le0 (or a1 a2) v1) (B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (v1 : val) (A1 : eval_expr ge sp e m le0 (or a1 a2) v1) (B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1)","proofString":"simpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x))))","proofString":"exploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Ceq).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) : (exists v : val,\n   eval_expr ge sp e m le0\n     (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef\n     (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero)) v) ->\neval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0\n     (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef\n     (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero)) v) ->\neval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x))))","proofString":"intros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2)","proofString":"unfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero\n   then Vtrue\n   else Vfalse) v2) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero\n   then Vtrue\n   else Vfalse) v2)","proofString":"rewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero\n   then Vtrue\n   else Vfalse) v2) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero\n   then Vtrue\n   else Vfalse) v2)","proofString":"rewrite Int64.ofwords_recompose in B2.\ndestruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef (if Int64.eq x Int64.zero then Vtrue else Vfalse) v2) : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero)).","conclusion":"eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef (if Int64.eq x Int64.zero then Vtrue else Vfalse) v2)","proofString":"destruct (Int64.eq x Int64.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : eval_expr ge sp e m le (cmpl_ne_zero a)\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero a)\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"unfold cmpl_ne_zero.\neapply eval_splitlong_strict; eauto.\nintros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr => comp Cne (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr => comp Cne (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"eapply eval_splitlong_strict; eauto.\nintros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) : forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"forall (le0 : letenv) (a1 a2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x))","proofString":"intros.\nexploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))","proofString":"exploit eval_or.\neexact H0.\neexact H1.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (v1 : val) (A1 : eval_expr ge sp e m le0 (or a1 a2) v1) (B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (v1 : val) (A1 : eval_expr ge sp e m le0 (or a1 a2) v1) (B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1)","proofString":"simpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x))))","proofString":"exploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cne).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) : (exists v : val,\n   eval_expr ge sp e m le0\n     (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef\n     (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero)) v) ->\neval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le0\n     (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef\n     (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero)) v) ->\neval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x))))","proofString":"intros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2)","proofString":"unfold Val.cmp in B2; simpl in B2.\nrewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if negb (Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero)\n   then Vtrue\n   else Vfalse) v2) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if negb (Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero)\n   then Vtrue\n   else Vfalse) v2)","proofString":"rewrite <- decompose_cmpl_eq_zero in B2.\nrewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if\n    negb\n      (Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero)\n   then Vtrue\n   else Vfalse) v2) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef\n  (if\n    negb\n      (Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero)\n   then Vtrue\n   else Vfalse) v2)","proofString":"rewrite Int64.ofwords_recompose in B2.\ndestruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef (if negb (Int64.eq x Int64.zero) then Vtrue else Vfalse) v2) : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero))).","conclusion":"eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (H : eval_expr ge sp e m le a (Vlong x)) (le0 : letenv) (a1 a2 : expr) (H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))) (v2 : val) (A2 : eval_expr ge sp e m le0 (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  v2) (B2 : Val.lessdef (if negb (Int64.eq x Int64.zero) then Vtrue else Vfalse) v2)","proofString":"destruct (negb (Int64.eq x Int64.zero)); inv B2; auto."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmplu_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le (cmplu_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"unfold cmplu_gen.\neapply eval_splitlong2_strict; eauto.\nintros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (h1 ::: h2 ::: Enil))\n        (Eop (Ocmp (Ccompu cl)) (l1 ::: l2 ::: Enil))\n        (Eop (Ocmp (Ccompu ch)) (h1 ::: h2 ::: Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (h1 ::: h2 ::: Enil))\n        (Eop (Ocmp (Ccompu cl)) (l1 ::: l2 ::: Enil))\n        (Eop (Ocmp (Ccompu ch)) (h1 ::: h2 ::: Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"eapply eval_splitlong2_strict; eauto.\nintros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword y)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword y)) ->\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccompu ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword y)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword y)) ->\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccompu ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"intros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (le0 : letenv) (a1 a2 b1 b2 : expr) (H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))) (H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y))) : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccompu ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccompu ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (le0 : letenv) (a1 a2 b1 b2 : expr) (H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))) (H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y)))","proofString":"econstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(p q : int64) : Int64.eq p q = Int64.eq (Int64.xor p q) Int64.zero.","conclusion":"Int64.eq p q = Int64.eq (Int64.xor p q) Int64.zero","hypotheses":"(p q : int64)","proofString":"predSpec Int64.eq Int64.eq_spec p q.\nsubst q.\nrewrite Int64.xor_idem.\nrewrite Int64.eq_true.\nauto.\npredSpec Int64.eq Int64.eq_spec (Int64.xor p q) Int64.zero.\nelim H.\napply Int64.xor_zero_equal; auto.\nauto."},{"statement":"(p q : int64) (H : p = q) : true = Int64.eq (Int64.xor p q) Int64.zero.","conclusion":"true = Int64.eq (Int64.xor p q) Int64.zero","hypotheses":"(p q : int64) (H : p = q)","proofString":"subst q.\nrewrite Int64.xor_idem.\nrewrite Int64.eq_true.\nauto."},{"statement":"(p : int64) : true = Int64.eq (Int64.xor p p) Int64.zero.","conclusion":"true = Int64.eq (Int64.xor p p) Int64.zero","hypotheses":"(p : int64)","proofString":"rewrite Int64.xor_idem.\nrewrite Int64.eq_true.\nauto."},{"statement":"(p : int64) : true = Int64.eq Int64.zero Int64.zero.","conclusion":"true = Int64.eq Int64.zero Int64.zero","hypotheses":"(p : int64)","proofString":"rewrite Int64.eq_true.\nauto."},{"statement":"(p : int64) : true = true.","conclusion":"true = true","hypotheses":"(p : int64)","proofString":"auto."},{"statement":"(p q : int64) (H : p <> q) : false = Int64.eq (Int64.xor p q) Int64.zero.","conclusion":"false = Int64.eq (Int64.xor p q) Int64.zero","hypotheses":"(p q : int64) (H : p <> q)","proofString":"predSpec Int64.eq Int64.eq_spec (Int64.xor p q) Int64.zero.\nelim H.\napply Int64.xor_zero_equal; auto.\nauto."},{"statement":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q = Int64.zero) : false = true.","conclusion":"false = true","hypotheses":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q = Int64.zero)","proofString":"elim H.\napply Int64.xor_zero_equal; auto."},{"statement":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q = Int64.zero) : p = q.","conclusion":"p = q","hypotheses":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q = Int64.zero)","proofString":"apply Int64.xor_zero_equal; auto."},{"statement":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q <> Int64.zero) : false = false.","conclusion":"false = false","hypotheses":"(p q : int64) (H : p <> q) (H0 : Int64.xor p q <> Int64.zero)","proofString":"auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) v.","conclusion":"eval_expr ge sp e m le (cmplu c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.cmplu (Mem.valid_pointer m) c x y = Some v) (H2 : Archi.ptr64 = false)","proofString":"unfold Val.cmplu, Val.cmplu_bool in H1.\nrewrite H2 in H1.\nsimpl in H1.\ndestruct x; simpl in H1; try discriminate H1; destruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if\n            Int64.eq n1 Int64.zero &&\n            (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n             || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match y with\n      | Vlong n2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if\n            Int64.eq n2 Int64.zero &&\n            (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n             || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if eq_block b1 b2\n           then\n            if\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n             (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n              || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n            then Some (Ptrofs.cmpu c ofs1 ofs2)\n            else None\n           else\n            if\n             Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n             Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            then Val.cmp_different_blocks c\n            else None\n      | _ => None\n      end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) v.","conclusion":"eval_expr ge sp e m le (cmplu c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if\n            Int64.eq n1 Int64.zero &&\n            (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n             || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match y with\n      | Vlong n2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if\n            Int64.eq n2 Int64.zero &&\n            (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n             || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | Vptr b2 ofs2 =>\n          if negb Archi.ptr64\n          then None\n          else\n           if eq_block b1 b2\n           then\n            if\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n             (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n              || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n            then Some (Ptrofs.cmpu c ofs1 ofs2)\n            else None\n           else\n            if\n             Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n             Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            then Val.cmp_different_blocks c\n            else None\n      | _ => None\n      end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false)","proofString":"rewrite H2 in H1.\nsimpl in H1.\ndestruct x; simpl in H1; try discriminate H1; destruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | Vptr b2 ofs2 =>\n          if negb false\n          then None\n          else\n           if\n            Int64.eq n1 Int64.zero &&\n            (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n             || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match y with\n      | Vlong n2 =>\n          if negb false\n          then None\n          else\n           if\n            Int64.eq n2 Int64.zero &&\n            (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n             || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | Vptr b2 ofs2 =>\n          if negb false\n          then None\n          else\n           if eq_block b1 b2\n           then\n            if\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n             (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n              || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n            then Some (Ptrofs.cmpu c ofs1 ofs2)\n            else None\n           else\n            if\n             Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n             Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            then Val.cmp_different_blocks c\n            else None\n      | _ => None\n      end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) v.","conclusion":"eval_expr ge sp e m le (cmplu c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | Vptr b2 ofs2 =>\n          if negb false\n          then None\n          else\n           if\n            Int64.eq n1 Int64.zero &&\n            (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n             || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | _ => None\n      end\n  | Vptr b1 ofs1 =>\n      match y with\n      | Vlong n2 =>\n          if negb false\n          then None\n          else\n           if\n            Int64.eq n2 Int64.zero &&\n            (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n             || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1))\n           then Val.cmp_different_blocks c\n           else None\n      | Vptr b2 ofs2 =>\n          if negb false\n          then None\n          else\n           if eq_block b1 b2\n           then\n            if\n             (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1)\n              || Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1 - 1)) &&\n             (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n              || Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2 - 1))\n            then Some (Ptrofs.cmpu c ofs1 ofs2)\n            else None\n           else\n            if\n             Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1) &&\n             Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2)\n            then Val.cmp_different_blocks c\n            else None\n      | _ => None\n      end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false)","proofString":"simpl in H1.\ndestruct x; simpl in H1; try discriminate H1; destruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | _ => None\n      end\n  | Vptr _ _ => match y with\n                | Vundef | _ => None\n                end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) v.","conclusion":"eval_expr ge sp e m le (cmplu c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match x with\n  | Vlong n1 =>\n      match y with\n      | Vlong n2 => Some (Int64.cmpu c n1 n2)\n      | _ => None\n      end\n  | Vptr _ _ => match y with\n                | Vundef | _ => None\n                end\n  | _ => None\n  end = Some v) (H2 : Archi.ptr64 = false)","proofString":"destruct x; simpl in H1; try discriminate H1; destruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b (Vlong i0)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0)).","conclusion":"eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b (Vlong i0)) (H2 : Archi.ptr64 = false)","proofString":"rename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong i0)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x i0)).","conclusion":"eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x i0))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong i0)) (H2 : Archi.ptr64 = false)","proofString":"rename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x y)).","conclusion":"eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x y))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"destruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\nexploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto.\nexploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1)","proofString":"simpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Vlong (Int64.xor x y)) v1) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Vlong (Int64.xor x y)) v1)","proofString":"inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"rewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"apply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1)","proofString":"simpl in B.\ninv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Vlong (Int64.xor x y)) v1) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Vlong (Int64.xor x y)) v1)","proofString":"inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"rewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"apply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit (eval_cmplu_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword x) (Int64.loword y)\n      else Int.ltu (Int64.hiword x) (Int64.hiword y))) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword x) (Int64.loword y)\n      else Int.ltu (Int64.hiword x) (Int64.hiword y))) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"rewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool\n     (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        (Int64.ofwords (Int64.hiword y) (Int64.loword y)))) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool\n     (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        (Int64.ofwords (Int64.hiword y) (Int64.loword y)))) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"rewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y)) ->\neval_expr ge sp e m le (cmplu_gen Clt Clt a b) (Val.of_bool (Int64.ltu x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit (eval_cmplu_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb (Int64.ltu y (Int64.ofwords (Int64.hiword x) (Int64.loword x))))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb (Int64.ltu y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x))))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int64.decompose_leu.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.ltu (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.ltu (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit (eval_cmplu_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"rewrite Int.eq_sym.\nrewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"rewrite <- Int64.decompose_ltu.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n        (Int64.ofwords (Int64.hiword x) (Int64.loword x)))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool\n     (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n        (Int64.ofwords (Int64.hiword x) (Int64.loword x)))) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"rewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x)) ->\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b) (Val.of_bool (Int64.ltu y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false)","proofString":"exploit (eval_cmplu_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y))))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int64.decompose_leu.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x))).","conclusion":"eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H2 : Archi.ptr64 = false) (H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"auto."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le (cmpl_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"unfold cmpl_gen.\neapply eval_splitlong2_strict; eauto.\nintros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (h1 ::: h2 ::: Enil))\n        (Eop (Ocmp (Ccompu cl)) (l1 ::: l2 ::: Enil))\n        (Eop (Ocmp (Ccomp ch)) (h1 ::: h2 ::: Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (h1 ::: h2 ::: Enil))\n        (Eop (Ocmp (Ccompu cl)) (l1 ::: l2 ::: Enil))\n        (Eop (Ocmp (Ccomp ch)) (h1 ::: h2 ::: Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"eapply eval_splitlong2_strict; eauto.\nintros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword y)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword y)) ->\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccomp ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"forall (le0 : letenv) (a1 a2 b1 b2 : expr),\neval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)) ->\neval_expr ge sp e m le0 a2 (Vint (Int64.loword x)) ->\neval_expr ge sp e m le0 b1 (Vint (Int64.hiword y)) ->\neval_expr ge sp e m le0 b2 (Vint (Int64.loword y)) ->\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccomp ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"intros.\neconstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (le0 : letenv) (a1 a2 b1 b2 : expr) (H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))) (H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y))) : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccomp ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (a1 ::: b1 ::: Enil))\n     (Eop (Ocmp (Ccompu cl)) (a2 ::: b2 ::: Enil))\n     (Eop (Ocmp (Ccomp ch)) (a1 ::: b1 ::: Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(ch cl : comparison) (a b : expr) (le : letenv) (x y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (le0 : letenv) (a1 a2 b1 b2 : expr) (H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))) (H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))) (H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))) (H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y)))","proofString":"econstructor.\neconstructor.\nEvalOp.\nsimpl.\neauto.\ndestruct (Int.eq (Int64.hiword x) (Int64.hiword y)); EvalOp."},{"statement":"(h l : int) : Int64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"generalize (Int64.shru_lt_zero (Int64.ofwords h l)).\nchange (Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)))    with (Int64.shru' (Int64.ofwords h l) (Int.repr 63)).\nrewrite Int64.decompose_shru_2.\nchange (Int.sub (Int.repr 63) Int.iwordsize)    with (Int.repr (Int.zwordsize - 1)).\nrewrite Int.shru_lt_zero.\ndestruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto.\nvm_compute.\nintuition congruence."},{"statement":"(h l : int) : Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"change (Int64.shru (Int64.ofwords h l) (Int64.repr (Int64.zwordsize - 1)))    with (Int64.shru' (Int64.ofwords h l) (Int.repr 63)).\nrewrite Int64.decompose_shru_2.\nchange (Int.sub (Int.repr 63) Int.iwordsize)    with (Int.repr (Int.zwordsize - 1)).\nrewrite Int.shru_lt_zero.\ndestruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto.\nvm_compute.\nintuition congruence."},{"statement":"(h l : int) : Int64.shru' (Int64.ofwords h l) (Int.repr 63) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.shru' (Int64.ofwords h l) (Int.repr 63) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"rewrite Int64.decompose_shru_2.\nchange (Int.sub (Int.repr 63) Int.iwordsize)    with (Int.repr (Int.zwordsize - 1)).\nrewrite Int.shru_lt_zero.\ndestruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto.\nvm_compute.\nintuition congruence."},{"statement":"(h l : int) : Int64.ofwords Int.zero (Int.shru h (Int.sub (Int.repr 63) Int.iwordsize)) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.ofwords Int.zero (Int.shru h (Int.sub (Int.repr 63) Int.iwordsize)) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"change (Int.sub (Int.repr 63) Int.iwordsize)    with (Int.repr (Int.zwordsize - 1)).\nrewrite Int.shru_lt_zero.\ndestruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto."},{"statement":"(h l : int) : Int64.ofwords Int.zero (Int.shru h (Int.repr (Int.zwordsize - 1))) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.ofwords Int.zero (Int.shru h (Int.repr (Int.zwordsize - 1))) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"rewrite Int.shru_lt_zero.\ndestruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto."},{"statement":"(h l : int) : Int64.ofwords Int.zero (if Int.lt h Int.zero then Int.one else Int.zero) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero.","conclusion":"Int64.ofwords Int.zero (if Int.lt h Int.zero then Int.one else Int.zero) =\n(if Int64.lt (Int64.ofwords h l) Int64.zero then Int64.one else Int64.zero) ->\nInt64.lt (Int64.ofwords h l) Int64.zero = Int.lt h Int.zero","hypotheses":"(h l : int)","proofString":"destruct (Int64.lt (Int64.ofwords h l) Int64.zero); destruct (Int.lt h Int.zero); auto; intros.\nelim Int64.one_not_zero.\nauto.\nelim Int64.one_not_zero.\nauto."},{"statement":"(h l : int) (H : Int64.ofwords Int.zero Int.zero = Int64.one) : true = false.","conclusion":"true = false","hypotheses":"(h l : int) (H : Int64.ofwords Int.zero Int.zero = Int64.one)","proofString":"elim Int64.one_not_zero.\nauto."},{"statement":"(h l : int) (H : Int64.ofwords Int.zero Int.zero = Int64.one) : Int64.one = Int64.zero.","conclusion":"Int64.one = Int64.zero","hypotheses":"(h l : int) (H : Int64.ofwords Int.zero Int.zero = Int64.one)","proofString":"auto."},{"statement":"(h l : int) (H : Int64.ofwords Int.zero Int.one = Int64.zero) : false = true.","conclusion":"false = true","hypotheses":"(h l : int) (H : Int64.ofwords Int.zero Int.one = Int64.zero)","proofString":"elim Int64.one_not_zero.\nauto."},{"statement":"(h l : int) (H : Int64.ofwords Int.zero Int.one = Int64.zero) : Int64.one = Int64.zero.","conclusion":"Int64.one = Int64.zero","hypotheses":"(h l : int) (H : Int64.ofwords Int.zero Int.one = Int64.zero)","proofString":"auto."},{"statement":"(h l : int) : Int.zwordsize <= Int.unsigned (Int.repr 63) < Int64.zwordsize.","conclusion":"Int.zwordsize <= Int.unsigned (Int.repr 63) < Int64.zwordsize","hypotheses":"(h l : int)","proofString":"vm_compute.\nintuition congruence."},{"statement":"(h l : int) : (Lt = Gt -> False) /\\ Lt = Lt.","conclusion":"(Lt = Gt -> False) /\\ Lt = Lt","hypotheses":"(h l : int)","proofString":"intuition congruence."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.cmpl c x y = Some v) : eval_expr ge sp e m le (cmpl c a b) v.","conclusion":"eval_expr ge sp e m le (cmpl c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.cmpl c x y = Some v)","proofString":"unfold Val.cmpl in H1.\ndestruct x; simpl in H1; try discriminate.\ndestruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool (Val.cmpl_bool c x y) = Some v) : eval_expr ge sp e m le (cmpl c a b) v.","conclusion":"eval_expr ge sp e m le (cmpl c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y v : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool (Val.cmpl_bool c x y) = Some v)","proofString":"destruct x; simpl in H1; try discriminate.\ndestruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (y v : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match y with\n  | Vlong n2 => Some (Int64.cmp c i n2)\n  | _ => None\n  end = Some v) : eval_expr ge sp e m le (cmpl c a b) v.","conclusion":"eval_expr ge sp e m le (cmpl c a b) v","hypotheses":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (y v : val) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b y) (H1 : option_map Val.of_bool\n  match y with\n  | Vlong n2 => Some (Int64.cmp c i n2)\n  | _ => None\n  end = Some v)","proofString":"destruct y; inv H1.\nrename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b (Vlong i0)) : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c i i0)).","conclusion":"eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c i i0))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (i : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong i)) (H0 : eval_expr ge sp e m le b (Vlong i0))","proofString":"rename i into x.\nrename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong i0)) : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x i0)).","conclusion":"eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x i0))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (i0 : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong i0))","proofString":"rename i0 into y.\ndestruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x y)).","conclusion":"eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x y))","hypotheses":"(c : comparison) (le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"destruct c; simpl.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto.\nexploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\nexploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto.\nexploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto.\ndestruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"exploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1)","proofString":"simpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b)) (Val.of_bool (Int64.eq x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"rewrite int64_eq_xor.\napply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero)).","conclusion":"eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"apply eval_cmpl_eq_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"exploit eval_xorl.\neexact H.\neexact H0.\nintros [v1 [A B]].\nsimpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (v1 : val) (A : eval_expr ge sp e m le (xorl a b) v1) (B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1)","proofString":"simpl in B; inv B.\nrewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"rewrite int64_eq_xor.\napply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))) : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero))).","conclusion":"eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y)))","proofString":"apply eval_cmpl_ne_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"destruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto.\nexploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true)","proofString":"exploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true) : Vlong y = Vlong Int64.zero ->\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y)).","conclusion":"Vlong y = Vlong Int64.zero ->\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true)","proofString":"intros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true)","proofString":"exploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong x)) v1) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong x)) v1)","proofString":"simpl in B1.\ninv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Vint (Int64.hiword x)) v1) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Vint (Int64.hiword x)) v1)","proofString":"inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x)))","proofString":"exploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Clt).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) : (exists v : val,\n   eval_expr ge sp e m le\n     (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v) ->\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v) ->\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x)))","proofString":"intros [v2 [A2 B2]].\nunfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v2) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v2)","proofString":"unfold Val.cmp in B2.\nsimpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (Val.of_optbool (Val.cmp_bool Clt (Vint (Int64.hiword x)) (Vint Int.zero)))\n  v2) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (Val.of_optbool (Val.cmp_bool Clt (Vint (Int64.hiword x)) (Vint Int.zero)))\n  v2)","proofString":"simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2)","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) Int64.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2)","proofString":"rewrite decompose_cmpl_lt_zero.\ndestruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int.lt (Int64.hiword x) Int.zero)).","conclusion":"eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int.lt (Int64.hiword x) Int.zero))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2)","proofString":"destruct (Int.lt (Int64.hiword x) Int.zero); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) : eval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false)","proofString":"exploit (eval_cmpl_gen Clt Clt).\neexact H.\neexact H0.\nsimpl.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword x) (Int64.loword y)\n      else Int.lt (Int64.hiword x) (Int64.hiword y))) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword x) (Int64.loword y)\n      else Int.lt (Int64.hiword x) (Int64.hiword y))) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false)","proofString":"rewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        (Int64.ofwords (Int64.hiword y) (Int64.loword y)))) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        (Int64.ofwords (Int64.hiword y) (Int64.loword y)))) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false)","proofString":"rewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) : eval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y)) ->\neval_expr ge sp e m le (cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false)","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"exploit (eval_cmpl_gen Clt Cle).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb (Int64.lt y (Int64.ofwords (Int64.hiword x) (Int64.loword x))))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb (Int64.lt y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x))))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int64.decompose_le.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.lt (Int64.hiword x) (Int64.hiword y))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.lt (Int64.hiword x) (Int64.hiword y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"exploit (eval_cmpl_gen Cgt Cgt).\neexact H.\neexact H0.\nsimpl.\nrewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.lt (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.lt (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"rewrite Int.eq_sym.\nrewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.lt (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then Int.ltu (Int64.loword y) (Int64.loword x)\n      else Int.lt (Int64.hiword y) (Int64.hiword x))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"rewrite <- Int64.decompose_lt.\nrewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n        (Int64.ofwords (Int64.hiword x) (Int64.loword x)))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n        (Int64.ofwords (Int64.hiword x) (Int64.loword x)))) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"rewrite ! Int64.ofwords_recompose.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x)) ->\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b) (Val.of_bool (Int64.lt y x))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Cgt Cge a b) (Val.of_bool (negb (Int64.lt x y))).","conclusion":"eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Cgt Cge a b) (Val.of_bool (negb (Int64.lt x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y))","proofString":"destruct (is_longconst_zero b) eqn:LC.\nexploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto.\nexploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true)","proofString":"exploit is_longconst_zero_sound; eauto.\nintros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true) : Vlong y = Vlong Int64.zero ->\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y))).","conclusion":"Vlong y = Vlong Int64.zero ->\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = true)","proofString":"intros EQ; inv EQ; clear H0.\nexploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true)","proofString":"exploit eval_highlong.\neexact H.\nintros [v1 [A1 B1]].\nsimpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong x)) v1) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (v1 : val) (A1 : eval_expr ge sp e m le (highlong a) v1) (B1 : Val.lessdef (Val.hiword (Vlong x)) v1)","proofString":"simpl in B1; inv B1.\nexploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x)))","proofString":"exploit eval_comp.\neexact A1.\ninstantiate (2 := Eop (Ointconst Int.zero) Enil).\nEvalOp.\ninstantiate (1 := Cge).\nintros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) : (exists v : val,\n   eval_expr ge sp e m le\n     (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v) ->\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"(exists v : val,\n   eval_expr ge sp e m le\n     (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v /\\\n   Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v) ->\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x)))","proofString":"intros [v2 [A2 B2]].\nunfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v2) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v2)","proofString":"unfold Val.cmp in B2; simpl in B2.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2)","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           Int64.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           Int64.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2)","proofString":"rewrite decompose_cmpl_lt_zero.\ndestruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2) : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int.lt (Int64.hiword x) Int.zero))).","conclusion":"eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int.lt (Int64.hiword x) Int.zero)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (H : eval_expr ge sp e m le a (Vlong x)) (LC : is_longconst_zero b = true) (A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))) (v2 : val) (A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2) (B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse) v2)","proofString":"destruct (negb (Int.lt (Int64.hiword x) Int.zero)); inv B2; auto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false)","proofString":"exploit (eval_cmpl_gen Cgt Cge).\neexact H.\neexact H0.\nintros.\nrewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose x).\nrewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite <- (Int64.ofwords_recompose y).\nrewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y))))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int64.decompose_le.\nrewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"rewrite Int.eq_sym.\nauto."},{"statement":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))) : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x))).","conclusion":"eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))","hypotheses":"(le : letenv) (a : expr) (x : int64) (b : expr) (y : int64) (H : eval_expr ge sp e m le a (Vlong x)) (H0 : eval_expr ge sp e m le b (Vlong y)) (LC : is_longconst_zero b = false) (H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))))","proofString":"auto."}]}