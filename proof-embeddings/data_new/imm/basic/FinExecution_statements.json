{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/basic/FinExecution.v","fileSamples":[{"statement":"(G : execution) : set_finite (acts_set G) <->\nset_finite (acts_set G \\₁ (fun a : actid => is_init a)) /\\\nset_finite (acts_set G ∩₁ (fun a : actid => is_init a)).","conclusion":"set_finite (acts_set G) <->\nset_finite (acts_set G \\₁ (fun a : actid => is_init a)) /\\\nset_finite (acts_set G ∩₁ (fun a : actid => is_init a))","hypotheses":"(G : execution)","proofString":"rewrite <- set_finite_union.\napply set_finite_more.\nrewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : set_finite (acts_set G) <->\nset_finite\n  (acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a)).","conclusion":"set_finite (acts_set G) <->\nset_finite\n  (acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a))","hypotheses":"(G : execution)","proofString":"apply set_finite_more.\nrewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : acts_set G\n≡₁ acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a).","conclusion":"acts_set G\n≡₁ acts_set G \\₁ (fun a : actid => is_init a)\n   ∪₁ acts_set G ∩₁ (fun a : actid => is_init a)","hypotheses":"(G : execution)","proofString":"rewrite set_minusE, set_unionC, <- set_inter_union_r, <- set_full_split.\nbasic_solver."},{"statement":"(G : execution) : acts_set G ≡₁ acts_set G ∩₁ ⊤₁.","conclusion":"acts_set G ≡₁ acts_set G ∩₁ ⊤₁","hypotheses":"(G : execution)","proofString":"basic_solver."},{"statement":"(thread : thread_id) (AA : fin_exec_full G) (n m : nat) (EQ : ThreadEvent thread n = ThreadEvent thread m) : n = m.","conclusion":"n = m","hypotheses":"(thread : thread_id) (AA : fin_exec_full G) (n m : nat) (EQ : ThreadEvent thread n = ThreadEvent thread m)","proofString":"desf."},{"statement":"(thread : thread_id) (AA : fin_exec_full G) : forall x y : actid, {x = y} + {x <> y}.","conclusion":"forall x y : actid, {x = y} + {x <> y}","hypotheses":"(thread : thread_id) (AA : fin_exec_full G)","proofString":"apply eq_dec_actid."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : exists n0 : nat, ~ acts_set G (ThreadEvent thread n0).","conclusion":"exists n0 : nat, ~ acts_set G (ThreadEvent thread n0)","hypotheses":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m))","proofString":"exists (1 + n).\napply AA.\nlia."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : ~ acts_set G (ThreadEvent thread (1 + n)).","conclusion":"~ acts_set G (ThreadEvent thread (1 + n))","hypotheses":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m))","proofString":"apply AA.\nlia."},{"statement":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m)) : n < 1 + n.","conclusion":"n < 1 + n","hypotheses":"(thread : thread_id) (n : nat) (AA : forall m : nat, n < m -> ~ acts_set G (ThreadEvent thread m))","proofString":"lia."},{"statement":"(G G' : execution) (SAME : acts_set G ≡₁ acts_set G') (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a))) : set_finite (acts_set G' \\₁ (fun a : actid => is_init a)).","conclusion":"set_finite (acts_set G' \\₁ (fun a : actid => is_init a))","hypotheses":"(G G' : execution) (SAME : acts_set G ≡₁ acts_set G') (FIN : set_finite (acts_set G \\₁ (fun a : actid => is_init a)))","proofString":"by rewrite <- SAME."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite\n  (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)\n   ∪₁ S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","conclusion":"set_finite\n  (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)\n   ∪₁ S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"apply set_finite_union.\nsplit.\neapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x.\neapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)) /\\\nset_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","conclusion":"set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)) /\\\nset_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"split.\neapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x.\neapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)).","conclusion":"set_finite (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"eapply set_finite_mori; [| by apply set_finite_empty].\nred.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : Basics.flip set_subset ∅ (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a)).","conclusion":"Basics.flip set_subset ∅ (S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"red.\nunfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a) ⊆₁ ∅.","conclusion":"S ∩₁ Tid_ thread ∩₁ (fun a : actid => is_init a) ⊆₁ ∅","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"unfolder.\nins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : forall x : actid, (S x /\\ tid x = thread) /\\ is_init x -> False.","conclusion":"forall x : actid, (S x /\\ tid x = thread) /\\ is_init x -> False","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"ins.\ndesc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : (S x /\\ tid x = thread) /\\ is_init x) : False.","conclusion":"False","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : (S x /\\ tid x = thread) /\\ is_init x)","proofString":"desc.\nvauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : S x) (H1 : tid x = thread) (H0 : is_init x) : False.","conclusion":"False","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (x : actid) (H : S x) (H1 : tid x = thread) (H0 : is_init x)","proofString":"vauto.\nby destruct x."},{"statement":"(S : actid -> Prop) (x : actid) (NT : tid x <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (H : S x) (H0 : is_init x) : False.","conclusion":"False","hypotheses":"(S : actid -> Prop) (x : actid) (NT : tid x <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) (H : S x) (H0 : is_init x)","proofString":"by destruct x."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : set_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","conclusion":"set_finite (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"eapply set_finite_mori; [| by apply FIN].\nred.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : Basics.flip set_subset (S \\₁ (fun a : actid => is_init a))\n  (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)).","conclusion":"Basics.flip set_subset (S \\₁ (fun a : actid => is_init a))\n  (S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a))","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"red.\nbasic_solver."},{"statement":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a))) : S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ S \\₁ (fun a : actid => is_init a).","conclusion":"S ∩₁ Tid_ thread ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ S \\₁ (fun a : actid => is_init a)","hypotheses":"(S : actid -> Prop) (thread : BinNums.positive) (NT : thread <> tid_init) (FIN : set_finite (S \\₁ (fun a : actid => is_init a)))","proofString":"basic_solver."}]}