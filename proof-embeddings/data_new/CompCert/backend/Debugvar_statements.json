{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Debugvar.v","fileSamples":[{"statement":"(i1 i2 : debuginfo) (e : proj1_sig i1 = proj1_sig i2) : {i1 = i2} + {i1 <> i2}.","conclusion":"{i1 = i2} + {i1 <> i2}","hypotheses":"(i1 i2 : debuginfo) (e : proj1_sig i1 = proj1_sig i2)","proofString":"left.\ndestruct i1, i2; simpl in *.\nsubst x0.\nf_equal.\napply proof_irr."},{"statement":"(i1 i2 : debuginfo) (e : proj1_sig i1 = proj1_sig i2) : i1 = i2.","conclusion":"i1 = i2","hypotheses":"(i1 i2 : debuginfo) (e : proj1_sig i1 = proj1_sig i2)","proofString":"destruct i1, i2; simpl in *.\nsubst x0.\nf_equal.\napply proof_irr."},{"statement":"(x : builtin_arg loc) (s : safe_builtin_arg x) (x0 : builtin_arg loc) (s0 : safe_builtin_arg x0) (e : x = x0) : exist (fun a : builtin_arg loc => safe_builtin_arg a) x s =\nexist (fun a : builtin_arg loc => safe_builtin_arg a) x0 s0.","conclusion":"exist (fun a : builtin_arg loc => safe_builtin_arg a) x s =\nexist (fun a : builtin_arg loc => safe_builtin_arg a) x0 s0","hypotheses":"(x : builtin_arg loc) (s : safe_builtin_arg x) (x0 : builtin_arg loc) (s0 : safe_builtin_arg x0) (e : x = x0)","proofString":"subst x0.\nf_equal.\napply proof_irr."},{"statement":"(x : builtin_arg loc) (s s0 : safe_builtin_arg x) : exist (fun a : builtin_arg loc => safe_builtin_arg a) x s =\nexist (fun a : builtin_arg loc => safe_builtin_arg a) x s0.","conclusion":"exist (fun a : builtin_arg loc => safe_builtin_arg a) x s =\nexist (fun a : builtin_arg loc => safe_builtin_arg a) x s0","hypotheses":"(x : builtin_arg loc) (s s0 : safe_builtin_arg x)","proofString":"f_equal.\napply proof_irr."},{"statement":"(x : builtin_arg loc) (s s0 : safe_builtin_arg x) : s = s0.","conclusion":"s = s0","hypotheses":"(x : builtin_arg loc) (s s0 : safe_builtin_arg x)","proofString":"apply proof_irr."},{"statement":"(i1 i2 : debuginfo) (n : proj1_sig i1 <> proj1_sig i2) : {i1 = i2} + {i1 <> i2}.","conclusion":"{i1 = i2} + {i1 <> i2}","hypotheses":"(i1 i2 : debuginfo) (n : proj1_sig i1 <> proj1_sig i2)","proofString":"right.\ncongruence."},{"statement":"(i1 i2 : debuginfo) (n : proj1_sig i1 <> proj1_sig i2) : i1 <> i2.","conclusion":"i1 <> i2","hypotheses":"(i1 i2 : debuginfo) (n : proj1_sig i1 <> proj1_sig i2)","proofString":"congruence."},{"statement":"(s1 s2 : avail) : forall x y : ident * debuginfo, {x = y} + {x <> y}.","conclusion":"forall x y : ident * debuginfo, {x = y} + {x <> y}","hypotheses":"(s1 s2 : avail)","proofString":"decide equality.\napply eq_debuginfo.\napply ident_eq."},{"statement":"(s1 s2 : avail) (x y : ident * debuginfo) (a : ident) (b : debuginfo) (i : ident) (d : debuginfo) (a0 : a = i) : {b = d} + {b <> d}.","conclusion":"{b = d} + {b <> d}","hypotheses":"(s1 s2 : avail) (x y : ident * debuginfo) (a : ident) (b : debuginfo) (i : ident) (d : debuginfo) (a0 : a = i)","proofString":"apply eq_debuginfo."},{"statement":"(s1 s2 : avail) (x y : ident * debuginfo) (a : ident) (b : debuginfo) (i : ident) (d : debuginfo) : {a = i} + {a <> i}.","conclusion":"{a = i} + {a <> i}","hypotheses":"(s1 s2 : avail) (x y : ident * debuginfo) (a : ident) (b : debuginfo) (i : ident) (d : debuginfo)","proofString":"apply ident_eq."}]}