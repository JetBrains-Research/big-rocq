{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/Round_NE.v","fileSamples":[{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"destruct (total_order_T 0 x) as [[Hx|Hx]|Hx].\nexact (Hpos x xd xu Hx Hfx Hd Hu Hxd Hxu).\nelim Hfx.\nrewrite <- Hx.\napply generic_format_0.\nassert (Hx': (0 < -x)%R).\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive, Ropp_0.\ndestruct xd as (md, ed).\ndestruct xu as (mu, eu).\nsimpl.\nrewrite <- (Bool.negb_involutive (Z.even mu)).\napply f_equal.\napply sym_eq.\nrewrite <- (Z.even_opp mu), <- (Z.even_opp md).\nchange (Z.even (Fnum (Float beta (-md) ed)) = negb (Z.even (Fnum (Float beta (-mu) eu)))).\napply (Hpos (-x)%R _ _ Hx').\nintros H.\napply Hfx.\nrewrite <- Ropp_involutive.\nnow apply generic_format_opp.\nnow apply canonical_opp.\nnow apply canonical_opp.\nrewrite round_DN_opp, F2R_Zopp.\nnow apply f_equal.\nrewrite round_UP_opp, F2R_Zopp.\nnow apply f_equal."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : (0 < x)%R) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"exact (Hpos x xd xu Hx Hfx Hd Hu Hxd Hxu)."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : 0%R = x) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"elim Hfx.\nrewrite <- Hx.\napply generic_format_0."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : 0%R = x) : format x.","proofString":"rewrite <- Hx.\napply generic_format_0."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : 0%R = x) : format 0.","proofString":"apply generic_format_0."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : (x < 0)%R) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"assert (Hx': (0 < -x)%R).\napply Ropp_lt_cancel.\nnow rewrite Ropp_involutive, Ropp_0.\ndestruct xd as (md, ed).\ndestruct xu as (mu, eu).\nsimpl.\nrewrite <- (Bool.negb_involutive (Z.even mu)).\napply f_equal.\napply sym_eq.\nrewrite <- (Z.even_opp mu), <- (Z.even_opp md).\nchange (Z.even (Fnum (Float beta (-md) ed)) = negb (Z.even (Fnum (Float beta (-mu) eu)))).\napply (Hpos (-x)%R _ _ Hx').\nintros H.\napply Hfx.\nrewrite <- Ropp_involutive.\nnow apply generic_format_opp.\nnow apply canonical_opp.\nnow apply canonical_opp.\nrewrite round_DN_opp, F2R_Zopp.\nnow apply f_equal.\nrewrite round_UP_opp, F2R_Zopp.\nnow apply f_equal."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : (x < 0)%R) : (0 < - x)%R.","proofString":"apply Ropp_lt_cancel.\nnow rewrite Ropp_involutive, Ropp_0."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : (x < 0)%R) : (- - x < - 0)%R.","proofString":"now rewrite Ropp_involutive, Ropp_0."},{"statement":"(Hpos : DN_UP_parity_pos_prop) (x : R) (xd xu : float beta) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (Hx : (x < 0)%R) (Hx' : (0 < - x)%R) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"destruct xd as (md, ed).\ndestruct xu as (mu, eu).\nsimpl.\nrewrite <- (Bool.negb_involutive (Z.even mu)).\napply f_equal.\napply sym_eq.\nrewrite <- (Z.even_opp mu), <- (Z.even_opp md).\nchange (Z.even (Fnum (Float beta (-md) ed)) = negb (Z.even (Fnum (Float beta (-mu) eu)))).\napply (Hpos (-x)%R _ _ Hx').\nintros H.\napply Hfx.\nrewrite <- Ropp_involutive.\nnow apply generic_format_opp.\nnow apply canonical_opp.\nnow apply canonical_opp.\nrewrite round_DN_opp, F2R_Zopp.\nnow apply f_equal.\nrewrite round_UP_opp, F2R_Zopp.\nnow apply f_equal."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"assert (Hd3 : Fnum xd = Z0).\napply eq_0_F2R with beta (Fexp xd).\nchange (F2R xd = R0).\nrewrite Hxd.\napply round_DN_small_pos with (1 := Hex) (2 := Hxe).\nassert (Hu3 : xu = Float beta (1 * Zpower beta (fexp ex - fexp (fexp ex + 1))) (fexp (fexp ex + 1))).\napply canonical_unique with (1 := Hu).\napply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp.\nrewrite <- F2R_change_exp.\nrewrite F2R_bpow.\napply sym_eq.\nrewrite Hxu.\napply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe).\nnow apply valid_exp.\nrewrite Hd3, Hu3.\nrewrite Zmult_1_l.\nsimpl.\ndestruct exists_NE_ as [H|H].\napply Zeven_Zpower_odd with (2 := H).\napply Zle_minus_le_0.\nnow apply valid_exp.\nrewrite (proj2 (H ex)).\nnow rewrite Zminus_diag.\nexact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) : Fnum xd = 0%Z.","proofString":"apply eq_0_F2R with beta (Fexp xd).\nchange (F2R xd = R0).\nrewrite Hxd.\napply round_DN_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) : F2R xd = R0.","proofString":"rewrite Hxd.\napply round_DN_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) : round beta fexp Zfloor x = R0.","proofString":"apply round_DN_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"assert (Hu3 : xu = Float beta (1 * Zpower beta (fexp ex - fexp (fexp ex + 1))) (fexp (fexp ex + 1))).\napply canonical_unique with (1 := Hu).\napply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp.\nrewrite <- F2R_change_exp.\nrewrite F2R_bpow.\napply sym_eq.\nrewrite Hxu.\napply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe).\nnow apply valid_exp.\nrewrite Hd3, Hu3.\nrewrite Zmult_1_l.\nsimpl.\ndestruct exists_NE_ as [H|H].\napply Zeven_Zpower_odd with (2 := H).\napply Zle_minus_le_0.\nnow apply valid_exp.\nrewrite (proj2 (H ex)).\nnow rewrite Zminus_diag.\nexact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}.","proofString":"apply canonical_unique with (1 := Hu).\napply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp.\nrewrite <- F2R_change_exp.\nrewrite F2R_bpow.\napply sym_eq.\nrewrite Hxu.\napply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe).\nnow apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : canonical\n  {|\n    Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n    Fexp := fexp (fexp ex + 1)\n  |}.","proofString":"apply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : (fexp (fexp ex + 1) <= fexp ex)%Z.","proofString":"now apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : F2R xu = bpow (fexp ex).","proofString":"apply sym_eq.\nrewrite Hxu.\napply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : bpow (fexp ex) = F2R xu.","proofString":"rewrite Hxu.\napply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : bpow (fexp ex) = round beta fexp Zceil x.","proofString":"apply sym_eq.\napply round_UP_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : round beta fexp Zceil x = bpow (fexp ex).","proofString":"apply round_UP_small_pos with (1 := Hex) (2 := Hxe)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) : (fexp (fexp ex + 1) <= fexp ex)%Z.","proofString":"now apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite Hd3, Hu3.\nrewrite Zmult_1_l.\nsimpl.\ndestruct exists_NE_ as [H|H].\napply Zeven_Zpower_odd with (2 := H).\napply Zle_minus_le_0.\nnow apply valid_exp.\nrewrite (proj2 (H ex)).\nnow rewrite Zminus_diag.\nexact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) : Z.even (beta ^ (fexp ex - fexp (fexp ex + 1))) = false.","proofString":"destruct exists_NE_ as [H|H].\napply Zeven_Zpower_odd with (2 := H).\napply Zle_minus_le_0.\nnow apply valid_exp.\nrewrite (proj2 (H ex)).\nnow rewrite Zminus_diag.\nexact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : Z.even beta = false) : Z.even (beta ^ (fexp ex - fexp (fexp ex + 1))) = false.","proofString":"apply Zeven_Zpower_odd with (2 := H).\napply Zle_minus_le_0.\nnow apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : Z.even beta = false) : (0 <= fexp ex - fexp (fexp ex + 1))%Z.","proofString":"apply Zle_minus_le_0.\nnow apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : Z.even beta = false) : (fexp (fexp ex + 1) <= fexp ex)%Z.","proofString":"now apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : forall e : Z,\n((fexp e < e)%Z -> (fexp (e + 1) < e)%Z) /\\\n((e <= fexp e)%Z -> fexp (fexp e + 1) = fexp e)) : Z.even (beta ^ (fexp ex - fexp (fexp ex + 1))) = false.","proofString":"rewrite (proj2 (H ex)).\nnow rewrite Zminus_diag.\nexact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : forall e : Z,\n((fexp e < e)%Z -> (fexp (e + 1) < e)%Z) /\\\n((e <= fexp e)%Z -> fexp (fexp e + 1) = fexp e)) : Z.even (beta ^ (fexp ex - fexp ex)) = false.","proofString":"now rewrite Zminus_diag."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (ex <= fexp ex)%Z) (Hd3 : Fnum xd = 0%Z) (Hu3 : xu =\n{|\n  Fnum := 1 * beta ^ (fexp ex - fexp (fexp ex + 1));\n  Fexp := fexp (fexp ex + 1)\n|}) (H : forall e : Z,\n((fexp e < e)%Z -> (fexp (e + 1) < e)%Z) /\\\n((e <= fexp e)%Z -> fexp (fexp e + 1) = fexp e)) : (ex <= fexp ex)%Z.","proofString":"exact Hxe."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nrewrite Hxd.\nsplit.\napply (round_DN_pt beta fexp x).\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\nlia.\napply Hex.\napply Rle_lt_trans with (2 := proj2 Hex).\napply (round_DN_pt beta fexp x).\nrewrite Hxd.\napply (round_DN_pt beta fexp x).\napply generic_format_0.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (bpow (ex - 1) <= F2R xd < bpow ex)%R.","proofString":"rewrite Hxd.\nsplit.\napply (round_DN_pt beta fexp x).\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\nlia.\napply Hex.\napply Rle_lt_trans with (2 := proj2 Hex).\napply (round_DN_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (bpow (ex - 1) <= round beta fexp Zfloor x < bpow ex)%R.","proofString":"split.\napply (round_DN_pt beta fexp x).\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\nlia.\napply Hex.\napply Rle_lt_trans with (2 := proj2 Hex).\napply (round_DN_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (bpow (ex - 1) <= round beta fexp Zfloor x)%R.","proofString":"apply (round_DN_pt beta fexp x).\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\nlia.\napply Hex."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : format (bpow (ex - 1)).","proofString":"apply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (fexp (ex - 1 + 1) <= ex - 1)%Z.","proofString":"ring_simplify (ex - 1 + 1)%Z.\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (fexp ex <= ex - 1)%Z.","proofString":"lia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (bpow (ex - 1) <= x)%R.","proofString":"apply Hex."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (round beta fexp Zfloor x < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 Hex).\napply (round_DN_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (round beta fexp Zfloor x <= x)%R.","proofString":"apply (round_DN_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (0 <= F2R xd)%R.","proofString":"rewrite Hxd.\napply (round_DN_pt beta fexp x).\napply generic_format_0.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (0 <= round beta fexp Zfloor x)%R.","proofString":"apply (round_DN_pt beta fexp x).\napply generic_format_0.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : format 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) : F2R xu = (F2R xd + ulp beta fexp x)%R.","proofString":"rewrite Hxu, Hxd.\nnow apply round_UP_DN_ulp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) : round beta fexp Zceil x = (round beta fexp Zfloor x + ulp beta fexp x)%R.","proofString":"now apply round_UP_DN_ulp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"assert (Hu3: xu = Float beta (1 * Zpower beta (ex - fexp (ex + 1))) (fexp (ex + 1))).\napply canonical_unique with (1 := Hu).\napply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp.\nrewrite <- Hu2.\napply sym_eq.\nrewrite <- F2R_change_exp.\napply F2R_bpow.\nexact Hxe2.\nassert (Hd3: xd = Float beta (Zpower beta (ex - fexp ex) - 1) (fexp ex)).\nassert (H: F2R xd = F2R (Float beta (Zpower beta (ex - fexp ex) - 1) (fexp ex))).\nunfold F2R.\nsimpl.\nrewrite minus_IZR.\nunfold Rminus.\nrewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak.\napply canonical_unique with (1 := Hd) (3 := H).\napply (f_equal fexp).\nrewrite <- H.\napply sym_eq.\nnow apply mag_unique.\nrewrite Hd3, Hu3.\nunfold Fnum.\nrewrite Z.even_mul.\nsimpl.\nunfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}.","proofString":"apply canonical_unique with (1 := Hu).\napply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp.\nrewrite <- Hu2.\napply sym_eq.\nrewrite <- F2R_change_exp.\napply F2R_bpow.\nexact Hxe2."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) : canonical\n  {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}.","proofString":"apply (f_equal fexp).\nrewrite <- F2R_change_exp.\nnow rewrite F2R_bpow, mag_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) : (fexp (ex + 1) <= ex)%Z.","proofString":"now apply valid_exp."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) : (fexp (ex + 1) <= ex)%Z.","proofString":"exact Hxe2."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"assert (Hd3: xd = Float beta (Zpower beta (ex - fexp ex) - 1) (fexp ex)).\nassert (H: F2R xd = F2R (Float beta (Zpower beta (ex - fexp ex) - 1) (fexp ex))).\nunfold F2R.\nsimpl.\nrewrite minus_IZR.\nunfold Rminus.\nrewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak.\napply canonical_unique with (1 := Hd) (3 := H).\napply (f_equal fexp).\nrewrite <- H.\napply sym_eq.\nnow apply mag_unique.\nrewrite Hd3, Hu3.\nunfold Fnum.\nrewrite Z.even_mul.\nsimpl.\nunfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}.","proofString":"assert (H: F2R xd = F2R (Float beta (Zpower beta (ex - fexp ex) - 1) (fexp ex))).\nunfold F2R.\nsimpl.\nrewrite minus_IZR.\nunfold Rminus.\nrewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak.\napply canonical_unique with (1 := Hd) (3 := H).\napply (f_equal fexp).\nrewrite <- H.\napply sym_eq.\nnow apply mag_unique."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(IZR (beta ^ (ex - fexp ex) - 1) * bpow (fexp ex))%R.","proofString":"rewrite minus_IZR.\nunfold Rminus.\nrewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n((IZR (beta ^ (ex - fexp ex)) - 1) * bpow (fexp ex))%R.","proofString":"unfold Rminus.\nrewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n((IZR (beta ^ (ex - fexp ex)) + - (1)) * bpow (fexp ex))%R.","proofString":"rewrite Rmult_plus_distr_r.\nrewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(IZR (beta ^ (ex - fexp ex)) * bpow (fexp ex) + - (1) * bpow (fexp ex))%R.","proofString":"rewrite IZR_Zpower, <- bpow_plus.\nring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le.\napply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(bpow (ex - fexp ex + fexp ex) + - (1) * bpow (fexp ex))%R.","proofString":"ring_simplify (ex - fexp ex + fexp ex)%Z.\nrewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R = (bpow ex + - (1) * bpow (fexp ex))%R.","proofString":"rewrite Hu2, Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(F2R xd + ulp beta fexp x + - (1) * bpow (fexp ex))%R.","proofString":"rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(F2R xd + bpow (cexp beta fexp x) + - (1) * bpow (fexp ex))%R.","proofString":"unfold cexp.\nrewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(F2R xd + bpow (fexp (mag beta x)) + - (1) * bpow (fexp ex))%R.","proofString":"rewrite mag_unique with beta x ex.\nunfold F2R.\nsimpl.\nring.\nrewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(F2R xd + bpow (fexp ex) + - (1) * bpow (fexp ex))%R.","proofString":"unfold F2R.\nsimpl.\nring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(IZR (Fnum xd) * bpow (Fexp xd) + bpow (fexp ex) + - (1) * bpow (fexp ex))%R.","proofString":"simpl.\nring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (IZR (Fnum xd) * bpow (Fexp xd))%R =\n(IZR (Fnum xd) * bpow (Fexp xd) + bpow (fexp ex) + - (1) * bpow (fexp ex))%R.","proofString":"ring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (bpow (ex - 1) <= Rabs x < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nexact Hex.\nnow apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (bpow (ex - 1) <= x < bpow ex)%R.","proofString":"exact Hex."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (0 <= ex - fexp ex)%Z.","proofString":"apply Zle_minus_le_0.\nnow apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) : (fexp ex <= ex)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite Hd3, Hu3.\nunfold Fnum.\nrewrite Z.even_mul.\nsimpl.\nunfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (1 * beta ^ (ex - fexp (ex + 1))) =\nnegb (Z.even (beta ^ (ex - fexp ex) - 1)).","proofString":"rewrite Z.even_mul.\nsimpl.\nunfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : (Z.even 1 || Z.even (beta ^ (ex - fexp (ex + 1))))%bool =\nnegb (Z.even (beta ^ (ex - fexp ex) - 1)).","proofString":"simpl.\nunfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (Z.even (beta ^ (ex - fexp ex) - 1)).","proofString":"unfold Zminus at 2.\nrewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (Z.even (beta ^ (ex - fexp ex) + - (1))).","proofString":"rewrite Z.even_add.\nrewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (Bool.eqb (Z.even (beta ^ (ex - fexp ex))) (Z.even (- (1)))).","proofString":"rewrite eqb_sym.\nsimpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (Bool.eqb (Z.even (- (1))) (Z.even (beta ^ (ex - fexp ex)))).","proofString":"simpl.\nfold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (if Z.even (beta ^ (ex - fexp ex)) then false else true).","proofString":"fold (negb (Z.even (beta ^ (ex - fexp ex)))).\nrewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) =\nnegb (negb (Z.even (beta ^ (ex - fexp ex)))).","proofString":"rewrite Bool.negb_involutive.\nrewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) = Z.even (beta ^ (ex - fexp ex)).","proofString":"rewrite (Z.even_pow beta (ex - fexp ex)) by lia.\ndestruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) : Z.even (beta ^ (ex - fexp (ex + 1))) = Z.even beta.","proofString":"destruct exists_NE_.\nrewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0.\napply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : Z.even beta = false) : Z.even (beta ^ (ex - fexp (ex + 1))) = Z.even beta.","proofString":"rewrite H.\napply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : Z.even beta = false) : Z.even (beta ^ (ex - fexp (ex + 1))) = false.","proofString":"apply Zeven_Zpower_odd with (2 := H).\nnow apply Zle_minus_le_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : Z.even beta = false) : (0 <= ex - fexp (ex + 1))%Z.","proofString":"now apply Zle_minus_le_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : forall e : Z,\n((fexp e < e)%Z -> (fexp (e + 1) < e)%Z) /\\\n((e <= fexp e)%Z -> fexp (fexp e + 1) = fexp e)) : Z.even (beta ^ (ex - fexp (ex + 1))) = Z.even beta.","proofString":"apply Z.even_pow.\nspecialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : forall e : Z,\n((fexp e < e)%Z -> (fexp (e + 1) < e)%Z) /\\\n((e <= fexp e)%Z -> fexp (fexp e + 1) = fexp e)) : (0 < ex - fexp (ex + 1))%Z.","proofString":"specialize (H ex).\nlia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : bpow ex = F2R xu) (Hu3 : xu = {| Fnum := 1 * beta ^ (ex - fexp (ex + 1)); Fexp := fexp (ex + 1) |}) (Hd3 : xd = {| Fnum := beta ^ (ex - fexp ex) - 1; Fexp := fexp ex |}) (H : ((fexp ex < ex)%Z -> (fexp (ex + 1) < ex)%Z) /\\\n((ex <= fexp ex)%Z -> fexp (fexp ex + 1) = fexp ex)) : (0 < ex - fexp (ex + 1))%Z.","proofString":"lia."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hud : F2R xu = (F2R xd + ulp beta fexp x)%R) (Hu2 : (F2R xu < bpow ex)%R) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"revert Hud.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold F2R.\nrewrite Hd, Hu.\nunfold cexp.\nrewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : F2R xu = (F2R xd + ulp beta fexp x)%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold F2R.\nrewrite Hd, Hu.\nunfold cexp.\nrewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : F2R xu = (F2R xd + bpow (cexp beta fexp x))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"unfold F2R.\nrewrite Hd, Hu.\nunfold cexp.\nrewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (Fexp xu))%R =\n(IZR (Fnum xd) * bpow (Fexp xd) + bpow (cexp beta fexp x))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite Hd, Hu.\nunfold cexp.\nrewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (cexp beta fexp (F2R xu)))%R =\n(IZR (Fnum xd) * bpow (cexp beta fexp (F2R xd)) + bpow (cexp beta fexp x))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"unfold cexp.\nrewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (fexp (mag beta (F2R xu))))%R =\n(IZR (Fnum xd) * bpow (fexp (mag beta (F2R xd))) + bpow (fexp (mag beta x)))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite mag_unique with beta (F2R xu) ex.\nrewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp (mag beta (F2R xd))) + bpow (fexp (mag beta x)))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite mag_unique with (1 := Hd4).\nrewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp (mag beta x)))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"rewrite mag_unique with (1 := Hexa).\nintros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R ->\nZ.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"intros H.\nreplace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : Z.even (Fnum xu) = negb (Z.even (Fnum xd)).","proofString":"replace (Fnum xu) with (Fnum xd + 1)%Z.\nrewrite Z.even_add.\nnow apply eqb_sym.\napply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : Z.even (Fnum xd + 1) = negb (Z.even (Fnum xd)).","proofString":"rewrite Z.even_add.\nnow apply eqb_sym."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : Bool.eqb (Z.even (Fnum xd)) (Z.even 1) = negb (Z.even (Fnum xd)).","proofString":"now apply eqb_sym."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : (Fnum xd + 1)%Z = Fnum xu.","proofString":"apply sym_eq.\napply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : Fnum xu = (Fnum xd + 1)%Z.","proofString":"apply eq_IZR.\nrewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : IZR (Fnum xu) = IZR (Fnum xd + 1).","proofString":"rewrite plus_IZR.\napply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : IZR (Fnum xu) = (IZR (Fnum xd) + 1)%R.","proofString":"apply Rmult_eq_reg_r with (bpow (fexp ex)).\nrewrite H.\nsimpl.\nring.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : (IZR (Fnum xu) * bpow (fexp ex))%R = ((IZR (Fnum xd) + 1) * bpow (fexp ex))%R.","proofString":"rewrite H.\nsimpl.\nring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : (IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R =\n((IZR (Fnum xd) + 1) * bpow (fexp ex))%R.","proofString":"simpl.\nring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : (IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R =\n((IZR (Fnum xd) + 1) * bpow (fexp ex))%R.","proofString":"ring."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : bpow (fexp ex) <> 0%R.","proofString":"apply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) (H : (IZR (Fnum xu) * bpow (fexp ex))%R =\n(IZR (Fnum xd) * bpow (fexp ex) + bpow (fexp ex))%R) : (bpow (fexp ex) > 0)%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (bpow (ex - 1) <= Rabs (F2R xu) < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2.\napply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (bpow (ex - 1) <= F2R xu < bpow ex)%R.","proofString":"split.\napply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x).\nexact Hu2."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (bpow (ex - 1) <= F2R xu)%R.","proofString":"apply Rle_trans with (1 := proj1 Hex).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (x <= F2R xu)%R.","proofString":"rewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (x <= round beta fexp Zceil x)%R.","proofString":"apply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (F2R xu < bpow ex)%R.","proofString":"exact Hu2."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (0 <= F2R xu)%R.","proofString":"apply Rlt_le.\napply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (0 < F2R xu)%R.","proofString":"apply Rlt_le_trans with (1 := H0x).\nrewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (x <= F2R xu)%R.","proofString":"rewrite Hxu.\napply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (xd xu : float beta) (H0x : (0 < x)%R) (Hfx : ~ format x) (Hd : canonical xd) (Hu : canonical xu) (Hxd : F2R xd = round beta fexp Zfloor x) (Hxu : F2R xu = round beta fexp Zceil x) (ex : Z) (Hexa : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hxe : (fexp ex < ex)%Z) (Hd4 : (bpow (ex - 1) <= Rabs (F2R xd) < bpow ex)%R) (Hxe2 : (fexp (ex + 1) <= ex)%Z) (Hu2 : (F2R xu < bpow ex)%R) : (x <= round beta fexp Zceil x)%R.","proofString":"apply (round_UP_pt beta fexp x)."},{"statement":"DN_UP_parity_pos_prop.","proofString":"apply DN_UP_parity_generic_pos."},{"statement":"satisfies_any format.","proofString":"now apply generic_format_satisfies_any."},{"statement":"NG_existence_prop format NE_prop.","proofString":"intros x d u Hf Hd Hu.\ngeneralize (proj1 Hd).\nunfold generic_format.\nset (ed := cexp beta fexp d).\nset (md := Ztrunc (scaled_mantissa beta fexp d)).\nintros Hd1.\ncase_eq (Z.even md) ; [ intros He | intros Ho ].\nright.\nexists (Float beta md ed).\nunfold Generic_fmt.canonical.\nrewrite <- Hd1.\nnow repeat split.\nleft.\ngeneralize (proj1 Hu).\nunfold generic_format.\nset (eu := cexp beta fexp u).\nset (mu := Ztrunc (scaled_mantissa beta fexp u)).\nintros Hu1.\nrewrite Hu1.\neexists ; repeat split.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite (DN_UP_parity_generic x (Float beta md ed) (Float beta mu eu)).\nsimpl.\nnow rewrite Ho.\nexact Hf.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hd1.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hf : ~ format x) (Hd : Rnd_DN_pt format x d) (Hu : Rnd_UP_pt format x u) : NE_prop x u \\/ NE_prop x d.","proofString":"generalize (proj1 Hd).\nunfold generic_format.\nset (ed := cexp beta fexp d).\nset (md := Ztrunc (scaled_mantissa beta fexp d)).\nintros Hd1.\ncase_eq (Z.even md) ; [ intros He | intros Ho ].\nright.\nexists (Float beta md ed).\nunfold Generic_fmt.canonical.\nrewrite <- Hd1.\nnow repeat split.\nleft.\ngeneralize (proj1 Hu).\nunfold generic_format.\nset (eu := cexp beta fexp u).\nset (mu := Ztrunc (scaled_mantissa beta fexp u)).\nintros Hu1.\nrewrite Hu1.\neexists ; repeat split.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite (DN_UP_parity_generic x (Float beta md ed) (Float beta mu eu)).\nsimpl.\nnow rewrite Ho.\nexact Hf.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hd1.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hf : ~ format x) (Hd : Rnd_DN_pt format x d) (Hu : Rnd_UP_pt format x u) : format d -> NE_prop x u \\/ NE_prop x d.","proofString":"unfold generic_format.\nset (ed := cexp beta fexp d).\nset (md := Ztrunc (scaled_mantissa beta fexp d)).\nintros Hd1.\ncase_eq (Z.even md) ; [ intros He | intros Ho ].\nright.\nexists (Float beta md ed).\nunfold Generic_fmt.canonical.\nrewrite <- Hd1.\nnow repeat split.\nleft.\ngeneralize (proj1 Hu).\nunfold generic_format.\nset (eu := cexp beta fexp u).\nset (mu := Ztrunc (scaled_mantissa beta fexp u)).\nintros Hu1.\nrewrite Hu1.\neexists ; repeat split.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite (DN_UP_parity_generic x (Float beta md ed) (Float beta mu eu)).\nsimpl.\nnow rewrite Ho.\nexact Hf.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hd1.\nunfold Generic_fmt.canonical.\nnow rewrite <- Hu1.\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"Rnd_NG_pt_unique_prop format NE_prop.","proofString":"intros x d u Hd Hdn Hu Hun (cd, (Hd1, Hd2)) (cu, (Hu1, Hu2)).\ndestruct (Req_dec x d) as [Hx|Hx].\nrewrite <- Hx.\napply sym_eq.\napply Rnd_UP_pt_idempotent with (1 := Hu).\nrewrite Hx.\napply Hd.\nrewrite (DN_UP_parity_aux DN_UP_parity_generic_pos x cd cu) in Hu2 ; try easy.\nnow rewrite (proj2 Hd2) in Hu2.\nintros Hf.\napply Hx.\napply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd).\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) : d = u.","proofString":"destruct (Req_dec x d) as [Hx|Hx].\nrewrite <- Hx.\napply sym_eq.\napply Rnd_UP_pt_idempotent with (1 := Hu).\nrewrite Hx.\napply Hd.\nrewrite (DN_UP_parity_aux DN_UP_parity_generic_pos x cd cu) in Hu2 ; try easy.\nnow rewrite (proj2 Hd2) in Hu2.\nintros Hf.\napply Hx.\napply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd).\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x = d) : d = u.","proofString":"rewrite <- Hx.\napply sym_eq.\napply Rnd_UP_pt_idempotent with (1 := Hu).\nrewrite Hx.\napply Hd."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x = d) : x = u.","proofString":"apply sym_eq.\napply Rnd_UP_pt_idempotent with (1 := Hu).\nrewrite Hx.\napply Hd."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x = d) : u = x.","proofString":"apply Rnd_UP_pt_idempotent with (1 := Hu).\nrewrite Hx.\napply Hd."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x = d) : format x.","proofString":"rewrite Hx.\napply Hd."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x = d) : format d.","proofString":"apply Hd."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : d = u.","proofString":"rewrite (DN_UP_parity_aux DN_UP_parity_generic_pos x cd cu) in Hu2 ; try easy.\nnow rewrite (proj2 Hd2) in Hu2.\nintros Hf.\napply Hx.\napply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd).\nrewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt.\nrewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ negb (Z.even (Fnum cd)) = true) (Hx : x <> d) : d = u.","proofString":"now rewrite (proj2 Hd2) in Hu2."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : ~ format x.","proofString":"intros Hf.\napply Hx.\napply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd)."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) (Hf : format x) : False.","proofString":"apply Hx.\napply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd)."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) (Hf : format x) : x = d.","proofString":"apply sym_eq.\nnow apply Rnd_DN_pt_idempotent with (1 := Hd)."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) (Hf : format x) : d = x.","proofString":"now apply Rnd_DN_pt_idempotent with (1 := Hd)."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : F2R cd = round beta fexp Zfloor x.","proofString":"rewrite <- Hd1.\napply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : d = round beta fexp Zfloor x.","proofString":"apply Rnd_DN_pt_unique with (1 := Hd).\nnow apply round_DN_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : Rnd_DN_pt format x (round beta fexp Zfloor x).","proofString":"now apply round_DN_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : F2R cu = round beta fexp Zceil x.","proofString":"rewrite <- Hu1.\napply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : u = round beta fexp Zceil x.","proofString":"apply Rnd_UP_pt_unique with (1 := Hu).\nnow apply round_UP_pt."},{"statement":"(x d u : R) (Hd : Rnd_DN_pt format x d) (Hdn : Rnd_N_pt format x d) (Hu : Rnd_UP_pt format x u) (Hun : Rnd_N_pt format x u) (cd : float beta) (Hd1 : d = F2R cd) (Hd2 : canonical cd /\\ Z.even (Fnum cd) = true) (cu : float beta) (Hu1 : u = F2R cu) (Hu2 : canonical cu /\\ Z.even (Fnum cu) = true) (Hx : x <> d) : Rnd_UP_pt format x (round beta fexp Zceil x).","proofString":"now apply round_UP_pt."},{"statement":"round_pred_total Rnd_NE_pt.","proofString":"apply Rnd_NE_pt_total."},{"statement":"round_pred_monotone Rnd_NE_pt.","proofString":"apply Rnd_NE_pt_monotone."},{"statement":"(x : R) : round beta fexp ZnearestE (- x) = (- round beta fexp ZnearestE x)%R.","proofString":"unfold round.\nsimpl.\nrewrite scaled_mantissa_opp, cexp_opp.\nrewrite Znearest_opp.\nrewrite <- F2R_Zopp.\napply (f_equal (fun v => F2R (Float beta (-v) _))).\nset (m := scaled_mantissa beta fexp x).\nunfold Znearest.\ncase Rcompare ; trivial.\napply (f_equal (fun (b : bool) => if b then Zceil m else Zfloor m)).\nrewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) : Znearest (fun t : Z => negb (negb (Z.even (- (t + 1)))))\n  (scaled_mantissa beta fexp x) = ZnearestE (scaled_mantissa beta fexp x).","proofString":"set (m := scaled_mantissa beta fexp x).\nunfold Znearest.\ncase Rcompare ; trivial.\napply (f_equal (fun (b : bool) => if b then Zceil m else Zfloor m)).\nrewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : Znearest (fun t : Z => negb (negb (Z.even (- (t + 1))))) m = ZnearestE m.","proofString":"unfold Znearest.\ncase Rcompare ; trivial.\napply (f_equal (fun (b : bool) => if b then Zceil m else Zfloor m)).\nrewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : match Rcompare (m - IZR (Zfloor m)) (/ 2) with\n| Eq => if negb (negb (Z.even (- (Zfloor m + 1)))) then Zceil m else Zfloor m\n| Lt => Zfloor m\n| Gt => Zceil m\nend =\nmatch Rcompare (m - IZR (Zfloor m)) (/ 2) with\n| Eq => if negb (Z.even (Zfloor m)) then Zceil m else Zfloor m\n| Lt => Zfloor m\n| Gt => Zceil m\nend.","proofString":"case Rcompare ; trivial.\napply (f_equal (fun (b : bool) => if b then Zceil m else Zfloor m)).\nrewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : (if negb (negb (Z.even (- (Zfloor m + 1)))) then Zceil m else Zfloor m) =\n(if negb (Z.even (Zfloor m)) then Zceil m else Zfloor m).","proofString":"apply (f_equal (fun (b : bool) => if b then Zceil m else Zfloor m)).\nrewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : negb (negb (Z.even (- (Zfloor m + 1)))) = negb (Z.even (Zfloor m)).","proofString":"rewrite Bool.negb_involutive.\nrewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : Z.even (- (Zfloor m + 1)) = negb (Z.even (Zfloor m)).","proofString":"rewrite Z.even_opp.\nrewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : Z.even (Zfloor m + 1) = negb (Z.even (Zfloor m)).","proofString":"rewrite Z.even_add.\nnow rewrite eqb_sym."},{"statement":"(x : R) (m : R) : Bool.eqb (Z.even (Zfloor m)) (Z.even 1) = negb (Z.even (Zfloor m)).","proofString":"now rewrite eqb_sym."},{"statement":"(x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hx : (x >= 0)%R) : (0 <= x)%R.","proofString":"now apply Rge_le."},{"statement":"(x : R) (Hx : (x < 0)%R) : Rnd_NE_pt x (round beta fexp ZnearestE x).","proofString":"apply Rnd_NG_pt_opp_inv.\napply generic_format_opp.\nunfold NE_prop.\nintros _ f ((mg,eg),(H1,(H2,H3))).\nexists (Float beta (- mg) eg).\nrepeat split.\nrewrite H1.\nnow rewrite F2R_Zopp.\nnow apply canonical_opp.\nsimpl.\nnow rewrite Z.even_opp.\nrewrite <- round_NE_opp.\napply round_NE_pt_pos.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Hx : (x < 0)%R) : forall x0 : R, format x0 -> format (- x0).","proofString":"apply generic_format_opp."},{"statement":"(x : R) (Hx : (x < 0)%R) : forall x0 f : R, NE_prop x0 f -> NE_prop (- x0) (- f).","proofString":"unfold NE_prop.\nintros _ f ((mg,eg),(H1,(H2,H3))).\nexists (Float beta (- mg) eg).\nrepeat split.\nrewrite H1.\nnow rewrite F2R_Zopp.\nnow apply canonical_opp.\nsimpl.\nnow rewrite Z.even_opp."},{"statement":"(x : R) (Hx : (x < 0)%R) : R ->\nforall f : R,\n(exists g : float beta, f = F2R g /\\ canonical g /\\ Z.even (Fnum g) = true) ->\nexists g : float beta,\n  (- f)%R = F2R g /\\ canonical g /\\ Z.even (Fnum g) = true.","proofString":"intros _ f ((mg,eg),(H1,(H2,H3))).\nexists (Float beta (- mg) eg).\nrepeat split.\nrewrite H1.\nnow rewrite F2R_Zopp.\nnow apply canonical_opp.\nsimpl.\nnow rewrite Z.even_opp."},{"statement":"(x : R) (Hx : (x < 0)%R) : Rnd_NG_pt format NE_prop (- x) (- round beta fexp ZnearestE x).","proofString":"rewrite <- round_NE_opp.\napply round_NE_pt_pos.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Hx : (x < 0)%R) : Rnd_NG_pt format NE_prop (- x) (round beta fexp ZnearestE (- x)).","proofString":"apply round_NE_pt_pos.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Hx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Hx : x = 0%R) : Rnd_NE_pt 0 0.","proofString":"apply Rnd_NG_pt_refl.\napply generic_format_0."},{"statement":"(x : R) (Hx : x = 0%R) : format 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (Hx : (0 < x)%R) : Rnd_NE_pt x (round beta fexp ZnearestE x).","proofString":"now apply round_NE_pt_pos."}]}