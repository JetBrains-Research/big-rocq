{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Unusedglobproof.v","fileSamples":[{"statement":"(w1 w2 : workset) (id : IS.elt) (H : workset_incl w1 w2) (H0 : IS.In id w1) : IS.In id w2.","proofString":"destruct H.\nauto."},{"statement":"(w1 w2 : workset) (id : IS.elt) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id0 : IS.elt, IS.In id0 w2 -> IS.In id0 w1 \\/ In id0 (w_todo w2)) (H0 : IS.In id w1) : IS.In id w2.","proofString":"auto."},{"statement":"(w : workset) : IS.Subset w w.","proofString":"red; auto."},{"statement":"(w : workset) : incl (w_todo w) (w_todo w).","proofString":"red; auto."},{"statement":"(w : workset) : forall id : IS.elt, IS.In id w -> IS.In id w \\/ In id (w_todo w).","proofString":"auto."},{"statement":"(w1 w2 w3 : workset) (H : workset_incl w1 w2) (H0 : workset_incl w2 w3) : workset_incl w1 w3.","proofString":"destruct H, H0; split.\nred; eauto.\nred; eauto.\nintros.\nedestruct TRACK0; eauto.\nedestruct TRACK; eauto."},{"statement":"(w1 w2 w3 : workset) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id : IS.elt, IS.In id w2 -> IS.In id w1 \\/ In id (w_todo w2)) (SEEN0 : IS.Subset w2 w3) (TODO0 : incl (w_todo w2) (w_todo w3)) (TRACK0 : forall id : IS.elt, IS.In id w3 -> IS.In id w2 \\/ In id (w_todo w3)) : IS.Subset w1 w3.","proofString":"red; eauto."},{"statement":"(w1 w2 w3 : workset) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id : IS.elt, IS.In id w2 -> IS.In id w1 \\/ In id (w_todo w2)) (SEEN0 : IS.Subset w2 w3) (TODO0 : incl (w_todo w2) (w_todo w3)) (TRACK0 : forall id : IS.elt, IS.In id w3 -> IS.In id w2 \\/ In id (w_todo w3)) : incl (w_todo w1) (w_todo w3).","proofString":"red; eauto."},{"statement":"(w1 w2 w3 : workset) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id : IS.elt, IS.In id w2 -> IS.In id w1 \\/ In id (w_todo w2)) (SEEN0 : IS.Subset w2 w3) (TODO0 : incl (w_todo w2) (w_todo w3)) (TRACK0 : forall id : IS.elt, IS.In id w3 -> IS.In id w2 \\/ In id (w_todo w3)) : forall id : IS.elt, IS.In id w3 -> IS.In id w1 \\/ In id (w_todo w3).","proofString":"intros.\nedestruct TRACK0; eauto.\nedestruct TRACK; eauto."},{"statement":"(w1 w2 w3 : workset) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id0 : IS.elt, IS.In id0 w2 -> IS.In id0 w1 \\/ In id0 (w_todo w2)) (SEEN0 : IS.Subset w2 w3) (TODO0 : incl (w_todo w2) (w_todo w3)) (TRACK0 : forall id0 : IS.elt, IS.In id0 w3 -> IS.In id0 w2 \\/ In id0 (w_todo w3)) (id : IS.elt) (H : IS.In id w3) : IS.In id w1 \\/ In id (w_todo w3).","proofString":"edestruct TRACK0; eauto.\nedestruct TRACK; eauto."},{"statement":"(w1 w2 w3 : workset) (SEEN : IS.Subset w1 w2) (TODO : incl (w_todo w1) (w_todo w2)) (TRACK : forall id0 : IS.elt, IS.In id0 w2 -> IS.In id0 w1 \\/ In id0 (w_todo w2)) (SEEN0 : IS.Subset w2 w3) (TODO0 : incl (w_todo w2) (w_todo w3)) (TRACK0 : forall id0 : IS.elt, IS.In id0 w3 -> IS.In id0 w2 \\/ In id0 (w_todo w3)) (id : IS.elt) (H : IS.In id w3) (H0 : IS.In id w2) : IS.In id w1 \\/ In id (w_todo w3).","proofString":"edestruct TRACK; eauto."},{"statement":"(id : ident) (w : workset) : workset_incl w\n  (if IS.mem id w\n   then w\n   else {| w_seen := IS.add id w; w_todo := id :: w_todo w |}).","proofString":"destruct (IS.mem id w) eqn:MEM.\napply workset_incl_refl.\nsplit; simpl.\nred; intros.\napply IS.add_2; auto.\nred; simpl; auto.\nintros.\ndestruct (ident_eq id id0); auto.\napply IS.add_3 in H; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = true) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) : workset_incl w {| w_seen := IS.add id w; w_todo := id :: w_todo w |}.","proofString":"split; simpl.\nred; intros.\napply IS.add_2; auto.\nred; simpl; auto.\nintros.\ndestruct (ident_eq id id0); auto.\napply IS.add_3 in H; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) : IS.Subset w (IS.add id w).","proofString":"red; intros.\napply IS.add_2; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) (a : IS.elt) (H : IS.In a w) : IS.In a (IS.add id w).","proofString":"apply IS.add_2; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) : incl (w_todo w) (id :: w_todo w).","proofString":"red; simpl; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) : forall id0 : IS.elt,\nIS.In id0 (IS.add id w) -> IS.In id0 w \\/ id = id0 \\/ In id0 (w_todo w).","proofString":"intros.\ndestruct (ident_eq id id0); auto.\napply IS.add_3 in H; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) (id0 : IS.elt) (H : IS.In id0 (IS.add id w)) : IS.In id0 w \\/ id = id0 \\/ In id0 (w_todo w).","proofString":"destruct (ident_eq id id0); auto.\napply IS.add_3 in H; auto."},{"statement":"(id : ident) (w : workset) (MEM : IS.mem id w = false) (id0 : IS.elt) (H : IS.In id0 (IS.add id w)) (n : id <> id0) : IS.In id0 w \\/ id = id0 \\/ In id0 (w_todo w).","proofString":"apply IS.add_3 in H; auto."},{"statement":"(w : workset) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(a : ident) (l : list ident) (IHl : forall w0 : workset, workset_incl w0 (addlist_workset l w0)) (w : workset) : workset_incl w (addlist_workset l (add_workset a w)).","proofString":"eapply workset_incl_trans.\napply add_workset_incl.\neauto."},{"statement":"(f : function) (w : workset) : workset_incl w (PTree.fold add_ref_instruction (fn_code f) w).","proofString":"apply PTree_Properties.fold_rec.\nauto.\napply workset_incl_refl.\nintros.\napply workset_incl_trans with a; auto.\nunfold add_ref_instruction.\napply addlist_workset_incl."},{"statement":"(f : function) (w : workset) : forall (m m' : PTree.t instruction) (a : workset),\n(forall x : PTree.elt, m ! x = m' ! x) ->\nworkset_incl w a -> workset_incl w a.","proofString":"auto."},{"statement":"(f : function) (w : workset) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(f : function) (w : workset) : forall (m : PTree.t instruction) (a : workset) (k : PTree.elt)\n  (v : instruction),\nm ! k = None ->\n(fn_code f) ! k = Some v ->\nworkset_incl w a -> workset_incl w (add_ref_instruction a k v).","proofString":"intros.\napply workset_incl_trans with a; auto.\nunfold add_ref_instruction.\napply addlist_workset_incl."},{"statement":"(f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : workset_incl w a) : workset_incl w (add_ref_instruction a k v).","proofString":"apply workset_incl_trans with a; auto.\nunfold add_ref_instruction.\napply addlist_workset_incl."},{"statement":"(f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : workset_incl w a) : workset_incl a (add_ref_instruction a k v).","proofString":"unfold add_ref_instruction.\napply addlist_workset_incl."},{"statement":"(f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : workset_incl w a) : workset_incl a (addlist_workset (ref_instruction v) a).","proofString":"apply addlist_workset_incl."},{"statement":"(gv : globvar unit) (w : workset) : workset_incl w (fold_left add_ref_init_data (gvar_init gv) w).","proofString":"revert w.\ninduction (gvar_init gv); simpl; intros.\napply workset_incl_refl.\neapply workset_incl_trans; [ | eauto ].\nunfold add_ref_init_data.\ndestruct a; (apply workset_incl_refl || apply add_workset_incl)."},{"statement":"(gv : globvar unit) : forall w : workset,\nworkset_incl w (fold_left add_ref_init_data (gvar_init gv) w).","proofString":"induction (gvar_init gv); simpl; intros.\napply workset_incl_refl.\neapply workset_incl_trans; [ | eauto ].\nunfold add_ref_init_data.\ndestruct a; (apply workset_incl_refl || apply add_workset_incl)."},{"statement":"(gv : globvar unit) (w : workset) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(gv : globvar unit) (a : init_data) (l : list init_data) (IHl : forall w0 : workset, workset_incl w0 (fold_left add_ref_init_data l w0)) (w : workset) : workset_incl w (fold_left add_ref_init_data l (add_ref_init_data w a)).","proofString":"eapply workset_incl_trans; [ | eauto ].\nunfold add_ref_init_data.\ndestruct a; (apply workset_incl_refl || apply add_workset_incl)."},{"statement":"(gv : globvar unit) (a : init_data) (l : list init_data) (IHl : forall w0 : workset, workset_incl w0 (fold_left add_ref_init_data l w0)) (w : workset) : workset_incl w (add_ref_init_data w a).","proofString":"unfold add_ref_init_data.\ndestruct a; (apply workset_incl_refl || apply add_workset_incl)."},{"statement":"(gv : globvar unit) (a : init_data) (l : list init_data) (IHl : forall w0 : workset, workset_incl w0 (fold_left add_ref_init_data l w0)) (w : workset) : workset_incl w\n  match a with\n  | Init_addrof id _ => add_workset id w\n  | _ => w\n  end.","proofString":"destruct a; (apply workset_incl_refl || apply add_workset_incl)."},{"statement":"(pm : prog_map) (id : ident) (w : workset) : workset_incl w\n  match pm ! id with\n  | Some (Gfun (Internal f)) => add_ref_function f w\n  | Some (Gvar gv) => add_ref_globvar gv w\n  | _ => w\n  end.","proofString":"destruct (pm!id) as [[[] | ? ] | ].\napply add_ref_function_incl.\napply workset_incl_refl.\napply add_ref_globvar_incl.\napply workset_incl_refl."},{"statement":"(pm : prog_map) (id : ident) (w : workset) (f : function) : workset_incl w (add_ref_function f w).","proofString":"apply add_ref_function_incl."},{"statement":"(pm : prog_map) (id : ident) (w : workset) (e : external_function) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(pm : prog_map) (id : ident) (w : workset) (v : globvar unit) : workset_incl w (add_ref_globvar v w).","proofString":"apply add_ref_globvar_incl."},{"statement":"(pm : prog_map) (id : ident) (w : workset) : workset_incl w w.","proofString":"apply workset_incl_refl."},{"statement":"(id : IS.elt) (w : workset) : IS.In id\n  (if IS.mem id w\n   then w\n   else {| w_seen := IS.add id w; w_todo := id :: w_todo w |}).","proofString":"destruct (IS.mem id w) eqn:MEM.\napply IS.mem_2; auto.\nsimpl.\napply IS.add_1; auto."},{"statement":"(id : IS.elt) (w : workset) (MEM : IS.mem id w = true) : IS.In id w.","proofString":"apply IS.mem_2; auto."},{"statement":"(id : IS.elt) (w : workset) (MEM : IS.mem id w = false) : IS.In id {| w_seen := IS.add id w; w_todo := id :: w_todo w |}.","proofString":"simpl.\napply IS.add_1; auto."},{"statement":"(id : IS.elt) (w : workset) (MEM : IS.mem id w = false) : IS.In id (IS.add id w).","proofString":"apply IS.add_1; auto."},{"statement":"(id : IS.elt) (w : workset) (H : False) : IS.In id w.","proofString":"tauto."},{"statement":"(id a : IS.elt) (l : list IS.elt) (IHl : forall w0 : workset, In id l -> IS.In id (addlist_workset l w0)) (w : workset) (H : a = id \\/ In id l) : IS.In id (addlist_workset l (add_workset a w)).","proofString":"destruct H.\nsubst a.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply seen_add_workset.\napply IHl; auto."},{"statement":"(id a : IS.elt) (l : list IS.elt) (IHl : forall w0 : workset, In id l -> IS.In id (addlist_workset l w0)) (w : workset) (H : a = id) : IS.In id (addlist_workset l (add_workset a w)).","proofString":"subst a.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply seen_add_workset."},{"statement":"(id : IS.elt) (l : list IS.elt) (IHl : forall w0 : workset, In id l -> IS.In id (addlist_workset l w0)) (w : workset) : IS.In id (addlist_workset l (add_workset id w)).","proofString":"eapply seen_workset_incl.\napply addlist_workset_incl.\napply seen_add_workset."},{"statement":"(id a : IS.elt) (l : list IS.elt) (IHl : forall w0 : workset, In id l -> IS.In id (addlist_workset l w0)) (w : workset) (H : In id l) : IS.In id (addlist_workset l (add_workset a w)).","proofString":"apply IHl; auto."},{"statement":"(id : ident) (f : function) (w : workset) : ref_function f id -> IS.In id (add_ref_function f w).","proofString":"unfold ref_function, add_ref_function.\napply PTree_Properties.fold_rec; intros.\ndestruct H1 as (pc & i & A & B).\napply H0; auto.\nexists pc, i; split; auto.\nrewrite H; auto.\ndestruct H as (pc & i & A & B).\nrewrite PTree.gempty in A; discriminate.\ndestruct H2 as (pc & i & A & B).\nrewrite PTree.gsspec in A.\ndestruct (peq pc k).\ninv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto.\nunfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) : (exists (pc : positive) (i : instruction),\n   (fn_code f) ! pc = Some i /\\ In id (ref_instruction i)) ->\nIS.In id (PTree.fold add_ref_instruction (fn_code f) w).","proofString":"apply PTree_Properties.fold_rec; intros.\ndestruct H1 as (pc & i & A & B).\napply H0; auto.\nexists pc, i; split; auto.\nrewrite H; auto.\ndestruct H as (pc & i & A & B).\nrewrite PTree.gempty in A; discriminate.\ndestruct H2 as (pc & i & A & B).\nrewrite PTree.gsspec in A.\ndestruct (peq pc k).\ninv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto.\nunfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m m' : PTree.t instruction) (a : workset) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (exists (pc : positive) (i : instruction),\n   m ! pc = Some i /\\ In id (ref_instruction i)) -> \nIS.In id a) (H1 : exists (pc : positive) (i : instruction),\n  m' ! pc = Some i /\\ In id (ref_instruction i)) : IS.In id a.","proofString":"destruct H1 as (pc & i & A & B).\napply H0; auto.\nexists pc, i; split; auto.\nrewrite H; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m m' : PTree.t instruction) (a : workset) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (A : m' ! pc = Some i) (B : In id (ref_instruction i)) : IS.In id a.","proofString":"apply H0; auto.\nexists pc, i; split; auto.\nrewrite H; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m m' : PTree.t instruction) (a : workset) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (A : m' ! pc = Some i) (B : In id (ref_instruction i)) : exists (pc0 : positive) (i0 : instruction),\n  m ! pc0 = Some i0 /\\ In id (ref_instruction i0).","proofString":"exists pc, i; split; auto.\nrewrite H; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m m' : PTree.t instruction) (a : workset) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (A : m' ! pc = Some i) (B : In id (ref_instruction i)) : m ! pc = Some i.","proofString":"rewrite H; auto."},{"statement":"(id : ident) (f : function) (w : workset) (H : exists (pc : positive) (i : instruction),\n  (PTree.empty instruction) ! pc = Some i /\\ In id (ref_instruction i)) : IS.In id w.","proofString":"destruct H as (pc & i & A & B).\nrewrite PTree.gempty in A; discriminate."},{"statement":"(id : ident) (f : function) (w : workset) (pc : positive) (i : instruction) (A : (PTree.empty instruction) ! pc = Some i) (B : In id (ref_instruction i)) : IS.In id w.","proofString":"rewrite PTree.gempty in A; discriminate."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc : positive) (i : instruction),\n   m ! pc = Some i /\\ In id (ref_instruction i)) -> \nIS.In id a) (H2 : exists (pc : positive) (i : instruction),\n  (PTree.set k v m) ! pc = Some i /\\ In id (ref_instruction i)) : IS.In id (add_ref_instruction a k v).","proofString":"destruct H2 as (pc & i & A & B).\nrewrite PTree.gsspec in A.\ndestruct (peq pc k).\ninv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto.\nunfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (A : (PTree.set k v m) ! pc = Some i) (B : In id (ref_instruction i)) : IS.In id (add_ref_instruction a k v).","proofString":"rewrite PTree.gsspec in A.\ndestruct (peq pc k).\ninv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto.\nunfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (A : (if peq pc k then Some v else m ! pc) = Some i) (B : In id (ref_instruction i)) : IS.In id (add_ref_instruction a k v).","proofString":"destruct (peq pc k).\ninv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto.\nunfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (e : pc = k) (A : Some v = Some i) (B : In id (ref_instruction i)) : IS.In id (add_ref_instruction a k v).","proofString":"inv A.\nunfold add_ref_instruction.\napply seen_addlist_workset; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : (fn_code f) ! k = Some i) (H1 : (exists (pc : positive) (i0 : instruction),\n   m ! pc = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (B : In id (ref_instruction i)) : IS.In id (add_ref_instruction a k i).","proofString":"unfold add_ref_instruction.\napply seen_addlist_workset; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : (fn_code f) ! k = Some i) (H1 : (exists (pc : positive) (i0 : instruction),\n   m ! pc = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (B : In id (ref_instruction i)) : IS.In id (addlist_workset (ref_instruction i) a).","proofString":"apply seen_addlist_workset; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (n : pc <> k) (A : m ! pc = Some i) (B : In id (ref_instruction i)) : IS.In id (add_ref_instruction a k v).","proofString":"unfold add_ref_instruction.\neapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (n : pc <> k) (A : m ! pc = Some i) (B : In id (ref_instruction i)) : IS.In id (addlist_workset (ref_instruction v) a).","proofString":"eapply seen_workset_incl.\napply addlist_workset_incl.\napply H1.\nexists pc, i; auto."},{"statement":"(id : ident) (f : function) (w : workset) (m : PTree.t instruction) (a : workset) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : (fn_code f) ! k = Some v) (H1 : (exists (pc0 : positive) (i0 : instruction),\n   m ! pc0 = Some i0 /\\ In id (ref_instruction i0)) -> \nIS.In id a) (pc : positive) (i : instruction) (n : pc <> k) (A : m ! pc = Some i) (B : In id (ref_instruction i)) : exists (pc0 : positive) (i0 : instruction),\n  m ! pc0 = Some i0 /\\ In id (ref_instruction i0).","proofString":"exists pc, i; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gd : globdef fundef unit) (id' : ident) (w : workset) (H : pm ! id = Some gd) (H0 : ref_def gd id') : IS.In id'\n  match pm ! id with\n  | Some (Gfun (Internal f)) => add_ref_function f w\n  | Some (Gvar gv) => add_ref_globvar gv w\n  | _ => w\n  end.","proofString":"rewrite H.\nred in H0; destruct gd as [[f|ef]|gv].\napply seen_add_ref_function; auto.\ncontradiction.\ndestruct H0 as (ofs & IN).\nunfold add_ref_globvar.\nassert (forall l (w: workset),          IS.In id' w \\/ In (Init_addrof id' ofs) l ->          IS.In id' (fold_left add_ref_init_data l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset.\napply H0; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gd : globdef fundef unit) (id' : ident) (w : workset) (H : pm ! id = Some gd) (H0 : ref_def gd id') : IS.In id'\n  match gd with\n  | Gfun (Internal f) => add_ref_function f w\n  | Gfun (External _) => w\n  | Gvar gv => add_ref_globvar gv w\n  end.","proofString":"red in H0; destruct gd as [[f|ef]|gv].\napply seen_add_ref_function; auto.\ncontradiction.\ndestruct H0 as (ofs & IN).\nunfold add_ref_globvar.\nassert (forall l (w: workset),          IS.In id' w \\/ In (Init_addrof id' ofs) l ->          IS.In id' (fold_left add_ref_init_data l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset.\napply H0; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (f : function) (id' : ident) (w : workset) (H : pm ! id = Some (Gfun (Internal f))) (H0 : ref_fundef (Internal f) id') : IS.In id' (add_ref_function f w).","proofString":"apply seen_add_ref_function; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (ef : external_function) (id' : ident) (w : workset) (H : pm ! id = Some (Gfun (External ef))) (H0 : ref_fundef (External ef) id') : IS.In id' w.","proofString":"contradiction."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (H0 : ref_init (gvar_init gv) id') : IS.In id' (add_ref_globvar gv w).","proofString":"destruct H0 as (ofs & IN).\nunfold add_ref_globvar.\nassert (forall l (w: workset),          IS.In id' w \\/ In (Init_addrof id' ofs) l ->          IS.In id' (fold_left add_ref_init_data l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset.\napply H0; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) : IS.In id' (add_ref_globvar gv w).","proofString":"unfold add_ref_globvar.\nassert (forall l (w: workset),          IS.In id' w \\/ In (Init_addrof id' ofs) l ->          IS.In id' (fold_left add_ref_init_data l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset.\napply H0; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) : IS.In id' (fold_left add_ref_init_data (gvar_init gv) w).","proofString":"assert (forall l (w: workset),          IS.In id' w \\/ In (Init_addrof id' ofs) l ->          IS.In id' (fold_left add_ref_init_data l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset.\napply H0; auto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) : forall (l : list init_data) (w0 : workset),\nIS.In id' w0 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w0).","proofString":"induction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (w0 : workset) (H0 : IS.In id' w0 \\/ False) : IS.In id' w0.","proofString":"tauto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (a : init_data) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H0 : IS.In id' w0 \\/ a = Init_addrof id' ofs \\/ In (Init_addrof id' ofs) l) : IS.In id' (fold_left add_ref_init_data l (add_ref_init_data w0 a)).","proofString":"apply IHl.\nintuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (a : init_data) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H0 : IS.In id' w0 \\/ a = Init_addrof id' ofs \\/ In (Init_addrof id' ofs) l) : IS.In id' (add_ref_init_data w0 a) \\/ In (Init_addrof id' ofs) l.","proofString":"intuition auto.\nleft.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst; left; simpl.\napply seen_add_workset."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (a : init_data) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H1 : IS.In id' w0) : IS.In id' (add_ref_init_data w0 a) \\/ In (Init_addrof id' ofs) l.","proofString":"left.\ndestruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (a : init_data) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H1 : IS.In id' w0) : IS.In id' (add_ref_init_data w0 a).","proofString":"destruct a; simpl; auto.\neapply seen_workset_incl.\napply add_workset_incl.\nauto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (i : ident) (i0 : ptrofs) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H1 : IS.In id' w0) : IS.In id' (add_workset i w0).","proofString":"eapply seen_workset_incl.\napply add_workset_incl.\nauto."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (a : init_data) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) (H0 : a = Init_addrof id' ofs) : IS.In id' (add_ref_init_data w0 a) \\/ In (Init_addrof id' ofs) l.","proofString":"subst; left; simpl.\napply seen_add_workset."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (l : list init_data) (IHl : forall w1 : workset,\nIS.In id' w1 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w1)) (w0 : workset) : IS.In id' (add_workset id' w0).","proofString":"apply seen_add_workset."},{"statement":"(pm : PTree.tree (globdef fundef unit)) (id : positive) (gv : globvar unit) (id' : ident) (w : workset) (H : pm ! id = Some (Gvar gv)) (ofs : ptrofs) (IN : In (Init_addrof id' ofs) (gvar_init gv)) (H0 : forall (l : list init_data) (w0 : workset),\nIS.In id' w0 \\/ In (Init_addrof id' ofs) l ->\nIS.In id' (fold_left add_ref_init_data l w0)) : IS.In id' (fold_left add_ref_init_data (gvar_init gv) w).","proofString":"apply H0; auto."},{"statement":"(p : AST.program fundef unit) : IS.In (prog_main p) (initial_workset p).","proofString":"apply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) : IS.In id (initial_workset p).","proofString":"unfold initial_workset.\neapply seen_workset_incl.\napply add_workset_incl.\nassert (forall l (w: workset),          IS.In id w \\/ In id l -> IS.In id (fold_left (fun w id => add_workset id w) l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto; left.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst a.\napply seen_add_workset.\napply H0.\nauto."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) : IS.In id\n  (add_workset (prog_main p)\n     (fold_left (fun (w : workset) (id0 : ident) => add_workset id0 w)\n        (prog_public p) {| w_seen := IS.empty; w_todo := nil |})).","proofString":"eapply seen_workset_incl.\napply add_workset_incl.\nassert (forall l (w: workset),          IS.In id w \\/ In id l -> IS.In id (fold_left (fun w id => add_workset id w) l w)).\ninduction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto; left.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst a.\napply seen_add_workset.\napply H0.\nauto."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) : forall (l : list ident) (w : workset),\nIS.In id w \\/ In id l ->\nIS.In id\n  (fold_left (fun (w0 : workset) (id0 : ident) => add_workset id0 w0) l w).","proofString":"induction l; simpl; intros.\ntauto.\napply IHl.\nintuition auto; left.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst a.\napply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (w : workset) (H0 : IS.In id w \\/ False) : IS.In id w.","proofString":"tauto."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (a : ident) (l : list ident) (IHl : forall w0 : workset,\nIS.In id w0 \\/ In id l ->\nIS.In id\n  (fold_left (fun (w1 : workset) (id0 : ident) => add_workset id0 w1) l w0)) (w : workset) (H0 : IS.In id w \\/ a = id \\/ In id l) : IS.In id\n  (fold_left (fun (w0 : workset) (id0 : ident) => add_workset id0 w0) l\n     (add_workset a w)).","proofString":"apply IHl.\nintuition auto; left.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst a.\napply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (a : ident) (l : list ident) (IHl : forall w0 : workset,\nIS.In id w0 \\/ In id l ->\nIS.In id\n  (fold_left (fun (w1 : workset) (id0 : ident) => add_workset id0 w1) l w0)) (w : workset) (H0 : IS.In id w \\/ a = id \\/ In id l) : IS.In id (add_workset a w) \\/ In id l.","proofString":"intuition auto; left.\neapply seen_workset_incl.\napply add_workset_incl.\nauto.\nsubst a.\napply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (a : ident) (l : list ident) (IHl : forall w0 : workset,\nIS.In id w0 \\/ In id l ->\nIS.In id\n  (fold_left (fun (w1 : workset) (id0 : ident) => add_workset id0 w1) l w0)) (w : workset) (H1 : IS.In id w) : IS.In id (add_workset a w).","proofString":"eapply seen_workset_incl.\napply add_workset_incl.\nauto."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (a : ident) (l : list ident) (IHl : forall w0 : workset,\nIS.In id w0 \\/ In id l ->\nIS.In id\n  (fold_left (fun (w1 : workset) (id0 : ident) => add_workset id0 w1) l w0)) (w : workset) (H0 : a = id) : IS.In id (add_workset a w).","proofString":"subst a.\napply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (l : list ident) (IHl : forall w0 : workset,\nIS.In id w0 \\/ In id l ->\nIS.In id\n  (fold_left (fun (w1 : workset) (id0 : ident) => add_workset id0 w1) l w0)) (w : workset) : IS.In id (add_workset id w).","proofString":"apply seen_add_workset."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (H0 : forall (l : list ident) (w : workset),\nIS.In id w \\/ In id l ->\nIS.In id\n  (fold_left (fun (w0 : workset) (id0 : ident) => add_workset id0 w0) l w)) : IS.In id\n  (fold_left (fun (w : workset) (id0 : ident) => add_workset id0 w)\n     (prog_public p) {| w_seen := IS.empty; w_todo := nil |}).","proofString":"apply H0.\nauto."},{"statement":"(p : AST.program fundef unit) (id : ident) (H : In id (prog_public p)) (H0 : forall (l : list ident) (w : workset),\nIS.In id w \\/ In id l ->\nIS.In id\n  (fold_left (fun (w0 : workset) (id0 : ident) => add_workset id0 w0) l w)) : IS.In id {| w_seen := IS.empty; w_todo := nil |} \\/ In id (prog_public p).","proofString":"auto."},{"statement":"(w : workset) (H : forall (id : IS.elt) (gd : globdef fundef unit) (id' : ident),\nIS.In id w ->\n~ In id (w_todo w) -> pm ! id = Some gd -> ref_def gd id' -> IS.In id' w) : match\n  match w_todo w with\n  | nil => inl w\n  | id :: rem =>\n      inr (add_ref_definition pm id {| w_seen := w; w_todo := rem |})\n  end\nwith\n| inl u =>\n    forall (id : IS.elt) (gd : globdef fundef unit) (id' : ident),\n    IS.In id u -> pm ! id = Some gd -> ref_def gd id' -> IS.In id' u\n| inr w' =>\n    forall (id : IS.elt) (gd : globdef fundef unit) (id' : ident),\n    IS.In id w' ->\n    ~ In id (w_todo w') ->\n    pm ! id = Some gd -> ref_def gd id' -> IS.In id' w'\nend.","proofString":"destruct (w_todo w) as [ | id rem ]; intros.\neapply H; eauto.\nset (w' := {| w_seen := w.(w_seen); w_todo := rem |}) in *.\ndestruct (add_ref_definition_incl pm id w').\ndestruct (ident_eq id id0).\nsubst id0.\neapply seen_add_ref_definition; eauto.\nexploit TRACK; eauto.\nintros [A|A].\napply SEEN.\neapply H; eauto.\nsimpl.\nassert (~ In id0 rem).\nchange rem with (w_todo w').\nred; intros.\nelim H1; auto.\ntauto.\ncontradiction."},{"statement":"(w : workset) (H : forall (id0 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id0 w ->\n~ In id0 nil -> pm ! id0 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id w) (H1 : pm ! id = Some gd) (H2 : ref_def gd id') : IS.In id' w.","proofString":"eapply H; eauto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id0 (add_ref_definition pm id {| w_seen := w; w_todo := rem |})) (H1 : ~ In id0 (w_todo (add_ref_definition pm id {| w_seen := w; w_todo := rem |}))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') : IS.In id' (add_ref_definition pm id {| w_seen := w; w_todo := rem |}).","proofString":"set (w' := {| w_seen := w.(w_seen); w_todo := rem |}) in *.\ndestruct (add_ref_definition_incl pm id w').\ndestruct (ident_eq id id0).\nsubst id0.\neapply seen_add_ref_definition; eauto.\nexploit TRACK; eauto.\nintros [A|A].\napply SEEN.\neapply H; eauto.\nsimpl.\nassert (~ In id0 rem).\nchange rem with (w_todo w').\nred; intros.\nelim H1; auto.\ntauto.\ncontradiction."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H0 : IS.In id0 (add_ref_definition pm id w')) (H1 : ~ In id0 (w_todo (add_ref_definition pm id w'))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id1 : IS.elt,\nIS.In id1 (add_ref_definition pm id w') ->\nIS.In id1 w' \\/ In id1 (w_todo (add_ref_definition pm id w'))) (e : id = id0) : IS.In id' (add_ref_definition pm id w').","proofString":"subst id0.\neapply seen_add_ref_definition; eauto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id0 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id0 w ->\n~ In id0 (id :: rem) ->\npm ! id0 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H2 : pm ! id = Some gd) (H1 : ~ In id (w_todo (add_ref_definition pm id w'))) (H0 : IS.In id (add_ref_definition pm id w')) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (add_ref_definition pm id w') ->\nIS.In id0 w' \\/ In id0 (w_todo (add_ref_definition pm id w'))) : IS.In id' (add_ref_definition pm id w').","proofString":"eapply seen_add_ref_definition; eauto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H0 : IS.In id0 (add_ref_definition pm id w')) (H1 : ~ In id0 (w_todo (add_ref_definition pm id w'))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id1 : IS.elt,\nIS.In id1 (add_ref_definition pm id w') ->\nIS.In id1 w' \\/ In id1 (w_todo (add_ref_definition pm id w'))) (n : id <> id0) (A : IS.In id0 w') : ~ In id0 (w_todo w').","proofString":"red; intros.\nelim H1; auto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H0 : IS.In id0 (add_ref_definition pm id w')) (H1 : ~ In id0 (w_todo (add_ref_definition pm id w'))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id1 : IS.elt,\nIS.In id1 (add_ref_definition pm id w') ->\nIS.In id1 w' \\/ In id1 (w_todo (add_ref_definition pm id w'))) (n : id <> id0) (A : IS.In id0 w') (H4 : In id0 (w_todo w')) : False.","proofString":"elim H1; auto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H0 : IS.In id0 (add_ref_definition pm id w')) (H1 : ~ In id0 (w_todo (add_ref_definition pm id w'))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id1 : IS.elt,\nIS.In id1 (add_ref_definition pm id w') ->\nIS.In id1 w' \\/ In id1 (w_todo (add_ref_definition pm id w'))) (n : id <> id0) (A : IS.In id0 w') (H4 : ~ In id0 rem) : ~ (id = id0 \\/ In id0 rem).","proofString":"tauto."},{"statement":"(w : workset) (id : ident) (rem : list ident) (H : forall (id1 : IS.elt) (gd0 : globdef fundef unit) (id'0 : ident),\nIS.In id1 w ->\n~ In id1 (id :: rem) ->\npm ! id1 = Some gd0 -> ref_def gd0 id'0 -> IS.In id'0 w) (id0 : IS.elt) (gd : globdef fundef unit) (id' : ident) (w' : workset) (H0 : IS.In id0 (add_ref_definition pm id w')) (H1 : ~ In id0 (w_todo (add_ref_definition pm id w'))) (H2 : pm ! id0 = Some gd) (H3 : ref_def gd id') (SEEN : IS.Subset w' (add_ref_definition pm id w')) (TODO : incl (w_todo w') (w_todo (add_ref_definition pm id w'))) (TRACK : forall id1 : IS.elt,\nIS.In id1 (add_ref_definition pm id w') ->\nIS.In id1 w' \\/ In id1 (w_todo (add_ref_definition pm id w'))) (n : id <> id0) (A : In id0 (w_todo (add_ref_definition pm id w'))) : IS.In id' (add_ref_definition pm id w').","proofString":"contradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : used_set_closed u.","proofString":"eapply PrimIter.iterate_prop with (P := workset_invariant); eauto.\nintros.\napply iter_step_invariant; auto.\ndestruct (initial_workset_incl p).\nred; intros.\nedestruct TRACK; eauto.\nsimpl in H4.\neelim IS.empty_1; eauto.\ncontradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : forall a : workset,\nworkset_invariant a ->\nmatch iter_step pm a with\n| inl b => used_set_closed b\n| inr a' => workset_invariant a'\nend.","proofString":"intros.\napply iter_step_invariant; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (a : workset) (H0 : workset_invariant a) : match iter_step pm a with\n| inl b => used_set_closed b\n| inr a' => workset_invariant a'\nend.","proofString":"apply iter_step_invariant; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : workset_invariant (initial_workset p).","proofString":"destruct (initial_workset_incl p).\nred; intros.\nedestruct TRACK; eauto.\nsimpl in H4.\neelim IS.empty_1; eauto.\ncontradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (SEEN : IS.Subset {| w_seen := IS.empty; w_todo := nil |} (initial_workset p)) (TODO : incl (w_todo {| w_seen := IS.empty; w_todo := nil |})\n  (w_todo (initial_workset p))) (TRACK : forall id : IS.elt,\nIS.In id (initial_workset p) ->\nIS.In id {| w_seen := IS.empty; w_todo := nil |} \\/\nIn id (w_todo (initial_workset p))) : workset_invariant (initial_workset p).","proofString":"red; intros.\nedestruct TRACK; eauto.\nsimpl in H4.\neelim IS.empty_1; eauto.\ncontradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (SEEN : IS.Subset {| w_seen := IS.empty; w_todo := nil |} (initial_workset p)) (TODO : incl (w_todo {| w_seen := IS.empty; w_todo := nil |})\n  (w_todo (initial_workset p))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (initial_workset p) ->\nIS.In id0 {| w_seen := IS.empty; w_todo := nil |} \\/\nIn id0 (w_todo (initial_workset p))) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id (initial_workset p)) (H1 : ~ In id (w_todo (initial_workset p))) (H2 : pm ! id = Some gd) (H3 : ref_def gd id') : IS.In id' (initial_workset p).","proofString":"edestruct TRACK; eauto.\nsimpl in H4.\neelim IS.empty_1; eauto.\ncontradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (SEEN : IS.Subset {| w_seen := IS.empty; w_todo := nil |} (initial_workset p)) (TODO : incl (w_todo {| w_seen := IS.empty; w_todo := nil |})\n  (w_todo (initial_workset p))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (initial_workset p) ->\nIS.In id0 {| w_seen := IS.empty; w_todo := nil |} \\/\nIn id0 (w_todo (initial_workset p))) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id (initial_workset p)) (H1 : ~ In id (w_todo (initial_workset p))) (H2 : pm ! id = Some gd) (H3 : ref_def gd id') (H4 : IS.In id {| w_seen := IS.empty; w_todo := nil |}) : IS.In id' (initial_workset p).","proofString":"simpl in H4.\neelim IS.empty_1; eauto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (SEEN : IS.Subset {| w_seen := IS.empty; w_todo := nil |} (initial_workset p)) (TODO : incl (w_todo {| w_seen := IS.empty; w_todo := nil |})\n  (w_todo (initial_workset p))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (initial_workset p) ->\nIS.In id0 {| w_seen := IS.empty; w_todo := nil |} \\/\nIn id0 (w_todo (initial_workset p))) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id (initial_workset p)) (H1 : ~ In id (w_todo (initial_workset p))) (H2 : pm ! id = Some gd) (H3 : ref_def gd id') (H4 : IS.In id IS.empty) : IS.In id' (initial_workset p).","proofString":"eelim IS.empty_1; eauto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (SEEN : IS.Subset {| w_seen := IS.empty; w_todo := nil |} (initial_workset p)) (TODO : incl (w_todo {| w_seen := IS.empty; w_todo := nil |})\n  (w_todo (initial_workset p))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (initial_workset p) ->\nIS.In id0 {| w_seen := IS.empty; w_todo := nil |} \\/\nIn id0 (w_todo (initial_workset p))) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H0 : IS.In id (initial_workset p)) (H1 : ~ In id (w_todo (initial_workset p))) (H2 : pm ! id = Some gd) (H3 : ref_def gd id') (H4 : In id (w_todo (initial_workset p))) : IS.In id' (initial_workset p).","proofString":"contradiction."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : IS.Subset (initial_workset p) u.","proofString":"eapply PrimIter.iterate_prop with (P := fun (w: workset) => IS.Subset (initial_workset p) w); eauto.\nfold pm; unfold iter_step; intros.\ndestruct (w_todo a) as [ | id rem ].\nauto.\ndestruct (add_ref_definition_incl pm id {| w_seen := a; w_todo := rem |}).\nred; auto.\nred; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : forall a : workset,\nIS.Subset (initial_workset p) a ->\nmatch iter_step pm a with\n| inl b => IS.Subset (initial_workset p) b\n| inr a' => IS.Subset (initial_workset p) a'\nend.","proofString":"fold pm; unfold iter_step; intros.\ndestruct (w_todo a) as [ | id rem ].\nauto.\ndestruct (add_ref_definition_incl pm id {| w_seen := a; w_todo := rem |}).\nred; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (a : workset) (H0 : IS.Subset (initial_workset p) a) : match\n  match w_todo a with\n  | nil => inl a\n  | id :: rem =>\n      inr (add_ref_definition pm id {| w_seen := a; w_todo := rem |})\n  end\nwith\n| inl b => IS.Subset (initial_workset p) b\n| inr a' => IS.Subset (initial_workset p) a'\nend.","proofString":"destruct (w_todo a) as [ | id rem ].\nauto.\ndestruct (add_ref_definition_incl pm id {| w_seen := a; w_todo := rem |}).\nred; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (a : workset) (H0 : IS.Subset (initial_workset p) a) : IS.Subset (initial_workset p) a.","proofString":"auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (a : workset) (H0 : IS.Subset (initial_workset p) a) (id : ident) (rem : list ident) : IS.Subset (initial_workset p)\n  (add_ref_definition pm id {| w_seen := a; w_todo := rem |}).","proofString":"destruct (add_ref_definition_incl pm id {| w_seen := a; w_todo := rem |}).\nred; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) (a : workset) (H0 : IS.Subset (initial_workset p) a) (id : ident) (rem : list ident) (SEEN : IS.Subset {| w_seen := a; w_todo := rem |}\n  (add_ref_definition pm id {| w_seen := a; w_todo := rem |})) (TODO : incl (w_todo {| w_seen := a; w_todo := rem |})\n  (w_todo (add_ref_definition pm id {| w_seen := a; w_todo := rem |}))) (TRACK : forall id0 : IS.elt,\nIS.In id0 (add_ref_definition pm id {| w_seen := a; w_todo := rem |}) ->\nIS.In id0 {| w_seen := a; w_todo := rem |} \\/\nIn id0 (w_todo (add_ref_definition pm id {| w_seen := a; w_todo := rem |}))) : IS.Subset (initial_workset p)\n  (add_ref_definition pm id {| w_seen := a; w_todo := rem |}).","proofString":"red; auto."},{"statement":"(u : IS.t) (H : PrimIter.iterate workset IS.t (iter_step pm) (initial_workset p) = Some u) : IS.Subset (initial_workset p) (initial_workset p).","proofString":"red; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : valid_used_set p u.","proofString":"constructor.\nintros.\neapply used_globals_sound; eauto.\neapply used_globals_incl; eauto.\napply seen_main_initial_workset.\nintros.\neapply used_globals_incl; eauto.\napply seen_public_initial_workset; auto.\nintros.\napply ISF.for_all_iff in H0.\nred in H0.\napply H0 in H1.\nunfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto.\nhnf.\nsimpl; intros; congruence."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : forall (id : IS.elt) (gd : globdef fundef unit) (id' : ident),\nIS.In id u -> (prog_defmap p) ! id = Some gd -> ref_def gd id' -> IS.In id' u.","proofString":"intros.\neapply used_globals_sound; eauto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H1 : IS.In id u) (H2 : (prog_defmap p) ! id = Some gd) (H3 : ref_def gd id') : IS.In id' u.","proofString":"eapply used_globals_sound; eauto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : IS.In (prog_main p) u.","proofString":"eapply used_globals_incl; eauto.\napply seen_main_initial_workset."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : IS.In (prog_main p) (initial_workset p).","proofString":"apply seen_main_initial_workset."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : forall id : ident, In id (prog_public p) -> IS.In id u.","proofString":"intros.\neapply used_globals_incl; eauto.\napply seen_public_initial_workset; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : ident) (H1 : In id (prog_public p)) : IS.In id u.","proofString":"eapply used_globals_incl; eauto.\napply seen_public_initial_workset; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : ident) (H1 : In id (prog_public p)) : IS.In id (initial_workset p).","proofString":"apply seen_public_initial_workset; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) : forall id : IS.elt,\nIS.In id u -> In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"intros.\napply ISF.for_all_iff in H0.\nred in H0.\napply H0 in H1.\nunfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto.\nhnf.\nsimpl; intros; congruence."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : IS.elt) (H1 : IS.In id u) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"apply ISF.for_all_iff in H0.\nred in H0.\napply H0 in H1.\nunfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto.\nhnf.\nsimpl; intros; congruence."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.For_all (fun x : IS.elt => global_defined p pm x = true) u) (id : IS.elt) (H1 : IS.In id u) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"red in H0.\napply H0 in H1.\nunfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (H1 : IS.In id u) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"apply H0 in H1.\nunfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (H1 : global_defined p pm id = true) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"unfold global_defined in H1.\ndestruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (H1 : match pm ! id with\n| Some _ => true\n| None => ident_eq id (prog_main p)\nend = true) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"destruct pm!id as [g|] eqn:E.\nleft.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto.\nInvBooleans; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (g : globdef fundef unit) (E : pm ! id = Some g) (H1 : true = true) : In id (prog_defs_names p) \\/ id = prog_main p.","proofString":"left.\nchange id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (g : globdef fundef unit) (E : pm ! id = Some g) (H1 : true = true) : In id (prog_defs_names p).","proofString":"change id with (fst (id,g)).\napply in_map.\napply in_prog_defmap; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (g : globdef fundef unit) (E : pm ! id = Some g) (H1 : true = true) : In (fst (id, g)) (prog_defs_names p).","proofString":"apply in_map.\napply in_prog_defmap; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : forall x : IS.elt, IS.In x u -> global_defined p pm x = true) (id : IS.elt) (g : globdef fundef unit) (E : pm ! id = Some g) (H1 : true = true) : In (id, g) (prog_defs p).","proofString":"apply in_prog_defmap; auto."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : IS.elt) (H1 : IS.In id u) (H2 : forall (s : IS.t) (f : IS.elt -> bool),\ncompat_bool (fun x y : OrderedPositive.t => x = y) f ->\nIS.for_all f s = true -> IS.For_all (fun x : IS.elt => f x = true) s) : compat_bool (fun x y : OrderedPositive.t => x = y) (global_defined p pm).","proofString":"hnf.\nsimpl; intros; congruence."},{"statement":"(u : IS.t) (H : used_globals p pm = Some u) (H0 : IS.for_all (global_defined p pm) u = true) (id : IS.elt) (H1 : IS.In id u) (H2 : forall (s : IS.t) (f : IS.elt -> bool),\ncompat_bool (fun x y : OrderedPositive.t => x = y) f ->\nIS.for_all f s = true -> IS.For_all (fun x : IS.elt => f x = true) s) : forall x y : positive, x = y -> global_defined p pm x = global_defined p pm y.","proofString":"simpl; intros; congruence."},{"statement":"(accu1 accu2 : list (ident * globdef fundef unit)) (u : IS.t) : accu1 ++ accu2 = accu1 ++ accu2.","proofString":"auto."},{"statement":"(a : ident * globdef fundef unit) (defs : list (ident * globdef fundef unit)) (IHdefs : forall (accu0 accu3 : list (ident * globdef fundef unit)) (u0 : IS.t),\nfilter_globdefs u0 (accu0 ++ accu3) defs =\nfilter_globdefs u0 accu0 defs ++ accu3) (accu1 accu2 : list (ident * globdef fundef unit)) (u : IS.t) : (let (id, gd) := a in\n if IS.mem id u\n then filter_globdefs (IS.remove id u) ((id, gd) :: accu1 ++ accu2) defs\n else filter_globdefs u (accu1 ++ accu2) defs) =\n(let (id, gd) := a in\n if IS.mem id u\n then filter_globdefs (IS.remove id u) ((id, gd) :: accu1) defs\n else filter_globdefs u accu1 defs) ++ accu2.","proofString":"destruct a as [id gd].\ndestruct (IS.mem id u); auto.\nrewrite <- IHdefs.\nauto."},{"statement":"(id : ident) (gd : globdef fundef unit) (defs : list (ident * globdef fundef unit)) (IHdefs : forall (accu0 accu3 : list (ident * globdef fundef unit)) (u0 : IS.t),\nfilter_globdefs u0 (accu0 ++ accu3) defs =\nfilter_globdefs u0 accu0 defs ++ accu3) (accu1 accu2 : list (ident * globdef fundef unit)) (u : IS.t) : (if IS.mem id u\n then filter_globdefs (IS.remove id u) ((id, gd) :: accu1 ++ accu2) defs\n else filter_globdefs u (accu1 ++ accu2) defs) =\n(if IS.mem id u\n then filter_globdefs (IS.remove id u) ((id, gd) :: accu1) defs\n else filter_globdefs u accu1 defs) ++ accu2.","proofString":"destruct (IS.mem id u); auto.\nrewrite <- IHdefs.\nauto."},{"statement":"(id : ident) (gd : globdef fundef unit) (defs : list (ident * globdef fundef unit)) (IHdefs : forall (accu0 accu3 : list (ident * globdef fundef unit)) (u0 : IS.t),\nfilter_globdefs u0 (accu0 ++ accu3) defs =\nfilter_globdefs u0 accu0 defs ++ accu3) (accu1 accu2 : list (ident * globdef fundef unit)) (u : IS.t) : filter_globdefs (IS.remove id u) ((id, gd) :: accu1 ++ accu2) defs =\nfilter_globdefs (IS.remove id u) ((id, gd) :: accu1) defs ++ accu2.","proofString":"rewrite <- IHdefs.\nauto."},{"statement":"(id : ident) (gd : globdef fundef unit) (defs : list (ident * globdef fundef unit)) (IHdefs : forall (accu0 accu3 : list (ident * globdef fundef unit)) (u0 : IS.t),\nfilter_globdefs u0 (accu0 ++ accu3) defs =\nfilter_globdefs u0 accu0 defs ++ accu3) (accu1 accu2 : list (ident * globdef fundef unit)) (u : IS.t) : filter_globdefs (IS.remove id u) ((id, gd) :: accu1 ++ accu2) defs =\nfilter_globdefs (IS.remove id u) (((id, gd) :: accu1) ++ accu2) defs.","proofString":"auto."},{"statement":"(u : IS.t) (accu defs : list (ident * globdef fundef unit)) : filter_globdefs u accu defs = filter_globdefs u nil defs ++ accu.","proofString":"rewrite <- filter_globdefs_accu.\nauto."},{"statement":"(u : IS.t) (accu defs : list (ident * globdef fundef unit)) : filter_globdefs u accu defs = filter_globdefs u (nil ++ accu) defs.","proofString":"auto."},{"statement":"(id : IS.elt) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) : m1 ! id = None.","proofString":"auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) : (fold_left add_def\n   (if IS.mem id1 u\n    then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n    else filter_globdefs u nil l) m1) ! id = None.","proofString":"destruct (IS.mem id1 u) eqn:MEM.\nrewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1.\nsimpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto.\neapply IHl; eauto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (fold_left add_def (filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l)\n   m1) ! id = None.","proofString":"rewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1.\nsimpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (fold_left add_def\n   (filter_globdefs (IS.remove id1 u) nil l ++ (id1, gd1) :: nil) m1) ! id =\nNone.","proofString":"rewrite fold_left_app.\nsimpl.\nunfold add_def at 1.\nsimpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (fold_left add_def ((id1, gd1) :: nil)\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\nNone.","proofString":"simpl.\nunfold add_def at 1.\nsimpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (add_def (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)\n   (id1, gd1)) ! id = None.","proofString":"unfold add_def at 1.\nsimpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (PTree.set (fst (id1, gd1)) (snd (id1, gd1))\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\nNone.","proofString":"simpl.\nrewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (PTree.set id1 gd1\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\nNone.","proofString":"rewrite PTree.gso by congruence.\neapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1) ! id = None.","proofString":"eapply IHl; eauto.\nrewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : IS.mem id (IS.remove id1 u) = false.","proofString":"rewrite ISF.remove_b.\nrewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = true) : IS.mem id u && negb (ISF.eqb id1 id) = false.","proofString":"rewrite H; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = false ->\nm0 ! id = None ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id = None) (u : IS.t) (m1 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = false) (H0 : m1 ! id = None) (MEM : IS.mem id1 u = false) : (fold_left add_def (filter_globdefs u nil l) m1) ! id = None.","proofString":"eapply IHl; eauto."},{"statement":"(id : IS.elt) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) : m1 ! id = m2 ! id.","proofString":"auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) : (fold_left add_def\n   (if IS.mem id1 u\n    then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n    else filter_globdefs u nil l) m1) ! id =\n(fold_left add_def (rev l ++ (id1, gd1) :: nil) m2) ! id.","proofString":"rewrite fold_left_app.\nsimpl.\ndestruct (IS.mem id1 u) eqn:MEM.\nrewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto.\nunfold add_def at 2.\nsimpl.\nrewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) : (fold_left add_def\n   (if IS.mem id1 u\n    then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n    else filter_globdefs u nil l) m1) ! id =\n(fold_left add_def ((id1, gd1) :: nil) (fold_left add_def (rev l) m2)) ! id.","proofString":"simpl.\ndestruct (IS.mem id1 u) eqn:MEM.\nrewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto.\nunfold add_def at 2.\nsimpl.\nrewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) : (fold_left add_def\n   (if IS.mem id1 u\n    then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n    else filter_globdefs u nil l) m1) ! id =\n(add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"destruct (IS.mem id1 u) eqn:MEM.\nrewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto.\nunfold add_def at 2.\nsimpl.\nrewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (fold_left add_def (filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l)\n   m1) ! id = (add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"rewrite filter_globdefs_nil.\nrewrite fold_left_app.\nsimpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (fold_left add_def\n   (filter_globdefs (IS.remove id1 u) nil l ++ (id1, gd1) :: nil) m1) ! id =\n(add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"rewrite fold_left_app.\nsimpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (fold_left add_def ((id1, gd1) :: nil)\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\n(add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"simpl.\nunfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (add_def (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)\n   (id1, gd1)) ! id =\n(add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"unfold add_def at 1 3.\nsimpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (PTree.set (fst (id1, gd1)) (snd (id1, gd1))\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\n(PTree.set (fst (id1, gd1)) (snd (id1, gd1)) (fold_left add_def (rev l) m2))\n! id.","proofString":"simpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (PTree.set id1 gd1\n   (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1)) ! id =\n(PTree.set id1 gd1 (fold_left add_def (rev l) m2)) ! id.","proofString":"rewrite ! PTree.gsspec.\ndestruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) : (if peq id id1\n then Some gd1\n else (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1) ! id) =\n(if peq id id1 then Some gd1 else (fold_left add_def (rev l) m2) ! id).","proofString":"destruct (peq id id1).\nauto.\napply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) (e : id = id1) : Some gd1 = Some gd1.","proofString":"auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) (n : id <> id1) : (fold_left add_def (filter_globdefs (IS.remove id1 u) nil l) m1) ! id =\n(fold_left add_def (rev l) m2) ! id.","proofString":"apply IHl; auto.\napply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) (n : id <> id1) : IS.mem id (IS.remove id1 u) = true.","proofString":"apply IS.mem_1.\napply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) (n : id <> id1) : IS.In id (IS.remove id1 u).","proofString":"apply IS.remove_2; auto.\napply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = true) (n : id <> id1) : IS.In id u.","proofString":"apply IS.mem_2; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = false) : (fold_left add_def (filter_globdefs u nil l) m1) ! id =\n(add_def (fold_left add_def (rev l) m2) (id1, gd1)) ! id.","proofString":"unfold add_def at 2.\nsimpl.\nrewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = false) : (fold_left add_def (filter_globdefs u nil l) m1) ! id =\n(PTree.set (fst (id1, gd1)) (snd (id1, gd1)) (fold_left add_def (rev l) m2))\n! id.","proofString":"simpl.\nrewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = false) : (fold_left add_def (filter_globdefs u nil l) m1) ! id =\n(PTree.set id1 gd1 (fold_left add_def (rev l) m2)) ! id.","proofString":"rewrite PTree.gso by congruence.\napply IHl; auto."},{"statement":"(id : IS.elt) (id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall (u0 : IS.t) (m0 m3 : PTree.tree (globdef fundef unit)),\nIS.mem id u0 = true ->\nm0 ! id = m3 ! id ->\n(fold_left add_def (filter_globdefs u0 nil l) m0) ! id =\n(fold_left add_def (rev l) m3) ! id) (u : IS.t) (m1 m2 : PTree.tree (globdef fundef unit)) (H : IS.mem id u = true) (H0 : m1 ! id = m2 ! id) (MEM : IS.mem id1 u = false) : (fold_left add_def (filter_globdefs u nil l) m1) ! id =\n(fold_left add_def (rev l) m2) ! id.","proofString":"apply IHl; auto."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) : (PTree_Properties.of_list (filter_globdefs u nil (rev defs))) ! id =\n(if IS.mem id u then (PTree_Properties.of_list defs) ! id else None).","proofString":"unfold PTree_Properties.of_list.\nfold prog_map.\nunfold PTree.elt.\nfold add_def.\ndestruct (IS.mem id u) eqn:MEM.\nerewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto.\napply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) : (fold_left\n   (fun (m : PTree.t (globdef fundef unit))\n      (k_v : PTree.elt * globdef fundef unit) =>\n    PTree.set (fst k_v) (snd k_v) m) (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id =\n(if IS.mem id u\n then\n  (fold_left\n     (fun (m : PTree.t (globdef fundef unit))\n        (k_v : PTree.elt * globdef fundef unit) =>\n      PTree.set (fst k_v) (snd k_v) m) defs\n     (PTree.empty (globdef fundef unit))) ! id\n else None).","proofString":"fold prog_map.\nunfold PTree.elt.\nfold add_def.\ndestruct (IS.mem id u) eqn:MEM.\nerewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto.\napply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) : (fold_left\n   (fun (m : prog_map) (k_v : PTree.elt * globdef fundef unit) =>\n    PTree.set (fst k_v) (snd k_v) m) (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id =\n(if IS.mem id u\n then\n  (fold_left\n     (fun (m : prog_map) (k_v : PTree.elt * globdef fundef unit) =>\n      PTree.set (fst k_v) (snd k_v) m) defs\n     (PTree.empty (globdef fundef unit))) ! id\n else None).","proofString":"unfold PTree.elt.\nfold add_def.\ndestruct (IS.mem id u) eqn:MEM.\nerewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto.\napply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) : (fold_left\n   (fun (m : prog_map) (k_v : positive * globdef fundef unit) =>\n    PTree.set (fst k_v) (snd k_v) m) (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id =\n(if IS.mem id u\n then\n  (fold_left\n     (fun (m : prog_map) (k_v : positive * globdef fundef unit) =>\n      PTree.set (fst k_v) (snd k_v) m) defs\n     (PTree.empty (globdef fundef unit))) ! id\n else None).","proofString":"fold add_def.\ndestruct (IS.mem id u) eqn:MEM.\nerewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto.\napply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) : (fold_left add_def (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id =\n(if IS.mem id u\n then (fold_left add_def defs (PTree.empty (globdef fundef unit))) ! id\n else None).","proofString":"destruct (IS.mem id u) eqn:MEM.\nerewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto.\napply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) (MEM : IS.mem id u = true) : (fold_left add_def (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id =\n(fold_left add_def defs (PTree.empty (globdef fundef unit))) ! id.","proofString":"erewrite filter_globdefs_map_2.\nrewrite List.rev_involutive.\nreflexivity.\nauto.\nauto."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) (MEM : IS.mem id u = true) : IS.mem id u = true.","proofString":"auto."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) (MEM : IS.mem id u = false) : (fold_left add_def (filter_globdefs u nil (rev defs))\n   (PTree.empty (globdef fundef unit))) ! id = None.","proofString":"apply filter_globdefs_map_1.\nauto.\napply PTree.gempty."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) (MEM : IS.mem id u = false) : IS.mem id u = false.","proofString":"auto."},{"statement":"(id : positive) (u : IS.t) (defs : list (ident * globdef fundef unit)) (MEM : IS.mem id u = false) : (PTree.empty (globdef fundef unit)) ! id = None.","proofString":"apply PTree.gempty."},{"statement":"(id : ident) (u : IS.t) (H : False) : IS.In id u /\\ False.","proofString":"tauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (H : In id\n  (map fst\n     (if IS.mem id1 u\n      then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n      else filter_globdefs u nil l))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"destruct (IS.mem id1 u) eqn:MEM.\nrewrite filter_globdefs_nil, map_app, in_app_iff in H.\ndestruct H.\napply IHl in H.\nrewrite ISF.remove_iff in H.\ntauto.\nsimpl in H.\ndestruct H; try tauto.\nsubst id1.\nsplit; auto.\napply IS.mem_2; auto.\napply IHl in H.\ntauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : In id (map fst (filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"rewrite filter_globdefs_nil, map_app, in_app_iff in H.\ndestruct H.\napply IHl in H.\nrewrite ISF.remove_iff in H.\ntauto.\nsimpl in H.\ndestruct H; try tauto.\nsubst id1.\nsplit; auto.\napply IS.mem_2; auto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : In id (map fst (filter_globdefs (IS.remove id1 u) nil l)) \\/\nIn id (map fst ((id1, gd1) :: nil))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"destruct H.\napply IHl in H.\nrewrite ISF.remove_iff in H.\ntauto.\nsimpl in H.\ndestruct H; try tauto.\nsubst id1.\nsplit; auto.\napply IS.mem_2; auto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : In id (map fst (filter_globdefs (IS.remove id1 u) nil l))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"apply IHl in H.\nrewrite ISF.remove_iff in H.\ntauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : IS.In id (IS.remove id1 u) /\\ In id (map fst l)) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"rewrite ISF.remove_iff in H.\ntauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : (IS.In id u /\\ id1 <> id) /\\ In id (map fst l)) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"tauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : In id (map fst ((id1, gd1) :: nil))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"simpl in H.\ndestruct H; try tauto.\nsubst id1.\nsplit; auto.\napply IS.mem_2; auto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : id1 = id \\/ False) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"destruct H; try tauto.\nsubst id1.\nsplit; auto.\napply IS.mem_2; auto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = true) (H : id1 = id) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"subst id1.\nsplit; auto.\napply IS.mem_2; auto."},{"statement":"(id : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id u = true) : IS.In id u /\\ (id = id \\/ In id (map fst l)).","proofString":"split; auto.\napply IS.mem_2; auto."},{"statement":"(id : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id u = true) : IS.In id u.","proofString":"apply IS.mem_2; auto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = false) (H : In id (map fst (filter_globdefs u nil l))) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"apply IHl in H.\ntauto."},{"statement":"(id id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t,\nIn id (map fst (filter_globdefs u0 nil l)) ->\nIS.In id u0 /\\ In id (map fst l)) (u : IS.t) (MEM : IS.mem id1 u = false) (H : IS.In id u /\\ In id (map fst l)) : IS.In id u /\\ (id1 = id \\/ In id (map fst l)).","proofString":"tauto."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) : list_norepet\n  (map fst\n     (if IS.mem id1 u\n      then filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l\n      else filter_globdefs u nil l)).","proofString":"destruct (IS.mem id1 u) eqn:MEM; auto.\nrewrite filter_globdefs_nil, map_app.\nsimpl.\napply list_norepet_append; auto.\nconstructor.\nsimpl; tauto.\nconstructor.\nred; simpl; intros.\ndestruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : list_norepet\n  (map fst (filter_globdefs (IS.remove id1 u) ((id1, gd1) :: nil) l)).","proofString":"rewrite filter_globdefs_nil, map_app.\nsimpl.\napply list_norepet_append; auto.\nconstructor.\nsimpl; tauto.\nconstructor.\nred; simpl; intros.\ndestruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : list_norepet\n  (map fst (filter_globdefs (IS.remove id1 u) nil l) ++\n   map fst ((id1, gd1) :: nil)).","proofString":"simpl.\napply list_norepet_append; auto.\nconstructor.\nsimpl; tauto.\nconstructor.\nred; simpl; intros.\ndestruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : list_norepet\n  (map fst (filter_globdefs (IS.remove id1 u) nil l) ++ id1 :: nil).","proofString":"apply list_norepet_append; auto.\nconstructor.\nsimpl; tauto.\nconstructor.\nred; simpl; intros.\ndestruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : list_norepet (id1 :: nil).","proofString":"constructor.\nsimpl; tauto.\nconstructor."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : ~ In id1 nil.","proofString":"simpl; tauto."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) : list_disjoint (map fst (filter_globdefs (IS.remove id1 u) nil l))\n  (id1 :: nil).","proofString":"red; simpl; intros.\ndestruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) (x y : ident) (H : In x (map fst (filter_globdefs (IS.remove id1 u) nil l))) (H0 : id1 = y \\/ False) : x <> y.","proofString":"destruct H0; try tauto.\nsubst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) (x y : ident) (H : In x (map fst (filter_globdefs (IS.remove id1 u) nil l))) (H0 : id1 = y) : x <> y.","proofString":"subst y.\napply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) (x : ident) (H : In x (map fst (filter_globdefs (IS.remove id1 u) nil l))) : x <> id1.","proofString":"apply filter_globdefs_domain in H.\nrewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) (x : ident) (H : IS.In x (IS.remove id1 u) /\\ In x (map fst l)) : x <> id1.","proofString":"rewrite ISF.remove_iff in H.\nintuition."},{"statement":"(id1 : ident) (gd1 : globdef fundef unit) (l : list (ident * globdef fundef unit)) (IHl : forall u0 : IS.t, list_norepet (map fst (filter_globdefs u0 nil l))) (u : IS.t) (MEM : IS.mem id1 u = true) (x : ident) (H : (IS.In x u /\\ id1 <> x) /\\ In x (map fst l)) : x <> id1.","proofString":"intuition."},{"statement":"(p tp : program) (TR : match used_globals p (prog_defmap p) with\n| Some used =>\n    if IS.for_all (global_defined p (prog_defmap p)) used\n    then\n     OK\n       {|\n         prog_defs := filter_globdefs used nil (rev (prog_defs p));\n         prog_public := prog_public p;\n         prog_main := prog_main p\n       |}\n    else Error (msg \"Unusedglob: reference to undefined global\")\n| None => Error (msg \"Unusedglob: analysis failed\")\nend = OK tp) : match_prog p tp.","proofString":"set (pm := prog_defmap p) in *.\ndestruct (used_globals p pm) as [u|] eqn:U; try discriminate.\ndestruct (IS.for_all (global_defined p pm) u) eqn:DEF; inv TR.\nexists u; split.\napply used_globals_valid; auto.\nconstructor; simpl; auto.\nintros.\nunfold prog_defmap; simpl.\napply filter_globdefs_map.\napply filter_globdefs_unique_names."},{"statement":"(p : program) (pm : PTree.t (globdef fundef unit)) (u : IS.t) (U : used_globals p pm = Some u) (DEF : IS.for_all (global_defined p pm) u = true) : match_prog_1 u p\n  {|\n    prog_defs := filter_globdefs u nil (rev (prog_defs p));\n    prog_public := prog_public p;\n    prog_main := prog_main p\n  |}.","proofString":"constructor; simpl; auto.\nintros.\nunfold prog_defmap; simpl.\napply filter_globdefs_map.\napply filter_globdefs_unique_names."},{"statement":"(p : program) (pm : PTree.t (globdef fundef unit)) (u : IS.t) (U : used_globals p pm = Some u) (DEF : IS.for_all (global_defined p pm) u = true) : forall id : positive,\n(prog_defmap\n   {|\n     prog_defs := filter_globdefs u nil (rev (prog_defs p));\n     prog_public := prog_public p;\n     prog_main := prog_main p\n   |}) ! id = (if IS.mem id u then (prog_defmap p) ! id else None).","proofString":"intros.\nunfold prog_defmap; simpl.\napply filter_globdefs_map."},{"statement":"(p : program) (pm : PTree.t (globdef fundef unit)) (u : IS.t) (U : used_globals p pm = Some u) (DEF : IS.for_all (global_defined p pm) u = true) (id : positive) : (prog_defmap\n   {|\n     prog_defs := filter_globdefs u nil (rev (prog_defs p));\n     prog_public := prog_public p;\n     prog_main := prog_main p\n   |}) ! id = (if IS.mem id u then (prog_defmap p) ! id else None).","proofString":"unfold prog_defmap; simpl.\napply filter_globdefs_map."},{"statement":"(p : program) (pm : PTree.t (globdef fundef unit)) (u : IS.t) (U : used_globals p pm = Some u) (DEF : IS.for_all (global_defined p pm) u = true) (id : positive) : (PTree_Properties.of_list (filter_globdefs u nil (rev (prog_defs p)))) ! id =\n(if IS.mem id u then (PTree_Properties.of_list (prog_defs p)) ! id else None).","proofString":"apply filter_globdefs_map."},{"statement":"(p : program) (pm : PTree.t (globdef fundef unit)) (u : IS.t) (U : used_globals p pm = Some u) (DEF : IS.for_all (global_defined p pm) u = true) : list_norepet\n  (prog_defs_names\n     {|\n       prog_defs := filter_globdefs u nil (rev (prog_defs p));\n       prog_public := prog_public p;\n       prog_main := prog_main p\n     |}).","proofString":"apply filter_globdefs_unique_names."},{"statement":"(id : ident) (gd : globdef fundef unit) (id' : ident) (H : kept id) (H0 : pm ! id = Some gd) (H1 : ref_def gd id') : kept id'.","proofString":"eapply used_closed; eauto."},{"statement":"(id : ident) (H : In id (prog_public p)) : kept id.","proofString":"eapply used_public; eauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) : exists b' : block, Genv.find_symbol tge id = Some b'.","proofString":"assert (A: exists g, (prog_defmap p)!id = Some g).\napply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto.\ndestruct A as (g & P).\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) : exists g : globdef fundef unit, (prog_defmap p) ! id = Some g.","proofString":"apply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) : In id (prog_defs_names p).","proofString":"eapply Genv.find_symbol_inversion; eauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (A : exists g : globdef fundef unit, (prog_defmap p) ! id = Some g) : exists b' : block, Genv.find_symbol tge id = Some b'.","proofString":"destruct A as (g & P).\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (g : globdef fundef unit) (P : (prog_defmap p) ! id = Some g) : exists b' : block, Genv.find_symbol tge id = Some b'.","proofString":"apply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (g : globdef fundef unit) (P : (prog_defmap p) ! id = Some g) : In (id, g) (prog_defs tp).","proofString":"apply in_prog_defmap.\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (g : globdef fundef unit) (P : (prog_defmap p) ! id = Some g) : (prog_defmap tp) ! id = Some g.","proofString":"erewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (g : globdef fundef unit) (P : (prog_defmap p) ! id = Some g) : (if IS.mem id used then (prog_defmap p) ! id else None) = Some g.","proofString":"rewrite IS.mem_1 by auto.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) (H0 : kept id) (g : globdef fundef unit) (P : (prog_defmap p) ! id = Some g) : (prog_defmap p) ! id = Some g.","proofString":"auto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) : kept id /\\ (exists b' : block, Genv.find_symbol ge id = Some b').","proofString":"assert (A: exists g, (prog_defmap tp)!id = Some g).\napply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto.\ndestruct A as (g & P).\nerewrite match_prog_def in P by eauto.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nsplit.\napply IS.mem_2; auto.\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) : exists g : globdef fundef unit, (prog_defmap tp) ! id = Some g.","proofString":"apply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) : In id (prog_defs_names tp).","proofString":"eapply Genv.find_symbol_inversion; eauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (A : exists g : globdef fundef unit, (prog_defmap tp) ! id = Some g) : kept id /\\ (exists b' : block, Genv.find_symbol ge id = Some b').","proofString":"destruct A as (g & P).\nerewrite match_prog_def in P by eauto.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nsplit.\napply IS.mem_2; auto.\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (P : (prog_defmap tp) ! id = Some g) : kept id /\\ (exists b' : block, Genv.find_symbol ge id = Some b').","proofString":"erewrite match_prog_def in P by eauto.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nsplit.\napply IS.mem_2; auto.\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (P : (if IS.mem id used then (prog_defmap p) ! id else None) = Some g) : kept id /\\ (exists b' : block, Genv.find_symbol ge id = Some b').","proofString":"destruct (IS.mem id used) eqn:U; try discriminate.\nsplit.\napply IS.mem_2; auto.\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some g) : kept id /\\ (exists b' : block, Genv.find_symbol ge id = Some b').","proofString":"split.\napply IS.mem_2; auto.\napply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some g) : kept id.","proofString":"apply IS.mem_2; auto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some g) : exists b' : block, Genv.find_symbol ge id = Some b'.","proofString":"apply Genv.find_symbol_exists with g.\napply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some g) : In (id, g) (prog_defs p).","proofString":"apply in_prog_defmap.\nauto."},{"statement":"(id : ident) (b : block) (H : Genv.find_symbol tge id = Some b) (g : globdef fundef unit) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some g) : (prog_defmap p) ! id = Some g.","proofString":"auto."},{"statement":"(id : ident) (b b' : block) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_symbol tge id = Some b') : init_meminj b = Some (b', 0).","proofString":"unfold init_meminj.\nerewrite Genv.find_invert_symbol by eauto.\nrewrite H0.\nauto."},{"statement":"(id : ident) (b b' : block) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_symbol tge id = Some b') : match Genv.invert_symbol ge b with\n| Some id0 =>\n    match Genv.find_symbol tge id0 with\n    | Some b'0 => Some (b'0, 0)\n    | None => None\n    end\n| None => None\nend = Some (b', 0).","proofString":"erewrite Genv.find_invert_symbol by eauto.\nrewrite H0.\nauto."},{"statement":"(id : ident) (b b' : block) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_symbol tge id = Some b') : match Genv.find_symbol tge id with\n| Some b'0 => Some (b'0, 0)\n| None => None\nend = Some (b', 0).","proofString":"rewrite H0.\nauto."},{"statement":"(id : ident) (b b' : block) (H : Genv.find_symbol ge id = Some b) (H0 : Genv.find_symbol tge id = Some b') : Some (b', 0) = Some (b', 0).","proofString":"auto."},{"statement":"(b b' : block) (delta : Z) (H : match Genv.invert_symbol ge b with\n| Some id =>\n    match Genv.find_symbol tge id with\n    | Some b'0 => Some (b'0, 0)\n    | None => None\n    end\n| None => None\nend = Some (b', delta)) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b').","proofString":"destruct (Genv.invert_symbol ge b) as [id|] eqn:S; try discriminate.\ndestruct (Genv.find_symbol tge id) as [b''|] eqn:F; inv H.\nsplit.\nauto.\nexists id.\nsplit.\napply Genv.invert_find_symbol; auto.\nauto."},{"statement":"(b b' : block) (delta : Z) (id : ident) (S : Genv.invert_symbol ge b = Some id) (H : match Genv.find_symbol tge id with\n| Some b'0 => Some (b'0, 0)\n| None => None\nend = Some (b', delta)) : delta = 0 /\\\n(exists id0 : ident,\n   Genv.find_symbol ge id0 = Some b /\\ Genv.find_symbol tge id0 = Some b').","proofString":"destruct (Genv.find_symbol tge id) as [b''|] eqn:F; inv H.\nsplit.\nauto.\nexists id.\nsplit.\napply Genv.invert_find_symbol; auto.\nauto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : 0 = 0 /\\\n(exists id0 : ident,\n   Genv.find_symbol ge id0 = Some b /\\ Genv.find_symbol tge id0 = Some b').","proofString":"split.\nauto.\nexists id.\nsplit.\napply Genv.invert_find_symbol; auto.\nauto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : 0 = 0.","proofString":"auto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : exists id0 : ident,\n  Genv.find_symbol ge id0 = Some b /\\ Genv.find_symbol tge id0 = Some b'.","proofString":"exists id.\nsplit.\napply Genv.invert_find_symbol; auto.\nauto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b'.","proofString":"split.\napply Genv.invert_find_symbol; auto.\nauto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : Genv.find_symbol ge id = Some b.","proofString":"apply Genv.invert_find_symbol; auto."},{"statement":"(b b' : block) (id : ident) (S : Genv.invert_symbol ge b = Some id) (F : Genv.find_symbol tge id = Some b') : Genv.find_symbol tge id = Some b'.","proofString":"auto."},{"statement":"(id : ident) (b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_symbol ge id = Some b) : delta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id1 & B & C).\nassert (id1 = id) by (eapply (Genv.genv_vars_inj ge); eauto).\nsubst id1.\nauto."},{"statement":"(id : ident) (b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_symbol ge id = Some b) : delta = 0 /\\\n(exists id0 : ident,\n   Genv.find_symbol ge id0 = Some b /\\ Genv.find_symbol tge id0 = Some b') ->\ndelta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"intros (A & id1 & B & C).\nassert (id1 = id) by (eapply (Genv.genv_vars_inj ge); eauto).\nsubst id1.\nauto."},{"statement":"(id : ident) (b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_symbol ge id = Some b) (A : delta = 0) (id1 : ident) (B : Genv.find_symbol ge id1 = Some b) (C : Genv.find_symbol tge id1 = Some b') : delta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"assert (id1 = id) by (eapply (Genv.genv_vars_inj ge); eauto).\nsubst id1.\nauto."},{"statement":"(id : ident) (b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_symbol ge id = Some b) (A : delta = 0) (id1 : ident) (B : Genv.find_symbol ge id1 = Some b) (C : Genv.find_symbol tge id1 = Some b') (H1 : id1 = id) : delta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"subst id1.\nauto."},{"statement":"(id : ident) (b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_symbol ge id = Some b) (A : delta = 0) (C : Genv.find_symbol tge id = Some b') (B : Genv.find_symbol ge id = Some b) : delta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"auto."},{"statement":"(id : ident) (b : block) (H : kept id) (H0 : Genv.find_symbol ge id = Some b) : exists b' : block,\n  Genv.find_symbol tge id = Some b' /\\ init_meminj b = Some (b', 0).","proofString":"exploit transform_find_symbol_1; eauto.\nintros (b' & F).\nexists b'; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b : block) (H : kept id) (H0 : Genv.find_symbol ge id = Some b) : (exists b' : block, Genv.find_symbol tge id = Some b') ->\nexists b' : block,\n  Genv.find_symbol tge id = Some b' /\\ init_meminj b = Some (b', 0).","proofString":"intros (b' & F).\nexists b'; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b : block) (H : kept id) (H0 : Genv.find_symbol ge id = Some b) (b' : block) (F : Genv.find_symbol tge id = Some b') : exists b'0 : block,\n  Genv.find_symbol tge id = Some b'0 /\\ init_meminj b = Some (b'0, 0).","proofString":"exists b'; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b : block) (H : kept id) (H0 : Genv.find_symbol ge id = Some b) (b' : block) (F : Genv.find_symbol tge id = Some b') : init_meminj b = Some (b', 0).","proofString":"eapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b' : block) (H : Genv.find_symbol tge id = Some b') : exists b : block,\n  Genv.find_symbol ge id = Some b /\\ init_meminj b = Some (b', 0).","proofString":"exploit transform_find_symbol_2; eauto.\nintros (K & b & F).\nexists b; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b' : block) (H : Genv.find_symbol tge id = Some b') : kept id /\\ (exists b'0 : block, Genv.find_symbol ge id = Some b'0) ->\nexists b : block,\n  Genv.find_symbol ge id = Some b /\\ init_meminj b = Some (b', 0).","proofString":"intros (K & b & F).\nexists b; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b' : block) (H : Genv.find_symbol tge id = Some b') (K : kept id) (b : block) (F : Genv.find_symbol ge id = Some b) : exists b0 : block,\n  Genv.find_symbol ge id = Some b0 /\\ init_meminj b0 = Some (b', 0).","proofString":"exists b; split; auto.\neapply init_meminj_eq; eauto."},{"statement":"(id : ident) (b' : block) (H : Genv.find_symbol tge id = Some b') (K : kept id) (b : block) (F : Genv.find_symbol ge id = Some b) : init_meminj b = Some (b', 0).","proofString":"eapply init_meminj_eq; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id : ident, ref_def gd id -> kept id).","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\nassert (kept id) by (eapply transform_find_symbol_2; eauto).\nassert (pm!id = Some gd).\nunfold pm; rewrite Genv.find_def_symbol.\nexists b; auto.\nassert ((prog_defmap tp)!id = Some gd).\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto.\nrewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\nGenv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id : ident, ref_def gd id -> kept id).","proofString":"intros (A & id & B & C).\nassert (kept id) by (eapply transform_find_symbol_2; eauto).\nassert (pm!id = Some gd).\nunfold pm; rewrite Genv.find_def_symbol.\nexists b; auto.\nassert ((prog_defmap tp)!id = Some gd).\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto.\nrewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"assert (kept id) by (eapply transform_find_symbol_2; eauto).\nassert (pm!id = Some gd).\nunfold pm; rewrite Genv.find_def_symbol.\nexists b; auto.\nassert ((prog_defmap tp)!id = Some gd).\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto.\nrewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"assert (pm!id = Some gd).\nunfold pm; rewrite Genv.find_def_symbol.\nexists b; auto.\nassert ((prog_defmap tp)!id = Some gd).\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto.\nrewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) : pm ! id = Some gd.","proofString":"unfold pm; rewrite Genv.find_def_symbol.\nexists b; auto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv p) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv p) b0 = Some gd.","proofString":"exists b; auto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"assert ((prog_defmap tp)!id = Some gd).\nerewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto.\nrewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) : (prog_defmap tp) ! id = Some gd.","proofString":"erewrite match_prog_def by eauto.\nrewrite IS.mem_1 by auto.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) : (if IS.mem id used then (prog_defmap p) ! id else None) = Some gd.","proofString":"rewrite IS.mem_1 by auto.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) : (prog_defmap p) ! id = Some gd.","proofString":"auto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (H3 : (prog_defmap tp) ! id = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"rewrite Genv.find_def_symbol in H3.\ndestruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (H3 : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv tp) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv tp) b0 = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"destruct H3 as (b1 & P & Q).\nfold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol (Genv.globalenv tp) id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"fold tge in P.\nreplace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol tge id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"replace b' with b1 by congruence.\nsplit; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol tge id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) : Genv.find_def tge b1 = Some gd /\\\ndelta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"split; auto.\nsplit; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol tge id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) : delta = 0 /\\ (forall id0 : ident, ref_def gd id0 -> kept id0).","proofString":"split; auto.\nintros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol tge id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) : forall id0 : ident, ref_def gd id0 -> kept id0.","proofString":"intros.\neapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def ge b = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : kept id) (H2 : pm ! id = Some gd) (b1 : block) (P : Genv.find_symbol tge id = Some b1) (Q : Genv.find_def (Genv.globalenv tp) b1 = Some gd) (id0 : ident) (H3 : ref_def gd id0) : kept id0.","proofString":"eapply kept_closed; eauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\nassert ((prog_defmap tp)!id = Some gd).\nrewrite Genv.find_def_symbol.\nexists b'; auto.\nerewrite match_prog_def in H1 by eauto.\ndestruct (IS.mem id used); try discriminate.\nrewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\nGenv.find_def ge b = Some gd /\\ delta = 0.","proofString":"intros (A & id & B & C).\nassert ((prog_defmap tp)!id = Some gd).\nrewrite Genv.find_def_symbol.\nexists b'; auto.\nerewrite match_prog_def in H1 by eauto.\ndestruct (IS.mem id used); try discriminate.\nrewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"assert ((prog_defmap tp)!id = Some gd).\nrewrite Genv.find_def_symbol.\nexists b'; auto.\nerewrite match_prog_def in H1 by eauto.\ndestruct (IS.mem id used); try discriminate.\nrewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : (prog_defmap tp) ! id = Some gd.","proofString":"rewrite Genv.find_def_symbol.\nexists b'; auto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv tp) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv tp) b0 = Some gd.","proofString":"exists b'; auto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : (prog_defmap tp) ! id = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"erewrite match_prog_def in H1 by eauto.\ndestruct (IS.mem id used); try discriminate.\nrewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : (if IS.mem id used then (prog_defmap p) ! id else None) = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"destruct (IS.mem id used); try discriminate.\nrewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : (prog_defmap p) ! id = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"rewrite Genv.find_def_symbol in H1.\ndestruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H1 : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv p) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv p) b0 = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"destruct H1 as (b1 & P & Q).\nfold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (b1 : block) (P : Genv.find_symbol (Genv.globalenv p) id = Some b1) (Q : Genv.find_def (Genv.globalenv p) b1 = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"fold ge in P.\nreplace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (b1 : block) (P : Genv.find_symbol ge id = Some b1) (Q : Genv.find_def (Genv.globalenv p) b1 = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"replace b with b1 by congruence.\nauto."},{"statement":"(b b' : block) (delta : Z) (gd : globdef fundef unit) (H : init_meminj b = Some (b', delta)) (H0 : Genv.find_def tge b' = Some gd) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (b1 : block) (P : Genv.find_symbol ge id = Some b1) (Q : Genv.find_def (Genv.globalenv p) b1 = Some gd) : Genv.find_def ge b1 = Some gd /\\ delta = 0.","proofString":"auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) : symbols_inject j ge tge.","proofString":"assert (E1: Genv.genv_public ge = p.(prog_public)).\napply Genv.globalenv_public.\nassert (E2: Genv.genv_public tge = p.(prog_public)).\nunfold tge; rewrite Genv.globalenv_public.\neapply match_prog_public; eauto.\nsplit; [|split;[|split]]; intros.\nsimpl; unfold Genv.public_symbol; rewrite E1, E2.\ndestruct (Genv.find_symbol tge id) as [b'|] eqn:TFS.\nexploit symbols_inject_3; eauto.\nintros (b & FS & INJ).\nrewrite FS.\nauto.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ndestruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence.\neapply symbols_inject_1; eauto.\nsimpl in *; unfold Genv.public_symbol in H0.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite E1 in H0.\ndestruct (in_dec ident_eq id (prog_public p)); try discriminate.\ninv H1.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & A & B); exists b'; auto.\nsimpl.\nunfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) : Genv.genv_public ge = prog_public p.","proofString":"apply Genv.globalenv_public."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) : symbols_inject j ge tge.","proofString":"assert (E2: Genv.genv_public tge = p.(prog_public)).\nunfold tge; rewrite Genv.globalenv_public.\neapply match_prog_public; eauto.\nsplit; [|split;[|split]]; intros.\nsimpl; unfold Genv.public_symbol; rewrite E1, E2.\ndestruct (Genv.find_symbol tge id) as [b'|] eqn:TFS.\nexploit symbols_inject_3; eauto.\nintros (b & FS & INJ).\nrewrite FS.\nauto.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ndestruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence.\neapply symbols_inject_1; eauto.\nsimpl in *; unfold Genv.public_symbol in H0.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite E1 in H0.\ndestruct (in_dec ident_eq id (prog_public p)); try discriminate.\ninv H1.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & A & B); exists b'; auto.\nsimpl.\nunfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) : Genv.genv_public tge = prog_public p.","proofString":"unfold tge; rewrite Genv.globalenv_public.\neapply match_prog_public; eauto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) : prog_public tp = prog_public p.","proofString":"eapply match_prog_public; eauto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) : symbols_inject j ge tge.","proofString":"split; [|split;[|split]]; intros.\nsimpl; unfold Genv.public_symbol; rewrite E1, E2.\ndestruct (Genv.find_symbol tge id) as [b'|] eqn:TFS.\nexploit symbols_inject_3; eauto.\nintros (b & FS & INJ).\nrewrite FS.\nauto.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ndestruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence.\neapply symbols_inject_1; eauto.\nsimpl in *; unfold Genv.public_symbol in H0.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite E1 in H0.\ndestruct (in_dec ident_eq id (prog_public p)); try discriminate.\ninv H1.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & A & B); exists b'; auto.\nsimpl.\nunfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) : Senv.public_symbol tge id = Senv.public_symbol ge id.","proofString":"simpl; unfold Genv.public_symbol; rewrite E1, E2.\ndestruct (Genv.find_symbol tge id) as [b'|] eqn:TFS.\nexploit symbols_inject_3; eauto.\nintros (b & FS & INJ).\nrewrite FS.\nauto.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ndestruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (b' : block) (TFS : Genv.find_symbol tge id = Some b') (b : block) (FS : Genv.find_symbol ge id = Some b) (INJ : j b = Some (b', 0)) : in_dec ident_eq id (prog_public p) = in_dec ident_eq id (prog_public p).","proofString":"auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) : false =\nmatch Genv.find_symbol ge id with\n| Some _ => in_dec ident_eq id (prog_public p)\n| None => false\nend.","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\ndestruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) (b : block) (FS : Genv.find_symbol ge id = Some b) : false = in_dec ident_eq id (prog_public p).","proofString":"destruct (in_dec ident_eq id (prog_public p)); simpl; auto.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) (b : block) (FS : Genv.find_symbol ge id = Some b) (i : In id (prog_public p)) : false = true.","proofString":"exploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & TFS' & INJ).\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) (b : block) (FS : Genv.find_symbol ge id = Some b) (i : In id (prog_public p)) : kept id.","proofString":"eapply kept_public; eauto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) (b : block) (FS : Genv.find_symbol ge id = Some b) (i : In id (prog_public p)) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nfalse = true.","proofString":"intros (b' & TFS' & INJ).\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (TFS : Genv.find_symbol tge id = None) (b : block) (FS : Genv.find_symbol ge id = Some b) (i : In id (prog_public p)) (b' : block) (TFS' : Genv.find_symbol tge id = Some b') (INJ : j b = Some (b', 0)) : false = true.","proofString":"congruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (H1 : Senv.find_symbol ge id = Some b1) : delta = 0 /\\ Senv.find_symbol tge id = Some b2.","proofString":"eapply symbols_inject_1; eauto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (id : ident) (b1 : block) (H0 : Senv.public_symbol ge id = true) (H1 : Senv.find_symbol ge id = Some b1) : exists b2 : block, j b1 = Some (b2, 0) /\\ Senv.find_symbol tge id = Some b2.","proofString":"simpl in *; unfold Genv.public_symbol in H0.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nrewrite E1 in H0.\ndestruct (in_dec ident_eq id (prog_public p)); try discriminate.\ninv H1.\nexploit symbols_inject_2; eauto.\neapply kept_public; eauto.\nintros (b' & A & B); exists b'; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) : Senv.block_is_volatile tge b2 = Senv.block_is_volatile ge b1.","proofString":"simpl.\nunfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) : Genv.block_is_volatile tge b2 = Genv.block_is_volatile ge b1.","proofString":"unfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) : match Genv.find_var_info tge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch Genv.find_var_info ge b1 with\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"destruct (Genv.find_var_info ge b1) as [gv|] eqn:V1.\nrewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto.\ndestruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (gv : globvar unit) (V1 : Genv.find_var_info ge b1 = Some gv) : match Genv.find_var_info tge b2 with\n| Some gv0 => gvar_volatile gv0\n| None => false\nend = gvar_volatile gv.","proofString":"rewrite Genv.find_var_info_iff in V1.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (gv : globvar unit) (V1 : Genv.find_def ge b1 = Some (Gvar gv)) : match Genv.find_var_info tge b2 with\n| Some gv0 => gvar_volatile gv0\n| None => false\nend = gvar_volatile gv.","proofString":"exploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (gv : globvar unit) (V1 : Genv.find_def ge b1 = Some (Gvar gv)) : Genv.find_def tge b2 = Some (Gvar gv) /\\\ndelta = 0 /\\ (forall id : ident, ref_def (Gvar gv) id -> kept id) ->\nmatch Genv.find_var_info tge b2 with\n| Some gv0 => gvar_volatile gv0\n| None => false\nend = gvar_volatile gv.","proofString":"intros (A & B & C).\nrewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (gv : globvar unit) (V1 : Genv.find_def ge b1 = Some (Gvar gv)) (A : Genv.find_def tge b2 = Some (Gvar gv)) (B : delta = 0) (C : forall id : ident, ref_def (Gvar gv) id -> kept id) : match Genv.find_var_info tge b2 with\n| Some gv0 => gvar_volatile gv0\n| None => false\nend = gvar_volatile gv.","proofString":"rewrite <- Genv.find_var_info_iff in A.\nrewrite A; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (gv : globvar unit) (V1 : Genv.find_def ge b1 = Some (Gvar gv)) (A : Genv.find_var_info tge b2 = Some gv) (B : delta = 0) (C : forall id : ident, ref_def (Gvar gv) id -> kept id) : match Genv.find_var_info tge b2 with\n| Some gv0 => gvar_volatile gv0\n| None => false\nend = gvar_volatile gv.","proofString":"rewrite A; auto."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) : match Genv.find_var_info tge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = false.","proofString":"destruct (Genv.find_var_info tge b2) as [gv|] eqn:V2; auto.\nrewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv : globvar unit) (V2 : Genv.find_var_info tge b2 = Some gv) : gvar_volatile gv = false.","proofString":"rewrite Genv.find_var_info_iff in V2.\nexploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv : globvar unit) (V2 : Genv.find_def tge b2 = Some (Gvar gv)) : gvar_volatile gv = false.","proofString":"exploit defs_rev_inject; eauto.\nintros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv : globvar unit) (V2 : Genv.find_def tge b2 = Some (Gvar gv)) : Genv.find_def ge b1 = Some (Gvar gv) /\\ delta = 0 -> gvar_volatile gv = false.","proofString":"intros (A & B).\nrewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv : globvar unit) (V2 : Genv.find_def tge b2 = Some (Gvar gv)) (A : Genv.find_def ge b1 = Some (Gvar gv)) (B : delta = 0) : gvar_volatile gv = false.","proofString":"rewrite <- Genv.find_var_info_iff in A.\ncongruence."},{"statement":"(j : meminj) (H : meminj_preserves_globals j) (E1 : Genv.genv_public ge = prog_public p) (E2 : Genv.genv_public tge = prog_public p) (b1 b2 : block) (delta : Z) (H0 : j b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv : globvar unit) (V2 : Genv.find_def tge b2 = Some (Gvar gv)) (A : Genv.find_var_info ge b1 = Some gv) (B : delta = 0) : gvar_volatile gv = false.","proofString":"congruence."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) : Val.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & TFS & INJ).\nrewrite TFS.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) : Val.inject j\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & TFS & INJ).\nrewrite TFS.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) (b : block) (FS : Genv.find_symbol ge id = Some b) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"exploit symbols_inject_2; eauto.\nintros (b' & TFS & INJ).\nrewrite TFS.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) (b : block) (FS : Genv.find_symbol ge id = Some b) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nVal.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"intros (b' & TFS & INJ).\nrewrite TFS.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (TFS : Genv.find_symbol tge id = Some b') (INJ : j b = Some (b', 0)) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"rewrite TFS.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (TFS : Genv.find_symbol tge id = Some b') (INJ : j b = Some (b', 0)) : Val.inject j (Vptr b ofs) (Vptr b' ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(j : meminj) (id : ident) (ofs : ptrofs) (H : meminj_preserves_globals j) (H0 : kept id) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (TFS : Genv.find_symbol tge id = Some b') (INJ : j b = Some (b', 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(f : meminj) (rs rs' : regset) (H : regset_inject f rs rs') : Val.inject_list f nil nil.","proofString":"constructor."},{"statement":"(f : meminj) (rs rs' : regset) (H : regset_inject f rs rs') (a : positive) (l : list positive) (IHl : Val.inject_list f rs ## l rs' ## l) : Val.inject_list f (rs # a :: rs ## l) (rs' # a :: rs' ## l).","proofString":"constructor; auto."},{"statement":"(f : meminj) (rs rs' : regset) (r : positive) (v v' : val) (H : regset_inject f rs rs') (H0 : Val.inject f v v') (r0 : positive) : Val.inject f (rs # r <- v) # r0 (rs' # r <- v') # r0.","proofString":"rewrite ! Regmap.gsspec.\ndestruct (peq r0 r); auto."},{"statement":"(f : meminj) (rs rs' : regset) (r : positive) (v v' : val) (H : regset_inject f rs rs') (H0 : Val.inject f v v') (r0 : positive) : Val.inject f (if peq r0 r then v else rs # r0)\n  (if peq r0 r then v' else rs' # r0).","proofString":"destruct (peq r0 r); auto."},{"statement":"(f : meminj) (rs rs' : regset) (res : builtin_res reg) (v v' : val) (H : regset_inject f rs rs') (H0 : Val.inject f v v') : regset_inject f (regmap_setres res v rs) (regmap_setres res v' rs').","proofString":"destruct res; auto.\napply set_reg_inject; auto."},{"statement":"(f : meminj) (rs rs' : regset) (x : reg) (v v' : val) (H : regset_inject f rs rs') (H0 : Val.inject f v v') : regset_inject f (regmap_setres (BR x) v rs) (regmap_setres (BR x) v' rs').","proofString":"apply set_reg_inject; auto."},{"statement":"(f f' : meminj) (rs rs' : regset) (H : regset_inject f rs rs') (H0 : inject_incr f f') (r : positive) : Val.inject f' rs # r rs' # r.","proofString":"apply val_inject_incr with f; auto."},{"statement":"(f : meminj) (r : positive) : Val.inject f (Regmap.init Vundef) # r (Regmap.init Vundef) # r.","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(f : meminj) (r : positive) : Val.inject f Vundef Vundef.","proofString":"auto."},{"statement":"(f : meminj) (v v' : val) (vl vl' : list val) (H : Val.inject f v v') (H0 : Val.inject_list f vl vl') (IHinject_list : forall params0 : list reg,\nregset_inject f (init_regs vl params0) (init_regs vl' params0)) (r : reg) (params : list reg) : regset_inject f (init_regs vl params) # r <- v\n  (init_regs vl' params) # r <- v'.","proofString":"apply set_reg_inject; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : match_stacks j' nil nil bound tbound.","proofString":"assert (SAME: forall b b' delta, Plt b (Genv.genv_next ge) ->                                   j' b = Some(b', delta) -> j b = Some(b', delta)).\nintros.\ndestruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto.\nassert (SAME': forall b b' delta, Plt b' (Genv.genv_next tge) ->                                   j' b = Some(b', delta) -> j b = Some (b', delta)).\nintros.\ndestruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto.\nconstructor; auto.\nconstructor; intros.\nexploit symbols_inject_1; eauto.\napply SAME; auto.\neapply Genv.genv_symb_range; eauto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nexists b'; auto.\nexploit symbols_inject_3; eauto.\nintros (b & A & B).\nexists b; auto.\neapply defs_inject; eauto.\napply SAME; auto.\neapply Genv.genv_defs_range; eauto.\neapply defs_rev_inject; eauto.\napply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : forall (b : positive) (b' : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta).","proofString":"intros.\ndestruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) : j b = Some (b', delta).","proofString":"destruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b0 b2 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b2, delta0) -> Ple bound b0 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (b1 : block) (delta1 : Z) (J : j b = Some (b1, delta1)) : Some (b1, delta1) = Some (b', delta).","proofString":"exploit H; eauto.\ncongruence."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b0 b2 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b2, delta0) -> Ple bound b0 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (b1 : block) (delta1 : Z) (J : j b = Some (b1, delta1)) : j' b = Some (b1, delta1) -> Some (b1, delta1) = Some (b', delta).","proofString":"congruence."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (J : j b = None) : None = Some (b', delta).","proofString":"exploit H3; eauto.\nintros [A B].\nelim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (J : j b = None) : Ple bound b /\\ Ple tbound b' -> None = Some (b', delta).","proofString":"intros [A B].\nelim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (J : j b = None) (A : Ple bound b) (B : Ple tbound b') : None = Some (b', delta).","proofString":"elim (Plt_strict b).\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (b : positive) (b' : block) (delta : Z) (H4 : Plt b (Genv.genv_next ge)) (H5 : j' b = Some (b', delta)) (J : j b = None) (A : Ple bound b) (B : Ple tbound b') : Plt b b.","proofString":"eapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b' : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) : match_stacks j' nil nil bound tbound.","proofString":"assert (SAME': forall b b' delta, Plt b' (Genv.genv_next tge) ->                                   j' b = Some(b', delta) -> j b = Some (b', delta)).\nintros.\ndestruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto.\nconstructor; auto.\nconstructor; intros.\nexploit symbols_inject_1; eauto.\napply SAME; auto.\neapply Genv.genv_symb_range; eauto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nexists b'; auto.\nexploit symbols_inject_3; eauto.\nintros (b & A & B).\nexists b; auto.\neapply defs_inject; eauto.\napply SAME; auto.\neapply Genv.genv_defs_range; eauto.\neapply defs_rev_inject; eauto.\napply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b' : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) : forall (b : block) (b' : positive) (delta : Z),\nPlt b' (Genv.genv_next tge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta).","proofString":"intros.\ndestruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) : j b = Some (b', delta).","proofString":"destruct (j b) as [[b1 delta1] | ] eqn: J.\nexploit H; eauto.\ncongruence.\nexploit H3; eauto.\nintros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b0 b2 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b2, delta0) -> Ple bound b0 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (b1 : block) (delta1 : Z) (J : j b = Some (b1, delta1)) : Some (b1, delta1) = Some (b', delta).","proofString":"exploit H; eauto.\ncongruence."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b0 b2 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b2, delta0) -> Ple bound b0 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (b1 : block) (delta1 : Z) (J : j b = Some (b1, delta1)) : j' b = Some (b1, delta1) -> Some (b1, delta1) = Some (b', delta).","proofString":"congruence."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (J : j b = None) : None = Some (b', delta).","proofString":"exploit H3; eauto.\nintros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (J : j b = None) : Ple bound b /\\ Ple tbound b' -> None = Some (b', delta).","proofString":"intros [A B].\nelim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (J : j b = None) (A : Ple bound b) (B : Ple tbound b') : None = Some (b', delta).","proofString":"elim (Plt_strict b').\neapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b : block) (b' : positive) (delta : Z) (H4 : Plt b' (Genv.genv_next tge)) (H5 : j' b = Some (b', delta)) (J : j b = None) (A : Ple bound b) (B : Ple tbound b') : Plt b' b'.","proofString":"eapply Plt_Ple_trans.\neauto.\neapply Ple_trans; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b' : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) (SAME' : forall (b : block) (b' : positive) (delta : Z),\nPlt b' (Genv.genv_next tge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) : match_stacks j' nil nil bound tbound.","proofString":"constructor; auto.\nconstructor; intros.\nexploit symbols_inject_1; eauto.\napply SAME; auto.\neapply Genv.genv_symb_range; eauto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nexists b'; auto.\nexploit symbols_inject_3; eauto.\nintros (b & A & B).\nexists b; auto.\neapply defs_inject; eauto.\napply SAME; auto.\neapply Genv.genv_defs_range; eauto.\neapply defs_rev_inject; eauto.\napply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b' : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) (SAME' : forall (b : block) (b' : positive) (delta : Z),\nPlt b' (Genv.genv_next tge) ->\nj' b = Some (b', delta) -> j b = Some (b', delta)) : meminj_preserves_globals j'.","proofString":"constructor; intros.\nexploit symbols_inject_1; eauto.\napply SAME; auto.\neapply Genv.genv_symb_range; eauto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nexists b'; auto.\nexploit symbols_inject_3; eauto.\nintros (b & A & B).\nexists b; auto.\neapply defs_inject; eauto.\napply SAME; auto.\neapply Genv.genv_defs_range; eauto.\neapply defs_rev_inject; eauto.\napply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (id : ident) (b b' : block) (delta : Z) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_symbol ge id = Some b) : delta = 0 /\\ Genv.find_symbol tge id = Some b'.","proofString":"exploit symbols_inject_1; eauto.\napply SAME; auto.\neapply Genv.genv_symb_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (id : ident) (b b' : block) (delta : Z) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_symbol ge id = Some b) : j b = Some (b', delta).","proofString":"apply SAME; auto.\neapply Genv.genv_symb_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (id : ident) (b b' : block) (delta : Z) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_symbol ge id = Some b) : Plt b (Genv.genv_next ge).","proofString":"eapply Genv.genv_symb_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b' : block) (delta : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b', delta) -> j b0 = Some (b', delta)) (SAME' : forall (b0 : block) (b' : positive) (delta : Z),\nPlt b' (Genv.genv_next tge) ->\nj' b0 = Some (b', delta) -> j b0 = Some (b', delta)) (id : ident) (b : block) (H4 : kept id) (H5 : Genv.find_symbol ge id = Some b) : exists b' : block, Genv.find_symbol tge id = Some b' /\\ j' b = Some (b', 0).","proofString":"exploit symbols_inject_2; eauto.\nintros (b' & A & B).\nexists b'; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b' : block) (delta : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b', delta) -> j b0 = Some (b', delta)) (SAME' : forall (b0 : block) (b' : positive) (delta : Z),\nPlt b' (Genv.genv_next tge) ->\nj' b0 = Some (b', delta) -> j b0 = Some (b', delta)) (id : ident) (b : block) (H4 : kept id) (H5 : Genv.find_symbol ge id = Some b) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nexists b' : block, Genv.find_symbol tge id = Some b' /\\ j' b = Some (b', 0).","proofString":"intros (b' & A & B).\nexists b'; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta) -> j b0 = Some (b'0, delta)) (SAME' : forall (b0 : block) (b'0 : positive) (delta : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta) -> j b0 = Some (b'0, delta)) (id : ident) (b : block) (H4 : kept id) (H5 : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : exists b'0 : block,\n  Genv.find_symbol tge id = Some b'0 /\\ j' b = Some (b'0, 0).","proofString":"exists b'; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b'0 : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b'0, delta) -> j b = Some (b'0, delta)) (SAME' : forall (b : block) (b'0 : positive) (delta : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b = Some (b'0, delta) -> j b = Some (b'0, delta)) (id : ident) (b' : block) (H4 : Genv.find_symbol tge id = Some b') : exists b : block, Genv.find_symbol ge id = Some b /\\ j' b = Some (b', 0).","proofString":"exploit symbols_inject_3; eauto.\nintros (b & A & B).\nexists b; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b : positive) (b'0 : block) (delta : Z),\nPlt b (Genv.genv_next ge) ->\nj' b = Some (b'0, delta) -> j b = Some (b'0, delta)) (SAME' : forall (b : block) (b'0 : positive) (delta : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b = Some (b'0, delta) -> j b = Some (b'0, delta)) (id : ident) (b' : block) (H4 : Genv.find_symbol tge id = Some b') : (exists b : block, Genv.find_symbol ge id = Some b /\\ j b = Some (b', 0)) ->\nexists b : block, Genv.find_symbol ge id = Some b /\\ j' b = Some (b', 0).","proofString":"intros (b & A & B).\nexists b; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta) -> j b0 = Some (b'0, delta)) (SAME' : forall (b0 : block) (b'0 : positive) (delta : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta) -> j b0 = Some (b'0, delta)) (id : ident) (b' : block) (H4 : Genv.find_symbol tge id = Some b') (b : block) (A : Genv.find_symbol ge id = Some b) (B : j b = Some (b', 0)) : exists b0 : block, Genv.find_symbol ge id = Some b0 /\\ j' b0 = Some (b', 0).","proofString":"exists b; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def ge b = Some gd) : Genv.find_def tge b' = Some gd /\\\ndelta = 0 /\\ (forall id : ident, ref_def gd id -> kept id).","proofString":"eapply defs_inject; eauto.\napply SAME; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def ge b = Some gd) : j b = Some (b', delta).","proofString":"apply SAME; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def ge b = Some gd) : Plt b (Genv.genv_next ge).","proofString":"eapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def tge b' = Some gd) : Genv.find_def ge b = Some gd /\\ delta = 0.","proofString":"eapply defs_rev_inject; eauto.\napply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def tge b' = Some gd) : j b = Some (b', delta).","proofString":"apply SAME'; auto.\neapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (bound tbound : positive) (H0 : meminj_preserves_globals j) (H1 : Ple (Genv.genv_next ge) bound) (H2 : Ple (Genv.genv_next tge) tbound) (H3 : forall (b1 b2 : block) (delta0 : Z),\nj b1 = None -> j' b1 = Some (b2, delta0) -> Ple bound b1 /\\ Ple tbound b2) (SAME : forall (b0 : positive) (b'0 : block) (delta0 : Z),\nPlt b0 (Genv.genv_next ge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (SAME' : forall (b0 : block) (b'0 : positive) (delta0 : Z),\nPlt b'0 (Genv.genv_next tge) ->\nj' b0 = Some (b'0, delta0) -> j b0 = Some (b'0, delta0)) (b b' : block) (delta : Z) (gd : globdef fundef unit) (H4 : j' b = Some (b', delta)) (H5 : Genv.find_def tge b' = Some gd) : Plt b' (Genv.genv_next tge).","proofString":"eapply Genv.genv_defs_range; eauto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b1 b2 : block) (delta : Z),\n j b1 = None -> j' b1 = Some (b2, delta) -> Ple sp b1 /\\ Ple tsp b2) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : match_stacks j' (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: s)\n  (Stackframe res f (Vptr tsp Ptrofs.zero) pc trs :: ts) bound tbound.","proofString":"econstructor; eauto.\napply IHmatch_stacks.\nintros.\nexploit H1; eauto.\nintros [A B].\nsplit; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto.\napply regset_inject_incr with j; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b1 b2 : block) (delta : Z),\n j b1 = None -> j' b1 = Some (b2, delta) -> Ple sp b1 /\\ Ple tsp b2) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : match_stacks j' s ts sp tsp.","proofString":"apply IHmatch_stacks.\nintros.\nexploit H1; eauto.\nintros [A B].\nsplit; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b1 b2 : block) (delta : Z),\n j b1 = None -> j' b1 = Some (b2, delta) -> Ple sp b1 /\\ Ple tsp b2) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple sp b1 /\\ Ple tsp b2.","proofString":"intros.\nexploit H1; eauto.\nintros [A B].\nsplit; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b3 b4 : block) (delta0 : Z),\n j b3 = None -> j' b3 = Some (b4, delta0) -> Ple sp b3 /\\ Ple tsp b4) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b0 b3 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b3, delta0) -> Ple bound b0 /\\ Ple tbound b3) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) : Ple sp b1 /\\ Ple tsp b2.","proofString":"exploit H1; eauto.\nintros [A B].\nsplit; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b3 b4 : block) (delta0 : Z),\n j b3 = None -> j' b3 = Some (b4, delta0) -> Ple sp b3 /\\ Ple tsp b4) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b0 b3 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b3, delta0) -> Ple bound b0 /\\ Ple tbound b3) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) : Ple bound b1 /\\ Ple tbound b2 -> Ple sp b1 /\\ Ple tsp b2.","proofString":"intros [A B].\nsplit; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b3 b4 : block) (delta0 : Z),\n j b3 = None -> j' b3 = Some (b4, delta0) -> Ple sp b3 /\\ Ple tsp b4) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b0 b3 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b3, delta0) -> Ple bound b0 /\\ Ple tbound b3) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (A : Ple bound b1) (B : Ple tbound b2) : Ple sp b1 /\\ Ple tsp b2.","proofString":"split; eapply Ple_trans; eauto.\napply Plt_Ple; auto.\napply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b3 b4 : block) (delta0 : Z),\n j b3 = None -> j' b3 = Some (b4, delta0) -> Ple sp b3 /\\ Ple tsp b4) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b0 b3 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b3, delta0) -> Ple bound b0 /\\ Ple tbound b3) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (A : Ple bound b1) (B : Ple tbound b2) : Ple sp bound.","proofString":"apply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b3 b4 : block) (delta0 : Z),\n j b3 = None -> j' b3 = Some (b4, delta0) -> Ple sp b3 /\\ Ple tsp b4) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b0 b3 : block) (delta0 : Z),\nj b0 = None -> j' b0 = Some (b3, delta0) -> Ple bound b0 /\\ Ple tbound b3) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (A : Ple bound b1) (B : Ple tbound b2) : Ple tsp tbound.","proofString":"apply Plt_Ple; auto."},{"statement":"(j j' : meminj) (H : inject_incr j j') (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H0 : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : (forall (b1 b2 : block) (delta : Z),\n j b1 = None -> j' b1 = Some (b2, delta) -> Ple sp b1 /\\ Ple tsp b2) ->\nmatch_stacks j' s ts sp tsp) (H1 : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple bound b1 /\\ Ple tbound b2) : regset_inject j' rs trs.","proofString":"apply regset_inject_incr with j; auto."},{"statement":"(j : meminj) (bound' tbound' bound tbound : positive) (H : meminj_preserves_globals j) (H0 : Ple (Genv.genv_next ge) bound) (H1 : Ple (Genv.genv_next tge) tbound) (H2 : Ple bound bound') (H3 : Ple tbound tbound') : match_stacks j nil nil bound' tbound'.","proofString":"constructor; auto.\neapply Ple_trans; eauto.\neapply Ple_trans; eauto."},{"statement":"(j : meminj) (bound' tbound' bound tbound : positive) (H : meminj_preserves_globals j) (H0 : Ple (Genv.genv_next ge) bound) (H1 : Ple (Genv.genv_next tge) tbound) (H2 : Ple bound bound') (H3 : Ple tbound tbound') : Ple (Genv.genv_next ge) bound'.","proofString":"eapply Ple_trans; eauto."},{"statement":"(j : meminj) (bound' tbound' bound tbound : positive) (H : meminj_preserves_globals j) (H0 : Ple (Genv.genv_next ge) bound) (H1 : Ple (Genv.genv_next tge) tbound) (H2 : Ple bound bound') (H3 : Ple tbound tbound') : Ple (Genv.genv_next tge) tbound'.","proofString":"eapply Ple_trans; eauto."},{"statement":"(j : meminj) (bound' tbound' : positive) (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : Ple sp bound' -> Ple tsp tbound' -> match_stacks j s ts bound' tbound') (H0 : Ple bound bound') (H1 : Ple tbound tbound') : match_stacks j (Stackframe res f (Vptr sp Ptrofs.zero) pc rs :: s)\n  (Stackframe res f (Vptr tsp Ptrofs.zero) pc trs :: ts) bound' tbound'.","proofString":"econstructor; eauto.\neapply Plt_Ple_trans; eauto.\neapply Plt_Ple_trans; eauto."},{"statement":"(j : meminj) (bound' tbound' : positive) (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : Ple sp bound' -> Ple tsp tbound' -> match_stacks j s ts bound' tbound') (H0 : Ple bound bound') (H1 : Ple tbound tbound') : Plt sp bound'.","proofString":"eapply Plt_Ple_trans; eauto."},{"statement":"(j : meminj) (bound' tbound' : positive) (res : reg) (f : function) (sp : block) (pc : node) (rs : regset) (s : list stackframe) (tsp : block) (trs : regset) (ts : list stackframe) (bound tbound : positive) (H : match_stacks j s ts sp tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp bound) (TBELOW : Plt tsp tbound) (IHmatch_stacks : Ple sp bound' -> Ple tsp tbound' -> match_stacks j s ts bound' tbound') (H0 : Ple bound bound') (H1 : Ple tbound tbound') : Plt tsp tbound'.","proofString":"eapply Plt_Ple_trans; eauto."},{"statement":"(ef : external_function) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : meminj) (m1' : mem) (vargs' : list val) (H : meminj_preserves_globals f) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  external_call ef tge vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","proofString":"eapply external_call_mem_inject_gen; eauto.\napply globals_symbols_inject; auto."},{"statement":"(ef : external_function) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : meminj) (m1' : mem) (vargs' : list val) (H : meminj_preserves_globals f) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : symbols_inject f ge tge.","proofString":"apply globals_symbols_inject; auto."},{"statement":"(j : meminj) (ros : reg + ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (H0 : find_function ge ros rs = Some fd) (H1 : match ros with\n| inl _ => regset_inject j rs trs\n| inr id => kept id\nend) : find_function tge ros trs = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"destruct ros as [r|id]; simpl in *.\nexploit Genv.find_funct_inv; eauto.\nintros (b & R).\nrewrite R in H0.\nrewrite Genv.find_funct_find_funct_ptr in H0.\nspecialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nexploit symbols_inject_2; eauto.\nintros (tb & P & Q).\nrewrite P.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (H0 : Genv.find_funct ge rs # r = Some fd) (H1 : regset_inject j rs trs) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"exploit Genv.find_funct_inv; eauto.\nintros (b & R).\nrewrite R in H0.\nrewrite Genv.find_funct_find_funct_ptr in H0.\nspecialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (H0 : Genv.find_funct ge rs # r = Some fd) (H1 : regset_inject j rs trs) : (exists b : block, rs # r = Vptr b Ptrofs.zero) ->\nGenv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"intros (b & R).\nrewrite R in H0.\nrewrite Genv.find_funct_find_funct_ptr in H0.\nspecialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (H0 : Genv.find_funct ge rs # r = Some fd) (H1 : regset_inject j rs trs) (b : block) (R : rs # r = Vptr b Ptrofs.zero) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite R in H0.\nrewrite Genv.find_funct_find_funct_ptr in H0.\nspecialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H1 : regset_inject j rs trs) (R : rs # r = Vptr b Ptrofs.zero) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite Genv.find_funct_find_funct_ptr in H0.\nspecialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : regset_inject j rs trs) (R : rs # r = Vptr b Ptrofs.zero) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"specialize (H1 r).\nrewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : Val.inject j rs # r trs # r) (R : rs # r = Vptr b Ptrofs.zero) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite R in H1.\ninv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : Val.inject j (Vptr b Ptrofs.zero) trs # r) (R : rs # r = Vptr b Ptrofs.zero) : Genv.find_funct tge trs # r = Some fd /\\\n(forall id : ident, ref_fundef fd id -> kept id).","proofString":"inv H1.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_funct_ptr ge b = Some fd) (R : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : j b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = trs # r) : Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\nSome fd /\\ (forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_def ge b = Some (Gfun fd)) (R : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : j b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = trs # r) : Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\nSome fd /\\ (forall id : ident, ref_fundef fd id -> kept id).","proofString":"exploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_def ge b = Some (Gfun fd)) (R : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : j b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = trs # r) : Genv.find_def tge b2 = Some (Gfun fd) /\\\ndelta = 0 /\\ (forall id : ident, ref_def (Gfun fd) id -> kept id) ->\nGenv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\nSome fd /\\ (forall id : ident, ref_fundef fd id -> kept id).","proofString":"intros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_def ge b = Some (Gfun fd)) (R : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : j b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = trs # r) (A : Genv.find_def tge b2 = Some (Gfun fd)) (B : delta = 0) (C : forall id : ident, ref_def (Gfun fd) id -> kept id) : Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\nSome fd /\\ (forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite <- Genv.find_funct_ptr_iff in A.\nrewrite B; auto."},{"statement":"(j : meminj) (r : reg) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (H0 : Genv.find_def ge b = Some (Gfun fd)) (R : rs # r = Vptr b Ptrofs.zero) (b2 : block) (delta : Z) (H5 : j b = Some (b2, delta)) (H4 : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = trs # r) (A : Genv.find_funct_ptr tge b2 = Some fd) (B : delta = 0) (C : forall id : ident, ref_def (Gfun fd) id -> kept id) : Genv.find_funct tge (Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta))) =\nSome fd /\\ (forall id : ident, ref_fundef fd id -> kept id).","proofString":"rewrite B; auto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (H0 : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) (H1 : kept id) : match Genv.find_symbol tge id with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some fd /\\ (forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; try discriminate.\nexploit symbols_inject_2; eauto.\nintros (tb & P & Q).\nrewrite P.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : kept id) : match Genv.find_symbol tge id with\n| Some b0 => Genv.find_funct_ptr tge b0\n| None => None\nend = Some fd /\\ (forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"exploit symbols_inject_2; eauto.\nintros (tb & P & Q).\nrewrite P.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : kept id) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nmatch Genv.find_symbol tge id with\n| Some b0 => Genv.find_funct_ptr tge b0\n| None => None\nend = Some fd /\\ (forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"intros (tb & P & Q).\nrewrite P.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) : match Genv.find_symbol tge id with\n| Some b0 => Genv.find_funct_ptr tge b0\n| None => None\nend = Some fd /\\ (forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"rewrite P.\nrewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_funct_ptr ge b = Some fd) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) : Genv.find_funct_ptr tge tb = Some fd /\\\n(forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"rewrite Genv.find_funct_ptr_iff in H0.\nexploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_def ge b = Some (Gfun fd)) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) : Genv.find_funct_ptr tge tb = Some fd /\\\n(forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"exploit defs_inject; eauto.\nintros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_def ge b = Some (Gfun fd)) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) : Genv.find_def tge tb = Some (Gfun fd) /\\\n0 = 0 /\\ (forall id0 : ident, ref_def (Gfun fd) id0 -> kept id0) ->\nGenv.find_funct_ptr tge tb = Some fd /\\\n(forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"intros (A & B & C).\nrewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_def ge b = Some (Gfun fd)) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) (A : Genv.find_def tge tb = Some (Gfun fd)) (B : 0 = 0) (C : forall id0 : ident, ref_def (Gfun fd) id0 -> kept id0) : Genv.find_funct_ptr tge tb = Some fd /\\\n(forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"rewrite <- Genv.find_funct_ptr_iff in A.\nauto."},{"statement":"(j : meminj) (id : ident) (rs : regset) (fd : fundef) (trs : regset) (H : meminj_preserves_globals j) (b : block) (FS : Genv.find_symbol ge id = Some b) (H0 : Genv.find_def ge b = Some (Gfun fd)) (H1 : kept id) (tb : block) (P : Genv.find_symbol tge id = Some tb) (Q : j b = Some (tb, 0)) (A : Genv.find_funct_ptr tge tb = Some fd) (B : 0 = 0) (C : forall id0 : ident, ref_def (Gfun fd) id0 -> kept id0) : Genv.find_funct_ptr tge tb = Some fd /\\\n(forall id0 : ident, ref_fundef fd id0 -> kept id0).","proofString":"auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (x : positive) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA x) v' /\\ Val.inject j rs # x v'.","proofString":"exists rs'#x; split; auto.\nconstructor."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (x : positive) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' (BA x) rs' # x.","proofString":"constructor."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (n : int) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_int n) v' /\\ Val.inject j (Vint n) v'.","proofString":"econstructor; eauto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (n : int64) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_long n) v' /\\ Val.inject j (Vlong n) v'.","proofString":"econstructor; eauto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (n : Floats.float) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_float n) v' /\\ Val.inject j (Vfloat n) v'.","proofString":"econstructor; eauto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (n : Floats.float32) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_single n) v' /\\ \n  Val.inject j (Vsingle n) v'.","proofString":"econstructor; eauto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  Val.inject j v v'.","proofString":"simpl in H.\nexploit Mem.load_inject; eauto.\nrewrite Z.add_0_r.\nintros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  Val.inject j v v'.","proofString":"exploit Mem.load_inject; eauto.\nrewrite Z.add_0_r.\nintros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : (exists v2 : val,\n   Mem.load chunk m' sp' (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs) + 0) =\n   Some v2 /\\ Val.inject j v v2) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  Val.inject j v v'.","proofString":"rewrite Z.add_0_r.\nintros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : (exists v2 : val,\n   Mem.load chunk m' sp' (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) =\n   Some v2 /\\ Val.inject j v v2) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadstack chunk ofs) v' /\\\n  Val.inject j v v'.","proofString":"intros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.load chunk m sp (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) (v' : val) (A : Mem.load chunk m' sp' (Ptrofs.unsigned (Ptrofs.add Ptrofs.zero ofs)) =\nSome v') (B : Val.inject j v v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadstack chunk ofs) v'0 /\\\n  Val.inject j v v'0.","proofString":"exists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addrstack ofs) v' /\\\n  Val.inject j (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs) v'.","proofString":"econstructor; split; eauto with barg.\nsimpl.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : Val.inject j (Val.offset_ptr (Vptr sp Ptrofs.zero) ofs)\n  (Val.offset_ptr (Vptr sp' Ptrofs.zero) ofs).","proofString":"simpl.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : Val.inject j (Vptr sp (Ptrofs.add Ptrofs.zero ofs))\n  (Vptr sp' (Ptrofs.add Ptrofs.zero ofs)).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident, False -> kept id) : Ptrofs.add Ptrofs.zero ofs =\nPtrofs.add (Ptrofs.add Ptrofs.zero ofs) (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject j v v'.","proofString":"assert (Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)).\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto.\nexploit Mem.loadv_inject; eauto.\nintros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs).","proofString":"unfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : Val.inject j\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"exploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nVal.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"intros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"rewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : Val.inject j (Vptr b ofs) (Vptr b' ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (H0 : Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject j v v'.","proofString":"exploit Mem.loadv_inject; eauto.\nintros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (H0 : Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) : (exists v2 : val,\n   Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v2 /\\\n   Val.inject j v v2) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v' /\\\n  Val.inject j v v'.","proofString":"intros (v' & A & B).\nexists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge id ofs) = Some v) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (H0 : Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs)) (v' : val) (A : Mem.loadv chunk m' (Senv.symbol_address tge id ofs) = Some v') (B : Val.inject j v v') : exists v'0 : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_loadglobal chunk id ofs) v'0 /\\\n  Val.inject j v v'0.","proofString":"exists v'; auto with barg."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addrglobal id ofs) v' /\\\n  Val.inject j (Senv.symbol_address ge id ofs) v'.","proofString":"econstructor; split; eauto with barg.\nunfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : Val.inject j (Senv.symbol_address ge id ofs) (Senv.symbol_address tge id ofs).","proofString":"unfold Senv.symbol_address; simpl; unfold Genv.symbol_address.\ndestruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) : Val.inject j\n  match Genv.find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\n  match Genv.find_symbol tge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end.","proofString":"destruct (Genv.find_symbol ge id) as [b|] eqn:FS; auto.\nexploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"exploit symbols_inject_2; eauto.\nintros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) : (exists b' : block, Genv.find_symbol tge id = Some b' /\\ j b = Some (b', 0)) ->\nVal.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"intros (b' & A & B).\nrewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : Val.inject j (Vptr b ofs)\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 ofs\n  | None => Vundef\n  end.","proofString":"rewrite A.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : Val.inject j (Vptr b ofs) (Vptr b' ofs).","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (id : ident) (ofs : ptrofs) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id0 : ident, id = id0 \\/ False -> kept id0) (b : block) (FS : Genv.find_symbol ge id = Some b) (b' : block) (A : Genv.find_symbol tge id = Some b') (B : j b = Some (b', 0)) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg1 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg hi) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' hi v' /\\ Val.inject j vhi v') (IHeval_builtin_arg2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg lo) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' lo v' /\\ Val.inject j vlo v') (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg hi ++ globals_of_builtin_arg lo) -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  Val.inject j (Val.longofwords vhi vlo) v'.","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1 & B1); eauto using in_or_app.\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2); eauto using in_or_app.\nexists (Val.longofwords v1' v2'); split; auto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (IHeval_builtin_arg2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg lo) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' lo v' /\\ Val.inject j vlo v') (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg hi ++ globals_of_builtin_arg lo) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' hi v1') (B1 : Val.inject j vhi v1') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  Val.inject j (Val.longofwords vhi vlo) v'.","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2 & B2); eauto using in_or_app.\nexists (Val.longofwords v1' v2'); split; auto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg hi ++ globals_of_builtin_arg lo) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' hi v1') (B1 : Val.inject j vhi v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' lo v2') (B2 : Val.inject j vlo v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_splitlong hi lo) v' /\\\n  Val.inject j (Val.longofwords vhi vlo) v'.","proofString":"exists (Val.longofwords v1' v2'); split; auto with barg.\napply Val.longofwords_inject; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (hi lo : builtin_arg positive) (vhi vlo : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m hi\n  vhi) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m lo\n  vlo) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg hi ++ globals_of_builtin_arg lo) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' hi v1') (B1 : Val.inject j vhi v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' lo v2') (B2 : Val.inject j vlo v2') : Val.inject j (Val.longofwords vhi vlo) (Val.longofwords v1' v2').","proofString":"apply Val.longofwords_inject; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (IHeval_builtin_arg1 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg a1) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' a1 v' /\\ Val.inject j v1 v') (IHeval_builtin_arg2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg a2) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' a2 v' /\\ Val.inject j v2 v') (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2) -> kept id) : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  Val.inject j (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","proofString":"destruct IHeval_builtin_arg1 as (v1' & A1 & B1); eauto using in_or_app.\ndestruct IHeval_builtin_arg2 as (v2' & A2 & B2); eauto using in_or_app.\neconstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (IHeval_builtin_arg2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_arg a2) -> kept id) ->\nexists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' a2 v' /\\ Val.inject j v2 v') (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a1 v1') (B1 : Val.inject j v1 v1') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  Val.inject j (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","proofString":"destruct IHeval_builtin_arg2 as (v2' & A2 & B2); eauto using in_or_app.\neconstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a1 v1') (B1 : Val.inject j v1 v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a2 v2') (B2 : Val.inject j v2 v2') : exists v' : val,\n  eval_builtin_arg tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (BA_addptr a1 a2) v' /\\\n  Val.inject j (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v'.","proofString":"econstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 a2 : builtin_arg positive) (v1 v2 : val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  v1) (H0 : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a2\n  v2) (SP : j sp = Some (sp', 0)) (GL : meminj_preserves_globals j) (RS : regset_inject j rs rs') (MI : Mem.inject j m m') (K : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2) -> kept id) (v1' : val) (A1 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a1 v1') (B1 : Val.inject j v1 v1') (v2' : val) (A2 : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a2 v2') (B2 : Val.inject j v2 v2') : Val.inject j (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64 then Val.addl v1' v2' else Val.add v1' v2').","proofString":"destruct Archi.ptr64; auto using Val.add_inject, Val.addl_inject."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_args al) -> kept id) ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' al vl' /\\ Val.inject_list j bl vl') (H1 : j sp = Some (sp', 0)) (H2 : meminj_preserves_globals j) (H3 : regset_inject j rs rs') (H4 : Mem.inject j m m') (H5 : forall id : ident, In id (globals_of_builtin_args (a1 :: al)) -> kept id) : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (a1 :: al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","proofString":"simpl in H5.\nexploit eval_builtin_arg_inject; eauto using in_or_app.\nintros (v1' & A & B).\ndestruct IHlist_forall2 as (vl' & C & D); eauto using in_or_app.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_args al) -> kept id) ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' al vl' /\\ Val.inject_list j bl vl') (H1 : j sp = Some (sp', 0)) (H2 : meminj_preserves_globals j) (H3 : regset_inject j rs rs') (H4 : Mem.inject j m m') (H5 : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_args al) -> kept id) : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (a1 :: al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","proofString":"exploit eval_builtin_arg_inject; eauto using in_or_app.\nintros (v1' & A & B).\ndestruct IHlist_forall2 as (vl' & C & D); eauto using in_or_app.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_args al) -> kept id) ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' al vl' /\\ Val.inject_list j bl vl') (H1 : j sp = Some (sp', 0)) (H2 : meminj_preserves_globals j) (H3 : regset_inject j rs rs') (H4 : Mem.inject j m m') (H5 : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_args al) -> kept id) : (exists v' : val,\n   eval_builtin_arg tge (fun r : positive => rs' # r) \n     (Vptr sp' Ptrofs.zero) m' a1 v' /\\ Val.inject j b1 v') ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (a1 :: al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","proofString":"intros (v1' & A & B).\ndestruct IHlist_forall2 as (vl' & C & D); eauto using in_or_app.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (IHlist_forall2 : j sp = Some (sp', 0) ->\nmeminj_preserves_globals j ->\nregset_inject j rs rs' ->\nMem.inject j m m' ->\n(forall id : ident, In id (globals_of_builtin_args al) -> kept id) ->\nexists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' al vl' /\\ Val.inject_list j bl vl') (H1 : j sp = Some (sp', 0)) (H2 : meminj_preserves_globals j) (H3 : regset_inject j rs rs') (H4 : Mem.inject j m m') (H5 : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_args al) -> kept id) (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a1 v1') (B : Val.inject j b1 v1') : exists vl' : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (a1 :: al) vl' /\\\n  Val.inject_list j (b1 :: bl) vl'.","proofString":"destruct IHlist_forall2 as (vl' & C & D); eauto using in_or_app.\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(rs : Regmap.t val) (sp : block) (m : mem) (j : block -> option (block * Z)) (rs' : regset) (sp' : block) (m' : mem) (a1 : builtin_arg positive) (al : list (builtin_arg positive)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m a1\n  b1) (H0 : list_forall2\n  (eval_builtin_arg ge (fun r : positive => rs # r) (Vptr sp Ptrofs.zero) m)\n  al bl) (H1 : j sp = Some (sp', 0)) (H2 : meminj_preserves_globals j) (H3 : regset_inject j rs rs') (H4 : Mem.inject j m m') (H5 : forall id : ident,\nIn id (globals_of_builtin_arg a1 ++ globals_of_builtin_args al) -> kept id) (v1' : val) (A : eval_builtin_arg tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' a1 v1') (B : Val.inject j b1 v1') (vl' : list val) (C : eval_builtin_args tge (fun r : positive => rs' # r) \n  (Vptr sp' Ptrofs.zero) m' al vl') (D : Val.inject_list j bl vl') : exists vl'0 : list val,\n  eval_builtin_args tge (fun r : positive => rs' # r) \n    (Vptr sp' Ptrofs.zero) m' (a1 :: al) vl'0 /\\\n  Val.inject_list j (b1 :: bl) vl'0.","proofString":"exists (v1' :: vl'); split; constructor; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2'.","proofString":"econstructor; split.\neapply exec_Inop; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2'.","proofString":"assert (A: exists tv,               eval_operation tge (Vptr tsp Ptrofs.zero) op trs##args tm = Some tv            /\\ Val.inject j v tv).\napply eval_operation_inj with (ge1 := ge) (m1 := m) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iop op args res pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption.\ndestruct A as (tv & B & C).\neconstructor; split.\neapply exec_Iop; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists tv : val,\n  eval_operation tge (Vptr tsp Ptrofs.zero) op trs ## args tm = Some tv /\\\n  Val.inject j v tv.","proofString":"apply eval_operation_inj with (ge1 := ge) (m1 := m) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iop op args res pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nj b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nj b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nj b1 = Some (b2, delta) ->\nMem.weak_valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m b2 (Ptrofs.unsigned ofs2) = true ->\nj b1 = Some (b1', delta1) ->\nj b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_operation op) ->\nVal.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"intros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iop op args res pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H1 : In id (globals_operation op)) : Val.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"apply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iop op args res pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H1 : In id (globals_operation op)) : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H1 : In id (globals_operation op)) : kept id.","proofString":"apply KEPT.\nred.\nexists pc, (Iop op args res pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H1 : In id (globals_operation op)) : ref_function f id.","proofString":"red.\nexists pc, (Iop op args res pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H1 : In id (globals_operation op)) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"exists pc, (Iop op args res pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject j (Vptr sp0 Ptrofs.zero) (Vptr tsp Ptrofs.zero).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v.","proofString":"assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : exists tv : val,\n  eval_operation tge (Vptr tsp Ptrofs.zero) op trs ## args tm = Some tv /\\\n  Val.inject j v tv) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2'.","proofString":"destruct A as (tv & B & C).\neconstructor; split.\neapply exec_Iop; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tv : val) (B : eval_operation tge (Vptr tsp Ptrofs.zero) op trs ## args tm = Some tv) (C : Val.inject j v tv) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # res <- v m) S2'.","proofString":"econstructor; split.\neapply exec_Iop; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (sp0 : block) (H0 : eval_operation ge (Vptr sp0 Ptrofs.zero) op rs ## args m = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tv : val) (B : eval_operation tge (Vptr tsp Ptrofs.zero) op trs ## args tm = Some tv) (C : Val.inject j v tv) : regset_inject j rs # res <- v trs # res <- tv.","proofString":"apply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2'.","proofString":"assert (A: exists ta,               eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs##args = Some ta            /\\ Val.inject j a ta).\napply eval_addressing_inj with (ge1 := ge) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iload chunk addr args dst pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption.\ndestruct A as (ta & B & C).\nexploit Mem.loadv_inject; eauto.\nintros (tv & D & E).\neconstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists ta : val,\n  eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta /\\\n  Val.inject j a ta.","proofString":"apply eval_addressing_inj with (ge1 := ge) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iload chunk addr args dst pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"intros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iload chunk addr args dst pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : Val.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"apply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Iload chunk addr args dst pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : kept id.","proofString":"apply KEPT.\nred.\nexists pc, (Iload chunk addr args dst pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : ref_function f id.","proofString":"red.\nexists pc, (Iload chunk addr args dst pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"exists pc, (Iload chunk addr args dst pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject j (Vptr sp0 Ptrofs.zero) (Vptr tsp Ptrofs.zero).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a.","proofString":"assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : exists ta : val,\n  eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta /\\\n  Val.inject j a ta) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2'.","proofString":"destruct A as (ta & B & C).\nexploit Mem.loadv_inject; eauto.\nintros (tv & D & E).\neconstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2'.","proofString":"exploit Mem.loadv_inject; eauto.\nintros (tv & D & E).\neconstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) : (exists v2 : val, Mem.loadv chunk tm ta = Some v2 /\\ Val.inject j v v2) ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2'.","proofString":"intros (tv & D & E).\neconstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) (tv : val) (D : Mem.loadv chunk tm ta = Some tv) (E : Val.inject j v tv) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs # dst <- v m) S2'.","proofString":"econstructor; split.\neapply exec_Iload; eauto.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) (tv : val) (D : Mem.loadv chunk tm ta = Some tv) (E : Val.inject j v tv) : regset_inject j rs # dst <- v trs # dst <- tv.","proofString":"apply set_reg_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2'.","proofString":"assert (A: exists ta,               eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs##args = Some ta            /\\ Val.inject j a ta).\napply eval_addressing_inj with (ge1 := ge) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Istore chunk addr args src pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption.\ndestruct A as (ta & B & C).\nexploit Mem.storev_mapped_inject; eauto.\nintros (tm' & D & E).\neconstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists ta : val,\n  eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta /\\\n  Val.inject j a ta.","proofString":"apply eval_addressing_inj with (ge1 := ge) (sp1 := Vptr sp0 Ptrofs.zero) (vl1 := rs##args).\nintros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Istore chunk addr args src pc'); auto.\neconstructor; eauto.\napply regs_inject; auto.\nassumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall (id : ident) (ofs : ptrofs),\nIn id (globals_addressing addr) ->\nVal.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"intros.\napply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Istore chunk addr args src pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : Val.inject j (Genv.symbol_address ge id ofs) (Genv.symbol_address tge id ofs).","proofString":"apply symbol_address_inject.\neapply match_stacks_preserves_globals; eauto.\napply KEPT.\nred.\nexists pc, (Istore chunk addr args src pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : kept id.","proofString":"apply KEPT.\nred.\nexists pc, (Istore chunk addr args src pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : ref_function f id.","proofString":"red.\nexists pc, (Istore chunk addr args src pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (ofs : ptrofs) (H2 : In id (globals_addressing addr)) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"exists pc, (Istore chunk addr args src pc'); auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject j (Vptr sp0 Ptrofs.zero) (Vptr tsp Ptrofs.zero).","proofString":"econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a.","proofString":"assumption."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : exists ta : val,\n  eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta /\\\n  Val.inject j a ta) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2'.","proofString":"destruct A as (ta & B & C).\nexploit Mem.storev_mapped_inject; eauto.\nintros (tm' & D & E).\neconstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2'.","proofString":"exploit Mem.storev_mapped_inject; eauto.\nintros (tm' & D & E).\neconstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) : (exists n2 : mem,\n   Mem.storev chunk tm ta trs # src = Some n2 /\\ Mem.inject j m' n2) ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2'.","proofString":"intros (tm' & D & E).\neconstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (sp0 : block) (H0 : eval_addressing ge (Vptr sp0 Ptrofs.zero) addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (ta : val) (B : eval_addressing tge (Vptr tsp Ptrofs.zero) addr trs ## args = Some ta) (C : Val.inject j a ta) (tm' : mem) (D : Mem.storev chunk tm ta trs # src = Some tm') (E : Mem.inject j m' tm') : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m') S2'.","proofString":"econstructor; split.\neapply exec_Istore; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states\n    (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n       rs ## args m) S2'.","proofString":"exploit find_function_inject.\neapply match_stacks_preserves_globals; eauto.\neauto.\ndestruct ros as [r|id].\neauto.\napply KEPT.\nred.\neconstructor; econstructor; split; eauto.\nsimpl; auto.\nintros (A & B).\neconstructor; split.\neapply exec_Icall; eauto.\neconstructor; eauto.\neconstructor; eauto.\nchange (Mem.valid_block m sp0).\neapply Mem.valid_block_inject_1; eauto.\nchange (Mem.valid_block tm tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : kept id.","proofString":"apply KEPT.\nred.\neconstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : ref_function f id.","proofString":"red.\neconstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"econstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) (inr id) args res pc')) (H0 : find_function ge (inr id) rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : In id (ref_instruction (Icall (funsig fd) (inr id) args res pc')).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states\n    (Callstate (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s) fd\n       rs ## args m) S2'.","proofString":"econstructor; split.\neapply exec_Icall; eauto.\neconstructor; eauto.\neconstructor; eauto.\nchange (Mem.valid_block m sp0).\neapply Mem.valid_block_inject_1; eauto.\nchange (Mem.valid_block tm tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : match_stacks j (Stackframe res f (Vptr sp0 Ptrofs.zero) pc' rs :: s)\n  (Stackframe res f (Vptr tsp Ptrofs.zero) pc' trs :: ts) \n  (Mem.nextblock m) (Mem.nextblock tm).","proofString":"econstructor; eauto.\nchange (Mem.valid_block m sp0).\neapply Mem.valid_block_inject_1; eauto.\nchange (Mem.valid_block tm tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : Plt sp0 (Mem.nextblock m).","proofString":"change (Mem.valid_block m sp0).\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : Mem.valid_block m sp0.","proofString":"eapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : Plt tsp (Mem.nextblock tm).","proofString":"change (Mem.valid_block tm tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : Mem.valid_block tm tsp.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","proofString":"exploit find_function_inject.\neapply match_stacks_preserves_globals; eauto.\neauto.\ndestruct ros as [r|id].\neauto.\napply KEPT.\nred.\neconstructor; econstructor; split; eauto.\nsimpl; auto.\nintros (A & B).\nexploit Mem.free_parallel_inject; eauto.\nrewrite ! Z.add_0_r.\nintros (tm' & C & D).\neconstructor; split.\neapply exec_Itailcall; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H0 : find_function ge (inr id) rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : kept id.","proofString":"apply KEPT.\nred.\neconstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H0 : find_function ge (inr id) rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : ref_function f id.","proofString":"red.\neconstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H0 : find_function ge (inr id) rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"econstructor; econstructor; split; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (id : ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) (inr id) args)) (H0 : find_function ge (inr id) rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : In id (ref_instruction (Itailcall (funsig fd) (inr id) args)).","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","proofString":"exploit Mem.free_parallel_inject; eauto.\nrewrite ! Z.add_0_r.\nintros (tm' & C & D).\neconstructor; split.\neapply exec_Itailcall; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : (exists m2' : mem,\n   Mem.free tm tsp (0 + 0) (fn_stacksize f + 0) = Some m2' /\\\n   Mem.inject j m' m2') ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","proofString":"rewrite ! Z.add_0_r.\nintros (tm' & C & D).\neconstructor; split.\neapply exec_Itailcall; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) : (exists m2' : mem,\n   Mem.free tm tsp 0 (fn_stacksize f) = Some m2' /\\ Mem.inject j m' m2') ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","proofString":"intros (tm' & C & D).\neconstructor; split.\neapply exec_Itailcall; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","proofString":"econstructor; split.\neapply exec_Itailcall; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : match_stacks j s ts (Mem.nextblock m') (Mem.nextblock tm').","proofString":"apply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Ple stk (Mem.nextblock m').","proofString":"apply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Plt stk (Mem.nextblock m').","proofString":"change (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Mem.valid_block m' stk.","proofString":"eapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Ple tsp (Mem.nextblock tm').","proofString":"apply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Plt tsp (Mem.nextblock tm').","proofString":"change (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Mem.valid_block tm' tsp.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (A : find_function tge ros trs = Some fd) (B : forall id : ident, ref_fundef fd id -> kept id) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) t S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') S2'.","proofString":"exploit eval_builtin_args_inject; eauto.\neapply match_stacks_preserves_globals; eauto.\nintros.\napply KEPT.\nred.\neconstructor; econstructor; eauto.\nintros (vargs' & P & Q).\nexploit external_call_inject; eauto.\neapply match_stacks_preserves_globals; eauto.\nintros (j' & tv & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_states_regular with (j := j'); eauto.\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia.\napply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : forall id : ident, In id (globals_of_builtin_args args) -> kept id.","proofString":"intros.\napply KEPT.\nred.\neconstructor; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (H2 : In id (globals_of_builtin_args args)) : kept id.","proofString":"apply KEPT.\nred.\neconstructor; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (H2 : In id (globals_of_builtin_args args)) : ref_function f id.","proofString":"red.\neconstructor; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id0 : ident, ref_function f id0 -> kept id0) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (id : ident) (H2 : In id (globals_of_builtin_args args)) : exists (pc0 : positive) (i : instruction),\n  (fn_code f) ! pc0 = Some i /\\ In id (ref_instruction i).","proofString":"econstructor; econstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : (exists vl' : list val,\n   eval_builtin_args tge (fun r : positive => trs # r) \n     (Vptr tsp Ptrofs.zero) tm args vl' /\\ Val.inject_list j vargs vl') ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) t S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') S2'.","proofString":"intros (vargs' & P & Q).\nexploit external_call_inject; eauto.\neapply match_stacks_preserves_globals; eauto.\nintros (j' & tv & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_states_regular with (j := j'); eauto.\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia.\napply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) t S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') S2'.","proofString":"exploit external_call_inject; eauto.\neapply match_stacks_preserves_globals; eauto.\nintros (j' & tv & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_states_regular with (j := j'); eauto.\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia.\napply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef tge vargs' tm t vres' m2' /\\\n   Val.inject f' vres vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) t S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') S2'.","proofString":"intros (j' & tv & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_states_regular with (j := j'); eauto.\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia.\napply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) t S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) pc' (regmap_setres res vres rs) m') S2'.","proofString":"econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply match_states_regular with (j := j'); eauto.\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia.\napply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : match_stacks j' s ts sp0 tsp.","proofString":"apply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : forall (b1 b2 : block) (delta : Z),\nj b1 = None -> j' b1 = Some (b2, delta) -> Ple sp0 b1 /\\ Ple tsp b2.","proofString":"intros.\nexploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) : Ple sp0 b1 /\\ Ple tsp b2.","proofString":"exploit G; eauto.\nintros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) : ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2 -> Ple sp0 b1 /\\ Ple tsp b2.","proofString":"intros [U V].\nassert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (U : ~ Mem.valid_block m b1) (V : ~ Mem.valid_block tm b2) : Ple sp0 b1 /\\ Ple tsp b2.","proofString":"assert (Mem.valid_block m sp0) by (eapply Mem.valid_block_inject_1; eauto).\nassert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (U : ~ Mem.valid_block m b1) (V : ~ Mem.valid_block tm b2) (H4 : Mem.valid_block m sp0) : Ple sp0 b1 /\\ Ple tsp b2.","proofString":"assert (Mem.valid_block tm tsp) by (eapply Mem.valid_block_inject_2; eauto).\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H2 : j b1 = None) (H3 : j' b1 = Some (b2, delta)) (U : ~ Mem.valid_block m b1) (V : ~ Mem.valid_block tm b2) (H4 : Mem.valid_block m sp0) (H5 : Mem.valid_block tm tsp) : Ple sp0 b1 /\\ Ple tsp b2.","proofString":"unfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : regset_inject j' (regmap_setres res vres rs) (regmap_setres res tv trs).","proofString":"apply set_res_inject; auto.\napply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (sp0 : block) (H0 : eval_builtin_args ge (fun r : positive => rs # r) \n  (Vptr sp0 Ptrofs.zero) m args vargs) (H1 : external_call ef ge vargs m t vres m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (vargs' : list val) (P : eval_builtin_args tge (fun r : positive => trs # r) \n  (Vptr tsp Ptrofs.zero) tm args vargs') (Q : Val.inject_list j vargs vargs') (j' : meminj) (tv : val) (tm' : mem) (A : external_call ef tge vargs' tm t tv tm') (B : Val.inject j' vres tv) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : regset_inject j' rs trs.","proofString":"apply regset_inject_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2'.","proofString":"assert (C: eval_condition cond trs##args tm = Some b).\neapply eval_condition_inject; eauto.\napply regs_inject; auto.\neconstructor; split.\neapply exec_Icond with (pc' := if b then ifso else ifnot); eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : eval_condition cond trs ## args tm = Some b.","proofString":"eapply eval_condition_inject; eauto.\napply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : Val.inject_list j rs ## args trs ## args.","proofString":"apply regs_inject; auto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (C : eval_condition cond trs ## args tm = Some b) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr sp0 Ptrofs.zero) (if b then ifso else ifnot) rs m) S2'.","proofString":"econstructor; split.\neapply exec_Icond with (pc' := if b then ifso else ifnot); eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2'.","proofString":"generalize (REGINJ arg); rewrite H0; intros INJ; inv INJ.\neconstructor; split.\neapply exec_Ijumptable; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Int.unsigned n) = Some pc') (sp0 : block) (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (H4 : Vint n = trs # arg) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc' rs m) S2'.","proofString":"econstructor; split.\neapply exec_Ijumptable; eauto.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'.","proofString":"exploit Mem.free_parallel_inject; eauto.\nrewrite ! Z.add_0_r.\nintros (tm' & C & D).\neconstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : (exists m2' : mem,\n   Mem.free tm tsp (0 + 0) (fn_stacksize f + 0) = Some m2' /\\\n   Mem.inject j m' m2') ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'.","proofString":"rewrite ! Z.add_0_r.\nintros (tm' & C & D).\neconstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) : (exists m2' : mem,\n   Mem.free tm tsp 0 (fn_stacksize f) = Some m2' /\\ Mem.inject j m' m2') ->\nexists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'.","proofString":"intros (tm' & C & D).\neconstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : exists S2' : state,\n  step tge (State ts f (Vptr tsp Ptrofs.zero) pc trs tm) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'.","proofString":"econstructor; split.\neapply exec_Ireturn; eauto.\neconstructor; eauto.\napply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto.\ndestruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : match_stacks j s ts (Mem.nextblock m') (Mem.nextblock tm').","proofString":"apply match_stacks_bound with stk tsp; auto.\napply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto.\napply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Ple stk (Mem.nextblock m').","proofString":"apply Plt_Ple.\nchange (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Plt stk (Mem.nextblock m').","proofString":"change (Mem.valid_block m' stk).\neapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Mem.valid_block m' stk.","proofString":"eapply Mem.valid_block_inject_1; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Ple tsp (Mem.nextblock tm').","proofString":"apply Plt_Ple.\nchange (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Plt tsp (Mem.nextblock tm').","proofString":"change (Mem.valid_block tm' tsp).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Mem.valid_block tm' tsp.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (ts : list stackframe) (tsp : block) (trs : regset) (tm : mem) (j : meminj) (STACKS : match_stacks j s ts stk tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j stk = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (MEMINJ : Mem.inject j m tm) (tm' : mem) (C : Mem.free tm tsp 0 (fn_stacksize f) = Some tm') (D : Mem.inject j m' tm') : Val.inject j (regmap_optget or Vundef rs) (regmap_optget or Vundef trs).","proofString":"destruct or; simpl; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (Callstate ts (Internal f) targs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","proofString":"exploit Mem.alloc_parallel_inject.\neauto.\neauto.\napply Z.le_refl.\napply Z.le_refl.\nintros (j' & tm' & tstk & C & D & E & F & G).\nassert (STK: stk = Mem.nextblock m) by (eapply Mem.alloc_result; eauto).\nassert (TSTK: tstk = Mem.nextblock tm) by (eapply Mem.alloc_result; eauto).\nassert (STACKS': match_stacks j' s ts stk tstk).\nrewrite STK, TSTK.\napply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence.\neconstructor; split.\neapply exec_function_internal; eauto using Val.has_argtype_list_inject.\neapply match_states_regular with (j := j'); eauto.\napply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) : exists S2' : state,\n  step tge (Callstate ts (Internal f) targs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","proofString":"assert (STK: stk = Mem.nextblock m) by (eapply Mem.alloc_result; eauto).\nassert (TSTK: tstk = Mem.nextblock tm) by (eapply Mem.alloc_result; eauto).\nassert (STACKS': match_stacks j' s ts stk tstk).\nrewrite STK, TSTK.\napply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence.\neconstructor; split.\neapply exec_function_internal; eauto using Val.has_argtype_list_inject.\neapply match_states_regular with (j := j'); eauto.\napply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) : exists S2' : state,\n  step tge (Callstate ts (Internal f) targs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","proofString":"assert (TSTK: tstk = Mem.nextblock tm) by (eapply Mem.alloc_result; eauto).\nassert (STACKS': match_stacks j' s ts stk tstk).\nrewrite STK, TSTK.\napply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence.\neconstructor; split.\neapply exec_function_internal; eauto using Val.has_argtype_list_inject.\neapply match_states_regular with (j := j'); eauto.\napply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) : exists S2' : state,\n  step tge (Callstate ts (Internal f) targs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","proofString":"assert (STACKS': match_stacks j' s ts stk tstk).\nrewrite STK, TSTK.\napply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence.\neconstructor; split.\neapply exec_function_internal; eauto using Val.has_argtype_list_inject.\neapply match_states_regular with (j := j'); eauto.\napply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) : match_stacks j' s ts stk tstk.","proofString":"rewrite STK, TSTK.\napply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) : match_stacks j' s ts (Mem.nextblock m) (Mem.nextblock tm).","proofString":"apply match_stacks_incr with j; auto.\nintros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) : forall (b1 b2 : block) (delta : Z),\nj b1 = None ->\nj' b1 = Some (b2, delta) ->\nPle (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"intros.\ndestruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (b1 b2 : block) (delta : Z) (H1 : j b1 = None) (H2 : j' b1 = Some (b2, delta)) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"destruct (eq_block b1 stk).\nsubst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl.\nrewrite G in H2 by auto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (b1 b2 : block) (delta : Z) (H1 : j b1 = None) (H2 : j' b1 = Some (b2, delta)) (e : b1 = stk) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"subst b1.\nrewrite F in H2; inv H2.\nsplit; apply Ple_refl."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (b2 : block) (delta : Z) (H2 : j' stk = Some (b2, delta)) (H1 : j stk = None) : Ple (Mem.nextblock m) stk /\\ Ple (Mem.nextblock tm) b2.","proofString":"rewrite F in H2; inv H2.\nsplit; apply Ple_refl."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', Mem.nextblock m)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', Mem.nextblock tm)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (G : forall b : block, b <> Mem.nextblock m -> j' b = j b) (F : j' (Mem.nextblock m) = Some (Mem.nextblock tm, 0)) (H1 : j (Mem.nextblock m) = None) : Ple (Mem.nextblock m) (Mem.nextblock m) /\\\nPle (Mem.nextblock tm) (Mem.nextblock tm).","proofString":"split; apply Ple_refl."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (b1 b2 : block) (delta : Z) (H1 : j b1 = None) (H2 : j' b1 = Some (b2, delta)) (n : b1 <> stk) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"rewrite G in H2 by auto.\ncongruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (b1 b2 : block) (delta : Z) (H1 : j b1 = None) (H2 : j b1 = Some (b2, delta)) (n : b1 <> stk) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"congruence."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (STACKS' : match_stacks j' s ts stk tstk) : exists S2' : state,\n  step tge (Callstate ts (Internal f) targs tm) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","proofString":"econstructor; split.\neapply exec_function_internal; eauto using Val.has_argtype_list_inject.\neapply match_states_regular with (j := j'); eauto.\napply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (STACKS' : match_stacks j' s ts stk tstk) : regset_inject j' (init_regs args (fn_params f))\n  (init_regs targs (fn_params f)).","proofString":"apply init_regs_inject; auto.\napply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (Internal f) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tm' : Mem.mem') (tstk : block) (C : Mem.alloc tm 0 (fn_stacksize f) = (tm', tstk)) (D : Mem.inject j' m' tm') (E : inject_incr j j') (F : j' stk = Some (tstk, 0)) (G : forall b : block, b <> stk -> j' b = j b) (STK : stk = Mem.nextblock m) (TSTK : tstk = Mem.nextblock tm) (STACKS' : match_stacks j' s ts stk tstk) : Val.inject_list j' args targs.","proofString":"apply val_inject_list_incr with j; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (Callstate ts (External ef) targs tm) t S2' /\\\n  match_states (Returnstate s res m') S2'.","proofString":"exploit external_call_inject; eauto.\neapply match_stacks_preserves_globals; eauto.\nintros (j' & tres & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_function_external; eauto.\neapply match_states_return with (j := j'); eauto.\napply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) : meminj_preserves_globals j.","proofString":"eapply match_stacks_preserves_globals; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) : (exists (f' : meminj) (vres' : val) (m2' : mem),\n   external_call ef tge targs tm t vres' m2' /\\\n   Val.inject f' res vres' /\\\n   Mem.inject f' m' m2' /\\\n   Mem.unchanged_on (loc_unmapped j) m m' /\\\n   Mem.unchanged_on (loc_out_of_reach j m) tm m2' /\\\n   inject_incr j f' /\\ inject_separated j f' m tm) ->\nexists S2' : state,\n  step tge (Callstate ts (External ef) targs tm) t S2' /\\\n  match_states (Returnstate s res m') S2'.","proofString":"intros (j' & tres & tm' & A & B & C & D & E & F & G).\neconstructor; split.\neapply exec_function_external; eauto.\neapply match_states_return with (j := j'); eauto.\napply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : exists S2' : state,\n  step tge (Callstate ts (External ef) targs tm) t S2' /\\\n  match_states (Returnstate s res m') S2'.","proofString":"econstructor; split.\neapply exec_function_external; eauto.\neapply match_states_return with (j := j'); eauto.\napply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : match_stacks j' s ts (Mem.nextblock m') (Mem.nextblock tm').","proofString":"apply match_stacks_bound with (Mem.nextblock m) (Mem.nextblock tm).\napply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia.\neapply external_call_nextblock; eauto.\neapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : match_stacks j' s ts (Mem.nextblock m) (Mem.nextblock tm).","proofString":"apply match_stacks_incr with j; auto.\nintros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : forall (b1 b2 : block) (delta : Z),\nj b1 = None ->\nj' b1 = Some (b2, delta) ->\nPle (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"intros.\nexploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H0 : j b1 = None) (H1 : j' b1 = Some (b2, delta)) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"exploit G; eauto.\nintros [P Q].\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H0 : j b1 = None) (H1 : j' b1 = Some (b2, delta)) : ~ Mem.valid_block m b1 /\\ ~ Mem.valid_block tm b2 ->\nPle (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"intros [P Q].\nunfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) (b1 b2 : block) (delta : Z) (H0 : j b1 = None) (H1 : j' b1 = Some (b2, delta)) (P : ~ Mem.valid_block m b1) (Q : ~ Mem.valid_block tm b2) : Ple (Mem.nextblock m) b1 /\\ Ple (Mem.nextblock tm) b2.","proofString":"unfold Mem.valid_block in *; extlia."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : Ple (Mem.nextblock m) (Mem.nextblock m').","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (ts : list stackframe) (targs : list val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j s ts (Mem.nextblock m) (Mem.nextblock tm)) (KEPT : forall id : ident, ref_fundef (External ef) id -> kept id) (ARGINJ : Val.inject_list j args targs) (MEMINJ : Mem.inject j m tm) (j' : meminj) (tres : val) (tm' : mem) (A : external_call ef tge targs tm t tres tm') (B : Val.inject j' res tres) (C : Mem.inject j' m' tm') (D : Mem.unchanged_on (loc_unmapped j) m m') (E : Mem.unchanged_on (loc_out_of_reach j m) tm tm') (F : inject_incr j j') (G : inject_separated j j' m tm) : Ple (Mem.nextblock tm) (Mem.nextblock tm').","proofString":"eapply external_call_nextblock; eauto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (ts : list stackframe) (tres : val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j (Stackframe res f sp pc rs :: s) ts \n  (Mem.nextblock m) (Mem.nextblock tm)) (RESINJ : Val.inject j vres tres) (MEMINJ : Mem.inject j m tm) : exists S2' : state,\n  step tge (Returnstate ts tres tm) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'.","proofString":"inv STACKS.\neconstructor; split.\neapply exec_return.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (tres : val) (tm : Mem.mem') (j : meminj) (RESINJ : Val.inject j vres tres) (MEMINJ : Mem.inject j m tm) (sp0 tsp : block) (trs : regset) (ts0 : list stackframe) (STACKS0 : match_stacks j s ts0 sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp0 (Mem.nextblock m)) (TBELOW : Plt tsp (Mem.nextblock tm)) : exists S2' : state,\n  step tge\n    (Returnstate (Stackframe res f (Vptr tsp Ptrofs.zero) pc trs :: ts0) tres\n       tm) E0 S2' /\\\n  match_states (State s f (Vptr sp0 Ptrofs.zero) pc rs # res <- vres m) S2'.","proofString":"econstructor; split.\neapply exec_return.\neconstructor; eauto.\napply set_reg_inject; auto."},{"statement":"(res : reg) (f : function) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (tres : val) (tm : Mem.mem') (j : meminj) (RESINJ : Val.inject j vres tres) (MEMINJ : Mem.inject j m tm) (sp0 tsp : block) (trs : regset) (ts0 : list stackframe) (STACKS0 : match_stacks j s ts0 sp0 tsp) (KEPT : forall id : ident, ref_function f id -> kept id) (SPINJ : j sp0 = Some (tsp, 0)) (REGINJ : regset_inject j rs trs) (BELOW : Plt sp0 (Mem.nextblock m)) (TBELOW : Plt tsp (Mem.nextblock tm)) : regset_inject j rs # res <- vres trs # res <- tres.","proofString":"apply set_reg_inject; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) : delta = 0 /\\\n(exists (id : ident) (gd : globdef fundef unit),\n   Genv.find_symbol ge id = Some b /\\\n   Genv.find_symbol tge id = Some b' /\\\n   Genv.find_def ge b = Some gd /\\\n   Genv.find_def tge b' = Some gd /\\\n   (forall i : ident, ref_def gd i -> kept i)).","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\nassert (exists gd, (prog_defmap p)!id = Some gd).\napply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto.\ndestruct H0 as [gd DM].\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\ndelta = 0 /\\\n(exists (id : ident) (gd : globdef fundef unit),\n   Genv.find_symbol ge id = Some b /\\\n   Genv.find_symbol tge id = Some b' /\\\n   Genv.find_def ge b = Some gd /\\\n   Genv.find_def tge b' = Some gd /\\\n   (forall i : ident, ref_def gd i -> kept i)).","proofString":"intros (A & id & B & C).\nassert (exists gd, (prog_defmap p)!id = Some gd).\napply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto.\ndestruct H0 as [gd DM].\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : delta = 0 /\\\n(exists (id0 : ident) (gd : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd /\\\n   Genv.find_def tge b' = Some gd /\\\n   (forall i : ident, ref_def gd i -> kept i)).","proofString":"assert (exists gd, (prog_defmap p)!id = Some gd).\napply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto.\ndestruct H0 as [gd DM].\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : exists gd : globdef fundef unit, (prog_defmap p) ! id = Some gd.","proofString":"apply prog_defmap_dom.\neapply Genv.find_symbol_inversion; eauto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : In id (prog_defs_names p).","proofString":"eapply Genv.find_symbol_inversion; eauto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (H0 : exists gd : globdef fundef unit, (prog_defmap p) ! id = Some gd) : delta = 0 /\\\n(exists (id0 : ident) (gd : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd /\\\n   Genv.find_def tge b' = Some gd /\\\n   (forall i : ident, ref_def gd i -> kept i)).","proofString":"destruct H0 as [gd DM].\nrewrite Genv.find_def_symbol in DM.\ndestruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (DM : (prog_defmap p) ! id = Some gd) : delta = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"rewrite Genv.find_def_symbol in DM.\ndestruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (DM : exists b0 : block,\n  Genv.find_symbol (Genv.globalenv p) id = Some b0 /\\\n  Genv.find_def (Genv.globalenv p) b0 = Some gd) : delta = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"destruct DM as (b'' & P & Q).\nfold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (b'' : block) (P : Genv.find_symbol (Genv.globalenv p) id = Some b'') (Q : Genv.find_def (Genv.globalenv p) b'' = Some gd) : delta = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"fold ge in P.\nrewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (b'' : block) (P : Genv.find_symbol ge id = Some b'') (Q : Genv.find_def (Genv.globalenv p) b'' = Some gd) : delta = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"rewrite P in B; inv B.\nfold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (H : init_meminj b = Some (b', 0)) (id : ident) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (Q : Genv.find_def (Genv.globalenv p) b = Some gd) (P : Genv.find_symbol ge id = Some b) : 0 = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"fold ge in Q.\nexploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (H : init_meminj b = Some (b', 0)) (id : ident) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (Q : Genv.find_def ge b = Some gd) (P : Genv.find_symbol ge id = Some b) : 0 = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"exploit defs_inject.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (X & _ & Y).\nsplit.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (H : init_meminj b = Some (b', 0)) (id : ident) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (Q : Genv.find_def ge b = Some gd) (P : Genv.find_symbol ge id = Some b) (X : Genv.find_def tge b' = Some gd) (Y : forall id0 : ident, ref_def gd id0 -> kept id0) : 0 = 0 /\\\n(exists (id0 : ident) (gd0 : globdef fundef unit),\n   Genv.find_symbol ge id0 = Some b /\\\n   Genv.find_symbol tge id0 = Some b' /\\\n   Genv.find_def ge b = Some gd0 /\\\n   Genv.find_def tge b' = Some gd0 /\\\n   (forall i : ident, ref_def gd0 i -> kept i)).","proofString":"split.\nauto.\nexists id, gd; auto."},{"statement":"(b b' : block) (H : init_meminj b = Some (b', 0)) (id : ident) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (Q : Genv.find_def ge b = Some gd) (P : Genv.find_symbol ge id = Some b) (X : Genv.find_def tge b' = Some gd) (Y : forall id0 : ident, ref_def gd id0 -> kept id0) : 0 = 0.","proofString":"auto."},{"statement":"(b b' : block) (H : init_meminj b = Some (b', 0)) (id : ident) (C : Genv.find_symbol tge id = Some b') (gd : globdef fundef unit) (Q : Genv.find_def ge b = Some gd) (P : Genv.find_symbol ge id = Some b) (X : Genv.find_def tge b' = Some gd) (Y : forall id0 : ident, ref_def gd id0 -> kept id0) : exists (id0 : ident) (gd0 : globdef fundef unit),\n  Genv.find_symbol ge id0 = Some b /\\\n  Genv.find_symbol tge id0 = Some b' /\\\n  Genv.find_def ge b = Some gd0 /\\\n  Genv.find_def tge b' = Some gd0 /\\\n  (forall i : ident, ref_def gd0 i -> kept i).","proofString":"exists id, gd; auto."},{"statement":"(H : forall id : ident, ref_init nil id -> kept id) : list_forall2 (memval_inject init_meminj) nil nil.","proofString":"constructor."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (i1 :: il) id -> kept id) : list_forall2 (memval_inject init_meminj)\n  (Genv.bytes_of_init_data ge i1 ++ Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data tge i1 ++ Genv.bytes_of_init_data_list tge il).","proofString":"apply list_forall2_app.\ndestruct i1; simpl; try (apply inj_bytes_inject).\ninduction (Z.to_nat z); simpl; constructor.\nconstructor.\nauto.\ndestruct (Genv.find_symbol ge i) as [b|] eqn:FS.\nassert (kept i).\napply H.\nred.\nexists i0; auto with coqlib.\nexploit symbols_inject_2.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (b' & A & B).\nrewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero.\ndestruct (Genv.find_symbol tge i) as [b'|] eqn:FS'.\nexploit symbols_inject_3.\napply init_meminj_preserves_globals.\neauto.\nintros (b & A & B).\ncongruence.\napply repeat_Undef_inject_self.\napply IHil.\nintros id [ofs IN].\napply H.\nexists ofs; auto with coqlib."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (i1 :: il) id -> kept id) : list_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data ge i1)\n  (Genv.bytes_of_init_data tge i1).","proofString":"destruct i1; simpl; try (apply inj_bytes_inject).\ninduction (Z.to_nat z); simpl; constructor.\nconstructor.\nauto.\ndestruct (Genv.find_symbol ge i) as [b|] eqn:FS.\nassert (kept i).\napply H.\nred.\nexists i0; auto with coqlib.\nexploit symbols_inject_2.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (b' & A & B).\nrewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero.\ndestruct (Genv.find_symbol tge i) as [b'|] eqn:FS'.\nexploit symbols_inject_3.\napply init_meminj_preserves_globals.\neauto.\nintros (b & A & B).\ncongruence.\napply repeat_Undef_inject_self."},{"statement":"(z : Z) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_space z :: il) id -> kept id) : list_forall2 (memval_inject init_meminj)\n  (repeat (Byte Byte.zero) (Z.to_nat z))\n  (repeat (Byte Byte.zero) (Z.to_nat z)).","proofString":"induction (Z.to_nat z); simpl; constructor.\nconstructor.\nauto."},{"statement":"(z : Z) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_space z :: il) id -> kept id) (n : nat) (IHn : list_forall2 (memval_inject init_meminj) (repeat (Byte Byte.zero) n)\n  (repeat (Byte Byte.zero) n)) : memval_inject init_meminj (Byte Byte.zero) (Byte Byte.zero).","proofString":"constructor."},{"statement":"(z : Z) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_space z :: il) id -> kept id) (n : nat) (IHn : list_forall2 (memval_inject init_meminj) (repeat (Byte Byte.zero) n)\n  (repeat (Byte Byte.zero) n)) : list_forall2 (memval_inject init_meminj) (repeat (Byte Byte.zero) n)\n  (repeat (Byte Byte.zero) n).","proofString":"auto."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) : list_forall2 (memval_inject init_meminj)\n  match Genv.find_symbol ge i with\n  | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end\n  match Genv.find_symbol tge i with\n  | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"destruct (Genv.find_symbol ge i) as [b|] eqn:FS.\nassert (kept i).\napply H.\nred.\nexists i0; auto with coqlib.\nexploit symbols_inject_2.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (b' & A & B).\nrewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero.\ndestruct (Genv.find_symbol tge i) as [b'|] eqn:FS'.\nexploit symbols_inject_3.\napply init_meminj_preserves_globals.\neauto.\nintros (b & A & B).\ncongruence.\napply repeat_Undef_inject_self."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) : list_forall2 (memval_inject init_meminj)\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0))\n  match Genv.find_symbol tge i with\n  | Some b0 => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b0 i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"assert (kept i).\napply H.\nred.\nexists i0; auto with coqlib.\nexploit symbols_inject_2.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (b' & A & B).\nrewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) : kept i.","proofString":"apply H.\nred.\nexists i0; auto with coqlib."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) : ref_init (Init_addrof i i0 :: il) i.","proofString":"red.\nexists i0; auto with coqlib."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) : exists ofs : ptrofs, In (Init_addrof i ofs) (Init_addrof i i0 :: il).","proofString":"exists i0; auto with coqlib."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) (H0 : kept i) : list_forall2 (memval_inject init_meminj)\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0))\n  match Genv.find_symbol tge i with\n  | Some b0 => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b0 i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"exploit symbols_inject_2.\napply init_meminj_preserves_globals.\neauto.\neauto.\nintros (b' & A & B).\nrewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) (H0 : kept i) (b' : block) (A : Genv.find_symbol tge i = Some b') (B : init_meminj b = Some (b', 0)) : list_forall2 (memval_inject init_meminj)\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0))\n  match Genv.find_symbol tge i with\n  | Some b0 => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b0 i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"rewrite A.\napply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) (H0 : kept i) (b' : block) (A : Genv.find_symbol tge i = Some b') (B : init_meminj b = Some (b', 0)) : list_forall2 (memval_inject init_meminj)\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0))\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"apply inj_value_inject.\neconstructor; eauto.\nsymmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) (H0 : kept i) (b' : block) (A : Genv.find_symbol tge i = Some b') (B : init_meminj b = Some (b', 0)) : Val.inject init_meminj (Vptr b i0) (Vptr b' i0).","proofString":"econstructor; eauto.\nsymmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (b : block) (FS : Genv.find_symbol ge i = Some b) (H0 : kept i) (b' : block) (A : Genv.find_symbol tge i = Some b') (B : init_meminj b = Some (b', 0)) : i0 = Ptrofs.add i0 (Ptrofs.repr 0).","proofString":"symmetry; apply Ptrofs.add_zero."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (FS : Genv.find_symbol ge i = None) : list_forall2 (memval_inject init_meminj)\n  (repeat Undef (if Archi.ptr64 then 8%nat else 4%nat))\n  match Genv.find_symbol tge i with\n  | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"destruct (Genv.find_symbol tge i) as [b'|] eqn:FS'.\nexploit symbols_inject_3.\napply init_meminj_preserves_globals.\neauto.\nintros (b & A & B).\ncongruence.\napply repeat_Undef_inject_self."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (FS : Genv.find_symbol ge i = None) (b' : block) (FS' : Genv.find_symbol tge i = Some b') : list_forall2 (memval_inject init_meminj)\n  (repeat Undef (if Archi.ptr64 then 8%nat else 4%nat))\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"exploit symbols_inject_3.\napply init_meminj_preserves_globals.\neauto.\nintros (b & A & B).\ncongruence."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (FS : Genv.find_symbol ge i = None) (b' : block) (FS' : Genv.find_symbol tge i = Some b') (b : block) (A : Genv.find_symbol ge i = Some b) (B : init_meminj b = Some (b', 0)) : list_forall2 (memval_inject init_meminj)\n  (repeat Undef (if Archi.ptr64 then 8%nat else 4%nat))\n  (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"congruence."},{"statement":"(i : ident) (i0 : ptrofs) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (Init_addrof i i0 :: il) id -> kept id) (FS : Genv.find_symbol ge i = None) (FS' : Genv.find_symbol tge i = None) : list_forall2 (memval_inject init_meminj)\n  (repeat Undef (if Archi.ptr64 then 8%nat else 4%nat))\n  (repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)).","proofString":"apply repeat_Undef_inject_self."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (i1 :: il) id -> kept id) : list_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il).","proofString":"apply IHil.\nintros id [ofs IN].\napply H.\nexists ofs; auto with coqlib."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id : ident, ref_init il id -> kept id) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id : ident, ref_init (i1 :: il) id -> kept id) : forall id : ident, ref_init il id -> kept id.","proofString":"intros id [ofs IN].\napply H.\nexists ofs; auto with coqlib."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id0 : ident, ref_init il id0 -> kept id0) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id0 : ident, ref_init (i1 :: il) id0 -> kept id0) (id : ident) (ofs : ptrofs) (IN : In (Init_addrof id ofs) il) : kept id.","proofString":"apply H.\nexists ofs; auto with coqlib."},{"statement":"(i1 : init_data) (il : list init_data) (IHil : (forall id0 : ident, ref_init il id0 -> kept id0) ->\nlist_forall2 (memval_inject init_meminj) (Genv.bytes_of_init_data_list ge il)\n  (Genv.bytes_of_init_data_list tge il)) (H : forall id0 : ident, ref_init (i1 :: il) id0 -> kept id0) (id : ident) (ofs : ptrofs) (IN : In (Init_addrof id ofs) il) : ref_init (i1 :: il) id.","proofString":"exists ofs; auto with coqlib."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i p0 : Z) (H : list_forall2 P nil nil) (H0 : p0 <= i) (H1 : i < p0 + Z.of_nat 0) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"simpl in H1.\nextlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i p0 : Z) (H : list_forall2 P nil nil) (H0 : p0 <= i) (H1 : i < p0 + 0) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"extlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H : list_forall2 P (ZMap.get p0 c1 :: Mem.getN n (p0 + 1) c1)\n  (ZMap.get p0 c2 :: Mem.getN n (p0 + 1) c2)) (H0 : p0 <= i) (H1 : i < p0 + Z.of_nat (S n)) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"inv H.\nrewrite Nat2Z.inj_succ in H1.\ndestruct (zeq i p0).\ncongruence.\napply IHn with (p0 + 1); auto.\nlia.\nlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.of_nat (S n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"rewrite Nat2Z.inj_succ in H1.\ndestruct (zeq i p0).\ncongruence.\napply IHn with (p0 + 1); auto.\nlia.\nlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.succ (Z.of_nat n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"destruct (zeq i p0).\ncongruence.\napply IHn with (p0 + 1); auto.\nlia.\nlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.succ (Z.of_nat n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) (e : i = p0) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"congruence."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.succ (Z.of_nat n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) (n0 : i <> p0) : P (ZMap.get i c1) (ZMap.get i c2).","proofString":"apply IHn with (p0 + 1); auto.\nlia.\nlia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.succ (Z.of_nat n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) (n0 : i <> p0) : p0 + 1 <= i.","proofString":"lia."},{"statement":"(P : memval -> memval -> Prop) (c1 c2 : ZMap.t memval) (i : Z) (n : nat) (IHn : forall p1 : Z,\nlist_forall2 P (Mem.getN n p1 c1) (Mem.getN n p1 c2) ->\np1 <= i -> i < p1 + Z.of_nat n -> P (ZMap.get i c1) (ZMap.get i c2)) (p0 : Z) (H0 : p0 <= i) (H1 : i < p0 + Z.succ (Z.of_nat n)) (H5 : P (ZMap.get p0 c1) (ZMap.get p0 c2)) (H7 : list_forall2 P (Mem.getN n (p0 + 1) c1) (Mem.getN n (p0 + 1) c2)) (n0 : i <> p0) : i < p0 + 1 + Z.of_nat n.","proofString":"lia."},{"statement":"Mem.mem_inj init_meminj m tm.","proofString":"apply init_mem_inj_1."},{"statement":"(b : block) (H : ~ Mem.valid_block m b) : init_meminj b = None.","proofString":"destruct (init_meminj b) as [[b' delta]|] eqn:INJ; auto.\nelim H.\nexploit init_meminj_invert; eauto.\nintros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (H : ~ Mem.valid_block m b) (b' : block) (delta : Z) (INJ : init_meminj b = Some (b', delta)) : Some (b', delta) = None.","proofString":"elim H.\nexploit init_meminj_invert; eauto.\nintros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (H : ~ Mem.valid_block m b) (b' : block) (delta : Z) (INJ : init_meminj b = Some (b', delta)) : Mem.valid_block m b.","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (H : ~ Mem.valid_block m b) (b' : block) (delta : Z) (INJ : init_meminj b = Some (b', delta)) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\nMem.valid_block m b.","proofString":"intros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b : block) (H : ~ Mem.valid_block m b) (b' : block) (delta : Z) (INJ : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : Mem.valid_block m b.","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) : Mem.valid_block tm b'.","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\nMem.valid_block tm b'.","proofString":"intros (A & id & B & C).\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(b b' : block) (delta : Z) (H : init_meminj b = Some (b', delta)) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : Mem.valid_block tm b'.","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"Mem.meminj_no_overlap init_meminj m.","proofString":"red; intros.\nexploit init_meminj_invert.\neexact H0.\nintros (A1 & id1 & B1 & C1).\nexploit init_meminj_invert.\neexact H1.\nintros (A2 & id2 & B2 & C2).\ndestruct (ident_eq id1 id2).\ncongruence.\nleft; eapply Genv.global_addresses_distinct; eauto."},{"statement":"(b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : init_meminj b1 = Some (b1', delta1)) (H1 : init_meminj b2 = Some (b2', delta2)) (H2 : Mem.perm m b1 ofs1 Max Nonempty) (H3 : Mem.perm m b2 ofs2 Max Nonempty) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"exploit init_meminj_invert.\neexact H0.\nintros (A1 & id1 & B1 & C1).\nexploit init_meminj_invert.\neexact H1.\nintros (A2 & id2 & B2 & C2).\ndestruct (ident_eq id1 id2).\ncongruence.\nleft; eapply Genv.global_addresses_distinct; eauto."},{"statement":"(b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : init_meminj b1 = Some (b1', delta1)) (H1 : init_meminj b2 = Some (b2', delta2)) (H2 : Mem.perm m b1 ofs1 Max Nonempty) (H3 : Mem.perm m b2 ofs2 Max Nonempty) (A1 : delta1 = 0) (id1 : ident) (B1 : Genv.find_symbol ge id1 = Some b1) (C1 : Genv.find_symbol tge id1 = Some b1') : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"exploit init_meminj_invert.\neexact H1.\nintros (A2 & id2 & B2 & C2).\ndestruct (ident_eq id1 id2).\ncongruence.\nleft; eapply Genv.global_addresses_distinct; eauto."},{"statement":"(b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : init_meminj b1 = Some (b1', delta1)) (H1 : init_meminj b2 = Some (b2', delta2)) (H2 : Mem.perm m b1 ofs1 Max Nonempty) (H3 : Mem.perm m b2 ofs2 Max Nonempty) (A1 : delta1 = 0) (id1 : ident) (B1 : Genv.find_symbol ge id1 = Some b1) (C1 : Genv.find_symbol tge id1 = Some b1') (A2 : delta2 = 0) (id2 : ident) (B2 : Genv.find_symbol ge id2 = Some b2) (C2 : Genv.find_symbol tge id2 = Some b2') : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"destruct (ident_eq id1 id2).\ncongruence.\nleft; eapply Genv.global_addresses_distinct; eauto."},{"statement":"(b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : init_meminj b1 = Some (b1', delta1)) (H1 : init_meminj b2 = Some (b2', delta2)) (H2 : Mem.perm m b1 ofs1 Max Nonempty) (H3 : Mem.perm m b2 ofs2 Max Nonempty) (A1 : delta1 = 0) (id1 : ident) (B1 : Genv.find_symbol ge id1 = Some b1) (C1 : Genv.find_symbol tge id1 = Some b1') (A2 : delta2 = 0) (id2 : ident) (B2 : Genv.find_symbol ge id2 = Some b2) (C2 : Genv.find_symbol tge id2 = Some b2') (e : id1 = id2) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"congruence."},{"statement":"(b1 b1' : block) (delta1 : Z) (b2 b2' : block) (delta2 ofs1 ofs2 : Z) (H : b1 <> b2) (H0 : init_meminj b1 = Some (b1', delta1)) (H1 : init_meminj b2 = Some (b2', delta2)) (H2 : Mem.perm m b1 ofs1 Max Nonempty) (H3 : Mem.perm m b2 ofs2 Max Nonempty) (A1 : delta1 = 0) (id1 : ident) (B1 : Genv.find_symbol ge id1 = Some b1) (C1 : Genv.find_symbol tge id1 = Some b1') (A2 : delta2 = 0) (id2 : ident) (B2 : Genv.find_symbol ge id2 = Some b2) (C2 : Genv.find_symbol tge id2 = Some b2') (n : id1 <> id2) : b1' <> b2' \\/ ofs1 + delta1 <> ofs2 + delta2.","proofString":"left; eapply Genv.global_addresses_distinct; eauto."},{"statement":"(b b' : block) (delta : Z) (ofs : ptrofs) (H : init_meminj b = Some (b', delta)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"exploit init_meminj_invert; eauto.\nintros (A & id & B & C).\nsubst delta.\nsplit.\nlia.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(b b' : block) (delta : Z) (ofs : ptrofs) (H : init_meminj b = Some (b', delta)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) : delta = 0 /\\\n(exists id : ident,\n   Genv.find_symbol ge id = Some b /\\ Genv.find_symbol tge id = Some b') ->\ndelta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"intros (A & id & B & C).\nsubst delta.\nsplit.\nlia.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(b b' : block) (delta : Z) (ofs : ptrofs) (H : init_meminj b = Some (b', delta)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : delta >= 0 /\\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned.","proofString":"subst delta.\nsplit.\nlia.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(b b' : block) (ofs : ptrofs) (H : init_meminj b = Some (b', 0)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : 0 >= 0 /\\ 0 <= Ptrofs.unsigned ofs + 0 <= Ptrofs.max_unsigned.","proofString":"split.\nlia.\ngeneralize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(b b' : block) (ofs : ptrofs) (H : init_meminj b = Some (b', 0)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : 0 >= 0.","proofString":"lia."},{"statement":"(b b' : block) (ofs : ptrofs) (H : init_meminj b = Some (b', 0)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : 0 <= Ptrofs.unsigned ofs + 0 <= Ptrofs.max_unsigned.","proofString":"generalize (Ptrofs.unsigned_range_2 ofs).\nlia."},{"statement":"(b b' : block) (ofs : ptrofs) (H : init_meminj b = Some (b', 0)) (H0 : Mem.perm m b (Ptrofs.unsigned ofs) Max Nonempty \\/\nMem.perm m b (Ptrofs.unsigned ofs - 1) Max Nonempty) (id : ident) (B : Genv.find_symbol ge id = Some b) (C : Genv.find_symbol tge id = Some b') : 0 <= Ptrofs.unsigned ofs <= Ptrofs.max_unsigned ->\n0 <= Ptrofs.unsigned ofs + 0 <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"exploit init_meminj_invert_strong; eauto.\nintros (A & id & gd & B & C & D & E & F).\nexploit (Genv.init_mem_characterization_gen p); eauto.\nexploit (Genv.init_mem_characterization_gen tp); eauto.\ndestruct gd as [f|v].\nintros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto.\nintros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) : delta = 0 /\\\n(exists (id : ident) (gd : globdef fundef unit),\n   Genv.find_symbol ge id = Some b1 /\\\n   Genv.find_symbol tge id = Some b2 /\\\n   Genv.find_def ge b1 = Some gd /\\\n   Genv.find_def tge b2 = Some gd /\\\n   (forall i : ident, ref_def gd i -> kept i)) ->\nMem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"intros (A & id & gd & B & C & D & E & F).\nexploit (Genv.init_mem_characterization_gen p); eauto.\nexploit (Genv.init_mem_characterization_gen tp); eauto.\ndestruct gd as [f|v].\nintros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto.\nintros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (gd : globdef fundef unit) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some gd) (E : Genv.find_def tge b2 = Some gd) (F : forall i : ident, ref_def gd i -> kept i) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"exploit (Genv.init_mem_characterization_gen p); eauto.\nexploit (Genv.init_mem_characterization_gen tp); eauto.\ndestruct gd as [f|v].\nintros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto.\nintros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (gd : globdef fundef unit) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some gd) (E : Genv.find_def tge b2 = Some gd) (F : forall i : ident, ref_def gd i -> kept i) : match gd with\n| Gfun _ =>\n    Mem.perm m b1 0 Cur Nonempty /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty)\n| Gvar v =>\n    Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n      (Genv.perm_globvar v) /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm m b1 ofs0 k0 p1 ->\n     0 <= ofs0 < init_data_list_size (gvar_init v) /\\\n     perm_order (Genv.perm_globvar v) p1) /\\\n    (gvar_volatile v = false ->\n     Genv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\n     Some (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v)))\nend -> Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"exploit (Genv.init_mem_characterization_gen tp); eauto.\ndestruct gd as [f|v].\nintros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto.\nintros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (gd : globdef fundef unit) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some gd) (E : Genv.find_def tge b2 = Some gd) (F : forall i : ident, ref_def gd i -> kept i) : match gd with\n| Gfun _ =>\n    Mem.perm tm b2 0 Cur Nonempty /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm tm b2 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty)\n| Gvar v =>\n    Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n      (Genv.perm_globvar v) /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm tm b2 ofs0 k0 p1 ->\n     0 <= ofs0 < init_data_list_size (gvar_init v) /\\\n     perm_order (Genv.perm_globvar v) p1) /\\\n    (gvar_volatile v = false ->\n     Genv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\n     Some (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v)))\nend ->\nmatch gd with\n| Gfun _ =>\n    Mem.perm m b1 0 Cur Nonempty /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty)\n| Gvar v =>\n    Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n      (Genv.perm_globvar v) /\\\n    (forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n     Mem.perm m b1 ofs0 k0 p1 ->\n     0 <= ofs0 < init_data_list_size (gvar_init v) /\\\n     perm_order (Genv.perm_globvar v) p1) /\\\n    (gvar_volatile v = false ->\n     Genv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\n     Some (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v)))\nend -> Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"destruct gd as [f|v].\nintros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto.\nintros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) : Mem.perm tm b2 0 Cur Nonempty /\\\n(forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n Mem.perm tm b2 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) ->\nMem.perm m b1 0 Cur Nonempty /\\\n(forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n Mem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) ->\nMem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"intros (P2 & Q2) (P1 & Q1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) (P2 : Mem.perm tm b2 0 Cur Nonempty) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) (P1 : Mem.perm m b1 0 Cur Nonempty) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"apply Q2 in H0.\ndestruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : ofs + delta = 0 /\\ p0 = Nonempty) (A : delta = 0) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) (P2 : Mem.perm tm b2 0 Cur Nonempty) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) (P1 : Mem.perm m b1 0 Cur Nonempty) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"destruct H0.\nsubst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : ofs + delta = 0) (H1 : p0 = Nonempty) (A : delta = 0) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) (P2 : Mem.perm tm b2 0 Cur Nonempty) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) (P1 : Mem.perm m b1 0 Cur Nonempty) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 -> ofs0 = 0 /\\ p1 = Nonempty) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"subst.\nreplace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (H0 : ofs + 0 = 0) (H : init_meminj b1 = Some (b2, 0)) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) (P2 : Mem.perm tm b2 0 Cur Nonempty) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm b2 ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) (P1 : Mem.perm m b1 0 Cur Nonempty) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b1 ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) : Mem.perm m b1 ofs k Nonempty \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"replace ofs with 0 by lia.\nleft; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (H0 : ofs + 0 = 0) (H : init_meminj b1 = Some (b2, 0)) (id : ident) (f : fundef) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gfun f)) (E : Genv.find_def tge b2 = Some (Gfun f)) (F : forall i : ident, ref_def (Gfun f) i -> kept i) (P2 : Mem.perm tm b2 0 Cur Nonempty) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm b2 ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) (P1 : Mem.perm m b1 0 Cur Nonempty) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b1 ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) : Mem.perm m b1 0 k Nonempty \\/ ~ Mem.perm m b1 0 Max Nonempty.","proofString":"left; apply Mem.perm_cur; auto."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (v : globvar unit) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v) /\\\n(forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n Mem.perm tm b2 ofs0 k0 p1 ->\n 0 <= ofs0 < init_data_list_size (gvar_init v) /\\\n perm_order (Genv.perm_globvar v) p1) /\\\n(gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) ->\nMem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v) /\\\n(forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\n Mem.perm m b1 ofs0 k0 p1 ->\n 0 <= ofs0 < init_data_list_size (gvar_init v) /\\\n perm_order (Genv.perm_globvar v) p1) /\\\n(gvar_volatile v = false ->\n Genv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\n Some (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) ->\nMem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"intros (P2 & Q2 & R2 & S2) (P1 & Q1 & R1 & S1).\napply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (H0 : Mem.perm tm b2 (ofs + delta) k p0) (A : delta = 0) (id : ident) (v : globvar unit) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"apply Q2 in H0.\ndestruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (v : globvar unit) (H0 : 0 <= ofs + delta < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p0) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"destruct H0.\nsubst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (delta : Z) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, delta)) (v : globvar unit) (H0 : 0 <= ofs + delta < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (A : delta = 0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"subst.\nleft.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, 0)) (v : globvar unit) (H0 : 0 <= ofs + 0 < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs k p0 \\/ ~ Mem.perm m b1 ofs Max Nonempty.","proofString":"left.\napply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, 0)) (v : globvar unit) (H0 : 0 <= ofs + 0 < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs k p0.","proofString":"apply Mem.perm_cur.\neapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, 0)) (v : globvar unit) (H0 : 0 <= ofs + 0 < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs Cur p0.","proofString":"eapply Mem.perm_implies; eauto.\napply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, 0)) (v : globvar unit) (H0 : 0 <= ofs + 0 < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : Mem.perm m b1 ofs Cur (Genv.perm_globvar v).","proofString":"apply P1.\nlia."},{"statement":"(b1 : block) (ofs : Z) (b2 : block) (k : perm_kind) (p0 : permission) (H : init_meminj b1 = Some (b2, 0)) (v : globvar unit) (H0 : 0 <= ofs + 0 < init_data_list_size (gvar_init v)) (H1 : perm_order (Genv.perm_globvar v) p0) (id : ident) (B : Genv.find_symbol ge id = Some b1) (C : Genv.find_symbol tge id = Some b2) (D : Genv.find_def ge b1 = Some (Gvar v)) (E : Genv.find_def tge b2 = Some (Gvar v)) (F : forall i : ident, ref_def (Gvar v) i -> kept i) (P2 : Mem.range_perm tm b2 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q2 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm tm b2 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R2 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv tp) tm b2 0 (gvar_init v)) (S2 : gvar_volatile v = false ->\nMem.loadbytes tm b2 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv tp) (gvar_init v))) (P1 : Mem.range_perm m b1 0 (init_data_list_size (gvar_init v)) Cur\n  (Genv.perm_globvar v)) (Q1 : forall (ofs0 : Z) (k0 : perm_kind) (p1 : permission),\nMem.perm m b1 ofs0 k0 p1 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (Genv.perm_globvar v) p1) (R1 : gvar_volatile v = false ->\nGenv.load_store_init_data (Genv.globalenv p) m b1 0 (gvar_init v)) (S1 : gvar_volatile v = false ->\nMem.loadbytes m b1 0 (init_data_list_size (gvar_init v)) =\nSome (Genv.bytes_of_init_data_list (Genv.globalenv p) (gvar_init v))) : 0 <= ofs < init_data_list_size (gvar_init v).","proofString":"lia."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) : exists tm : mem, Genv.init_mem tp = Some tm.","proofString":"apply Genv.init_mem_exists.\nintros.\nassert (P: (prog_defmap tp)!id = Some (Gvar v)).\neapply prog_defmap_norepet; eauto.\neapply match_prog_unique; eauto.\nrewrite (match_prog_def _ _ _ TRANSF) in P.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nexploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) : forall (id : ident) (v : globvar unit),\nIn (id, Gvar v) (prog_defs tp) ->\nGenv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"intros.\nassert (P: (prog_defmap tp)!id = Some (Gvar v)).\neapply prog_defmap_norepet; eauto.\neapply match_prog_unique; eauto.\nrewrite (match_prog_def _ _ _ TRANSF) in P.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nexploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) : Genv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"assert (P: (prog_defmap tp)!id = Some (Gvar v)).\neapply prog_defmap_norepet; eauto.\neapply match_prog_unique; eauto.\nrewrite (match_prog_def _ _ _ TRANSF) in P.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nexploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) : (prog_defmap tp) ! id = Some (Gvar v).","proofString":"eapply prog_defmap_norepet; eauto.\neapply match_prog_unique; eauto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) : list_norepet (prog_defs_names tp).","proofString":"eapply match_prog_unique; eauto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (P : (prog_defmap tp) ! id = Some (Gvar v)) : Genv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"rewrite (match_prog_def _ _ _ TRANSF) in P.\ndestruct (IS.mem id used) eqn:U; try discriminate.\nexploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (P : (if IS.mem id used then (prog_defmap p) ! id else None) = Some (Gvar v)) : Genv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"destruct (IS.mem id used) eqn:U; try discriminate.\nexploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) : Genv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"exploit Genv.init_mem_inversion; eauto.\napply in_prog_defmap; eauto.\nintros [AL FV].\nsplit.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv p) i = Some b) : Genv.init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b).","proofString":"split.\nauto.\nintros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv p) i = Some b) : Genv.init_data_list_aligned 0 (gvar_init v).","proofString":"auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv p) i = Some b) : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b.","proofString":"intros.\nexploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) : exists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b.","proofString":"exploit FV; eauto.\nintros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) : (exists b : block, Genv.find_symbol (Genv.globalenv p) i = Some b) ->\nexists b : block, Genv.find_symbol (Genv.globalenv tp) i = Some b.","proofString":"intros (b & FS).\napply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : exists b0 : block, Genv.find_symbol (Genv.globalenv tp) i = Some b0.","proofString":"apply transform_find_symbol_1 with b; auto.\napply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : kept i.","proofString":"apply kept_closed with id (Gvar v).\napply IS.mem_2; auto.\nauto.\nred.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : kept id.","proofString":"apply IS.mem_2; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : pm ! id = Some (Gvar v).","proofString":"auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : ref_def (Gvar v) i.","proofString":"red.\nred.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : ref_init (gvar_init v) i.","proofString":"red.\nexists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (id : ident) (v : globvar unit) (H0 : In (id, Gvar v) (prog_defs tp)) (U : IS.mem id used = true) (P : (prog_defmap p) ! id = Some (Gvar v)) (AL : Genv.init_data_list_aligned 0 (gvar_init v)) (FV : forall (i0 : ident) (o0 : ptrofs),\nIn (Init_addrof i0 o0) (gvar_init v) ->\nexists b0 : block, Genv.find_symbol (Genv.globalenv p) i0 = Some b0) (i : ident) (o : ptrofs) (H1 : In (Init_addrof i o) (gvar_init v)) (b : block) (FS : Genv.find_symbol (Genv.globalenv p) i = Some b) : exists ofs : ptrofs, In (Init_addrof i ofs) (gvar_init v).","proofString":"exists o; auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) : exists (f : meminj) (tm : mem),\n  Genv.init_mem tp = Some tm /\\\n  Mem.inject f m tm /\\ meminj_preserves_globals f.","proofString":"exploit init_mem_exists; eauto.\nintros [tm INIT].\nexists init_meminj, tm.\nsplit.\nauto.\nsplit.\neapply init_mem_inj_2; eauto.\napply init_meminj_preserves_globals."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) : (exists tm : mem, Genv.init_mem tp = Some tm) ->\nexists (f : meminj) (tm : mem),\n  Genv.init_mem tp = Some tm /\\\n  Mem.inject f m tm /\\ meminj_preserves_globals f.","proofString":"intros [tm INIT].\nexists init_meminj, tm.\nsplit.\nauto.\nsplit.\neapply init_mem_inj_2; eauto.\napply init_meminj_preserves_globals."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : exists (f : meminj) (tm0 : mem),\n  Genv.init_mem tp = Some tm0 /\\\n  Mem.inject f m tm0 /\\ meminj_preserves_globals f.","proofString":"exists init_meminj, tm.\nsplit.\nauto.\nsplit.\neapply init_mem_inj_2; eauto.\napply init_meminj_preserves_globals."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : Genv.init_mem tp = Some tm /\\\nMem.inject init_meminj m tm /\\ meminj_preserves_globals init_meminj.","proofString":"split.\nauto.\nsplit.\neapply init_mem_inj_2; eauto.\napply init_meminj_preserves_globals."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : Genv.init_mem tp = Some tm.","proofString":"auto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : Mem.inject init_meminj m tm /\\ meminj_preserves_globals init_meminj.","proofString":"split.\neapply init_mem_inj_2; eauto.\napply init_meminj_preserves_globals."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : Mem.inject init_meminj m tm.","proofString":"eapply init_mem_inj_2; eauto."},{"statement":"(m : mem) (H : Genv.init_mem p = Some m) (tm : mem) (INIT : Genv.init_mem tp = Some tm) : meminj_preserves_globals init_meminj.","proofString":"apply init_meminj_preserves_globals."},{"statement":"(S1 : state) (H : initial_state p S1) : exists S2 : state, initial_state tp S2 /\\ match_states S1 S2.","proofString":"inv H.\nexploit init_mem_inject; eauto.\nintros (j & tm & A & B & C).\nexploit symbols_inject_2.\neauto.\neapply kept_main.\neexact H1.\nintros (tb & P & Q).\nrewrite Genv.find_funct_ptr_iff in H2.\nexploit defs_inject.\neauto.\neexact Q.\nexact H2.\nintros (R & S & T).\nrewrite <- Genv.find_funct_ptr_iff in R.\nexists (Callstate nil f nil tm); split.\neconstructor; eauto.\nfold tge.\nerewrite match_prog_main by eauto.\nauto.\neconstructor; eauto.\nconstructor.\nauto.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_def tge tb = Some (Gfun f)) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : exists S2 : state,\n  initial_state tp S2 /\\ match_states (Callstate nil f nil m0) S2.","proofString":"rewrite <- Genv.find_funct_ptr_iff in R.\nexists (Callstate nil f nil tm); split.\neconstructor; eauto.\nfold tge.\nerewrite match_prog_main by eauto.\nauto.\neconstructor; eauto.\nconstructor.\nauto.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : exists S2 : state,\n  initial_state tp S2 /\\ match_states (Callstate nil f nil m0) S2.","proofString":"exists (Callstate nil f nil tm); split.\neconstructor; eauto.\nfold tge.\nerewrite match_prog_main by eauto.\nauto.\neconstructor; eauto.\nconstructor.\nauto.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : initial_state tp (Callstate nil f nil tm).","proofString":"econstructor; eauto.\nfold tge.\nerewrite match_prog_main by eauto.\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Genv.find_symbol (Genv.globalenv tp) (prog_main tp) = Some tb.","proofString":"fold tge.\nerewrite match_prog_main by eauto.\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Genv.find_symbol tge (prog_main tp) = Some tb.","proofString":"erewrite match_prog_main by eauto.\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Genv.find_symbol tge (prog_main p) = Some tb.","proofString":"auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : match_states (Callstate nil f nil m0) (Callstate nil f nil tm).","proofString":"econstructor; eauto.\nconstructor.\nauto.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : match_stacks j nil nil (Mem.nextblock m0) (Mem.nextblock tm).","proofString":"constructor.\nauto.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl.\nerewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : meminj_preserves_globals j.","proofString":"auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Ple (Genv.genv_next ge) (Mem.nextblock m0).","proofString":"erewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Ple (Genv.genv_next ge) (Genv.genv_next (Genv.globalenv p)).","proofString":"apply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Ple (Genv.genv_next tge) (Mem.nextblock tm).","proofString":"erewrite <- Genv.init_mem_genv_next by eauto.\napply Ple_refl."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_def ge0 b = Some (Gfun f)) (H3 : funsig f = signature_main) (j : meminj) (tm : mem) (A : Genv.init_mem tp = Some tm) (B : Mem.inject j m0 tm) (C : meminj_preserves_globals j) (tb : block) (P : Genv.find_symbol tge (prog_main p) = Some tb) (Q : j b = Some (tb, 0)) (R : Genv.find_funct_ptr tge tb = Some f) (S : 0 = 0) (T : forall id : ident, ref_def (Gfun f) id -> kept id) : Ple (Genv.genv_next tge) (Genv.genv_next (Genv.globalenv tp)).","proofString":"apply Ple_refl."},{"statement":"(S1 S2 : state) (r : int) (H : match_states S1 S2) (H0 : final_state S1 r) : final_state S2 r.","proofString":"inv H0.\ninv H.\ninv STACKS.\ninv RESINJ.\nconstructor."},{"statement":"(S2 : state) (r : int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) S2) : final_state S2 r.","proofString":"inv H.\ninv STACKS.\ninv RESINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (ts : list stackframe) (tres : val) (tm : Mem.mem') (j : meminj) (STACKS : match_stacks j nil ts (Mem.nextblock m) (Mem.nextblock tm)) (RESINJ : Val.inject j (Vint r) tres) (MEMINJ : Mem.inject j m tm) : final_state (Returnstate ts tres tm) r.","proofString":"inv STACKS.\ninv RESINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tres : val) (tm : Mem.mem') (j : meminj) (RESINJ : Val.inject j (Vint r) tres) (MEMINJ : Mem.inject j m tm) (H : meminj_preserves_globals j) (H0 : Ple (Genv.genv_next ge) (Mem.nextblock m)) (H1 : Ple (Genv.genv_next tge) (Mem.nextblock tm)) : final_state (Returnstate nil tres tm) r.","proofString":"inv RESINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tm : Mem.mem') (j : meminj) (MEMINJ : Mem.inject j m tm) (H : meminj_preserves_globals j) (H0 : Ple (Genv.genv_next ge) (Mem.nextblock m)) (H1 : Ple (Genv.genv_next tge) (Mem.nextblock tm)) : final_state (Returnstate nil (Vint r) tm) r.","proofString":"constructor."},{"statement":"forward_simulation (semantics p) (semantics tp).","proofString":"eapply forward_simulation_step.\nexploit globals_symbols_inject.\napply init_meminj_preserves_globals.\nintros [A B].\nexact A.\neexact transf_initial_states.\neexact transf_final_states.\neexact step_simulation."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tp)) id =\nSenv.public_symbol (symbolenv (semantics p)) id.","proofString":"exploit globals_symbols_inject.\napply init_meminj_preserves_globals.\nintros [A B].\nexact A."},{"statement":"(A : forall id : ident, Senv.public_symbol tge id = Senv.public_symbol ge id) (B : (forall (id : ident) (b1 b2 : block) (delta : Z),\n init_meminj b1 = Some (b2, delta) ->\n Senv.find_symbol ge id = Some b1 ->\n delta = 0 /\\ Senv.find_symbol tge id = Some b2) /\\\n(forall (id : ident) (b1 : block),\n Senv.public_symbol ge id = true ->\n Senv.find_symbol ge id = Some b1 ->\n exists b2 : block,\n   init_meminj b1 = Some (b2, 0) /\\ Senv.find_symbol tge id = Some b2) /\\\n(forall (b1 b2 : block) (delta : Z),\n init_meminj b1 = Some (b2, delta) ->\n Senv.block_is_volatile tge b2 = Senv.block_is_volatile ge b1)) : forall id : ident,\nSenv.public_symbol (symbolenv (semantics tp)) id =\nSenv.public_symbol (symbolenv (semantics p)) id.","proofString":"exact A."},{"statement":"(p tp : program) (used : IS.t) (A : valid_used_set p used) (B : match_prog_1 used p tp) : forward_simulation (semantics p) (semantics tp).","proofString":"apply transf_program_correct_1 with used; auto."},{"statement":"(p : program) (used : IS.t) (id : positive) (H : valid_used_set p used) (H0 : (prog_defmap p) ! id = None) : IS.mem id used = false \\/ id = prog_main p.","proofString":"destruct (IS.mem id used) eqn:M; auto.\nexploit used_defined; eauto using IS.mem_2.\nintros [A|A]; auto.\napply prog_defmap_dom in A.\ndestruct A as [g E]; congruence."},{"statement":"(p : program) (used : IS.t) (id : positive) (H : valid_used_set p used) (H0 : (prog_defmap p) ! id = None) (M : IS.mem id used = true) : true = false \\/ id = prog_main p.","proofString":"exploit used_defined; eauto using IS.mem_2.\nintros [A|A]; auto.\napply prog_defmap_dom in A.\ndestruct A as [g E]; congruence."},{"statement":"(p : program) (used : IS.t) (id : positive) (H : valid_used_set p used) (H0 : (prog_defmap p) ! id = None) (M : IS.mem id used = true) : In id (prog_defs_names p) \\/ id = prog_main p ->\ntrue = false \\/ id = prog_main p.","proofString":"intros [A|A]; auto.\napply prog_defmap_dom in A.\ndestruct A as [g E]; congruence."},{"statement":"(p : program) (used : IS.t) (id : positive) (H : valid_used_set p used) (H0 : (prog_defmap p) ! id = None) (M : IS.mem id used = true) (A : In id (prog_defs_names p)) : true = false \\/ id = prog_main p.","proofString":"apply prog_defmap_dom in A.\ndestruct A as [g E]; congruence."},{"statement":"(p : program) (used : IS.t) (id : positive) (H : valid_used_set p used) (H0 : (prog_defmap p) ! id = None) (M : IS.mem id used = true) (A : exists g : globdef fundef unit, (prog_defmap p) ! id = Some g) : true = false \\/ id = prog_main p.","proofString":"destruct A as [g E]; congruence."},{"statement":"(p : program) (used : IS.t) (id : ident) (H : valid_used_set p used) (H0 : id <> prog_main p) (H1 : (prog_defmap p) ! id = None) : ~ IS.In id used.","proofString":"exploit used_not_defined; eauto.\nintros [A|A].\nred; intros; apply IS.mem_1 in H2; congruence.\ncongruence."},{"statement":"(p : program) (used : IS.t) (id : ident) (H : valid_used_set p used) (H0 : id <> prog_main p) (H1 : (prog_defmap p) ! id = None) : IS.mem id used = false \\/ id = prog_main p -> ~ IS.In id used.","proofString":"intros [A|A].\nred; intros; apply IS.mem_1 in H2; congruence.\ncongruence."},{"statement":"(p : program) (used : IS.t) (id : ident) (H : valid_used_set p used) (H0 : id <> prog_main p) (H1 : (prog_defmap p) ! id = None) (A : IS.mem id used = false) : ~ IS.In id used.","proofString":"red; intros; apply IS.mem_1 in H2; congruence."},{"statement":"(p : program) (used : IS.t) (id : ident) (H : valid_used_set p used) (H0 : id <> prog_main p) (H1 : (prog_defmap p) ! id = None) (A : id = prog_main p) : ~ IS.In id used.","proofString":"congruence."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) : valid_used_set p (IS.union used1 used2).","proofString":"destruct (link_prog_inv _ _ _ L) as (X & Y & Z).\nrewrite Z; clear Z; constructor.\nintros.\nrewrite ISF.union_iff in H.\nrewrite ISF.union_iff.\nrewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto.\nsimpl.\nrewrite ISF.union_iff; left; eapply used_main; eauto.\nsimpl.\nintros id.\nrewrite in_app_iff, ISF.union_iff.\nintros [A|A]; [left|right]; eapply used_public; eauto.\nintros.\nrewrite ISF.union_iff in H.\ndestruct (ident_eq id (prog_main p1)).\nright; assumption.\nassert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (Z : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : valid_used_set p (IS.union used1 used2).","proofString":"rewrite Z; clear Z; constructor.\nintros.\nrewrite ISF.union_iff in H.\nrewrite ISF.union_iff.\nrewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto.\nsimpl.\nrewrite ISF.union_iff; left; eapply used_main; eauto.\nsimpl.\nintros id.\nrewrite in_app_iff, ISF.union_iff.\nintros [A|A]; [left|right]; eapply used_public; eauto.\nintros.\nrewrite ISF.union_iff in H.\ndestruct (ident_eq id (prog_main p1)).\nright; assumption.\nassert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : forall (id : IS.elt) (gd : globdef fundef unit) (id' : ident),\nIS.In id (IS.union used1 used2) ->\n(prog_defmap\n   {|\n     prog_defs :=\n       PTree.elements\n         (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n     prog_public := prog_public p1 ++ prog_public p2;\n     prog_main := prog_main p1\n   |}) ! id = Some gd -> ref_def gd id' -> IS.In id' (IS.union used1 used2).","proofString":"intros.\nrewrite ISF.union_iff in H.\nrewrite ISF.union_iff.\nrewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id (IS.union used1 used2)) (H0 : (prog_defmap\n   {|\n     prog_defs :=\n       PTree.elements\n         (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n     prog_public := prog_public p1 ++ prog_public p2;\n     prog_main := prog_main p1\n   |}) ! id = Some gd) (H1 : ref_def gd id') : IS.In id' (IS.union used1 used2).","proofString":"rewrite ISF.union_iff in H.\nrewrite ISF.union_iff.\nrewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (H0 : (prog_defmap\n   {|\n     prog_defs :=\n       PTree.elements\n         (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n     prog_public := prog_public p1 ++ prog_public p2;\n     prog_main := prog_main p1\n   |}) ! id = Some gd) (H1 : ref_def gd id') : IS.In id' (IS.union used1 used2).","proofString":"rewrite ISF.union_iff.\nrewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (H0 : (prog_defmap\n   {|\n     prog_defs :=\n       PTree.elements\n         (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n     prog_public := prog_public p1 ++ prog_public p2;\n     prog_main := prog_main p1\n   |}) ! id = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"rewrite prog_defmap_elements, PTree.gcombine in H0.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (H0 : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2;  simpl in H0; try discriminate.\nexploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto.\ninv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto.\ninv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H0 : link_def gd1 gd2 = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit Y; eauto.\nintros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H0 : link_def gd1 gd2 = Some gd) (H1 : ref_def gd id') : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0) ->\nIS.In id' used1 \\/ IS.In id' used2.","proofString":"intros (PUB1 & PUB2 & _).\nexploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H0 : link_def gd1 gd2 = Some gd) (H1 : ref_def gd id') (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit link_def_either; eauto.\nintros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H0 : link_def gd1 gd2 = Some gd) (H1 : ref_def gd id') (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : gd = gd1 \\/ gd = gd2 -> IS.In id' used1 \\/ IS.In id' used2.","proofString":"intros [EQ|EQ]; subst gd.\nleft.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto.\nright.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (id : IS.elt) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H1 : ref_def gd1 id') (H0 : link_def gd1 gd2 = Some gd1) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"left.\neapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (id : IS.elt) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H1 : ref_def gd1 id') (H0 : link_def gd1 gd2 = Some gd1) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : IS.In id' used1.","proofString":"eapply used_closed.\neexact V1.\neapply used_public.\neexact V1.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (id : IS.elt) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H1 : ref_def gd2 id') (H0 : link_def gd1 gd2 = Some gd2) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"right.\neapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (id : IS.elt) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H1 : ref_def gd2 id') (H0 : link_def gd1 gd2 = Some gd2) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : IS.In id' used2.","proofString":"eapply used_closed.\neexact V2.\neapply used_public.\neexact V2.\neauto.\neauto.\nauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd3 : globdef fundef unit, link gd0 gd2 = Some gd3)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (H0 : Some gd1 = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"inv H0.\ndestruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"destruct (ISP.In_dec id used1).\nleft; eapply used_closed; eauto.\nassert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (i : IS.In id used1) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"left; eapply used_closed; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"assert (IS.In id used2) by tauto.\nexploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit used_defined.\neexact V2.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) (A : In id (prog_defs_names p2)) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit prog_defmap_dom; eauto.\nintros [g E]; congruence."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) (A : In id (prog_defs_names p2)) : (exists g : globdef fundef unit, (prog_defmap p2) ! id = Some g) ->\nIS.In id' used1 \\/ IS.In id' used2.","proofString":"intros [g E]; congruence."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) (A : id = prog_main p2) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"elim n.\nrewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) (A : id = prog_main p2) : IS.In id used1.","proofString":"rewrite A, <- X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = Some gd) (GD2 : (prog_defmap p2) ! id = None) (H1 : ref_def gd id') (n : ~ IS.In id used1) (H0 : IS.In id used2) (A : id = prog_main p2) : IS.In (prog_main p1) used1.","proofString":"eapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd3 : globdef fundef unit, link gd1 gd0 = Some gd3)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (H0 : Some gd2 = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"inv H0.\ndestruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') : IS.In id' used1 \\/ IS.In id' used2.","proofString":"destruct (ISP.In_dec id used2).\nright; eapply used_closed; eauto.\nassert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (i : IS.In id used2) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"right; eapply used_closed; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"assert (IS.In id used1) by tauto.\nexploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit used_defined.\neexact V1.\neauto.\nintros [A|A].\nexploit prog_defmap_dom; eauto.\nintros [g E]; congruence.\nelim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) (A : In id (prog_defs_names p1)) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"exploit prog_defmap_dom; eauto.\nintros [g E]; congruence."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) (A : In id (prog_defs_names p1)) : (exists g : globdef fundef unit, (prog_defmap p1) ! id = Some g) ->\nIS.In id' used1 \\/ IS.In id' used2.","proofString":"intros [g E]; congruence."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) (A : id = prog_main p1) : IS.In id' used1 \\/ IS.In id' used2.","proofString":"elim n.\nrewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) (A : id = prog_main p1) : IS.In id used2.","proofString":"rewrite A, X.\neapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = Some gd) (H1 : ref_def gd id') (n : ~ IS.In id used2) (H0 : IS.In id used1) (A : id = prog_main p1) : IS.In (prog_main p2) used2.","proofString":"eapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd0 : globdef fundef unit, link gd1 gd2 = Some gd0)) (id : IS.elt) (gd : globdef fundef unit) (id' : ident) (H : IS.In id used1 \\/ IS.In id used2) (H0 : (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)) ! id =\nSome gd) (H1 : ref_def gd id') : link_prog_merge None None = None.","proofString":"auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : IS.In\n  (prog_main\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) (IS.union used1 used2).","proofString":"simpl.\nrewrite ISF.union_iff; left; eapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : IS.In (prog_main p1) (IS.union used1 used2).","proofString":"rewrite ISF.union_iff; left; eapply used_main; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : forall id : ident,\nIn id\n  (prog_public\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) -> IS.In id (IS.union used1 used2).","proofString":"simpl.\nintros id.\nrewrite in_app_iff, ISF.union_iff.\nintros [A|A]; [left|right]; eapply used_public; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : forall id : ident,\nIn id (prog_public p1 ++ prog_public p2) -> IS.In id (IS.union used1 used2).","proofString":"intros id.\nrewrite in_app_iff, ISF.union_iff.\nintros [A|A]; [left|right]; eapply used_public; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : ident) : In id (prog_public p1 ++ prog_public p2) -> IS.In id (IS.union used1 used2).","proofString":"rewrite in_app_iff, ISF.union_iff.\nintros [A|A]; [left|right]; eapply used_public; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : ident) : In id (prog_public p1) \\/ In id (prog_public p2) ->\nIS.In id used1 \\/ IS.In id used2.","proofString":"intros [A|A]; [left|right]; eapply used_public; eauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) : forall id : IS.elt,\nIS.In id (IS.union used1 used2) ->\nIn id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"intros.\nrewrite ISF.union_iff in H.\ndestruct (ident_eq id (prog_main p1)).\nright; assumption.\nassert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id (IS.union used1 used2)) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"rewrite ISF.union_iff in H.\ndestruct (ident_eq id (prog_main p1)).\nright; assumption.\nassert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"destruct (ident_eq id (prog_main p1)).\nright; assumption.\nassert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (e : id = prog_main p1) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"right; assumption."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"assert (E: exists g, link_prog_merge (prog_defmap p1)!id (prog_defmap p2)!id = Some g).\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto.\ndestruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) : exists g : globdef fundef unit,\n  link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g.","proofString":"destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;    destruct (prog_defmap p2)!id as [gd2|] eqn:GD2; simpl.\napply Y with id; auto.\nexists gd1; auto.\nexists gd2; auto.\neapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) : exists g : globdef fundef unit, link_def gd1 gd2 = Some g.","proofString":"apply Y with id; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) : exists g : globdef fundef unit, Some gd1 = Some g.","proofString":"exists gd1; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) : exists g : globdef fundef unit, Some gd2 = Some g.","proofString":"exists gd2; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = None) : exists g : globdef fundef unit, None = Some g.","proofString":"eapply used_not_defined_2 in GD1; [ | eauto | congruence ].\neapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (GD2 : (prog_defmap p2) ! id = None) (GD1 : ~ IS.In id used1) : exists g : globdef fundef unit, None = Some g.","proofString":"eapply used_not_defined_2 in GD2; [ | eauto | congruence ].\ntauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (GD1 : ~ IS.In id used1) (GD2 : ~ IS.In id used2) : exists g : globdef fundef unit, None = Some g.","proofString":"tauto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (E : exists g : globdef fundef unit,\n  link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"destruct E as [g LD].\nleft.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) \\/\nid =\nprog_main\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}.","proofString":"left.\nunfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In id\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}).","proofString":"unfold prog_defs_names; simpl.\nchange id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In id\n  (map fst\n     (PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)))).","proofString":"change id with (fst (id, g)).\napply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In (fst (id, g))\n  (map fst\n     (PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)))).","proofString":"apply in_map.\napply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : In (id, g)\n  (PTree.elements\n     (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2))).","proofString":"apply PTree.elements_correct.\nrewrite PTree.gcombine; auto."},{"statement":"(p1 p2 p : program) (used1 used2 : IS.t) (L : link p1 p2 = Some p) (V1 : valid_used_set p1 used1) (V2 : valid_used_set p2 used2) (X : prog_main p1 = prog_main p2) (Y : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (id : IS.elt) (H : IS.In id used1 \\/ IS.In id used2) (n : id <> prog_main p1) (g : globdef fundef unit) (LD : link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id = Some g) : (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2)) ! id =\nSome g.","proofString":"rewrite PTree.gcombine; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (H0 : match_prog p1 tp1) (H1 : match_prog p2 tp2) : exists tp : program, link tp1 tp2 = Some tp /\\ match_prog p tp.","proofString":"destruct H0 as (used1 & A1 & B1).\ndestruct H1 as (used2 & A2 & B2).\ndestruct (link_prog_inv _ _ _ H) as (U & V & W).\neconstructor; split.\napply link_prog_succeeds.\nrewrite (match_prog_main _ _ _ B1), (match_prog_main _ _ _ B2).\nauto.\nintros.\nrewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence.\nexists (IS.union used1 used2); split.\neapply link_valid_used_set; eauto.\nrewrite W.\nconstructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (H1 : match_prog p2 tp2) : exists tp : program, link tp1 tp2 = Some tp /\\ match_prog p tp.","proofString":"destruct H1 as (used2 & A2 & B2).\ndestruct (link_prog_inv _ _ _ H) as (U & V & W).\neconstructor; split.\napply link_prog_succeeds.\nrewrite (match_prog_main _ _ _ B1), (match_prog_main _ _ _ B2).\nauto.\nintros.\nrewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence.\nexists (IS.union used1 used2); split.\neapply link_valid_used_set; eauto.\nrewrite W.\nconstructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) : exists tp : program, link tp1 tp2 = Some tp /\\ match_prog p tp.","proofString":"destruct (link_prog_inv _ _ _ H) as (U & V & W).\neconstructor; split.\napply link_prog_succeeds.\nrewrite (match_prog_main _ _ _ B1), (match_prog_main _ _ _ B2).\nauto.\nintros.\nrewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence.\nexists (IS.union used1 used2); split.\neapply link_valid_used_set; eauto.\nrewrite W.\nconstructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : exists tp : program, link tp1 tp2 = Some tp /\\ match_prog p tp.","proofString":"econstructor; split.\napply link_prog_succeeds.\nrewrite (match_prog_main _ _ _ B1), (match_prog_main _ _ _ B2).\nauto.\nintros.\nrewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence.\nexists (IS.union used1 used2); split.\neapply link_valid_used_set; eauto.\nrewrite W.\nconstructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : prog_main tp1 = prog_main tp2.","proofString":"rewrite (match_prog_main _ _ _ B1), (match_prog_main _ _ _ B2).\nauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : prog_main p1 = prog_main p2.","proofString":"auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap tp1) ! id = Some gd1 ->\n(prog_defmap tp2) ! id = Some gd2 ->\nIn id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"intros.\nrewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (H0 : (prog_defmap tp1) ! id = Some gd1) (H1 : (prog_defmap tp2) ! id = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"rewrite (match_prog_def _ _ _ B1) in H0.\nrewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (H0 : (if IS.mem id used1 then (prog_defmap p1) ! id else None) = Some gd1) (H1 : (prog_defmap tp2) ! id = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"rewrite (match_prog_def _ _ _ B2) in H1.\ndestruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (H0 : (if IS.mem id used1 then (prog_defmap p1) ! id else None) = Some gd1) (H1 : (if IS.mem id used2 then (prog_defmap p2) ! id else None) = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"destruct (IS.mem id used1) eqn:U1; try discriminate.\ndestruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (H1 : (if IS.mem id used2 then (prog_defmap p2) ! id else None) = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"destruct (IS.mem id used2) eqn:U2; try discriminate.\nedestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"edestruct V as (X & Y & gd & Z); eauto.\nsplit.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef fundef unit) (Z : link gd1 gd2 = Some gd) : In id (prog_public tp1) /\\ In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"split.\nrewrite (match_prog_public _ _ _ B1); auto.\nsplit.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef fundef unit) (Z : link gd1 gd2 = Some gd) : In id (prog_public tp1).","proofString":"rewrite (match_prog_public _ _ _ B1); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef fundef unit) (Z : link gd1 gd2 = Some gd) : In id (prog_public tp2) /\\ link gd1 gd2 <> None.","proofString":"split.\nrewrite (match_prog_public _ _ _ B2); auto.\ncongruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef fundef unit) (Z : link gd1 gd2 = Some gd) : In id (prog_public tp2).","proofString":"rewrite (match_prog_public _ _ _ B2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd4 : globdef fundef unit, link gd0 gd3 = Some gd4)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 gd2 : globdef fundef unit) (U1 : IS.mem id used1 = true) (H0 : (prog_defmap p1) ! id = Some gd1) (U2 : IS.mem id used2 = true) (H1 : (prog_defmap p2) ! id = Some gd2) (X : In id (prog_public p1)) (Y : In id (prog_public p2)) (gd : globdef fundef unit) (Z : link gd1 gd2 = Some gd) : link gd1 gd2 <> None.","proofString":"congruence."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : valid_used_set p (IS.union used1 used2).","proofString":"eapply link_valid_used_set; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : match_prog_1 (IS.union used1 used2) p\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n    prog_public := prog_public tp1 ++ prog_public tp2;\n    prog_main := prog_main tp1\n  |}.","proofString":"rewrite W.\nconstructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : match_prog_1 (IS.union used1 used2)\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n    prog_public := prog_public p1 ++ prog_public p2;\n    prog_main := prog_main p1\n  |}\n  {|\n    prog_defs :=\n      PTree.elements\n        (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n    prog_public := prog_public tp1 ++ prog_public tp2;\n    prog_main := prog_main tp1\n  |}.","proofString":"constructor; simpl; intros.\neapply match_prog_main; eauto.\nrewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto.\nrewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto.\nintros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : prog_main tp1 = prog_main p1.","proofString":"eapply match_prog_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : prog_public tp1 ++ prog_public tp2 = prog_public p1 ++ prog_public p2.","proofString":"rewrite (match_prog_public _ _ _ B1), (match_prog_public _ _ _ B2).\nauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : prog_public p1 ++ prog_public p2 = prog_public p1 ++ prog_public p2.","proofString":"auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) : (prog_defmap\n   {|\n     prog_defs :=\n       PTree.elements\n         (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n     prog_public := prog_public tp1 ++ prog_public tp2;\n     prog_main := prog_main tp1\n   |}) ! id =\n(if IS.mem id (IS.union used1 used2)\n then\n  (prog_defmap\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n       prog_public := prog_public p1 ++ prog_public p2;\n       prog_main := prog_main p1\n     |}) ! id\n else None).","proofString":"rewrite ! prog_defmap_elements, !PTree.gcombine by auto.\nrewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) : link_prog_merge (prog_defmap tp1) ! id (prog_defmap tp2) ! id =\n(if IS.mem id (IS.union used1 used2)\n then link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id\n else None).","proofString":"rewrite (match_prog_def _ _ _ B1 id), (match_prog_def _ _ _ B2 id).\nrewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) : link_prog_merge (if IS.mem id used1 then (prog_defmap p1) ! id else None)\n  (if IS.mem id used2 then (prog_defmap p2) ! id else None) =\n(if IS.mem id (IS.union used1 used2)\n then link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id\n else None).","proofString":"rewrite ISF.union_b.\ndestruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) : link_prog_merge (if IS.mem id used1 then (prog_defmap p1) ! id else None)\n  (if IS.mem id used2 then (prog_defmap p2) ! id else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (prog_defmap p1) ! id (prog_defmap p2) ! id\n else None).","proofString":"destruct (prog_defmap p1)!id as [gd1|] eqn:GD1;  destruct (prog_defmap p2)!id as [gd2|] eqn:GD2.\nexploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto.\nexploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto.\nexploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto.\ndestruct (IS.mem id used1), (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) (Some gd2)\n else None).","proofString":"exploit V; eauto.\nintros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) : In id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd) ->\nlink_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) (Some gd2)\n else None).","proofString":"intros (PUB1 & PUB2 & _).\nassert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) (Some gd2)\n else None).","proofString":"assert (EQ1: IS.mem id used1 = true) by (apply IS.mem_1; eapply used_public; eauto).\nassert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) (EQ1 : IS.mem id used1 = true) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) (Some gd2)\n else None).","proofString":"assert (EQ2: IS.mem id used2 = true) by (apply IS.mem_1; eapply used_public; eauto).\nrewrite EQ1, EQ2; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd3 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd3 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd3 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (PUB1 : In id (prog_public p1)) (PUB2 : In id (prog_public p2)) (EQ1 : IS.mem id used1 = true) (EQ2 : IS.mem id used2 = true) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) (Some gd2)\n else None).","proofString":"rewrite EQ1, EQ2; auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then None else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) None\n else None).","proofString":"exploit used_not_defined; eauto.\nintros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) : IS.mem id used2 = false \\/ id = prog_main p2 ->\nlink_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then None else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) None\n else None).","proofString":"intros [A|A].\nrewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto.\nreplace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : IS.mem id used2 = false) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then None else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) None\n else None).","proofString":"rewrite A, orb_false_r.\ndestruct (IS.mem id used1); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : IS.mem id used2 = false) : link_prog_merge (if IS.mem id used1 then Some gd1 else None) None =\n(if IS.mem id used1 then link_prog_merge (Some gd1) None else None).","proofString":"destruct (IS.mem id used1); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : link_prog_merge (if IS.mem id used1 then Some gd1 else None)\n  (if IS.mem id used2 then None else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge (Some gd1) None\n else None).","proofString":"replace (IS.mem id used1) with true.\ndestruct (IS.mem id used2); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : link_prog_merge (Some gd1) (if IS.mem id used2 then None else None) =\n(if true || IS.mem id used2 then link_prog_merge (Some gd1) None else None).","proofString":"destruct (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : true = IS.mem id used1.","proofString":"symmetry.\napply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : IS.mem id used1 = true.","proofString":"apply IS.mem_1.\nrewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : IS.In id used1.","proofString":"rewrite A, <- U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd0 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd0 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd0 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (gd1 : globdef fundef unit) (GD1 : (prog_defmap p1) ! id = Some gd1) (GD2 : (prog_defmap p2) ! id = None) (A : id = prog_main p2) : IS.In (prog_main p1) used1.","proofString":"eapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) : link_prog_merge (if IS.mem id used1 then None else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge None (Some gd2)\n else None).","proofString":"exploit used_not_defined.\neexact A1.\neauto.\nintros [A|A].\nrewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto.\nreplace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : IS.mem id used1 = false) : link_prog_merge (if IS.mem id used1 then None else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge None (Some gd2)\n else None).","proofString":"rewrite A, orb_false_l.\ndestruct (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : IS.mem id used1 = false) : link_prog_merge None (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used2 then link_prog_merge None (Some gd2) else None).","proofString":"destruct (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : link_prog_merge (if IS.mem id used1 then None else None)\n  (if IS.mem id used2 then Some gd2 else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge None (Some gd2)\n else None).","proofString":"replace (IS.mem id used2) with true.\ndestruct (IS.mem id used1); auto.\nsymmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : link_prog_merge (if IS.mem id used1 then None else None) (Some gd2) =\n(if IS.mem id used1 || true then link_prog_merge None (Some gd2) else None).","proofString":"destruct (IS.mem id used1); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : true = IS.mem id used2.","proofString":"symmetry.\napply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : IS.mem id used2 = true.","proofString":"apply IS.mem_1.\nrewrite A, U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : IS.In id used2.","proofString":"rewrite A, U.\neapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd0 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd0 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd0 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (gd2 : globdef fundef unit) (GD2 : (prog_defmap p2) ! id = Some gd2) (A : id = prog_main p1) : IS.In (prog_main p2) used2.","proofString":"eapply used_main; eauto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id0 : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id0 = Some gd1 ->\n(prog_defmap p2) ! id0 = Some gd2 ->\nIn id0 (prog_public p1) /\\\nIn id0 (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) (id : positive) (GD1 : (prog_defmap p1) ! id = None) (GD2 : (prog_defmap p2) ! id = None) : link_prog_merge (if IS.mem id used1 then None else None)\n  (if IS.mem id used2 then None else None) =\n(if IS.mem id used1 || IS.mem id used2\n then link_prog_merge None None\n else None).","proofString":"destruct (IS.mem id used1), (IS.mem id used2); auto."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : list_norepet\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n       prog_public := prog_public tp1 ++ prog_public tp2;\n       prog_main := prog_main tp1\n     |}).","proofString":"intros.\napply PTree.elements_keys_norepet."},{"statement":"(p1 p2 tp1 tp2 p : program) (H : link p1 p2 = Some p) (used1 : IS.t) (A1 : valid_used_set p1 used1) (B1 : match_prog_1 used1 p1 tp1) (used2 : IS.t) (A2 : valid_used_set p2 used2) (B2 : match_prog_1 used2 p2 tp2) (U : prog_main p1 = prog_main p2) (V : forall (id : positive) (gd1 gd2 : globdef fundef unit),\n(prog_defmap p1) ! id = Some gd1 ->\n(prog_defmap p2) ! id = Some gd2 ->\nIn id (prog_public p1) /\\\nIn id (prog_public p2) /\\\n(exists gd : globdef fundef unit, link gd1 gd2 = Some gd)) (W : p =\n{|\n  prog_defs :=\n    PTree.elements\n      (PTree.combine link_prog_merge (prog_defmap p1) (prog_defmap p2));\n  prog_public := prog_public p1 ++ prog_public p2;\n  prog_main := prog_main p1\n|}) : list_norepet\n  (prog_defs_names\n     {|\n       prog_defs :=\n         PTree.elements\n           (PTree.combine link_prog_merge (prog_defmap tp1) (prog_defmap tp2));\n       prog_public := prog_public tp1 ++ prog_public tp2;\n       prog_main := prog_main tp1\n     |}).","proofString":"apply PTree.elements_keys_norepet."}]}