{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Calc/Plus.v","fileSamples":[{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) : (IZR m1 * bpow e1)%R = (IZR m1 * bpow (e1 - e) * bpow e)%R.","conclusion":"(IZR m1 * bpow e1)%R = (IZR m1 * bpow (e1 - e) * bpow e)%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z)","proofString":"rewrite Rmult_assoc, <- bpow_plus.\napply (f_equal (fun v => IZR m1 * bpow v)%R).\nring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) : (IZR m1 * bpow e1)%R = (IZR m1 * bpow (e1 - e + e))%R.","conclusion":"(IZR m1 * bpow e1)%R = (IZR m1 * bpow (e1 - e + e))%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z)","proofString":"apply (f_equal (fun v => IZR m1 * bpow v)%R).\nring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) : e1 = (e1 - e + e)%Z.","conclusion":"e1 = (e1 - e + e)%Z","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z)","proofString":"ring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) : inbetween (IZR (m2 / beta ^ (e - e2)) * bpow e + IZR m1 * bpow e1)\n  ((IZR (m2 / beta ^ (e - e2)) + 1) * bpow e + IZR m1 * bpow e1)\n  (IZR m2 * bpow e2 + IZR m1 * bpow e1)\n  (new_location (beta ^ (e - e2)) (m2 mod beta ^ (e - e2))\n     SpecFloat.loc_Exact).","conclusion":"inbetween (IZR (m2 / beta ^ (e - e2)) * bpow e + IZR m1 * bpow e1)\n  ((IZR (m2 / beta ^ (e - e2)) + 1) * bpow e + IZR m1 * bpow e1)\n  (IZR m2 * bpow e2 + IZR m1 * bpow e1)\n  (new_location (beta ^ (e - e2)) (m2 mod beta ^ (e - e2))\n     SpecFloat.loc_Exact)","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z)","proofString":"apply inbetween_plus_compat.\nset (k := (e - e2)%Z).\nrewrite <- (plus_IZR _ 1).\nreplace e with (e2 + k)%Z by (unfold k ; ring).\napply inbetween_float_new_location.\nexact He2.\nnow constructor 1."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) : inbetween (IZR (m2 / beta ^ (e - e2)) * bpow e)\n  ((IZR (m2 / beta ^ (e - e2)) + 1) * bpow e) (IZR m2 * bpow e2)\n  (new_location (beta ^ (e - e2)) (m2 mod beta ^ (e - e2))\n     SpecFloat.loc_Exact).","conclusion":"inbetween (IZR (m2 / beta ^ (e - e2)) * bpow e)\n  ((IZR (m2 / beta ^ (e - e2)) + 1) * bpow e) (IZR m2 * bpow e2)\n  (new_location (beta ^ (e - e2)) (m2 mod beta ^ (e - e2))\n     SpecFloat.loc_Exact)","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z)","proofString":"set (k := (e - e2)%Z).\nrewrite <- (plus_IZR _ 1).\nreplace e with (e2 + k)%Z by (unfold k ; ring).\napply inbetween_float_new_location.\nexact He2.\nnow constructor 1."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) (k : Z) : inbetween_float beta m2 e2 (IZR m2 * bpow e2) SpecFloat.loc_Exact.","conclusion":"inbetween_float beta m2 e2 (IZR m2 * bpow e2) SpecFloat.loc_Exact","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (0 < e - e2)%Z) (k : Z)","proofString":"now constructor 1."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z) : (IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR (m1 * beta ^ (e1 - e) + m2 * beta ^ (- (e - e2))) * bpow e)%R.","conclusion":"(IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR (m1 * beta ^ (e1 - e) + m2 * beta ^ (- (e - e2))) * bpow e)%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z)","proofString":"rewrite plus_IZR, Rmult_plus_distr_r.\nrewrite 2!mult_IZR, 2!IZR_Zpower by lia.\nrewrite 2!Rmult_assoc, <- 2!bpow_plus.\napply (f_equal2 (fun v w => IZR m1 * bpow v + IZR m2 * bpow w)%R) ; ring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z) : (IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR (m1 * beta ^ (e1 - e)) * bpow e +\n IZR (m2 * beta ^ (- (e - e2))) * bpow e)%R.","conclusion":"(IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR (m1 * beta ^ (e1 - e)) * bpow e +\n IZR (m2 * beta ^ (- (e - e2))) * bpow e)%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z)","proofString":"rewrite 2!mult_IZR, 2!IZR_Zpower by lia.\nrewrite 2!Rmult_assoc, <- 2!bpow_plus.\napply (f_equal2 (fun v w => IZR m1 * bpow v + IZR m2 * bpow w)%R) ; ring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z) : (IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR m1 * bpow (e1 - e) * bpow e + IZR m2 * bpow (- (e - e2)) * bpow e)%R.","conclusion":"(IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR m1 * bpow (e1 - e) * bpow e + IZR m2 * bpow (- (e - e2)) * bpow e)%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z)","proofString":"rewrite 2!Rmult_assoc, <- 2!bpow_plus.\napply (f_equal2 (fun v w => IZR m1 * bpow v + IZR m2 * bpow w)%R) ; ring."},{"statement":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z) : (IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR m1 * bpow (e1 - e + e) + IZR m2 * bpow (- (e - e2) + e))%R.","conclusion":"(IZR m1 * bpow e1 + IZR m2 * bpow e2)%R =\n(IZR m1 * bpow (e1 - e + e) + IZR m2 * bpow (- (e - e2) + e))%R","hypotheses":"(m1 e1 m2 e2 e : Z) (He1 : (e <= e1)%Z) (He2 : (e - e2 <= 0)%Z)","proofString":"apply (f_equal2 (fun v w => IZR m1 * bpow v + IZR m2 * bpow w)%R) ; ring."},{"statement":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z) : (let '(m, l) := Fplus_core m1 e1 m2 e2 e in inbetween_float beta m e z l) ->\nlet\n'(m, e0, l) := let (m, l) := Fplus_core m1 e1 m2 e2 e in (m, e, l) in\n (l = SpecFloat.loc_Exact \\/ (e0 <= cexp beta fexp z)%Z) /\\\n inbetween_float beta m e0 z l.","conclusion":"(let '(m, l) := Fplus_core m1 e1 m2 e2 e in inbetween_float beta m e z l) ->\nlet\n'(m, e0, l) := let (m, l) := Fplus_core m1 e1 m2 e2 e in (m, e, l) in\n (l = SpecFloat.loc_Exact \\/ (e0 <= cexp beta fexp z)%Z) /\\\n inbetween_float beta m e0 z l","hypotheses":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z)","proofString":"destruct Fplus_core as [m' l].\nrefine (fun H => conj _ H).\nnow right."},{"statement":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z) (m' : Z) (l : SpecFloat.location) : inbetween_float beta m' e z l ->\n(l = SpecFloat.loc_Exact \\/ (e <= cexp beta fexp z)%Z) /\\\ninbetween_float beta m' e z l.","conclusion":"inbetween_float beta m' e z l ->\n(l = SpecFloat.loc_Exact \\/ (e <= cexp beta fexp z)%Z) /\\\ninbetween_float beta m' e z l","hypotheses":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z) (m' : Z) (l : SpecFloat.location)","proofString":"refine (fun H => conj _ H).\nnow right."},{"statement":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z) (m' : Z) (l : SpecFloat.location) (H : inbetween_float beta m' e z l) : l = SpecFloat.loc_Exact \\/ (e <= cexp beta fexp z)%Z.","conclusion":"l = SpecFloat.loc_Exact \\/ (e <= cexp beta fexp z)%Z","hypotheses":"(m1 e1 m2 e2 : Z) (Hm1 : m1 <> 0%Z) (Hm2 : m2 <> 0%Z) (p1 : Z) (p2 : Z) (e : Z) (Hp : (2 <= Z.abs (p1 - p2))%Z) (z : R) (Hz : (e <= cexp beta fexp z)%Z) (He He' : (e <= e1)%Z) (m' : Z) (l : SpecFloat.location) (H : inbetween_float beta m' e z l)","proofString":"now right."}]}