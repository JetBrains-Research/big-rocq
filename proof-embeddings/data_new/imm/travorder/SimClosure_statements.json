{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/travorder/SimClosure.v","fileSamples":[{"statement":"(l : trav_label) (tc1 tc2 : trav_label -> Prop) (STEP : restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2) : tc2 ≡₁ tc1 ∪₁ eq l.","conclusion":"tc2 ≡₁ tc1 ∪₁ eq l","hypotheses":"(l : trav_label) (tc1 tc2 : trav_label -> Prop) (STEP : restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2)","proofString":"generalize STEP.\nbasic_solver."},{"statement":"(l : trav_label) (tc1 tc2 : trav_label -> Prop) (STEP : restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2) : restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2 ->\ntc2 ≡₁ tc1 ∪₁ eq l.","conclusion":"restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2 ->\ntc2 ≡₁ tc1 ∪₁ eq l","hypotheses":"(l : trav_label) (tc1 tc2 : trav_label -> Prop) (STEP : restr_rel (iord_coherent G sc)\n  (⦗fun tc : trav_label -> Prop => set_compl tc l⦘\n   ⨾ (fun tc tc' : trav_label -> Prop => tc' ≡₁ tc ∪₁ eq l)) tc1 tc2)","proofString":"basic_solver."},{"statement":"(tc : trav_label -> Prop) : covered (eq ta_cover <*> (Rel ∩₁ issued tc)) ≡₁ Rel ∩₁ issued tc.","conclusion":"covered (eq ta_cover <*> (Rel ∩₁ issued tc)) ≡₁ Rel ∩₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfold covered, set_pair.\nsplit; unfolder; ins; do 2 desf.\neexists (_, _); eauto."},{"statement":"(tc : trav_label -> Prop) : event\n↑₁ ((fun ab : trav_action * actid =>\n     let (a, b) := ab in ta_cover = a /\\ (Rel ∩₁ issued tc) b)\n    ∩₁ action ↓₁ eq ta_cover) ≡₁ Rel ∩₁ issued tc.","conclusion":"event\n↑₁ ((fun ab : trav_action * actid =>\n     let (a, b) := ab in ta_cover = a /\\ (Rel ∩₁ issued tc) b)\n    ∩₁ action ↓₁ eq ta_cover) ≡₁ Rel ∩₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"split; unfolder; ins; do 2 desf.\neexists (_, _); eauto."},{"statement":"(tc : trav_label -> Prop) (x : actid) (H : is_rel lab x) (H0 : issued tc x) : exists y : trav_label,\n  ((let (a, b) := y in ta_cover = a /\\ is_rel lab b /\\ issued tc b) /\\\n   ta_cover = action y) /\\ event y = x.","conclusion":"exists y : trav_label,\n  ((let (a, b) := y in ta_cover = a /\\ is_rel lab b /\\ issued tc b) /\\\n   ta_cover = action y) /\\ event y = x","hypotheses":"(tc : trav_label -> Prop) (x : actid) (H : is_rel lab x) (H0 : issued tc x)","proofString":"eexists (_, _); eauto."},{"statement":"(tc1 tc2 : trav_label -> Prop) : (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered (tc1 ∪₁ tc2)⦘ ⨾ rmw)\n≡₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc1⦘ ⨾ rmw)\n   ∪₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc2⦘ ⨾ rmw).","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered (tc1 ∪₁ tc2)⦘ ⨾ rmw)\n≡₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc1⦘ ⨾ rmw)\n   ∪₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc2⦘ ⨾ rmw)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"rewrite !set_pair_alt.\nunfold covered.\nbasic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd ↓₁ codom_rel (⦗covered (tc1 ∪₁ tc2)⦘ ⨾ rmw)\n≡₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗covered tc1⦘ ⨾ rmw)\n   ∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n      ∩₁ snd ↓₁ codom_rel (⦗covered tc2⦘ ⨾ rmw).","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd ↓₁ codom_rel (⦗covered (tc1 ∪₁ tc2)⦘ ⨾ rmw)\n≡₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗covered tc1⦘ ⨾ rmw)\n   ∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n      ∩₁ snd ↓₁ codom_rel (⦗covered tc2⦘ ⨾ rmw)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"unfold covered.\nbasic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel (⦗event ↑₁ ((tc1 ∪₁ tc2) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n≡₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc1 ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n   ∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n      ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc2 ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw).","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel (⦗event ↑₁ ((tc1 ∪₁ tc2) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n≡₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc1 ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n   ∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n      ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc2 ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : eq ta_cover <*> (Rel ∩₁ issued (tc1 ∪₁ tc2))\n≡₁ eq ta_cover <*> (Rel ∩₁ issued tc1) ∪₁ eq ta_cover <*> (Rel ∩₁ issued tc2).","conclusion":"eq ta_cover <*> (Rel ∩₁ issued (tc1 ∪₁ tc2))\n≡₁ eq ta_cover <*> (Rel ∩₁ issued tc1) ∪₁ eq ta_cover <*> (Rel ∩₁ issued tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"rewrite !set_pair_alt.\nunfold issued.\nbasic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued (tc1 ∪₁ tc2))\n≡₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc1)\n   ∪₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc2).","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued (tc1 ∪₁ tc2))\n≡₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc1)\n   ∪₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"unfold issued.\nbasic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : fst ↓₁ eq ta_cover\n∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ ((tc1 ∪₁ tc2) ∩₁ action ↓₁ eq ta_issue))\n≡₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc1 ∩₁ action ↓₁ eq ta_issue))\n   ∪₁ fst ↓₁ eq ta_cover\n      ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc2 ∩₁ action ↓₁ eq ta_issue)).","conclusion":"fst ↓₁ eq ta_cover\n∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ ((tc1 ∪₁ tc2) ∩₁ action ↓₁ eq ta_issue))\n≡₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc1 ∩₁ action ↓₁ eq ta_issue))\n   ∪₁ fst ↓₁ eq ta_cover\n      ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc2 ∩₁ action ↓₁ eq ta_issue))","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(tc1 tc2 : trav_label -> Prop) : tc1 ∪₁ tc2 ∪₁ rmw_clos (tc1 ∪₁ tc2) ∪₁ rel_clos (tc1 ∪₁ tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2).","conclusion":"tc1 ∪₁ tc2 ∪₁ rmw_clos (tc1 ∪₁ tc2) ∪₁ rel_clos (tc1 ∪₁ tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"rewrite rel_clos_dist, rmw_clos_dist.\nbasic_solver."},{"statement":"(tc1 tc2 : trav_label -> Prop) : tc1 ∪₁ tc2 ∪₁ (rmw_clos tc1 ∪₁ rmw_clos tc2)\n∪₁ (rel_clos tc1 ∪₁ rel_clos tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2).","conclusion":"tc1 ∪₁ tc2 ∪₁ (rmw_clos tc1 ∪₁ rmw_clos tc2)\n∪₁ (rel_clos tc1 ∪₁ rel_clos tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"basic_solver."},{"statement":"∅\n∪₁ (eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗event ↑₁ (∅ ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n∪₁ eq ta_cover <*> (Rel ∩₁ event ↑₁ (∅ ∩₁ action ↓₁ eq ta_issue)) ≡₁ ∅.","conclusion":"∅\n∪₁ (eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗event ↑₁ (∅ ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n∪₁ eq ta_cover <*> (Rel ∩₁ event ↑₁ (∅ ∩₁ action ↓₁ eq ta_issue)) ≡₁ ∅","hypotheses":"","proofString":"rewrite !set_pair_alt.\nbasic_solver."},{"statement":"∅\n∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (∅ ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n∪₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (∅ ∩₁ action ↓₁ eq ta_issue)) ≡₁ ∅.","conclusion":"∅\n∪₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (∅ ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n∪₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (∅ ∩₁ action ↓₁ eq ta_issue)) ≡₁ ∅","hypotheses":"","proofString":"basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗covered ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))⦘\n   ⨾ rmw) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗covered ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))⦘\n   ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop)","proofString":"unfold covered.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ ((eq ta_cover ∪₁ eq ta_issue) <*>\n        codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ ((eq ta_cover ∪₁ eq ta_issue) <*>\n        codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop)","proofString":"rewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ (fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n              ∩₁ snd\n                 ↓₁ codom_rel\n                      (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ (fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n              ∩₁ snd\n                 ↓₁ codom_rel\n                      (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop)","proofString":"unfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) : forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n        (exists x1 z : actid,\n           (x1 = z /\\\n            (exists y0 : trav_label,\n               (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x1)) /\\\n           rmw z (snd y))) /\\ ta_cover = action y) /\\ \n      event y = x0) /\\ rmw x0 (snd x)) -> False.","conclusion":"forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n        (exists x1 z : actid,\n           (x1 = z /\\\n            (exists y0 : trav_label,\n               (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x1)) /\\\n           rmw z (snd y))) /\\ ta_cover = action y) /\\ \n      event y = x0) /\\ rmw x0 (snd x)) -> False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop)","proofString":"ins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n        (exists x1 z : actid,\n           (x1 = z /\\\n            (exists y0 : trav_label,\n               (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x1)) /\\\n           rmw z (snd y))) /\\ ta_cover = action y) /\\ \n      event y = x0) /\\ rmw x0 (snd x))) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n        (exists x1 z : actid,\n           (x1 = z /\\\n            (exists y0 : trav_label,\n               (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x1)) /\\\n           rmw z (snd y))) /\\ ta_cover = action y) /\\ \n      event y = x0) /\\ rmw x0 (snd x)))","proofString":"desc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x \\/ ta_issue = fst x) (x0 : actid) (y : trav_label) (H0 : ta_cover = fst y \\/ ta_issue = fst y) (x1 z : actid) (H4 : x1 = z) (y0 : trav_label) (H6 : tc y0) (H8 : ta_cover = action y0) (H7 : event y0 = x1) (H5 : rmw z (snd y)) (H3 : ta_cover = action y) (H2 : event y = x0) (H1 : rmw x0 (snd x)) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x \\/ ta_issue = fst x) (x0 : actid) (y : trav_label) (H0 : ta_cover = fst y \\/ ta_issue = fst y) (x1 z : actid) (H4 : x1 = z) (y0 : trav_label) (H6 : tc y0) (H8 : ta_cover = action y0) (H7 : event y0 = x1) (H5 : rmw z (snd y)) (H3 : ta_cover = action y) (H2 : event y = x0) (H1 : rmw x0 (snd x))","proofString":"destruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = fst (a1, e1) \\/ ta_issue = fst (a1, e1)) (x1 z : actid) (H4 : x1 = z) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = action (a2, e2)) (H7 : event (a2, e2) = x1) (H5 : rmw z (snd (a1, e1))) (H3 : ta_cover = action (a1, e1)) (H2 : event (a1, e1) = x0) (H1 : rmw x0 (snd (a3, e3))) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = fst (a1, e1) \\/ ta_issue = fst (a1, e1)) (x1 z : actid) (H4 : x1 = z) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = action (a2, e2)) (H7 : event (a2, e2) = x1) (H5 : rmw z (snd (a1, e1))) (H3 : ta_cover = action (a1, e1)) (H2 : event (a1, e1) = x0) (H1 : rmw x0 (snd (a3, e3)))","proofString":"ins.\nsubst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1 \\/ ta_issue = a1) (x1 z : actid) (H4 : x1 = z) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = a2) (H7 : e2 = x1) (H5 : rmw z e1) (H3 : ta_cover = a1) (H2 : e1 = x0) (H1 : rmw x0 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1 \\/ ta_issue = a1) (x1 z : actid) (H4 : x1 = z) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = a2) (H7 : e2 = x1) (H5 : rmw z e1) (H3 : ta_cover = a1) (H2 : e1 = x0) (H1 : rmw x0 e3)","proofString":"subst x0 x1 z.\nsubst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1 \\/ ta_issue = a1) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = a2) (H5 : rmw e2 e1) (H3 : ta_cover = a1) (H1 : rmw e1 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1 \\/ ta_issue = a1) (a2 : trav_action) (e2 : actid) (H6 : tc (a2, e2)) (H8 : ta_cover = a2) (H5 : rmw e2 e1) (H3 : ta_cover = a1) (H1 : rmw e1 e3)","proofString":"subst.\neapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H0 : ta_cover = ta_cover \\/ ta_issue = ta_cover) (e2 : actid) (H6 : tc (ta_cover, e2)) (H5 : rmw e2 e1) (H1 : rmw e1 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H0 : ta_cover = ta_cover \\/ ta_issue = ta_cover) (e2 : actid) (H6 : tc (ta_cover, e2)) (H5 : rmw e2 e1) (H1 : rmw e1 e3)","proofString":"eapply wf_rmwD, seq_eqv_lr in H5, H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H0 : ta_cover = ta_cover \\/ ta_issue = ta_cover) (e2 : actid) (H6 : tc (ta_cover, e2)) (H5 : is_r lab e2 /\\ rmw e2 e1 /\\ is_w lab e1) (H1 : is_r lab e1 /\\ rmw e1 e3 /\\ is_w lab e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H0 : ta_cover = ta_cover \\/ ta_issue = ta_cover) (e2 : actid) (H6 : tc (ta_cover, e2)) (H5 : is_r lab e2 /\\ rmw e2 e1 /\\ is_w lab e1) (H1 : is_r lab e1 /\\ rmw e1 e3 /\\ is_w lab e3)","proofString":"type_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq ta_cover <*> (Rel ∩₁ issued tc))⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq ta_cover <*> (Rel ∩₁ issued tc))⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc)","proofString":"unfold covered, issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc)","proofString":"rewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ (fst ↓₁ eq ta_cover\n              ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ (fst ↓₁ eq ta_cover\n              ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc)","proofString":"unfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) : forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      ((ta_cover = fst y /\\\n        is_rel lab (snd y) /\\\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n       ta_cover = action y) /\\ event y = x0) /\\ rmw x0 (snd x)) -> False.","conclusion":"forall x : trav_label,\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      ((ta_cover = fst y /\\\n        is_rel lab (snd y) /\\\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n       ta_cover = action y) /\\ event y = x0) /\\ rmw x0 (snd x)) -> False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc)","proofString":"ins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (x : trav_label) (H : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      ((ta_cover = fst y /\\\n        is_rel lab (snd y) /\\\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n       ta_cover = action y) /\\ event y = x0) /\\ rmw x0 (snd x))) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (x : trav_label) (H : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label,\n      ((ta_cover = fst y /\\\n        is_rel lab (snd y) /\\\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n       ta_cover = action y) /\\ event y = x0) /\\ rmw x0 (snd x)))","proofString":"desc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (x : trav_label) (H : ta_cover = fst x \\/ ta_issue = fst x) (x0 : actid) (y : trav_label) (H0 : ta_cover = fst y) (H4 : is_rel lab (snd y)) (y0 : trav_label) (H5 : tc y0) (H7 : ta_issue = action y0) (H6 : event y0 = snd y) (H3 : ta_cover = action y) (H2 : event y = x0) (H1 : rmw x0 (snd x)) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (x : trav_label) (H : ta_cover = fst x \\/ ta_issue = fst x) (x0 : actid) (y : trav_label) (H0 : ta_cover = fst y) (H4 : is_rel lab (snd y)) (y0 : trav_label) (H5 : tc y0) (H7 : ta_issue = action y0) (H6 : event y0 = snd y) (H3 : ta_cover = action y) (H2 : event y = x0) (H1 : rmw x0 (snd x))","proofString":"destruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = fst (a1, e1)) (H4 : is_rel lab (snd (a1, e1))) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = action (a2, e2)) (H6 : event (a2, e2) = snd (a1, e1)) (H3 : ta_cover = action (a1, e1)) (H2 : event (a1, e1) = x0) (H1 : rmw x0 (snd (a3, e3))) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = fst (a1, e1)) (H4 : is_rel lab (snd (a1, e1))) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = action (a2, e2)) (H6 : event (a2, e2) = snd (a1, e1)) (H3 : ta_cover = action (a1, e1)) (H2 : event (a1, e1) = x0) (H1 : rmw x0 (snd (a3, e3)))","proofString":"ins.\nsubst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_cover = a1) (H2 : e1 = x0) (H1 : rmw x0 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (x0 : actid) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_cover = a1) (H2 : e1 = x0) (H1 : rmw x0 e3)","proofString":"subst x0.\nsubst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_cover = a1) (H1 : rmw e1 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (a1 : trav_action) (e1 : actid) (H0 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_cover = a1) (H1 : rmw e1 e3)","proofString":"subst.\nforward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3)","proofString":"forward eapply tlsc_I_in_W with (x := (ta_issue, e1)); eauto; [basic_solver| ].\nintros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3) : (event ↓₁ W) (ta_issue, e1) -> False.","conclusion":"(event ↓₁ W) (ta_issue, e1) -> False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3)","proofString":"intros [=We1].\napply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3) (We1 : is_w lab e1 = true) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : rmw e1 e3) (We1 : is_w lab e1 = true)","proofString":"apply wf_rmwD, seq_eqv_lr in H1; eauto.\ntype_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : is_r lab e1 /\\ rmw e1 e3 /\\ is_w lab e3) (We1 : is_w lab e1 = true) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3 \\/ ta_issue = a3) (e1 : actid) (H4 : is_rel lab e1) (H5 : tc (ta_issue, e1)) (H3 : ta_cover = ta_cover) (H1 : is_r lab e1 /\\ rmw e1 e3 /\\ is_w lab e3) (We1 : is_w lab e1 = true)","proofString":"type_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : eq ta_cover <*>\n(Rel\n ∩₁ issued ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw)))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw).","conclusion":"eq ta_cover <*>\n(Rel\n ∩₁ issued ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw)))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"unfold covered, issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ ((eq ta_cover ∪₁ eq ta_issue) <*>\n        codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw).","conclusion":"eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ ((eq ta_cover ∪₁ eq ta_issue) <*>\n        codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ (fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n              ∩₁ snd\n                 ↓₁ codom_rel\n                      (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw).","conclusion":"fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ (fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n              ∩₁ snd\n                 ↓₁ codom_rel\n                      (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n   ∩₁ snd ↓₁ codom_rel (⦗event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"unfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : forall x : trav_label,\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n     (exists x0 : actid,\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x0) /\\\n        rmw x0 (snd y))) /\\ ta_issue = action y) /\\ \n   event y = snd x) ->\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x0) /\\\n   rmw x0 (snd x)).","conclusion":"forall x : trav_label,\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n     (exists x0 : actid,\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x0) /\\\n        rmw x0 (snd y))) /\\ ta_issue = action y) /\\ \n   event y = snd x) ->\n(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x0) /\\\n   rmw x0 (snd x))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"ins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n     (exists x0 : actid,\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x0) /\\\n        rmw x0 (snd y))) /\\ ta_issue = action y) /\\ \n   event y = snd x)) : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x0) /\\\n   rmw x0 (snd x)).","conclusion":"(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x0 : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x0) /\\\n   rmw x0 (snd x))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   (((ta_cover = fst y \\/ ta_issue = fst y) /\\\n     (exists x0 : actid,\n        (exists y0 : trav_label,\n           (tc y0 /\\ ta_cover = action y0) /\\ event y0 = x0) /\\\n        rmw x0 (snd y))) /\\ ta_issue = action y) /\\ \n   event y = snd x))","proofString":"desc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : ta_cover = fst x) (H0 : is_rel lab (snd x)) (y : trav_label) (H1 : ta_cover = fst y \\/ ta_issue = fst y) (x0 : actid) (y0 : trav_label) (H4 : tc y0) (H7 : ta_cover = action y0) (H6 : event y0 = x0) (H5 : rmw x0 (snd y)) (H3 : ta_issue = action y) (H2 : event y = snd x) : (ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x1 : actid,\n   (exists y1 : trav_label, (tc y1 /\\ ta_cover = action y1) /\\ event y1 = x1) /\\\n   rmw x1 (snd x)).","conclusion":"(ta_cover = fst x \\/ ta_issue = fst x) /\\\n(exists x1 : actid,\n   (exists y1 : trav_label, (tc y1 /\\ ta_cover = action y1) /\\ event y1 = x1) /\\\n   rmw x1 (snd x))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : ta_cover = fst x) (H0 : is_rel lab (snd x)) (y : trav_label) (H1 : ta_cover = fst y \\/ ta_issue = fst y) (x0 : actid) (y0 : trav_label) (H4 : tc y0) (H7 : ta_cover = action y0) (H6 : event y0 = x0) (H5 : rmw x0 (snd y)) (H3 : ta_issue = action y) (H2 : event y = snd x)","proofString":"destruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3)) (H0 : is_rel lab (snd (a3, e3))) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = fst (a1, e1) \\/ ta_issue = fst (a1, e1)) (x0 : actid) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = action (a2, e2)) (H6 : event (a2, e2) = x0) (H5 : rmw x0 (snd (a1, e1))) (H3 : ta_issue = action (a1, e1)) (H2 : event (a1, e1) = snd (a3, e3)) : (ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x (snd (a3, e3))).","conclusion":"(ta_cover = fst (a3, e3) \\/ ta_issue = fst (a3, e3)) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x (snd (a3, e3)))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3)) (H0 : is_rel lab (snd (a3, e3))) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = fst (a1, e1) \\/ ta_issue = fst (a1, e1)) (x0 : actid) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = action (a2, e2)) (H6 : event (a2, e2) = x0) (H5 : rmw x0 (snd (a1, e1))) (H3 : ta_issue = action (a1, e1)) (H2 : event (a1, e1) = snd (a3, e3))","proofString":"ins.\nsubst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1 \\/ ta_issue = a1) (x0 : actid) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = a2) (H6 : e2 = x0) (H5 : rmw x0 e1) (H3 : ta_issue = a1) (H2 : e1 = e3) : (ta_cover = a3 \\/ ta_issue = a3) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3).","conclusion":"(ta_cover = a3 \\/ ta_issue = a3) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1 \\/ ta_issue = a1) (x0 : actid) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = a2) (H6 : e2 = x0) (H5 : rmw x0 e1) (H3 : ta_issue = a1) (H2 : e1 = e3)","proofString":"subst x0.\nsubst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1 \\/ ta_issue = a1) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = a2) (H5 : rmw e2 e1) (H3 : ta_issue = a1) (H2 : e1 = e3) : (ta_cover = a3 \\/ ta_issue = a3) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3).","conclusion":"(ta_cover = a3 \\/ ta_issue = a3) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1 \\/ ta_issue = a1) (a2 : trav_action) (e2 : actid) (H4 : tc (a2, e2)) (H7 : ta_cover = a2) (H5 : rmw e2 e1) (H3 : ta_issue = a1) (H2 : e1 = e3)","proofString":"subst.\nsplits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (e3 : actid) (H0 : is_rel lab e3) (H1 : ta_cover = ta_issue \\/ ta_issue = ta_issue) (e2 : actid) (H4 : tc (ta_cover, e2)) (H5 : rmw e2 e3) : (ta_cover = ta_cover \\/ ta_issue = ta_cover) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3).","conclusion":"(ta_cover = ta_cover \\/ ta_issue = ta_cover) /\\\n(exists x : actid,\n   (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n   rmw x e3)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (e3 : actid) (H0 : is_rel lab e3) (H1 : ta_cover = ta_issue \\/ ta_issue = ta_issue) (e2 : actid) (H4 : tc (ta_cover, e2)) (H5 : rmw e2 e3)","proofString":"splits; [by vauto| ].\nrepeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (e3 : actid) (H0 : is_rel lab e3) (H1 : ta_cover = ta_issue \\/ ta_issue = ta_issue) (e2 : actid) (H4 : tc (ta_cover, e2)) (H5 : rmw e2 e3) : exists x : actid,\n  (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n  rmw x e3.","conclusion":"exists x : actid,\n  (exists y : trav_label, (tc y /\\ ta_cover = action y) /\\ event y = x) /\\\n  rmw x e3","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (e3 : actid) (H0 : is_rel lab e3) (H1 : ta_cover = ta_issue \\/ ta_issue = ta_issue) (e2 : actid) (H4 : tc (ta_cover, e2)) (H5 : rmw e2 e3)","proofString":"repeat (eexists; eauto)."},{"statement":"(tc : trav_label -> Prop) : eq ta_cover <*> (Rel ∩₁ issued (eq ta_cover <*> (Rel ∩₁ issued tc)))\n⊆₁ eq ta_cover <*> (Rel ∩₁ issued tc).","conclusion":"eq ta_cover <*> (Rel ∩₁ issued (eq ta_cover <*> (Rel ∩₁ issued tc)))\n⊆₁ eq ta_cover <*> (Rel ∩₁ issued tc)","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfold issued.\nrewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) : eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)).","conclusion":"eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))","hypotheses":"(tc : trav_label -> Prop)","proofString":"rewrite !set_pair_alt.\nunfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) : fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ (fst ↓₁ eq ta_cover\n              ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)).","conclusion":"fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ (fst ↓₁ eq ta_cover\n              ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ eq ta_cover\n   ∩₁ snd ↓₁ (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfolder.\nins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) : forall x : trav_label,\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   ((ta_cover = fst y /\\\n     is_rel lab (snd y) /\\\n     (exists y0 : trav_label,\n        (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n    ta_issue = action y) /\\ event y = snd x) ->\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = snd x).","conclusion":"forall x : trav_label,\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   ((ta_cover = fst y /\\\n     is_rel lab (snd y) /\\\n     (exists y0 : trav_label,\n        (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n    ta_issue = action y) /\\ event y = snd x) ->\nta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = snd x)","hypotheses":"(tc : trav_label -> Prop)","proofString":"ins.\ndesc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   ((ta_cover = fst y /\\\n     is_rel lab (snd y) /\\\n     (exists y0 : trav_label,\n        (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n    ta_issue = action y) /\\ event y = snd x)) : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = snd x).","conclusion":"ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = snd x)","hypotheses":"(tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y : trav_label,\n   ((ta_cover = fst y /\\\n     is_rel lab (snd y) /\\\n     (exists y0 : trav_label,\n        (tc y0 /\\ ta_issue = action y0) /\\ event y0 = snd y)) /\\\n    ta_issue = action y) /\\ event y = snd x))","proofString":"desc.\ndestruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x) (H0 : is_rel lab (snd x)) (y : trav_label) (H1 : ta_cover = fst y) (H4 : is_rel lab (snd y)) (y0 : trav_label) (H5 : tc y0) (H7 : ta_issue = action y0) (H6 : event y0 = snd y) (H3 : ta_issue = action y) (H2 : event y = snd x) : ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y1 : trav_label, (tc y1 /\\ ta_issue = action y1) /\\ event y1 = snd x).","conclusion":"ta_cover = fst x /\\\nis_rel lab (snd x) /\\\n(exists y1 : trav_label, (tc y1 /\\ ta_issue = action y1) /\\ event y1 = snd x)","hypotheses":"(tc : trav_label -> Prop) (x : trav_label) (H : ta_cover = fst x) (H0 : is_rel lab (snd x)) (y : trav_label) (H1 : ta_cover = fst y) (H4 : is_rel lab (snd y)) (y0 : trav_label) (H5 : tc y0) (H7 : ta_issue = action y0) (H6 : event y0 = snd y) (H3 : ta_issue = action y) (H2 : event y = snd x)","proofString":"destruct y as [a1 e1], y0 as [a2 e2], x as [a3 e3].\nins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3)) (H0 : is_rel lab (snd (a3, e3))) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = fst (a1, e1)) (H4 : is_rel lab (snd (a1, e1))) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = action (a2, e2)) (H6 : event (a2, e2) = snd (a1, e1)) (H3 : ta_issue = action (a1, e1)) (H2 : event (a1, e1) = snd (a3, e3)) : ta_cover = fst (a3, e3) /\\\nis_rel lab (snd (a3, e3)) /\\\n(exists y : trav_label,\n   (tc y /\\ ta_issue = action y) /\\ event y = snd (a3, e3)).","conclusion":"ta_cover = fst (a3, e3) /\\\nis_rel lab (snd (a3, e3)) /\\\n(exists y : trav_label,\n   (tc y /\\ ta_issue = action y) /\\ event y = snd (a3, e3))","hypotheses":"(tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = fst (a3, e3)) (H0 : is_rel lab (snd (a3, e3))) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = fst (a1, e1)) (H4 : is_rel lab (snd (a1, e1))) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = action (a2, e2)) (H6 : event (a2, e2) = snd (a1, e1)) (H3 : ta_issue = action (a1, e1)) (H2 : event (a1, e1) = snd (a3, e3))","proofString":"ins.\nsubst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_issue = a1) (H2 : e1 = e3) : ta_cover = a3 /\\\nis_rel lab e3 /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = e3).","conclusion":"ta_cover = a3 /\\\nis_rel lab e3 /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = e3)","hypotheses":"(tc : trav_label -> Prop) (a3 : trav_action) (e3 : actid) (H : ta_cover = a3) (H0 : is_rel lab e3) (a1 : trav_action) (e1 : actid) (H1 : ta_cover = a1) (H4 : is_rel lab e1) (a2 : trav_action) (e2 : actid) (H5 : tc (a2, e2)) (H7 : ta_issue = a2) (H6 : e2 = e1) (H3 : ta_issue = a1) (H2 : e1 = e3)","proofString":"subst.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (e3 : actid) (H0 : is_rel lab e3) (H5 : tc (ta_issue, e3)) (H4 : is_rel lab e3) (H3 : ta_issue = ta_cover) : ta_cover = ta_cover /\\\nis_rel lab e3 /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = e3).","conclusion":"ta_cover = ta_cover /\\\nis_rel lab e3 /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = e3)","hypotheses":"(tc : trav_label -> Prop) (e3 : actid) (H0 : is_rel lab e3) (H5 : tc (ta_issue, e3)) (H4 : is_rel lab e3) (H3 : ta_issue = ta_cover)","proofString":"splits; eauto."},{"statement":"(tc1 tc2 : trav_label -> Prop) : tc1 ∪₁ tc2 ∪₁ rmw_clos (tc1 ∪₁ tc2) ∪₁ rel_clos (tc1 ∪₁ tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2).","conclusion":"tc1 ∪₁ tc2 ∪₁ rmw_clos (tc1 ∪₁ tc2) ∪₁ rel_clos (tc1 ∪₁ tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"rewrite rmw_clos_dist, rel_clos_dist.\nbasic_solver."},{"statement":"(tc1 tc2 : trav_label -> Prop) : tc1 ∪₁ tc2 ∪₁ (rmw_clos tc1 ∪₁ rmw_clos tc2)\n∪₁ (rel_clos tc1 ∪₁ rel_clos tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2).","conclusion":"tc1 ∪₁ tc2 ∪₁ (rmw_clos tc1 ∪₁ rmw_clos tc2)\n∪₁ (rel_clos tc1 ∪₁ rel_clos tc2)\n≡₁ tc1 ∪₁ rmw_clos tc1 ∪₁ rel_clos tc1\n   ∪₁ (tc2 ∪₁ rmw_clos tc2 ∪₁ rel_clos tc2)","hypotheses":"(tc1 tc2 : trav_label -> Prop)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : sim_clos tc ≡₁ sim_clos (sim_clos tc).","conclusion":"sim_clos tc ≡₁ sim_clos (sim_clos tc)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"unfold sim_clos.\nsplit; [basic_solver 10| ].\nrewrite !rmw_clos_dist, !rel_clos_dist.\nrepeat (apply set_subset_union_l; split; try basic_solver).\nrewrite rmw_clos_once; basic_solver.\nrewrite rmw_rel_clos_none; basic_solver.\nrewrite rel_rmw_clos_rmw; basic_solver.\nrewrite rel_clos_idemp; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n   ∪₁ rmw_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n   ∪₁ rel_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc).","conclusion":"tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n   ∪₁ rmw_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n   ∪₁ rel_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"split; [basic_solver 10| ].\nrewrite !rmw_clos_dist, !rel_clos_dist.\nrepeat (apply set_subset_union_l; split; try basic_solver).\nrewrite rmw_clos_once; basic_solver.\nrewrite rmw_rel_clos_none; basic_solver.\nrewrite rel_rmw_clos_rmw; basic_solver.\nrewrite rel_clos_idemp; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n∪₁ rmw_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n∪₁ rel_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n∪₁ rmw_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n∪₁ rel_clos (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite !rmw_clos_dist, !rel_clos_dist.\nrepeat (apply set_subset_union_l; split; try basic_solver).\nrewrite rmw_clos_once; basic_solver.\nrewrite rmw_rel_clos_none; basic_solver.\nrewrite rel_rmw_clos_rmw; basic_solver.\nrewrite rel_clos_idemp; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n∪₁ (rmw_clos tc ∪₁ rmw_clos (rmw_clos tc) ∪₁ rmw_clos (rel_clos tc))\n∪₁ (rel_clos tc ∪₁ rel_clos (rmw_clos tc) ∪₁ rel_clos (rel_clos tc))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ rmw_clos tc ∪₁ rel_clos tc\n∪₁ (rmw_clos tc ∪₁ rmw_clos (rmw_clos tc) ∪₁ rmw_clos (rel_clos tc))\n∪₁ (rel_clos tc ∪₁ rel_clos (rmw_clos tc) ∪₁ rel_clos (rel_clos tc))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"repeat (apply set_subset_union_l; split; try basic_solver).\nrewrite rmw_clos_once; basic_solver.\nrewrite rmw_rel_clos_none; basic_solver.\nrewrite rel_rmw_clos_rmw; basic_solver.\nrewrite rel_clos_idemp; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : rmw_clos (rmw_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"rmw_clos (rmw_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite rmw_clos_once; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : rmw_clos (rel_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"rmw_clos (rel_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite rmw_rel_clos_none; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : rel_clos (rmw_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"rel_clos (rmw_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite rel_rmw_clos_rmw; basic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : rel_clos (rel_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"rel_clos (rel_clos tc) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite rel_clos_idemp; basic_solver."},{"statement":"(WF : Wf G) : exec_tls G ≡₁ exec_tls G ∪₁ rmw_clos (exec_tls G) ∪₁ rel_clos (exec_tls G).","conclusion":"exec_tls G ≡₁ exec_tls G ∪₁ rmw_clos (exec_tls G) ∪₁ rel_clos (exec_tls G)","hypotheses":"(WF : Wf G)","proofString":"split; [basic_solver| ].\nrepeat (apply set_subset_union_l; split; try basic_solver).\nunfold rmw_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\nrewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition.\nunfold rel_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\niord_dom_unfolder.\nleft.\nvauto."},{"statement":"(WF : Wf G) : exec_tls G ∪₁ rmw_clos (exec_tls G) ∪₁ rel_clos (exec_tls G) ⊆₁ exec_tls G.","conclusion":"exec_tls G ∪₁ rmw_clos (exec_tls G) ∪₁ rel_clos (exec_tls G) ⊆₁ exec_tls G","hypotheses":"(WF : Wf G)","proofString":"repeat (apply set_subset_union_l; split; try basic_solver).\nunfold rmw_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\nrewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition.\nunfold rel_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\niord_dom_unfolder.\nleft.\nvauto."},{"statement":"(WF : Wf G) : rmw_clos (exec_tls G) ⊆₁ exec_tls G.","conclusion":"rmw_clos (exec_tls G) ⊆₁ exec_tls G","hypotheses":"(WF : Wf G)","proofString":"unfold rmw_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\nrewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition."},{"statement":"(WF : Wf G) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ ((eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n         ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n            ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel\n  (⦗event\n    ↑₁ ((eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n         ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n            ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n        ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(WF : Wf G)","proofString":"repeat rewrite set_pair_alt.\nrewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition."},{"statement":"(WF : Wf G) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(WF : Wf G)","proofString":"rewrite wf_rmwE, wf_rmwD, rmw_non_init_lr; auto.\niord_dom_unfolder; [by vauto| ].\nintuition."},{"statement":"(WF : Wf G) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_cover)⦘\n         ⨾ ⦗E⦘\n           ⨾ (⦗R⦘\n              ⨾ (⦗set_compl (fun a : actid => is_init a)⦘\n                 ⨾ rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n             ⨾ ⦗E⦘)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd\n   ↓₁ codom_rel\n        (⦗event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_cover)⦘\n         ⨾ ⦗E⦘\n           ⨾ (⦗R⦘\n              ⨾ (⦗set_compl (fun a : actid => is_init a)⦘\n                 ⨾ rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n             ⨾ ⦗E⦘)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(WF : Wf G)","proofString":"iord_dom_unfolder; [by vauto| ].\nintuition."},{"statement":"(WF : Wf G) (b a0 : actid) (d7 : E a0) (d9 : ~ is_init a0) (d0 : rmw a0 b) (d4 : ~ is_init a0) (d5 : is_r lab a0) (d6 : E a0) (d1 : ~ is_init b) (d2 : is_w lab b) (d3 : E b) : ta_cover = ta_issue /\\ E b /\\ ~ is_init b \\/\n((ta_issue = ta_issue \\/ ta_reserve = ta_issue) \\/\n (exists y : thread_id,\n    (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = ta_issue)) /\\\n(E b /\\ ~ is_init b) /\\ true.","conclusion":"ta_cover = ta_issue /\\ E b /\\ ~ is_init b \\/\n((ta_issue = ta_issue \\/ ta_reserve = ta_issue) \\/\n (exists y : thread_id,\n    (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = ta_issue)) /\\\n(E b /\\ ~ is_init b) /\\ true","hypotheses":"(WF : Wf G) (b a0 : actid) (d7 : E a0) (d9 : ~ is_init a0) (d0 : rmw a0 b) (d4 : ~ is_init a0) (d5 : is_r lab a0) (d6 : E a0) (d1 : ~ is_init b) (d2 : is_w lab b) (d3 : E b)","proofString":"intuition."},{"statement":"(WF : Wf G) : rel_clos (exec_tls G) ⊆₁ exec_tls G.","conclusion":"rel_clos (exec_tls G) ⊆₁ exec_tls G","hypotheses":"(WF : Wf G)","proofString":"unfold rel_clos, exec_tls, covered, issued.\nrepeat rewrite set_pair_alt.\niord_dom_unfolder.\nleft.\nvauto."},{"statement":"(WF : Wf G) : eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ ((eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n         ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n            ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"eq ta_cover <*>\n(Rel\n ∩₁ event\n    ↑₁ ((eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n         ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n            ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n        ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(WF : Wf G)","proofString":"repeat rewrite set_pair_alt.\niord_dom_unfolder.\nleft.\nvauto."},{"statement":"(WF : Wf G) : fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"fst ↓₁ eq ta_cover\n∩₁ snd\n   ↓₁ (Rel\n       ∩₁ event\n          ↑₁ ((fst ↓₁ eq ta_cover\n               ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n               ∪₁ fst\n                  ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n                  ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))\n              ∩₁ action ↓₁ eq ta_issue))\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(WF : Wf G)","proofString":"iord_dom_unfolder.\nleft.\nvauto."},{"statement":"(WF : Wf G) (a0 : actid) (d : is_rel lab a0) (d1 : E a0) (d4 : ~ is_init a0) (d3 : is_w lab a0) : ta_cover = ta_cover /\\ E a0 /\\ ~ is_init a0 \\/\n((ta_issue = ta_cover \\/ ta_reserve = ta_cover) \\/\n (exists y : thread_id,\n    (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = ta_cover)) /\\\n(E a0 /\\ ~ is_init a0) /\\ true.","conclusion":"ta_cover = ta_cover /\\ E a0 /\\ ~ is_init a0 \\/\n((ta_issue = ta_cover \\/ ta_reserve = ta_cover) \\/\n (exists y : thread_id,\n    (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = ta_cover)) /\\\n(E a0 /\\ ~ is_init a0) /\\ true","hypotheses":"(WF : Wf G) (a0 : actid) (d : is_rel lab a0) (d1 : E a0) (d4 : ~ is_init a0) (d3 : is_w lab a0)","proofString":"left.\nvauto."},{"statement":"(WF : Wf G) (a0 : actid) (d : is_rel lab a0) (d1 : E a0) (d4 : ~ is_init a0) (d3 : is_w lab a0) : ta_cover = ta_cover /\\ E a0 /\\ ~ is_init a0.","conclusion":"ta_cover = ta_cover /\\ E a0 /\\ ~ is_init a0","hypotheses":"(WF : Wf G) (a0 : actid) (d : is_rel lab a0) (d1 : E a0) (d4 : ~ is_init a0) (d3 : is_w lab a0)","proofString":"vauto."},{"statement":"(WF : Wf G) : init_tls G ≡₁ init_tls G ∪₁ rmw_clos (init_tls G) ∪₁ rel_clos (init_tls G).","conclusion":"init_tls G ≡₁ init_tls G ∪₁ rmw_clos (init_tls G) ∪₁ rel_clos (init_tls G)","hypotheses":"(WF : Wf G)","proofString":"split; [basic_solver| ].\nrepeat (apply set_subset_union_l; split); try basic_solver.\nunfold rmw_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver.\nunfold rel_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) : init_tls G ∪₁ rmw_clos (init_tls G) ∪₁ rel_clos (init_tls G) ⊆₁ init_tls G.","conclusion":"init_tls G ∪₁ rmw_clos (init_tls G) ∪₁ rel_clos (init_tls G) ⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"repeat (apply set_subset_union_l; split); try basic_solver.\nunfold rmw_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver.\nunfold rel_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) : rmw_clos (init_tls G) ⊆₁ init_tls G.","conclusion":"rmw_clos (init_tls G) ⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"unfold rmw_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) : (eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered (init_tls G)⦘ ⨾ rmw)\n⊆₁ init_tls G.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered (init_tls G)⦘ ⨾ rmw)\n⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"rewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) : fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd ↓₁ codom_rel (⦗covered (init_tls G)⦘ ⨾ rmw) ⊆₁ \ninit_tls G.","conclusion":"fst ↓₁ (eq ta_cover ∪₁ eq ta_issue)\n∩₁ snd ↓₁ codom_rel (⦗covered (init_tls G)⦘ ⨾ rmw) ⊆₁ \ninit_tls G","hypotheses":"(WF : Wf G)","proofString":"etransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (d : covered (init_tls G) c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (d : covered (init_tls G) c) (d0 : rmw c b)","proofString":"do 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (d : exists y : trav_label, (init_tls G ∩₁ action ↓₁ eq ta_cover) y /\\ event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (d : exists y : trav_label, (init_tls G ∩₁ action ↓₁ eq ta_cover) y /\\ event y = c) (d0 : rmw c b)","proofString":"desc.\nred in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (init_tls G ∩₁ action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (init_tls G ∩₁ action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b)","proofString":"red in d.\ndesc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : init_tls G y /\\ (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : init_tls G y /\\ (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b)","proofString":"desc.\napply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : init_tls G y) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : init_tls G y) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b)","proofString":"apply init_tls_EI in d.\nred in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (event ↓₁ (E ∩₁ (fun a0 : actid => is_init a0))) y) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (event ↓₁ (E ∩₁ (fun a0 : actid => is_init a0))) y) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b)","proofString":"red in d.\napply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (E ∩₁ (fun a0 : actid => is_init a0)) (event y)) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (E ∩₁ (fun a0 : actid => is_init a0)) (event y)) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : rmw c b)","proofString":"apply rmw_non_init_lr, seq_eqv_lr in d0; auto.\ntype_solver."},{"statement":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (E ∩₁ (fun a0 : actid => is_init a0)) (event y)) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : set_compl (fun a0 : actid => is_init a0) c /\\\nrmw c b /\\ set_compl (fun a0 : actid => is_init a0) b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b c : actid) (y : trav_label) (d : (E ∩₁ (fun a0 : actid => is_init a0)) (event y)) (d2 : (action ↓₁ eq ta_cover) y) (d1 : event y = c) (d0 : set_compl (fun a0 : actid => is_init a0) c /\\\nrmw c b /\\ set_compl (fun a0 : actid => is_init a0) b)","proofString":"type_solver."},{"statement":"(WF : Wf G) : rel_clos (init_tls G) ⊆₁ init_tls G.","conclusion":"rel_clos (init_tls G) ⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"unfold rel_clos.\nrewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) : eq ta_cover <*> (Rel ∩₁ issued (init_tls G)) ⊆₁ init_tls G.","conclusion":"eq ta_cover <*> (Rel ∩₁ issued (init_tls G)) ⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"rewrite set_pair_alt.\netransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued (init_tls G)) ⊆₁ init_tls G.","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued (init_tls G)) ⊆₁ init_tls G","hypotheses":"(WF : Wf G)","proofString":"etransitivity.\nred.\nintro.\napply proj2.\niord_dom_unfolder.\ndo 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (d : issued (init_tls G) b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (d : issued (init_tls G) b)","proofString":"do 2 red in d.\ndesc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (d : exists y : trav_label, (init_tls G ∩₁ action ↓₁ eq ta_issue) y /\\ event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (d : exists y : trav_label, (init_tls G ∩₁ action ↓₁ eq ta_issue) y /\\ event y = b)","proofString":"desc.\nred in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : (init_tls G ∩₁ action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : (init_tls G ∩₁ action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"red in d.\ndesc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : init_tls G y /\\ (action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : init_tls G y /\\ (action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"desc.\napply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : init_tls G y) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : init_tls G y) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"apply init_tls_EI in d.\ndo 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : (event ↓₁ (E ∩₁ (fun a0 : actid => is_init a0))) y) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : (event ↓₁ (E ∩₁ (fun a0 : actid => is_init a0))) y) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"do 2 red in d.\ndesc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : E (event y) /\\ is_init (event y)) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : E (event y) /\\ is_init (event y)) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"desc.\ndestruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : E (event y)) (d2 : is_init (event y)) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (y : trav_label) (d : E (event y)) (d2 : is_init (event y)) (d1 : (action ↓₁ eq ta_issue) y) (d0 : event y = b)","proofString":"destruct y, a0; try by vauto.\nins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (t : trav_action) (l : location) (d : E (event (t, InitEvent l))) (d2 : is_init (event (t, InitEvent l))) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (d0 : event (t, InitEvent l) = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (t : trav_action) (l : location) (d : E (event (t, InitEvent l))) (d2 : is_init (event (t, InitEvent l))) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (d0 : event (t, InitEvent l) = b)","proofString":"ins.\nsubst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (t : trav_action) (l : location) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (d0 : InitEvent l = b) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b.","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) b","hypotheses":"(WF : Wf G) (a : trav_action) (b : actid) (c : is_rel lab b) (t : trav_action) (l : location) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (d0 : InitEvent l = b)","proofString":"subst.\nforward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (l : location) (c : is_rel lab (InitEvent l)) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l).","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l)","hypotheses":"(WF : Wf G) (a : trav_action) (l : location) (c : is_rel lab (InitEvent l)) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l))","proofString":"forward eapply (wf_init_lab WF l) as ?.\nunfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (l : location) (c : is_rel lab (InitEvent l)) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l).","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l)","hypotheses":"(WF : Wf G) (a : trav_action) (l : location) (c : is_rel lab (InitEvent l)) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0)","proofString":"unfold is_rel, Events.mod in c.\nrewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (l : location) (c : mode_le Orel\n  match lab (InitEvent l) with\n  | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n  end) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l).","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l)","hypotheses":"(WF : Wf G) (a : trav_action) (l : location) (c : mode_le Orel\n  match lab (InitEvent l) with\n  | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n  end) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0)","proofString":"rewrite H in c.\nvauto."},{"statement":"(WF : Wf G) (a : trav_action) (l : location) (c : mode_le Orel Opln) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l).","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) a /\\\n(E ∩₁ (fun a0 : actid => is_init a0)) (InitEvent l)","hypotheses":"(WF : Wf G) (a : trav_action) (l : location) (c : mode_le Orel Opln) (t : trav_action) (d : E (InitEvent l)) (d2 : true) (d1 : (action ↓₁ eq ta_issue) (t, InitEvent l)) (H : lab (InitEvent l) = Astore Xpln Opln l 0)","proofString":"vauto."},{"statement":"(y : actid) : exists x : trav_label, event x = y.","conclusion":"exists x : trav_label, event x = y","hypotheses":"(y : actid)","proofString":"exists (mkTL ta_cover y).\nvauto."},{"statement":"(y : actid) : event (mkTL ta_cover y) = y.","conclusion":"event (mkTL ta_cover y) = y","hypotheses":"(y : actid)","proofString":"vauto."},{"statement":"(y : trav_action) : exists x : trav_label, action x = y.","conclusion":"exists x : trav_label, action x = y","hypotheses":"(y : trav_action)","proofString":"exists (mkTL y (InitEvent tid_init)).\nvauto."},{"statement":"(y : trav_action) : action (mkTL y (InitEvent tid_init)) = y.","conclusion":"action (mkTL y (InitEvent tid_init)) = y","hypotheses":"(y : trav_action)","proofString":"vauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) : forall x : trav_label,\n(exists x0 : trav_label, covered tc (event x0) /\\ rmw (event x0) (event x)) ->\nexists x0 : trav_label,\n  (tc x0 /\\ ta_cover = action x0) /\\ rmw (event x0) (event x).","conclusion":"forall x : trav_label,\n(exists x0 : trav_label, covered tc (event x0) /\\ rmw (event x0) (event x)) ->\nexists x0 : trav_label,\n  (tc x0 /\\ ta_cover = action x0) /\\ rmw (event x0) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop)","proofString":"ins.\ndesc.\ndo 2 red in H.\ndesc.\nred in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : exists x0 : trav_label, covered tc (event x0) /\\ rmw (event x0) (event x)) : exists x0 : trav_label,\n  (tc x0 /\\ ta_cover = action x0) /\\ rmw (event x0) (event x).","conclusion":"exists x0 : trav_label,\n  (tc x0 /\\ ta_cover = action x0) /\\ rmw (event x0) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x : trav_label) (H : exists x0 : trav_label, covered tc (event x0) /\\ rmw (event x0) (event x))","proofString":"desc.\ndo 2 red in H.\ndesc.\nred in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 : trav_label) (H : covered tc (event x0)) (H0 : rmw (event x0) (event x)) : exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x).","conclusion":"exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 : trav_label) (H : covered tc (event x0)) (H0 : rmw (event x0) (event x))","proofString":"do 2 red in H.\ndesc.\nred in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 : trav_label) (H : exists y : trav_label, (tc ∩₁ action ↓₁ eq ta_cover) y /\\ event y = event x0) (H0 : rmw (event x0) (event x)) : exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x).","conclusion":"exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 : trav_label) (H : exists y : trav_label, (tc ∩₁ action ↓₁ eq ta_cover) y /\\ event y = event x0) (H0 : rmw (event x0) (event x))","proofString":"desc.\nred in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : (tc ∩₁ action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x)) : exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x).","conclusion":"exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : (tc ∩₁ action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x))","proofString":"red in H.\ndesc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : tc y /\\ (action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x)) : exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x).","conclusion":"exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : tc y /\\ (action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x))","proofString":"desc.\ndestruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : tc y) (H2 : (action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x)) : exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x).","conclusion":"exists x1 : trav_label,\n  (tc x1 /\\ ta_cover = action x1) /\\ rmw (event x1) (event x)","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (x x0 y : trav_label) (H : tc y) (H2 : (action ↓₁ eq ta_cover) y) (H1 : event y = event x0) (H0 : rmw (event x0) (event x))","proofString":"destruct x as [a2 e2], x0 as [a1 e1], y as [a3 e3].\nred in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : (action ↓₁ eq ta_cover) (a3, e3)) (H1 : event (a3, e3) = event (a1, e1)) (H0 : rmw (event (a1, e1)) (event (a2, e2))) : exists x : trav_label,\n  (tc x /\\ ta_cover = action x) /\\ rmw (event x) (event (a2, e2)).","conclusion":"exists x : trav_label,\n  (tc x /\\ ta_cover = action x) /\\ rmw (event x) (event (a2, e2))","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : (action ↓₁ eq ta_cover) (a3, e3)) (H1 : event (a3, e3) = event (a1, e1)) (H0 : rmw (event (a1, e1)) (event (a2, e2)))","proofString":"red in H2.\nins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : ta_cover = action (a3, e3)) (H1 : event (a3, e3) = event (a1, e1)) (H0 : rmw (event (a1, e1)) (event (a2, e2))) : exists x : trav_label,\n  (tc x /\\ ta_cover = action x) /\\ rmw (event x) (event (a2, e2)).","conclusion":"exists x : trav_label,\n  (tc x /\\ ta_cover = action x) /\\ rmw (event x) (event (a2, e2))","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : ta_cover = action (a3, e3)) (H1 : event (a3, e3) = event (a1, e1)) (H0 : rmw (event (a1, e1)) (event (a2, e2)))","proofString":"ins.\nsubst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : ta_cover = a3) (H1 : e3 = e1) (H0 : rmw e1 e2) : exists x : trav_label, (tc x /\\ ta_cover = action x) /\\ rmw (event x) e2.","conclusion":"exists x : trav_label, (tc x /\\ ta_cover = action x) /\\ rmw (event x) e2","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (H : tc (a3, e3)) (H2 : ta_cover = a3) (H1 : e3 = e1) (H0 : rmw e1 e2)","proofString":"subst.\neexists.\nsplits; eauto."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (H : tc (ta_cover, e1)) (H0 : rmw e1 e2) : exists x : trav_label, (tc x /\\ ta_cover = action x) /\\ rmw (event x) e2.","conclusion":"exists x : trav_label, (tc x /\\ ta_cover = action x) /\\ rmw (event x) e2","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (a2 : trav_action) (e2 : actid) (a1 : trav_action) (e1 : actid) (H : tc (ta_cover, e1)) (H0 : rmw e1 e2)","proofString":"eexists.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ (event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n   ∪ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘)\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ (event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n     ∪ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘).","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ (event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n   ∪ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘)\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ (event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n     ∪ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"repeat case_union _ _.\napply union_mori.\niord_dom_solver.\nrewrite id_inter, seqA.\napply doma_helper, doma_alt.\nrewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ∪ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n    ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ∪ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n    ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply union_mori.\niord_dom_solver.\nrewrite id_inter, seqA.\napply doma_helper, doma_alt.\nrewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"iord_dom_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘\n⊆ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc ∩₁ action ↓₁ eq ta_cover⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite id_inter, seqA.\napply doma_helper, doma_alt.\nrewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗tc⦘\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗tc⦘\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply doma_helper, doma_alt.\nrewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite set_split_complete with (s' := action ↓₁ _) (s := event ↓₁ is_init)at 1.\nrewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)\n    ∪₁ action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)\n    ∪₁ action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite id_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  ((⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n    ∪ ⦗action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘)\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  ((⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n    ∪ ⦗action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘)\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"repeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ ⦗action ↓₁ eq ta_cover\n      ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n     ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ ⦗action ↓₁ eq ta_cover\n      ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n     ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite dom_union.\napply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n      ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_cover\n       ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n      ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply set_subset_union_l.\nsplit.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"split.\nrewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto.\nred in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite wf_sbE.\nrewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite <- map_rel_seq2; [| by_sur].\nrewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ (event ↓ ⦗E⦘ ⨾ event ↓ (sb ⨾ ⦗E⦘)) ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ (event ↓ ⦗E⦘ ⨾ event ↓ (sb ⨾ ⦗E⦘)) ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite <- !seqA.\ndo 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  ((((⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n      ⨾ event ↓ ⦗E⦘) ⨾ event ↓ (sb ⨾ ⦗E⦘)) ⨾ ⦗tc⦘) ⨾ ⦗\n   action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  ((((⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n      ⨾ event ↓ ⦗E⦘) ⨾ event ↓ (sb ⨾ ⦗E⦘)) ⨾ ⦗tc⦘) ⨾ ⦗\n   action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"do 3 rewrite dom_seq.\ndestruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"destruct TCOH.\nrewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc)","proofString":"rewrite <- tls_coh_init.\nunfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ init_tls G.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘) ⊆₁ init_tls G","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc)","proofString":"unfold init_tls.\nrewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘)\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a)).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘)\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a))","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc)","proofString":"rewrite set_pair_alt.\nunfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘)\n⊆₁ fst\n   ↓₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n   ∩₁ snd ↓₁ (E ∩₁ (fun a : actid => is_init a)).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover ∩₁ event ↓₁ (fun a : actid => is_init a)⦘\n   ⨾ event ↓ ⦗E⦘)\n⊆₁ fst\n   ↓₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n   ∩₁ snd ↓₁ (E ∩₁ (fun a : actid => is_init a))","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc)","proofString":"unfolder.\nins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) : forall x : trav_label,\n(exists y : trav_label,\n   (ta_cover = action x /\\ is_init (event x)) /\\\n   event x = event y /\\ E (event x)) ->\n(((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x).","conclusion":"forall x : trav_label,\n(exists y : trav_label,\n   (ta_cover = action x /\\ is_init (event x)) /\\\n   event x = event y /\\ E (event x)) ->\n(((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x)","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc)","proofString":"ins.\ndesc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : exists y : trav_label,\n  (ta_cover = action x /\\ is_init (event x)) /\\\n  event x = event y /\\ E (event x)) : (((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x).","conclusion":"(((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x)","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : exists y : trav_label,\n  (ta_cover = action x /\\ is_init (event x)) /\\\n  event x = event y /\\ E (event x))","proofString":"desc.\nsplits; eauto."},{"statement":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) (x y : trav_label) (H : ta_cover = action x) (H2 : is_init (event x)) (H0 : event x = event y) (H1 : E (event x)) : (((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x).","conclusion":"(((ta_cover = fst x \\/ ta_issue = fst x) \\/ ta_reserve = fst x) \\/\n is_ta_propagate_to_G G (fst x)) /\\ E (snd x) /\\ is_init (snd x)","hypotheses":"(tc : trav_label -> Prop) (tls_coh_init : init_tls G ⊆₁ tc) (tls_coh_exec : tc ⊆₁ init_tls G ∪₁ exec_tls G) (ICOH : iord_coherent G sc tc) (x y : trav_label) (H : ta_cover = action x) (H2 : is_init (event x)) (H0 : event x = event y) (H1 : E (event x))","proofString":"splits; eauto."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"red in ICOH.\nrewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘) ⊆₁ tc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- ICOH at 2.\napply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ dom_rel (iord G sc ⨾ ⦗tc⦘).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover\n    ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n   ⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆₁ dom_rel (iord G sc ⨾ ⦗tc⦘)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply dom_rel_mori.\nrewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ iord G sc ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗tc⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ iord G sc ⨾ ⦗tc⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite seq_eqvC.\nhahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘ ⊆ iord G sc ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘ ⊆ iord G sc ⨾ ⦗tc⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"hahn_frame_r.\nunfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ iord G sc.","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ iord G sc","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold iord.\nrewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc).","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite !unionA, restr_union.\netransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)\n  ∪ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n      (RF G ∪ (FWBOB G ∪ (AR G sc ∪ (IPROP G ∪ PROP G sc)))).","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)\n  ∪ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n      (RF G ∪ (FWBOB G ∪ (AR G sc ∪ (IPROP G ∪ PROP G sc))))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"etransitivity; [| apply inclusion_union_r1].\nrewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc).","conclusion":"⦗action ↓₁ eq ta_cover ∩₁ set_compl (event ↓₁ (fun a : actid => is_init a))⦘\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite id_inter.\nrewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : (⦗action ↓₁ eq ta_cover⦘\n ⨾ ⦗set_compl (event ↓₁ (fun a : actid => is_init a))⦘)\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc).","conclusion":"(⦗action ↓₁ eq ta_cover⦘\n ⨾ ⦗set_compl (event ↓₁ (fun a : actid => is_init a))⦘)\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite set_compl_set_mapC.\nrewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : (⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘)\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc).","conclusion":"(⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘)\n⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite seqA.\nrewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc).","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ event ↓ sb ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- seqA with (r2 := _ ↓ sb).\nunfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc).","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (SB G sc)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold SB.\nrewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover⦘\n⨾ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘).","conclusion":"⦗action ↓₁ eq ta_cover⦘\n⨾ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- !restr_relE.\nrewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : restr_rel (action ↓₁ eq ta_cover)\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (restr_rel (action ↓₁ eq ta_cover) (event ↓ (sb ∪ sc)⁺)).","conclusion":"restr_rel (action ↓₁ eq ta_cover)\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (restr_rel (action ↓₁ eq ta_cover) (event ↓ (sb ∪ sc)⁺))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite restrC.\napply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : restr_rel (action ↓₁ eq ta_cover)\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n⊆ restr_rel (action ↓₁ eq ta_cover)\n    (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb ∪ sc)⁺)).","conclusion":"restr_rel (action ↓₁ eq ta_cover)\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb)\n⊆ restr_rel (action ↓₁ eq ta_cover)\n    (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb ∪ sc)⁺))","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply restr_rel_mori; [done|].\nrewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (event ↓ (sb ∪ sc)⁺).","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (event ↓ (sb ∪ sc)⁺)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- ct_step, <- inclusion_union_r1.\nrewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ sb).","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ event ↓ sb\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ sb)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite wf_sbE, no_sb_to_init at 1.\nrewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n⨾ event ↓ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘)\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ sb).","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n⨾ event ↓ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘)\n⊆ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ sb)","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite restr_relE.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n⨾ event ↓ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘)\n⊆ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘\n  ⨾ event ↓ sb ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘.","conclusion":"⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n⨾ event ↓ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘)\n⊆ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘\n  ⨾ event ↓ sb ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘","hypotheses":"(tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ 0))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ 0))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"simpl.\nunfolder.\nins.\ndesc.\ndestruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"unfolder.\nins.\ndesc.\ndestruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : forall x : trav_label,\n(exists y : trav_label,\n   ta_issue = action x /\\\n   (event x = event y /\\ is_w lab (event x) /\\ True) /\\\n   ta_cover = action y /\\ tc y) -> tc x.","conclusion":"forall x : trav_label,\n(exists y : trav_label,\n   ta_issue = action x /\\\n   (event x = event y /\\ is_w lab (event x) /\\ True) /\\\n   ta_cover = action y /\\ tc y) -> tc x","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"ins.\ndesc.\ndestruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : exists y : trav_label,\n  ta_issue = action x /\\\n  (event x = event y /\\ is_w lab (event x) /\\ True) /\\\n  ta_cover = action y /\\ tc y) : tc x.","conclusion":"tc x","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x : trav_label) (H : exists y : trav_label,\n  ta_issue = action x /\\\n  (event x = event y /\\ is_w lab (event x) /\\ True) /\\\n  ta_cover = action y /\\ tc y)","proofString":"desc.\ndestruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x y : trav_label) (H : ta_issue = action x) (H0 : event x = event y) (H3 : is_w lab (event x)) (H4 : True) (H1 : ta_cover = action y) (H2 : tc y) : tc x.","conclusion":"tc x","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (x y : trav_label) (H : ta_issue = action x) (H0 : event x = event y) (H3 : is_w lab (event x)) (H4 : True) (H1 : ta_cover = action y) (H2 : tc y)","proofString":"destruct x, y; ins; vauto.\nforward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) : tc (ta_issue, a0).","conclusion":"tc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0))","proofString":"forward eapply tlsc_w_covered_issued with (x := (ta_cover, a0)); eauto.\nbasic_solver.\nunfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) : (tc ∩₁ action ↓₁ eq ta_cover ∩₁ event ↓₁ W) (ta_cover, a0).","conclusion":"(tc ∩₁ action ↓₁ eq ta_cover ∩₁ event ↓₁ W) (ta_cover, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0))","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) : (event ↓₁ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))) (ta_cover, a0) ->\ntc (ta_issue, a0).","conclusion":"(event ↓₁ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue))) (ta_cover, a0) ->\ntc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0))","proofString":"unfold event, action.\nunfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) : (snd ↓₁ (snd ↑₁ (tc ∩₁ fst ↓₁ eq ta_issue))) (ta_cover, a0) ->\ntc (ta_issue, a0).","conclusion":"(snd ↓₁ (snd ↑₁ (tc ∩₁ fst ↓₁ eq ta_issue))) (ta_cover, a0) ->\ntc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0))","proofString":"unfolder.\nins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) : (exists y : trav_label,\n   (tc y /\\ ta_issue = fst y) /\\ snd y = snd (ta_cover, a0)) ->\ntc (ta_issue, a0).","conclusion":"(exists y : trav_label,\n   (tc y /\\ ta_issue = fst y) /\\ snd y = snd (ta_cover, a0)) ->\ntc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0))","proofString":"ins.\ndesc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) (H : exists y : trav_label, (tc y /\\ ta_issue = fst y) /\\ snd y = a0) : tc (ta_issue, a0).","conclusion":"tc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) (H : exists y : trav_label, (tc y /\\ ta_issue = fst y) /\\ snd y = a0)","proofString":"desc.\ndestruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) (y : trav_label) (H : tc y) (H1 : ta_issue = fst y) (H0 : snd y = a0) : tc (ta_issue, a0).","conclusion":"tc (ta_issue, a0)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (a0 : actid) (H3 : is_w lab a0) (H4 : True) (H2 : tc (ta_cover, a0)) (y : trav_label) (H : tc y) (H1 : ta_issue = fst y) (H0 : snd y = a0)","proofString":"destruct y; ins; vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"ar ∪ rf ⨾ ppo ∩ same_loc ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold \"ar\".\nrewrite rfi_union_rfe, inclusion_inter_l1.\nrewrite ppo_in_sb, ar_int_in_sb, rfi_in_sb; auto.\ncase_union _ _.\nrewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ ar_int G ∪ rf ⨾ ppo ∩ same_loc ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ ar_int G ∪ rf ⨾ ppo ∩ same_loc ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite rfi_union_rfe, inclusion_inter_l1.\nrewrite ppo_in_sb, ar_int_in_sb, rfi_in_sb; auto.\ncase_union _ _.\nrewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ ar_int G ∪ (rfi ∪ rfe) ⨾ ppo ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ ar_int G ∪ (rfi ∪ rfe) ⨾ ppo ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite ppo_in_sb, ar_int_in_sb, rfi_in_sb; auto.\ncase_union _ _.\nrewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ sb ∪ (sb ∪ rfe) ⨾ sb ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ sb ∪ (sb ∪ rfe) ⨾ sb ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"case_union _ _.\nrewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ sb ∪ (sb ⨾ sb ∪ rfe ⨾ sb) ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ sb ∪ (sb ⨾ sb ∪ rfe ⨾ sb) ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite sb_sb.\nrewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ sb ∪ (sb ∪ rfe ⨾ sb) ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ sb ∪ (sb ∪ rfe ⨾ sb) ⊆ (sb ∪ sc)⁺ ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- ct_step.\nrepeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sc ∪ rfe ∪ sb ∪ (sb ∪ rfe ⨾ sb) ⊆ sb ∪ sc ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"sc ∪ rfe ∪ sb ∪ (sb ∪ rfe ⨾ sb) ⊆ sb ∪ sc ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"repeat (apply inclusion_union_l); try basic_solver 10.\napply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : rfe ⨾ sb ⊆ sb ∪ sc ∪ rfe ⨾ (sb ∪ sc)＊.","conclusion":"rfe ⨾ sb ⊆ sb ∪ sc ∪ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply inclusion_union_r2_search.\nhahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : rfe ⨾ sb ⊆ rfe ⨾ (sb ∪ sc)＊.","conclusion":"rfe ⨾ sb ⊆ rfe ⨾ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"hahn_frame.\nrewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sb ⊆ (sb ∪ sc)＊.","conclusion":"sb ⊆ (sb ∪ sc)＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- inclusion_union_r1.\nrewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sb ⊆ sb＊.","conclusion":"sb ⊆ sb＊","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- inclusion_t_rt.\napply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : sb ⊆ sb⁺.","conclusion":"sb ⊆ sb⁺","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply ct_step."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_issue) a.","conclusion":"exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_issue) a","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"exists (mkTL ta_issue b).\nvauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : event (mkTL ta_issue b) = b /\\ (action ↓₁ eq ta_issue) (mkTL ta_issue b).","conclusion":"event (mkTL ta_issue b) = b /\\ (action ↓₁ eq ta_issue) (mkTL ta_issue b)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_cover) a.","conclusion":"exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_cover) a","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"exists (mkTL ta_cover b).\nvauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : event (mkTL ta_cover b) = b /\\ (action ↓₁ eq ta_cover) (mkTL ta_cover b).","conclusion":"event (mkTL ta_cover b) = b /\\ (action ↓₁ eq ta_cover) (mkTL ta_cover b)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_simpl G sc ⨾ ⦗tc⦘ ⊆ ⦗tc⦘ ⨾ iord_simpl G sc ⨾ ⦗tc⦘) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ iord_simpl G sc ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ iord_simpl G sc ⨾ ⦗tc⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_simpl G sc ⨾ ⦗tc⦘ ⊆ ⦗tc⦘ ⨾ iord_simpl G sc ⨾ ⦗tc⦘) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_simpl G sc ⨾ ⦗tc⦘ ⊆ ⦗tc⦘ ⨾ iord_simpl G sc ⨾ ⦗tc⦘) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc) ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc) ⨾ ⦗tc⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_simpl G sc ⨾ ⦗tc⦘ ⊆ ⦗tc⦘ ⨾ iord_simpl G sc ⨾ ⦗tc⦘) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (((((⦗action ↓₁ eq ta_issue⦘\n       ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n      ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⨾ iord_simpl G sc) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (((((⦗action ↓₁ eq ta_issue⦘\n       ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n      ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⨾ iord_simpl G sc) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"do 2 rewrite dom_seq.\nrewrite !seqA.\nerewrite dom_rel_mori; [by apply IHn| ].\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite !seqA.\nerewrite dom_rel_mori; [by apply IHn| ].\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n     ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n     ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"erewrite dom_rel_mori; [by apply IHn| ].\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ ((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n   ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ ((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n   ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_cover) a.","conclusion":"exists a : trav_label, event a = b /\\ (action ↓₁ eq ta_cover) a","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"exists (mkTL ta_cover b).\nvauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid) : event (mkTL ta_cover b) = b /\\ (action ↓₁ eq ta_cover) (mkTL ta_cover b).","conclusion":"event (mkTL ta_cover b) = b /\\ (action ↓₁ eq ta_cover) (mkTL ta_cover b)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) (b : actid)","proofString":"vauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)＊ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)＊ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite rtE, map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event ↓ ⦗fun _ : actid => True⦘ ∪ event ↓ (sb ∪ sc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event ↓ ⦗fun _ : actid => True⦘ ∪ event ↓ (sb ∪ sc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"repeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n   ∪ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n   ∪ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply set_subset_union_l.\nsplit.\niord_dom_solver.\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"split.\niord_dom_solver.\netransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗fun _ : actid => True⦘ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"etransitivity; [| by apply ICOH].\nunfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold iord_simpl, SB.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel\n     ((⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n       ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc) ⨾ ⦗tc⦘).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel\n     ((⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n       ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc) ⨾ ⦗tc⦘)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"etransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply dom_rel_mori.\nhahn_frame.\ntransitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ iord_simpl G sc ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗tc⦘\n⊆ iord_simpl G sc ⨾ ⦗tc⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"hahn_frame.\ntransitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ iord_simpl G sc.","conclusion":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ iord_simpl G sc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"transitivity (RF G); [| unfold iord_simpl; basic_solver 10].\nunfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ RF G.","conclusion":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘ ⊆ RF G","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold RF.\nhahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ rfe ⨾ ⦗action ↓₁ eq ta_cover⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"hahn_frame.\nrewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : event ↓ rfe ⊆ event ↓ (⦗W⦘ ⨾ rf^?).","conclusion":"event ↓ rfe ⊆ event ↓ (⦗W⦘ ⨾ rf^?)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite rfe_in_rf, (dom_l (wf_rfD WF)).\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : event ↓ (⦗W⦘ ⨾ rf) ⊆ event ↓ (⦗W⦘ ⨾ (⦗W⦘ ⨾ rf)^?).","conclusion":"event ↓ (⦗W⦘ ⨾ rf) ⊆ event ↓ (⦗W⦘ ⨾ (⦗W⦘ ⨾ rf)^?)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  ((((((⦗action ↓₁ eq ta_issue⦘\n        ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)) ⨾ ⦗tc⦘)\n      ⨾ ⦗action ↓₁ eq ta_issue⦘) ⨾ event ↓ rfe) ⨾ ⦗\n    action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  ((((((⦗action ↓₁ eq ta_issue⦘\n        ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)) ⨾ ⦗tc⦘)\n      ⨾ ⦗action ↓₁ eq ta_issue⦘) ⨾ event ↓ rfe) ⨾ ⦗\n    action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"do 3 rewrite dom_seq.\nrewrite !seqA, seq_eqvC.\narewrite ((ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)^*).\nrewrite rtE.\ncase_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)) ⨾ ⦗tc⦘)\n   ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)) ⨾ ⦗tc⦘)\n   ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite !seqA, seq_eqvC.\narewrite ((ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)^*).\nrewrite rtE.\ncase_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"arewrite ((ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)^*).\nrewrite rtE.\ncase_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite rtE.\ncase_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺))\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺))\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"case_union _ _ .\nrewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘ ∪ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘ ∪ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite map_rel_union.\nrepeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ (event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘)\n      ∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺))\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ (event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘)\n      ∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺))\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"repeat case_union _ _.\nrewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘\n   ∪ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n       ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘\n   ∪ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n       ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite dom_union.\napply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_issue⦘\n      ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n        ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n∪₁ dom_rel\n     (⦗action ↓₁ eq ta_issue⦘\n      ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n        ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply set_subset_union_l.\nsplit.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n⊆₁ tc /\\\ndom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"split.\niord_dom_solver.\nrewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘)\n⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite <- id_inter, set_interC.\nerewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗tc ∩₁ action ↓₁ eq ta_issue⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗tc ∩₁ action ↓₁ eq ta_issue⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"erewrite <- set_inter_absorb_r with (s := _ ∩₁ _); [| apply tlsc_I_in_W; eauto].\nrewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗tc ∩₁ action ↓₁ eq ta_issue ∩₁ event ↓₁ W⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ ⦗tc ∩₁ action ↓₁ eq ta_issue ∩₁ event ↓₁ W⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite set_interA, set_interC, !id_inter.\netransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘) ⊆₁ tc.","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘) ⊆₁ tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"etransitivity; [| by apply ICOH].\napply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘).","conclusion":"dom_rel\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n     ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗tc⦘)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"apply dom_rel_mori.\nhahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘ ⊆ \niord_simpl G sc ⨾ ⦗tc⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ (⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘) ⨾ ⦗tc⦘ ⊆ \niord_simpl G sc ⨾ ⦗tc⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"hahn_frame.\ntransitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘ ⊆ iord_simpl G sc.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘ ⊆ iord_simpl G sc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"transitivity (AR G sc); [| unfold iord_simpl; basic_solver 10].\nunfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘ ⊆ AR G sc.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘ ⊆ AR G sc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"unfold AR.\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","conclusion":"⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺)\n  ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ ⦗event ↓₁ W⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) (n : nat) (IHn : dom_rel\n  (((⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc) ^^ n))\n    ⨾ ⦗action ↓₁ eq ta_cover⦘) ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : iord_simpl_coherent G sc (sim_clos tc).","conclusion":"iord_simpl_coherent G sc (sim_clos tc)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"unfold sim_clos, iord_coherent.\nred.\nrewrite !id_union, !seq_union_r, !dom_union.\ndo 2 (try (apply set_subset_union_l; split)).\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver.\napply sim_clos_iord_simpl_rmw_clos; auto.\napply sim_clos_iord_simpl_rel_clos; auto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : iord_simpl_coherent G sc (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc).","conclusion":"iord_simpl_coherent G sc (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"red.\nrewrite !id_union, !seq_union_r, !dom_union.\ndo 2 (try (apply set_subset_union_l; split)).\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver.\napply sim_clos_iord_simpl_rmw_clos; auto.\napply sim_clos_iord_simpl_rel_clos; auto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ rmw_clos tc ∪₁ rel_clos tc⦘)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ rmw_clos tc ∪₁ rel_clos tc⦘)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"rewrite !id_union, !seq_union_r, !dom_union.\ndo 2 (try (apply set_subset_union_l; split)).\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver.\napply sim_clos_iord_simpl_rmw_clos; auto.\napply sim_clos_iord_simpl_rel_clos; auto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ∪₁ dom_rel (iord_simpl G sc ⨾ ⦗rmw_clos tc⦘)\n∪₁ dom_rel (iord_simpl G sc ⨾ ⦗rel_clos tc⦘)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ∪₁ dom_rel (iord_simpl G sc ⨾ ⦗rmw_clos tc⦘)\n∪₁ dom_rel (iord_simpl G sc ⨾ ⦗rel_clos tc⦘)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"do 2 (try (apply set_subset_union_l; split)).\napply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver.\napply sim_clos_iord_simpl_rmw_clos; auto.\napply sim_clos_iord_simpl_rel_clos; auto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply iord_coh_implies_iord_simpl_coh in ICOH; auto.\nrewrite ICOH.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"rewrite ICOH.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc) : tc ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel (iord_simpl G sc ⨾ ⦗rmw_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗rmw_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply sim_clos_iord_simpl_rmw_clos; auto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) : dom_rel (iord_simpl G sc ⨾ ⦗rel_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗rel_clos tc⦘) ⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc : trav_label -> Prop) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc)","proofString":"apply sim_clos_iord_simpl_rel_clos; auto."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) : codom_rel\n  (⦗covered tc⦘\n   ⨾ ⦗R⦘ ⨾ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘) ⨾ ⦗W⦘)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W.","conclusion":"codom_rel\n  (⦗covered tc⦘\n   ⨾ ⦗R⦘ ⨾ (⦗E⦘ ⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗E⦘) ⨾ ⦗W⦘)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G)","proofString":"basic_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : eq ta_cover <*> (Rel ∩₁ issued tc)\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"eq ta_cover <*> (Rel ∩₁ issued tc)\n⊆₁ eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n   ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n      ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"rewrite !set_pair_alt.\napply set_subset_union_r.\nleft.\napply set_subset_inter; [done| ].\napply set_map_mori; [done| ].\nunfold issued.\nunfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))\n   ∪₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n      ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"apply set_subset_union_r.\nleft.\napply set_subset_inter; [done| ].\napply set_map_mori; [done| ].\nunfold issued.\nunfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a)) \\/\nfst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n   ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a)) \\/\nfst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n   ∩₁ snd ↓₁ ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"left.\napply set_subset_inter; [done| ].\napply set_map_mori; [done| ].\nunfold issued.\nunfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a)).","conclusion":"fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (Rel ∩₁ issued tc)\n⊆₁ fst ↓₁ eq ta_cover ∩₁ snd ↓₁ (E \\₁ (fun a : actid => is_init a))","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"apply set_subset_inter; [done| ].\napply set_map_mori; [done| ].\nunfold issued.\nunfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : Rel ∩₁ issued tc ⊆₁ E \\₁ (fun a : actid => is_init a).","conclusion":"Rel ∩₁ issued tc ⊆₁ E \\₁ (fun a : actid => is_init a)","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"unfold issued.\nunfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)\n⊆₁ E \\₁ (fun a : actid => is_init a).","conclusion":"Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)\n⊆₁ E \\₁ (fun a : actid => is_init a)","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"unfolder.\nins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) : forall x : actid,\nis_rel lab x /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = x) ->\nE x /\\ ~ is_init x.","conclusion":"forall x : actid,\nis_rel lab x /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = x) ->\nE x /\\ ~ is_init x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E)","proofString":"ins.\ndesc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = x)) : E x /\\ ~ is_init x.","conclusion":"E x /\\ ~ is_init x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x /\\\n(exists y : trav_label, (tc y /\\ ta_issue = action y) /\\ event y = x))","proofString":"desc.\nsplit.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x) : E x /\\ ~ is_init x.","conclusion":"E x /\\ ~ is_init x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x)","proofString":"split.\napply TC_E in H0.\nvauto.\neintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x) : E x.","conclusion":"E x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x)","proofString":"apply TC_E in H0.\nvauto."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : (event ↓₁ E) y) (H2 : ta_issue = action y) (H1 : event y = x) : E x.","conclusion":"E x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : (event ↓₁ E) y) (H2 : ta_issue = action y) (H1 : event y = x)","proofString":"vauto."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x) : ~ is_init x.","conclusion":"~ is_init x","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x)","proofString":"eintros INIT%init_pln; eauto.\nmode_solver."},{"statement":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x) (INIT : is_only_pln lab x) : False.","conclusion":"False","hypotheses":"(tc : trav_label -> Prop) (WF : Wf G) (TC_E : tc ⊆₁ event ↓₁ E) (x : actid) (H : is_rel lab x) (y : trav_label) (H0 : tc y) (H2 : ta_issue = action y) (H1 : event y = x) (INIT : is_only_pln lab x)","proofString":"mode_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G) : rmw_clos tc ⊆₁ exec_tls G.","conclusion":"rmw_clos tc ⊆₁ exec_tls G","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G)","proofString":"by apply rmw_clos_exec_tls."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G) : rel_clos tc ⊆₁ exec_tls G.","conclusion":"rel_clos tc ⊆₁ exec_tls G","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G)","proofString":"apply rel_clos_exec_tls; auto.\nrewrite TC_EXEC.\nrewrite exec_tls_ENI.\nbasic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G) : tc ⊆₁ event ↓₁ E.","conclusion":"tc ⊆₁ event ↓₁ E","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G)","proofString":"rewrite TC_EXEC.\nrewrite exec_tls_ENI.\nbasic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G) : exec_tls G ⊆₁ event ↓₁ E.","conclusion":"exec_tls G ⊆₁ event ↓₁ E","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G)","proofString":"rewrite exec_tls_ENI.\nbasic_solver."},{"statement":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G) : event ↓₁ (E \\₁ (fun a : actid => is_init a)) ⊆₁ event ↓₁ E.","conclusion":"event ↓₁ (E \\₁ (fun a : actid => is_init a)) ⊆₁ event ↓₁ E","hypotheses":"(WF : Wf G) (tc : trav_label -> Prop) (TC_EXEC : tc ⊆₁ exec_tls G)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc) : init_tls G ∪₁ tc' ∪₁ rmw_clos tc ∪₁ rel_clos tc\n≡₁ init_tls G ∪₁ (tc' ∪₁ rmw_clos tc ∪₁ rel_clos tc).","conclusion":"init_tls G ∪₁ tc' ∪₁ rmw_clos tc ∪₁ rel_clos tc\n≡₁ init_tls G ∪₁ (tc' ∪₁ rmw_clos tc ∪₁ rel_clos tc)","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc) : rmw_clos tc ⊆₁ exec_tls G.","conclusion":"rmw_clos tc ⊆₁ exec_tls G","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc)","proofString":"by apply rmw_clos_exec_tls."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc) : rel_clos tc ⊆₁ exec_tls G.","conclusion":"rel_clos tc ⊆₁ exec_tls G","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc)","proofString":"apply rel_clos_exec_tls; auto.\nby apply tlsc_E."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc) : tc ⊆₁ event ↓₁ E.","conclusion":"tc ⊆₁ event ↓₁ E","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (TCOH : tc' ⊆₁ exec_tls G) (TCOH0 : tc ≡₁ init_tls G ∪₁ tc') (TCOH' : tls_coherent G tc)","proofString":"by apply tlsc_E."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : iord_simpl_coherent G sc (tc ∪₁ s1).","conclusion":"iord_simpl_coherent G sc (tc ∪₁ s1)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"red.\nrewrite id_union, seq_union_r, dom_union.\napply set_subset_union_l.\nsplit.\nrewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver.\napply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite id_union, seq_union_r, dom_union.\napply set_subset_union_l.\nsplit.\nrewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver.\napply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ∪₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ∪₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"apply set_subset_union_l.\nsplit.\nrewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver.\napply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ s1 /\\\ndom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ s1 /\\\ndom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"split.\nrewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver.\napply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗tc⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite iord_coh_implies_iord_simpl_coh; auto using ICOH,TCOH.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : tc ⊆₁ tc ∪₁ s1.","conclusion":"tc ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"apply iord_coh_implies_iord_simpl_coh in ICOH2; auto.\nrewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ s1 ∪₁ s2⦘) ⊆₁ tc ∪₁ s1 ∪₁ s2) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗tc ∪₁ s1 ∪₁ s2⦘) ⊆₁ tc ∪₁ s1 ∪₁ s2) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite <- set_subset_union_r1, <- set_subset_union_r2 in ICOH2 at 1.\nrewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1 ∪₁ s2) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1 ∪₁ s2) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite set_subset_inter_exact in ICOH2.\nrewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1 ∪₁ s2)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite set_inter_union_r, NO_INTER, set_union_empty_r in ICOH2.\nrewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1.","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ⊆₁ tc ∪₁ s1","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"rewrite set_subset_inter_exact.\nauto."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅) : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1).","conclusion":"dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1)","hypotheses":"(WF : Wf G) (CONS : imm_consistent G sc) (tc s1 s2 : trav_label -> Prop) (ICOH : iord_coherent G sc tc) (ICOH2 : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘)\n⊆₁ dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ (tc ∪₁ s1)) (TCOH : tls_coherent G tc) (TCOH2 : tls_coherent G (tc ∪₁ s1 ∪₁ s2)) (NO_INTER : dom_rel (iord_simpl G sc ⨾ ⦗s1⦘) ∩₁ s2 ⊆₁ ∅)","proofString":"auto."},{"statement":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2) : tc1 ⊆₁ tc2.","conclusion":"tc1 ⊆₁ tc2","hypotheses":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2)","proofString":"inv STEP.\ndesf.\neapply isim_clos_step_mon; eauto."},{"statement":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2) (H : exists tll : list trav_label, isim_clos_step tll tc1 tc2) (H0 : sim_coherent tc1 /\\ sim_coherent tc2) : tc1 ⊆₁ tc2.","conclusion":"tc1 ⊆₁ tc2","hypotheses":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2) (H : exists tll : list trav_label, isim_clos_step tll tc1 tc2) (H0 : sim_coherent tc1 /\\ sim_coherent tc2)","proofString":"desf.\neapply isim_clos_step_mon; eauto."},{"statement":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2) (tll : list trav_label) (H : isim_clos_step tll tc1 tc2) (H0 : sim_coherent tc1) (H1 : sim_coherent tc2) : tc1 ⊆₁ tc2.","conclusion":"tc1 ⊆₁ tc2","hypotheses":"(tc1 tc2 : trav_label -> Prop) (STEP : sim_clos_step tc1 tc2) (tll : list trav_label) (H : isim_clos_step tll tc1 tc2) (H0 : sim_coherent tc1) (H1 : sim_coherent tc2)","proofString":"eapply isim_clos_step_mon; eauto."},{"statement":"iord_coherent G sc (sim_clos tc).","conclusion":"iord_coherent G sc (sim_clos tc)","hypotheses":"","proofString":"apply sim_clos_iord_coherent; auto; apply CONS."},{"statement":"iord_coherent G sc (sim_clos tc').","conclusion":"iord_coherent G sc (sim_clos tc')","hypotheses":"","proofString":"apply sim_clos_iord_coherent; auto; apply CONS."},{"statement":"tls_coherent G (sim_clos tc).","conclusion":"tls_coherent G (sim_clos tc)","hypotheses":"","proofString":"apply sim_clos_tls_coherent; auto; apply CONS."},{"statement":"tls_coherent G (sim_clos tc').","conclusion":"tls_coherent G (sim_clos tc')","hypotheses":"","proofString":"apply sim_clos_tls_coherent; auto; apply CONS."},{"statement":"(f : actid) (FENCE : F f) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ rmw) ⊆₁ ∅","hypotheses":"(f : actid) (FENCE : F f)","proofString":"rewrite wf_rmwD; auto.\niord_dom_unfolder; try type_solver."},{"statement":"(f : actid) (FENCE : F f) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)\n⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)\n⊆₁ ∅","hypotheses":"(f : actid) (FENCE : F f)","proofString":"iord_dom_unfolder; try type_solver."},{"statement":"(f : actid) (FENCE : F f) : rel_clos (eq lbl) ⊆₁ eq lbl.","conclusion":"rel_clos (eq lbl) ⊆₁ eq lbl","hypotheses":"(f : actid) (FENCE : F f)","proofString":"unfold rel_clos, issued.\nsubst lbl.\niord_dom_unfolder."},{"statement":"(f : actid) (FENCE : F f) : eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq lbl ∩₁ action ↓₁ eq ta_issue)) ⊆₁ eq lbl.","conclusion":"eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq lbl ∩₁ action ↓₁ eq ta_issue)) ⊆₁ eq lbl","hypotheses":"(f : actid) (FENCE : F f)","proofString":"subst lbl.\niord_dom_unfolder."},{"statement":"(f : actid) (FENCE : F f) : eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq (a, f).","conclusion":"eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq (a, f) ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq (a, f)","hypotheses":"(f : actid) (FENCE : F f)","proofString":"iord_dom_unfolder."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_compl ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (a, f).","conclusion":"set_compl ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (a, f)","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"apply set_disjoint_eq_r.\nrewrite wf_rmwD; auto.\niord_dom_unfolder.\ntype_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_disjoint\n  ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (eq (a, f)).","conclusion":"set_disjoint\n  ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (eq (a, f))","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"rewrite wf_rmwD; auto.\niord_dom_unfolder.\ntype_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_disjoint\n  ((eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗covered tc⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)) (eq (a, f)).","conclusion":"set_disjoint\n  ((eq ta_cover ∪₁ eq ta_issue) <*>\n   codom_rel (⦗covered tc⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)) (eq (a, f))","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"iord_dom_unfolder.\ntype_solver."},{"statement":"(b : actid) (REL_LBL : rel_clos (eq (ta_cover, b)) ⊆₁ eq (ta_cover, b)) (FENCE : is_f lab b) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (ta_cover, b) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (ta_cover, b)))) (x : actid) (d : covered tc x) (d2 : is_r lab x) (d0 : rmw x b) (d1 : is_w lab b) : False.","conclusion":"False","hypotheses":"(b : actid) (REL_LBL : rel_clos (eq (ta_cover, b)) ⊆₁ eq (ta_cover, b)) (FENCE : is_f lab b) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (ta_cover, b) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (ta_cover, b)))) (x : actid) (d : covered tc x) (d2 : is_r lab x) (d0 : rmw x b) (d1 : is_w lab b)","proofString":"type_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_compl (eq ta_cover <*> (Rel ∩₁ issued tc)) (a, f).","conclusion":"set_compl (eq ta_cover <*> (Rel ∩₁ issued tc)) (a, f)","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"apply set_disjoint_eq_r.\nunfold issued.\nrewrite tlsc_I_in_W; eauto.\niord_dom_unfolder.\ntype_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_disjoint (eq ta_cover <*> (Rel ∩₁ issued tc)) (eq (a, f)).","conclusion":"set_disjoint (eq ta_cover <*> (Rel ∩₁ issued tc)) (eq (a, f))","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"unfold issued.\nrewrite tlsc_I_in_W; eauto.\niord_dom_unfolder.\ntype_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_disjoint\n  (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)))\n  (eq (a, f)).","conclusion":"set_disjoint\n  (eq ta_cover <*> (Rel ∩₁ event ↑₁ (tc ∩₁ action ↓₁ eq ta_issue)))\n  (eq (a, f))","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"rewrite tlsc_I_in_W; eauto.\niord_dom_unfolder.\ntype_solver."},{"statement":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f)))) : set_disjoint (eq ta_cover <*> (Rel ∩₁ event ↑₁ (event ↓₁ W))) (eq (a, f)).","conclusion":"set_disjoint (eq ta_cover <*> (Rel ∩₁ event ↑₁ (event ↓₁ W))) (eq (a, f))","hypotheses":"(f : actid) (FENCE : F f) (REL_LBL : rel_clos (eq (a, f)) ⊆₁ eq (a, f)) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (a, f) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (a, f))))","proofString":"iord_dom_unfolder.\ntype_solver."},{"statement":"(a1 : actid) (REL_LBL : rel_clos (eq (ta_cover, a1)) ⊆₁ eq (ta_cover, a1)) (FENCE : is_f lab a1) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (ta_cover, a1) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (ta_cover, a1)))) (t : trav_action) (d : is_rel lab a1) (d0 : is_w lab a1) : False.","conclusion":"False","hypotheses":"(a1 : actid) (REL_LBL : rel_clos (eq (ta_cover, a1)) ⊆₁ eq (ta_cover, a1)) (FENCE : is_f lab a1) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc'\n≡₁ tc ∪₁ eq (ta_cover, a1) ∪₁ (rmw_clos tc ∪₁ ∅)\n   ∪₁ (rel_clos tc ∪₁ rel_clos (eq (ta_cover, a1)))) (t : trav_action) (d : is_rel lab a1) (d0 : is_w lab a1)","proofString":"type_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : iord_simpl G sc (mkTL ta_issue w) (mkTL ta_cover w).","conclusion":"iord_simpl G sc (mkTL ta_issue w) (mkTL ta_cover w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"apply hahn_inclusion_exp with (r := RF G); [unfold iord_simpl; basic_solver 10| ].\nred.\napply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : RF G (mkTL ta_issue w) (mkTL ta_cover w).","conclusion":"RF G (mkTL ta_issue w) (mkTL ta_cover w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"red.\napply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (mkTL ta_issue w) (mkTL ta_cover w).","conclusion":"(⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (mkTL ta_issue w) (mkTL ta_cover w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"apply seq_eqv_lr.\nsplits; try by vauto.\nred.\nsimpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : (action ↓₁ eq ta_issue) (mkTL ta_issue w) /\\\n(event ↓ (⦗W⦘ ⨾ rf^?)) (mkTL ta_issue w) (mkTL ta_cover w) /\\\n(action ↓₁ eq ta_cover) (mkTL ta_cover w).","conclusion":"(action ↓₁ eq ta_issue) (mkTL ta_issue w) /\\\n(event ↓ (⦗W⦘ ⨾ rf^?)) (mkTL ta_issue w) (mkTL ta_cover w) /\\\n(action ↓₁ eq ta_cover) (mkTL ta_cover w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"splits; try by vauto.\nred.\nsimpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : (event ↓ (⦗W⦘ ⨾ rf^?)) (mkTL ta_issue w) (mkTL ta_cover w).","conclusion":"(event ↓ (⦗W⦘ ⨾ rf^?)) (mkTL ta_issue w) (mkTL ta_cover w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"red.\nsimpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : (⦗W⦘ ⨾ rf^?) (event (mkTL ta_issue w)) (event (mkTL ta_cover w)).","conclusion":"(⦗W⦘ ⨾ rf^?) (event (mkTL ta_issue w)) (event (mkTL ta_cover w))","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"simpl.\napply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) : (⦗W⦘ ⨾ rf^?) w w.","conclusion":"(⦗W⦘ ⨾ rf^?) w w","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w))","proofString":"apply seq_eqv_l; auto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (H : lbl = mkTL ta_issue w) : tc (mkTL ta_issue w).","conclusion":"tc (mkTL ta_issue w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (H : lbl = mkTL ta_issue w)","proofString":"vauto."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq (a, w))⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) ≡₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq (a, w))⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) ≡₁ ∅","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w))","proofString":"apply set_subset_empty_r.\nunfold covered.\niord_dom_unfolder; type_solver 10."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq (a, w))⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) ⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗covered (eq (a, w))⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) ⊆₁ ∅","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w))","proofString":"unfold covered.\niord_dom_unfolder; type_solver 10."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) : (eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, w) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)\n⊆₁ ∅.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) <*>\ncodom_rel (⦗event ↑₁ (eq (a, w) ∩₁ action ↓₁ eq ta_cover)⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)\n⊆₁ ∅","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w))","proofString":"iord_dom_unfolder; type_solver 10."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) : rel_clos (eq lbl) ⊆₁ eq lbl.","conclusion":"rel_clos (eq lbl) ⊆₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅)","proofString":"unfold rel_clos.\nunfold issued.\nsubst lbl.\niord_dom_unfolder."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) : eq ta_cover <*> (Rel ∩₁ issued (eq lbl)) ⊆₁ eq lbl.","conclusion":"eq ta_cover <*> (Rel ∩₁ issued (eq lbl)) ⊆₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅)","proofString":"unfold issued.\nsubst lbl.\niord_dom_unfolder."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) : eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq lbl ∩₁ action ↓₁ eq ta_issue)) ⊆₁ eq lbl.","conclusion":"eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq lbl ∩₁ action ↓₁ eq ta_issue)) ⊆₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅)","proofString":"subst lbl.\niord_dom_unfolder."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq (a, w)) ≡₁ ∅) : eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq (a, w) ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq (a, w).","conclusion":"eq ta_cover <*> (Rel ∩₁ event ↑₁ (eq (a, w) ∩₁ action ↓₁ eq ta_issue))\n⊆₁ eq (a, w)","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq (a, w)) ≡₁ ∅)","proofString":"iord_dom_unfolder."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) : stc' ≡₁ stc ∪₁ eq lbl.","conclusion":"stc' ≡₁ stc ∪₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl)))","proofString":"rewrite STC, STC'.\nsplit; [| basic_solver].\nrewrite REL_CLOS.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl)))","proofString":"split; [| basic_solver].\nrewrite REL_CLOS.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl)))","proofString":"rewrite REL_CLOS.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc ∪₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl)))","proofString":"basic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : sim_clos_step＊ (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n  (tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))).","conclusion":"sim_clos_step＊ (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc)\n  (tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl)))","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"eapply set_equiv_rel_more; [reflexivity | | apply rt_refl].\nsplit; [| basic_solver].\nrewrite REL_CLOS.\nedestruct @set_disjoint_not_eq_r as [SD _].\nspecialize (SD OLDw).\napply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"split; [| basic_solver].\nrewrite REL_CLOS.\nedestruct @set_disjoint_not_eq_r as [SD _].\nspecialize (SD OLDw).\napply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"rewrite REL_CLOS.\nedestruct @set_disjoint_not_eq_r as [SD _].\nspecialize (SD OLDw).\napply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"edestruct @set_disjoint_not_eq_r as [SD _].\nspecialize (SD OLDw).\napply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : (rmw_clos tc ∪₁ rel_clos tc) lbl) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : (rmw_clos tc ∪₁ rel_clos tc) lbl)","proofString":"apply set_subset_eq in SD.\nrewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : eq lbl ⊆₁ rmw_clos tc ∪₁ rel_clos tc) : tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ eq lbl)\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : eq lbl ⊆₁ rmw_clos tc ∪₁ rel_clos tc)","proofString":"rewrite !SD.\nbasic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : eq lbl ⊆₁ rmw_clos tc ∪₁ rel_clos tc) : tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc) ∪₁ rmw_clos tc\n∪₁ (rel_clos tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc.","conclusion":"tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc) ∪₁ rmw_clos tc\n∪₁ (rel_clos tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc))\n⊆₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (OLDw : ~ set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) (SD : eq lbl ⊆₁ rmw_clos tc ∪₁ rel_clos tc)","proofString":"basic_solver."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : sim_clos_step stc stc'.","conclusion":"sim_clos_step stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"do 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_sim_coherent; auto).\nexists [lbl].\nsimpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : (exists tll : list trav_label, isim_clos_step tll stc stc') /\\\nsim_coherent stc /\\ sim_coherent stc'.","conclusion":"(exists tll : list trav_label, isim_clos_step tll stc stc') /\\\nsim_coherent stc /\\ sim_coherent stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"splits; try by (subst stc stc'; apply sim_clos_sim_coherent; auto).\nexists [lbl].\nsimpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : exists tll : list trav_label, isim_clos_step tll stc stc'.","conclusion":"exists tll : list trav_label, isim_clos_step tll stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"exists [lbl].\nsimpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : isim_clos_step [lbl] stc stc'.","conclusion":"isim_clos_step [lbl] stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"simpl.\nrewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : match a with\n| ta_cover | _ => iiord_step lbl\nend stc stc'.","conclusion":"match a with\n| ta_cover | _ => iiord_step lbl\nend stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"rewrite COVER.\ndo 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : iiord_step lbl stc stc'.","conclusion":"iiord_step lbl stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"do 2 red.\nsplits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : (⦗fun tc0 : trav_label -> Prop => set_compl tc0 lbl⦘\n ⨾ (fun tc0 tc'0 : trav_label -> Prop => tc'0 ≡₁ tc0 ∪₁ eq lbl)) stc stc' /\\\niord_coherent G sc stc /\\ iord_coherent G sc stc'.","conclusion":"(⦗fun tc0 : trav_label -> Prop => set_compl tc0 lbl⦘\n ⨾ (fun tc0 tc'0 : trav_label -> Prop => tc'0 ≡₁ tc0 ∪₁ eq lbl)) stc stc' /\\\niord_coherent G sc stc /\\ iord_coherent G sc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"splits; try by (subst stc stc'; apply sim_clos_iord_coherent; auto).\napply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : (⦗fun tc0 : trav_label -> Prop => set_compl tc0 lbl⦘\n ⨾ (fun tc0 tc'0 : trav_label -> Prop => tc'0 ≡₁ tc0 ∪₁ eq lbl)) stc stc'.","conclusion":"(⦗fun tc0 : trav_label -> Prop => set_compl tc0 lbl⦘\n ⨾ (fun tc0 tc'0 : trav_label -> Prop => tc'0 ≡₁ tc0 ∪₁ eq lbl)) stc stc'","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"apply seq_eqv_l.\nsplit; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : set_compl stc lbl /\\ stc' ≡₁ stc ∪₁ eq lbl.","conclusion":"set_compl stc lbl /\\ stc' ≡₁ stc ∪₁ eq lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"split; [| done].\neapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : set_compl stc lbl.","conclusion":"set_compl stc lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"eapply set_equiv_compl; [rewrite STC; apply set_unionA| ].\napply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : set_compl (tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc)) lbl.","conclusion":"set_compl (tc ∪₁ (rmw_clos tc ∪₁ rel_clos tc)) lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"apply set_compl_union; split; try done.\nby apply set_disjoint_eq_r."},{"statement":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl)) : set_compl (rmw_clos tc ∪₁ rel_clos tc) lbl.","conclusion":"set_compl (rmw_clos tc ∪₁ rel_clos tc) lbl","hypotheses":"(w : actid) (WRITE : W w) (stc_w : trav_label -> Prop) (Heqstc_w : stc_w = stc ∪₁ eq (mkTL ta_issue w)) (Iw : tc (mkTL ta_issue w)) (NOWRMW : rmw_clos (eq lbl) ≡₁ ∅) (REL_CLOS : rel_clos (eq lbl) ⊆₁ eq lbl) (STC : stc ≡₁ tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (STC' : stc' ≡₁ tc ∪₁ eq lbl ∪₁ rmw_clos tc ∪₁ (rel_clos tc ∪₁ rel_clos (eq lbl))) (STC'_ALT : stc' ≡₁ stc ∪₁ eq lbl) (NEWw : set_disjoint (rmw_clos tc ∪₁ rel_clos tc) (eq lbl))","proofString":"by apply set_disjoint_eq_r."},{"statement":"(LABe : is_r lab e \\/ is_w lab e \\/ is_f lab e) : sim_clos_step＊ stc stc'.","conclusion":"sim_clos_step＊ stc stc'","hypotheses":"(LABe : is_r lab e \\/ is_w lab e \\/ is_f lab e)","proofString":"des; auto using sim_clos_steps_cover_read,      sim_clos_steps_cover_write,      sim_clos_steps_cover_fence."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) : covered tc' r.","conclusion":"covered tc' r","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w)","proofString":"eapply dom_sb_covered; eauto.\napply (rmw_in_sb WF) in RMW.\nexists w.\napply seq_eqv_r.\nsplit; auto.\napply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) : dom_rel (sb ⨾ ⦗covered tc'⦘) r.","conclusion":"dom_rel (sb ⨾ ⦗covered tc'⦘) r","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w)","proofString":"apply (rmw_in_sb WF) in RMW.\nexists w.\napply seq_eqv_r.\nsplit; auto.\napply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w) : dom_rel (sb ⨾ ⦗covered tc'⦘) r.","conclusion":"dom_rel (sb ⨾ ⦗covered tc'⦘) r","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w)","proofString":"exists w.\napply seq_eqv_r.\nsplit; auto.\napply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w) : (sb ⨾ ⦗covered tc'⦘) r w.","conclusion":"(sb ⨾ ⦗covered tc'⦘) r w","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w)","proofString":"apply seq_eqv_r.\nsplit; auto.\napply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w) : sb r w /\\ covered tc' w.","conclusion":"sb r w /\\ covered tc' w","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w)","proofString":"split; auto.\napply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w) : covered tc' w.","conclusion":"covered tc' w","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w)","proofString":"apply COVEQ.\nnow right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w) : (covered tc ∪₁ eq w) w.","conclusion":"(covered tc ∪₁ eq w) w","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : sb r w)","proofString":"now right."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (AA : (covered tc ∪₁ eq w) r) (RNCOV : ~ covered tc r) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (AA : (covered tc ∪₁ eq w) r) (RNCOV : ~ covered tc r)","proofString":"destruct AA as [AA|AA]; auto; desf.\napply (wf_rmwD WF) in RMW.\ngeneralize RMW.\nclear.\ntype_solver."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : rmw r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : rmw r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r)","proofString":"apply (wf_rmwD WF) in RMW.\ngeneralize RMW.\nclear.\ntype_solver."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r)","proofString":"generalize RMW.\nclear.\ntype_solver."},{"statement":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r) : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r -> False.","conclusion":"(⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r -> False","hypotheses":"(WF : Wf G) (tc tc' : trav_label -> Prop) (r : actid) (RMW : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq r) (NCOV : ~ covered tc r) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (RNCOV : ~ covered tc r)","proofString":"clear.\ntype_solver."},{"statement":"(r : actid) : (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r -> False.","conclusion":"(⦗R⦘ ⨾ rmw ⨾ ⦗W⦘) r r -> False","hypotheses":"(r : actid)","proofString":"type_solver."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w)","proofString":"red in SCOH1.\ngeneralize SCOH1 AA NCOV.\nunfold covered.\nclear.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w)","proofString":"generalize SCOH1 AA NCOV.\nunfold covered.\nclear.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w) : tc ≡₁ sim_clos tc -> covered (sim_clos tc) w -> ~ covered tc w -> False.","conclusion":"tc ≡₁ sim_clos tc -> covered (sim_clos tc) w -> ~ covered tc w -> False","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w)","proofString":"unfold covered.\nclear.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w) : tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n~ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w -> False.","conclusion":"tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n~ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w -> False","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : tc ≡₁ sim_clos tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : covered (sim_clos tc) w)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) (tc : trav_label -> Prop) : tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n~ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w -> False.","conclusion":"tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n~ (event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w -> False","hypotheses":"(w : actid) (tc : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : rmw_clos tc (ta_cover, w)) : sim_clos tc (ta_cover, w).","conclusion":"sim_clos tc (ta_cover, w)","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : rmw_clos tc (ta_cover, w))","proofString":"red.\nclear -AA.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : rmw_clos tc (ta_cover, w)) : (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (ta_cover, w).","conclusion":"(tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (ta_cover, w)","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) (AA : rmw_clos tc (ta_cover, w))","proofString":"clear -AA.\nbasic_solver 10."},{"statement":"(w : actid) (tc : trav_label -> Prop) (AA : rmw_clos tc (ta_cover, w)) : (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (ta_cover, w).","conclusion":"(tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) (ta_cover, w)","hypotheses":"(w : actid) (tc : trav_label -> Prop) (AA : rmw_clos tc (ta_cover, w))","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) : rmw_clos tc (ta_cover, w).","conclusion":"rmw_clos tc (ta_cover, w)","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r)","proofString":"red.\nsplit.\nclear.\nbasic_solver.\nclear -RCOV RMW.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) : ((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (ta_cover, w).","conclusion":"((eq ta_cover ∪₁ eq ta_issue) <*> codom_rel (⦗covered tc⦘ ⨾ rmw))\n  (ta_cover, w)","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r)","proofString":"split.\nclear.\nbasic_solver.\nclear -RCOV RMW.\nbasic_solver 10."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) : (eq ta_cover ∪₁ eq ta_issue) ta_cover.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) ta_cover","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r)","proofString":"clear.\nbasic_solver."},{"statement":"(eq ta_cover ∪₁ eq ta_issue) ta_cover.","conclusion":"(eq ta_cover ∪₁ eq ta_issue) ta_cover","hypotheses":"","proofString":"basic_solver."},{"statement":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) : codom_rel (⦗covered tc⦘ ⨾ rmw) w.","conclusion":"codom_rel (⦗covered tc⦘ ⨾ rmw) w","hypotheses":"(WF : Wf G) (w : actid) (tc tc' : trav_label -> Prop) (NCOV : ~ covered tc w) (COVEQ : covered tc' ≡₁ covered tc ∪₁ eq w) (TCOH : tls_coherent G tc') (ICOH : iord_coherent G sc tc) (ICOH2 : iord_coherent G sc tc') (SCOH1 : sim_coherent tc) (r : actid) (RMW : rmw r w) (RCOV : covered tc r)","proofString":"clear -RCOV RMW.\nbasic_solver 10."},{"statement":"(w : actid) (tc : trav_label -> Prop) (r : actid) (RMW : rmw r w) (RCOV : covered tc r) : codom_rel (⦗covered tc⦘ ⨾ rmw) w.","conclusion":"codom_rel (⦗covered tc⦘ ⨾ rmw) w","hypotheses":"(w : actid) (tc : trav_label -> Prop) (r : actid) (RMW : rmw r w) (RCOV : covered tc r)","proofString":"basic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) : False.","conclusion":"False","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w)","proofString":"assert (issued tc' w) as ISSN.\neapply w_covered_issued; eauto.\nsplit; auto.\napply COVS.\nclear.\nbasic_solver.\nassert (issued tc w) as ISS by now apply ISSS.\napply NCOV.\nassert (covered (sim_clos tc) w) as HH.\nunfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins.\ngeneralize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) : issued tc' w.","conclusion":"issued tc' w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w)","proofString":"eapply w_covered_issued; eauto.\nsplit; auto.\napply COVS.\nclear.\nbasic_solver."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) : (W ∩₁ covered tc') w.","conclusion":"(W ∩₁ covered tc') w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w)","proofString":"split; auto.\napply COVS.\nclear.\nbasic_solver."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) : covered tc' w.","conclusion":"covered tc' w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w)","proofString":"apply COVS.\nclear.\nbasic_solver."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) : (covered tc ∪₁ eq w) w.","conclusion":"(covered tc ∪₁ eq w) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w)","proofString":"clear.\nbasic_solver."},{"statement":"(w : actid) (tc : trav_label -> Prop) : (covered tc ∪₁ eq w) w.","conclusion":"(covered tc ∪₁ eq w) w","hypotheses":"(w : actid) (tc : trav_label -> Prop)","proofString":"basic_solver."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) : False.","conclusion":"False","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w)","proofString":"assert (issued tc w) as ISS by now apply ISSS.\napply NCOV.\nassert (covered (sim_clos tc) w) as HH.\nunfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins.\ngeneralize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : False.","conclusion":"False","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"apply NCOV.\nassert (covered (sim_clos tc) w) as HH.\nunfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins.\ngeneralize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : covered tc w.","conclusion":"covered tc w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"assert (covered (sim_clos tc) w) as HH.\nunfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins.\ngeneralize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : covered (sim_clos tc) w.","conclusion":"covered (sim_clos tc) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"unfold sim_clos.\napply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : covered (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) w.","conclusion":"covered (tc ∪₁ rmw_clos tc ∪₁ rel_clos tc) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"apply covered_union.\nright.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : (covered (tc ∪₁ rmw_clos tc) ∪₁ covered (rel_clos tc)) w.","conclusion":"(covered (tc ∪₁ rmw_clos tc) ∪₁ covered (rel_clos tc)) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"right.\nunfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : covered (rel_clos tc) w.","conclusion":"covered (rel_clos tc) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"unfold rel_clos.\nred.\nunfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : covered (eq ta_cover <*> (Rel ∩₁ issued tc)) w.","conclusion":"covered (eq ta_cover <*> (Rel ∩₁ issued tc)) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"red.\nunfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : (event ↑₁ (eq ta_cover <*> (Rel ∩₁ issued tc) ∩₁ action ↓₁ eq ta_cover)) w.","conclusion":"(event ↑₁ (eq ta_cover <*> (Rel ∩₁ issued tc) ∩₁ action ↓₁ eq ta_cover)) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"unfolder.\neexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) : exists y : trav_label,\n  ((eq ta_cover <*> (fun x : actid => is_rel lab x /\\ issued tc x)) y /\\\n   ta_cover = action y) /\\ event y = w.","conclusion":"exists y : trav_label,\n  ((eq ta_cover <*> (fun x : actid => is_rel lab x /\\ issued tc x)) y /\\\n   ta_cover = action y) /\\ event y = w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w)","proofString":"eexists (_, _); ins."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w) : covered tc w.","conclusion":"covered tc w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w)","proofString":"generalize SCOH1 HH.\nunfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w) : sim_coherent tc -> covered (sim_clos tc) w -> covered tc w.","conclusion":"sim_coherent tc -> covered (sim_clos tc) w -> covered tc w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w)","proofString":"unfold covered, sim_coherent.\nclear.\nbasic_solver 10."},{"statement":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w) : tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n(event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w.","conclusion":"tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n(event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w","hypotheses":"(w : actid) (tc tc' : trav_label -> Prop) (WW : W w) (NCOV : ~ covered tc w) (COVS : covered tc ∪₁ eq w ⊆₁ covered tc') (ISSS : issued tc ≡₁ issued tc') (TCOH : tls_coherent G tc') (SCOH1 : sim_coherent tc) (ICOH2 : iord_coherent G sc tc') (SCOH2 : sim_coherent tc') (REL : is_rel lab w) (ISSN : issued tc' w) (ISS : issued tc w) (HH : covered (sim_clos tc) w)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) (tc : trav_label -> Prop) : tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n(event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w.","conclusion":"tc ≡₁ sim_clos tc ->\n(event ↑₁ (sim_clos tc ∩₁ action ↓₁ eq ta_cover)) w ->\n(event ↑₁ (tc ∩₁ action ↓₁ eq ta_cover)) w","hypotheses":"(w : actid) (tc : trav_label -> Prop)","proofString":"basic_solver 10."}]}