{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Renumberproof.v","fileSamples":[{"statement":"(p : program) : match_prog p (transf_program p).","conclusion":"match_prog p (transf_program p)","hypotheses":"(p : program)","proofString":"eapply match_transform_program; eauto."},{"statement":"(ros : reg + ident) (rs : regset) (fd : fundef) (H : match ros with\n| inl r => Genv.find_funct ge rs # r\n| inr symb =>\n    match Genv.find_symbol ge symb with\n    | Some b => Genv.find_funct_ptr ge b\n    | None => None\n    end\nend = Some fd) : match ros with\n| inl r => Genv.find_funct tge rs # r\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend = Some (transf_fundef fd).","conclusion":"match ros with\n| inl r => Genv.find_funct tge rs # r\n| inr symb =>\n    match Genv.find_symbol tge symb with\n    | Some b => Genv.find_funct_ptr tge b\n    | None => None\n    end\nend = Some (transf_fundef fd)","hypotheses":"(ros : reg + ident) (rs : regset) (fd : fundef) (H : match ros with\n| inl r => Genv.find_funct ge rs # r\n| inr symb =>\n    match Genv.find_symbol ge symb with\n    | Some b => Genv.find_funct_ptr ge b\n    | None => None\n    end\nend = Some fd)","proofString":"destruct ros as [r|id].\neapply functions_translated; eauto.\nrewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try congruence.\neapply function_ptr_translated; eauto."},{"statement":"(r : reg) (rs : regset) (fd : fundef) (H : Genv.find_funct ge rs # r = Some fd) : Genv.find_funct tge rs # r = Some (transf_fundef fd).","conclusion":"Genv.find_funct tge rs # r = Some (transf_fundef fd)","hypotheses":"(r : reg) (rs : regset) (fd : fundef) (H : Genv.find_funct ge rs # r = Some fd)","proofString":"eapply functions_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) : match Genv.find_symbol tge id with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef fd).","conclusion":"match Genv.find_symbol tge id with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef fd)","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd)","proofString":"rewrite symbols_preserved.\ndestruct (Genv.find_symbol ge id); try congruence.\neapply function_ptr_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd) : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef fd).","conclusion":"match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr tge b\n| None => None\nend = Some (transf_fundef fd)","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (H : match Genv.find_symbol ge id with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some fd)","proofString":"destruct (Genv.find_symbol ge id); try congruence.\neapply function_ptr_translated; eauto."},{"statement":"(id : ident) (rs : regset) (fd : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) : Genv.find_funct_ptr tge b = Some (transf_fundef fd).","conclusion":"Genv.find_funct_ptr tge b = Some (transf_fundef fd)","hypotheses":"(id : ident) (rs : regset) (fd : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some fd)","proofString":"eapply function_ptr_translated; eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m m' : PTree.t instruction) (a : code) (H : forall x0 : PTree.elt, m ! x0 = m' ! x0) (H0 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H1 : m' ! x = Some i) (H2 : f ! x = Some y) : a ! y = Some (renum_instr f i).","conclusion":"a ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m m' : PTree.t instruction) (a : code) (H : forall x0 : PTree.elt, m ! x0 = m' ! x0) (H0 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H1 : m' ! x = Some i) (H2 : f ! x = Some y)","proofString":"eapply H0; eauto.\nrewrite H; auto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m m' : PTree.t instruction) (a : code) (H : forall x0 : PTree.elt, m ! x0 = m' ! x0) (H0 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H1 : m' ! x = Some i) (H2 : f ! x = Some y) : m ! x = Some i.","conclusion":"m ! x = Some i","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m m' : PTree.t instruction) (a : code) (H : forall x0 : PTree.elt, m ! x0 = m' ! x0) (H0 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H1 : m' ! x = Some i) (H2 : f ! x = Some y)","proofString":"rewrite H; auto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (x y : positive) (i : instruction) (H : (PTree.empty instruction) ! x = Some i) (H0 : f ! x = Some y) : (PTree.empty instruction) ! y = Some (renum_instr f i).","conclusion":"(PTree.empty instruction) ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (x y : positive) (i : instruction) (H : (PTree.empty instruction) ! x = Some i) (H0 : f ! x = Some y)","proofString":"rewrite PTree.gempty in H; congruence."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (PTree.set k v m) ! x = Some i) (H3 : f ! x = Some y) : (renum_node f a k v) ! y = Some (renum_instr f i).","conclusion":"(renum_node f a k v) ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (PTree.set k v m) ! x = Some i) (H3 : f ! x = Some y)","proofString":"rewrite PTree.gsspec in H2.\nunfold renum_node.\ndestruct (peq x k).\ninv H2.\nrewrite H3.\napply PTree.gss.\ndestruct f!k as [y'|] eqn:?.\nrewrite PTree.gso.\neauto.\nred; intros; subst y'.\nelim n.\neapply f_inj; eauto.\neauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (if peq x k then Some v else m ! x) = Some i) (H3 : f ! x = Some y) : (renum_node f a k v) ! y = Some (renum_instr f i).","conclusion":"(renum_node f a k v) ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (if peq x k then Some v else m ! x) = Some i) (H3 : f ! x = Some y)","proofString":"unfold renum_node.\ndestruct (peq x k).\ninv H2.\nrewrite H3.\napply PTree.gss.\ndestruct f!k as [y'|] eqn:?.\nrewrite PTree.gso.\neauto.\nred; intros; subst y'.\nelim n.\neapply f_inj; eauto.\neauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (if peq x k then Some v else m ! x) = Some i) (H3 : f ! x = Some y) : match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i).","conclusion":"match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (H2 : (if peq x k then Some v else m ! x) = Some i) (H3 : f ! x = Some y)","proofString":"destruct (peq x k).\ninv H2.\nrewrite H3.\napply PTree.gss.\ndestruct f!k as [y'|] eqn:?.\nrewrite PTree.gso.\neauto.\nred; intros; subst y'.\nelim n.\neapply f_inj; eauto.\neauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (e : x = k) (H2 : Some v = Some i) (H3 : f ! x = Some y) : match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i).","conclusion":"match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (e : x = k) (H2 : Some v = Some i) (H3 : f ! x = Some y)","proofString":"inv H2.\nrewrite H3.\napply PTree.gss."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : c0 ! k = Some i) (H1 : forall (x y0 : positive) (i0 : instruction),\nm ! x = Some i0 -> f ! x = Some y0 -> a ! y0 = Some (renum_instr f i0)) (y : positive) (H3 : f ! k = Some y) : match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f i) a\n| None => a\nend ! y = Some (renum_instr f i).","conclusion":"match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f i) a\n| None => a\nend ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : c0 ! k = Some i) (H1 : forall (x y0 : positive) (i0 : instruction),\nm ! x = Some i0 -> f ! x = Some y0 -> a ! y0 = Some (renum_instr f i0)) (y : positive) (H3 : f ! k = Some y)","proofString":"rewrite H3.\napply PTree.gss."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : c0 ! k = Some i) (H1 : forall (x y0 : positive) (i0 : instruction),\nm ! x = Some i0 -> f ! x = Some y0 -> a ! y0 = Some (renum_instr f i0)) (y : positive) (H3 : f ! k = Some y) : (PTree.set y (renum_instr f i) a) ! y = Some (renum_instr f i).","conclusion":"(PTree.set y (renum_instr f i) a) ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (H : m ! k = None) (i : instruction) (H0 : c0 ! k = Some i) (H1 : forall (x y0 : positive) (i0 : instruction),\nm ! x = Some i0 -> f ! x = Some y0 -> a ! y0 = Some (renum_instr f i0)) (y : positive) (H3 : f ! k = Some y)","proofString":"apply PTree.gss."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) : match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i).","conclusion":"match f ! k with\n| Some pc' => PTree.set pc' (renum_instr f v) a\n| None => a\nend ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y)","proofString":"destruct f!k as [y'|] eqn:?.\nrewrite PTree.gso.\neauto.\nred; intros; subst y'.\nelim n.\neapply f_inj; eauto.\neauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y') : (PTree.set y' (renum_instr f v) a) ! y = Some (renum_instr f i).","conclusion":"(PTree.set y' (renum_instr f v) a) ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y')","proofString":"rewrite PTree.gso.\neauto.\nred; intros; subst y'.\nelim n.\neapply f_inj; eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y') : a ! y = Some (renum_instr f i).","conclusion":"a ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y')","proofString":"eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y') : y <> y'.","conclusion":"y <> y'","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (y' : positive) (Heqo : f ! k = Some y')","proofString":"red; intros; subst y'.\nelim n.\neapply f_inj; eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = Some y) : False.","conclusion":"False","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = Some y)","proofString":"elim n.\neapply f_inj; eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = Some y) : x = k.","conclusion":"x = k","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = Some y)","proofString":"eapply f_inj; eauto."},{"statement":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = None) : a ! y = Some (renum_instr f i).","conclusion":"a ! y = Some (renum_instr f i)","hypotheses":"(P : code -> code -> Prop) (c0 : PTree.tree instruction) (m : PTree.t instruction) (a : code) (k : PTree.elt) (v : instruction) (H : m ! k = None) (H0 : c0 ! k = Some v) (H1 : forall (x0 y0 : positive) (i0 : instruction),\nm ! x0 = Some i0 -> f ! x0 = Some y0 -> a ! y0 = Some (renum_instr f i0)) (x y : positive) (i : instruction) (n : x <> k) (H2 : m ! x = Some i) (H3 : f ! x = Some y) (Heqo : f ! k = None)","proofString":"eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc)","proofString":"destruct (postorder_correct (successors_map f) f.(fn_entrypoint)) as [A B].\nfold (pnum f) in *.\nunfold renum_pc.\ndestruct (pnum f)! pc as [pc'|] eqn:?.\nsimpl.\neapply renum_cfg_nodes; eauto.\nelim (B pc); auto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(postorder (successors_map f) (fn_entrypoint f)) ! x1 = Some y ->\n(postorder (successors_map f) (fn_entrypoint f)) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None ->\n(postorder (successors_map f) (fn_entrypoint f)) ! x <> None) : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(postorder (successors_map f) (fn_entrypoint f)) ! x1 = Some y ->\n(postorder (successors_map f) (fn_entrypoint f)) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None ->\n(postorder (successors_map f) (fn_entrypoint f)) ! x <> None)","proofString":"fold (pnum f) in *.\nunfold renum_pc.\ndestruct (pnum f)! pc as [pc'|] eqn:?.\nsimpl.\neapply renum_cfg_nodes; eauto.\nelim (B pc); auto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None)","proofString":"unfold renum_pc.\ndestruct (pnum f)! pc as [pc'|] eqn:?.\nsimpl.\neapply renum_cfg_nodes; eauto.\nelim (B pc); auto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) : (fn_code (transf_function f))\n! match (pnum f) ! pc with\n  | Some pc' => pc'\n  | None => 1\n  end = Some (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f))\n! match (pnum f) ! pc with\n  | Some pc' => pc'\n  | None => 1\n  end = Some (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None)","proofString":"destruct (pnum f)! pc as [pc'|] eqn:?.\nsimpl.\neapply renum_cfg_nodes; eauto.\nelim (B pc); auto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (pc' : positive) (Heqo : (pnum f) ! pc = Some pc') : (fn_code (transf_function f)) ! pc' = Some (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f)) ! pc' = Some (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (pc' : positive) (Heqo : (pnum f) ! pc = Some pc')","proofString":"simpl.\neapply renum_cfg_nodes; eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (pc' : positive) (Heqo : (pnum f) ! pc = Some pc') : (renum_cfg (postorder (successors_map f) (fn_entrypoint f)) (fn_code f))\n! pc' = Some (renum_instr (pnum f) i).","conclusion":"(renum_cfg (postorder (successors_map f) (fn_entrypoint f)) (fn_code f))\n! pc' = Some (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (pc' : positive) (Heqo : (pnum f) ! pc = Some pc')","proofString":"eapply renum_cfg_nodes; eauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : (fn_code (transf_function f)) ! 1 = Some (renum_instr (pnum f) i).","conclusion":"(fn_code (transf_function f)) ! 1 = Some (renum_instr (pnum f) i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"elim (B pc); auto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : (successors_map f) ! pc <> None.","conclusion":"(successors_map f) ! pc <> None","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"unfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : (PTree.map1 successors_instr (fn_code f)) ! pc <> None.","conclusion":"(PTree.map1 successors_instr (fn_code f)) ! pc <> None","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"rewrite PTree.gmap1.\nrewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : option_map successors_instr (fn_code f) ! pc <> None.","conclusion":"option_map successors_instr (fn_code f) ! pc <> None","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"rewrite H.\nsimpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : option_map successors_instr (Some i) <> None.","conclusion":"option_map successors_instr (Some i) <> None","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"simpl.\ncongruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None) : Some (successors_instr i) <> None.","conclusion":"Some (successors_instr i) <> None","hypotheses":"(f : function) (pc : positive) (i : instruction) (H : (fn_code f) ! pc = Some i) (H0 : reach f pc) (A : forall x1 x2 y : positive,\n(pnum f) ! x1 = Some y -> (pnum f) ! x2 = Some y -> x1 = x2) (B : forall x : positive,\nreachable (successors_map f) (fn_entrypoint f) x ->\n(successors_map f) ! x <> None -> (pnum f) ! x <> None) (Heqo : (pnum f) ! pc = None)","proofString":"congruence."},{"statement":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc) : reachable (successors_map f) (fn_entrypoint f) s.","conclusion":"reachable (successors_map f) (fn_entrypoint f) s","hypotheses":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc)","proofString":"econstructor; eauto.\nunfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc) : (successors_map f) ! pc = Some (successors_instr i).","conclusion":"(successors_map f) ! pc = Some (successors_instr i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc)","proofString":"unfold successors_map.\nrewrite PTree.gmap1.\nrewrite H.\nauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc) : (PTree.map1 successors_instr (fn_code f)) ! pc = Some (successors_instr i).","conclusion":"(PTree.map1 successors_instr (fn_code f)) ! pc = Some (successors_instr i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc)","proofString":"rewrite PTree.gmap1.\nrewrite H.\nauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc) : option_map successors_instr (fn_code f) ! pc = Some (successors_instr i).","conclusion":"option_map successors_instr (fn_code f) ! pc = Some (successors_instr i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc)","proofString":"rewrite H.\nauto."},{"statement":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc) : option_map successors_instr (Some i) = Some (successors_instr i).","conclusion":"option_map successors_instr (Some i) = Some (successors_instr i)","hypotheses":"(f : function) (pc : positive) (i : instruction) (s : node) (H : (fn_code f) ! pc = Some i) (H0 : In s (successors_instr i)) (H1 : reachable (successors_map f) (fn_entrypoint f) pc)","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m) S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m) S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\neapply exec_Inop; eauto.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Inop pc')).","conclusion":"In pc' (successors_instr (Inop pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (pc' : node) (H : (fn_code f) ! pc = Some (Inop pc')) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H0 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Inop (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs # res <- v m) S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs # res <- v m) S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\neapply exec_Iop; eauto.\ninstantiate (1 := v).\nrewrite <- H0.\napply eval_operation_preserved.\nexact symbols_preserved.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : eval_operation tge sp op rs ## args m = Some v.","conclusion":"eval_operation tge sp op rs ## args m = Some v","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"rewrite <- H0.\napply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : eval_operation tge sp op rs ## args m = eval_operation ge sp op rs ## args m.","conclusion":"eval_operation tge sp op rs ## args m = eval_operation ge sp op rs ## args m","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"apply eval_operation_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Iop op args res pc')).","conclusion":"In pc' (successors_instr (Iop op args res pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (op : operation) (args : list reg) (res : reg) (pc' : node) (v : val) (H : (fn_code f) ! pc = Some (Iop op args res pc')) (H0 : eval_operation ge sp op rs ## args m = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iop op args res (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs # dst <- v m) S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs # dst <- v m) S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\nassert (eval_addressing tge sp addr rs ## args = Some a).\nrewrite <- H0.\napply eval_addressing_preserved.\nexact symbols_preserved.\neapply exec_Iload; eauto.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : eval_addressing tge sp addr rs ## args = Some a.","conclusion":"eval_addressing tge sp addr rs ## args = Some a","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"rewrite <- H0.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : eval_addressing tge sp addr rs ## args =\neval_addressing ge sp addr rs ## args.","conclusion":"eval_addressing tge sp addr rs ## args =\neval_addressing ge sp addr rs ## args","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Iload chunk addr args dst pc')).","conclusion":"In pc' (successors_instr (Iload chunk addr args dst pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (dst : reg) (pc' : node) (a v : val) (H : (fn_code f) ! pc = Some (Iload chunk addr args dst pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.loadv chunk m a = Some v) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Iload chunk addr args dst (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m') S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m') S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\nassert (eval_addressing tge sp addr rs ## args = Some a).\nrewrite <- H0.\napply eval_addressing_preserved.\nexact symbols_preserved.\neapply exec_Istore; eauto.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : eval_addressing tge sp addr rs ## args = Some a.","conclusion":"eval_addressing tge sp addr rs ## args = Some a","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"rewrite <- H0.\napply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : eval_addressing tge sp addr rs ## args =\neval_addressing ge sp addr rs ## args.","conclusion":"eval_addressing tge sp addr rs ## args =\neval_addressing ge sp addr rs ## args","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"apply eval_addressing_preserved.\nexact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0.","conclusion":"forall s0 : ident, Genv.find_symbol tge s0 = Genv.find_symbol ge s0","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Istore chunk addr args src pc')).","conclusion":"In pc' (successors_instr (Istore chunk addr args src pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (chunk : memory_chunk) (addr : addressing) (args : list reg) (src : reg) (pc' : node) (a : val) (m' : mem) (H : (fn_code f) ! pc = Some (Istore chunk addr args src pc')) (H0 : eval_addressing ge sp addr rs ## args = Some a) (H1 : Mem.storev chunk m a rs # src = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Istore chunk addr args src (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\\n  match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n    S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\\n  match_states (Callstate (Stackframe res f sp pc' rs :: s) fd rs ## args m)\n    S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\neapply exec_Icall with (fd := transf_fundef fd); eauto.\neapply find_function_translated; eauto.\napply sig_preserved.\nconstructor.\nconstructor; auto.\nconstructor.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : find_function tge ros rs = Some (transf_fundef fd).","conclusion":"find_function tge ros rs = Some (transf_fundef fd)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"eapply find_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : funsig (transf_fundef fd) = funsig fd.","conclusion":"funsig (transf_fundef fd) = funsig fd","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"apply sig_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : list_forall2 match_frames (Stackframe res f sp pc' rs :: s)\n  (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc') rs :: stk').","conclusion":"list_forall2 match_frames (Stackframe res f sp pc' rs :: s)\n  (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc') rs :: stk')","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"constructor; auto.\nconstructor.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : match_frames (Stackframe res f sp pc' rs)\n  (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc') rs).","conclusion":"match_frames (Stackframe res f sp pc' rs)\n  (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc') rs)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"constructor.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Icall (funsig fd) ros args res pc')).","conclusion":"In pc' (successors_instr (Icall (funsig fd) ros args res pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (res : reg) (pc' : node) (fd : fundef) (H : (fn_code f) ! pc = Some (Icall (funsig fd) ros args res pc')) (H0 : find_function ge ros rs = Some fd) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icall (funsig fd) ros args res (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args)) : exists S2' : state,\n  step tge\n    (State stk' (transf_function f) (Vptr stk Integers.Ptrofs.zero)\n       (renum_pc (pnum f) pc) rs m) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'.","conclusion":"exists S2' : state,\n  step tge\n    (State stk' (transf_function f) (Vptr stk Integers.Ptrofs.zero)\n       (renum_pc (pnum f) pc) rs m) E0 S2' /\\\n  match_states (Callstate s fd rs ## args m') S2'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args))","proofString":"econstructor; split.\neapply exec_Itailcall with (fd := transf_fundef fd); eauto.\neapply find_function_translated; eauto.\napply sig_preserved.\nconstructor.\nauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args)) : find_function tge ros rs = Some (transf_fundef fd).","conclusion":"find_function tge ros rs = Some (transf_fundef fd)","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args))","proofString":"eapply find_function_translated; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args)) : funsig (transf_fundef fd) = funsig fd.","conclusion":"funsig (transf_fundef fd) = funsig fd","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args))","proofString":"apply sig_preserved."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args)) : list_forall2 match_frames s stk'.","conclusion":"list_forall2 match_frames s stk'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (ros : reg + ident) (args : list reg) (fd : fundef) (m' : mem) (H : (fn_code f) ! pc = Some (Itailcall (funsig fd) ros args)) (H0 : find_function ge ros rs = Some fd) (H2 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Itailcall (funsig fd) ros args))","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc'))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) t\n    S2' /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) t\n    S2' /\\ match_states (State s f sp pc' (regmap_setres res vres rs) m') S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc')))","proofString":"econstructor; split.\neapply exec_Ibuiltin; eauto.\neapply eval_builtin_args_preserved with (ge1 := ge); eauto.\nexact symbols_preserved.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc'))) : forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id.","conclusion":"forall id : ident, Genv.find_symbol tge id = Genv.find_symbol ge id","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc')))","proofString":"exact symbols_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc'))) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc')))","proofString":"apply senv_preserved."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc'))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc')))","proofString":"eapply reach_succ; eauto.\nsimpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc'))) : In pc' (successors_instr (Ibuiltin ef args res pc')).","conclusion":"In pc' (successors_instr (Ibuiltin ef args res pc'))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (ef : external_function) (args : list (builtin_arg reg)) (res : builtin_res reg) (pc' : node) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : (fn_code f) ! pc = Some (Ibuiltin ef args res pc')) (H0 : eval_builtin_args ge (fun r : positive => rs # r) sp m args vargs) (H1 : external_call ef ge vargs m t vres m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ibuiltin ef args res (renum_pc (pnum f) pc')))","proofString":"simpl; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp (if b then ifso else ifnot) rs m) S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp (if b then ifso else ifnot) rs m) S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"econstructor; split.\neapply exec_Icond; eauto.\nreplace (if b then renum_pc (pnum f) ifso else renum_pc (pnum f) ifnot)     with (renum_pc (pnum f) (if b then ifso else ifnot)).\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl.\ndestruct b; auto.\ndestruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : match_states (State s f sp (if b then ifso else ifnot) rs m)\n  (State stk' (transf_function f) sp\n     (renum_pc (pnum f) (if b then ifso else ifnot)) rs m).","conclusion":"match_states (State s f sp (if b then ifso else ifnot) rs m)\n  (State stk' (transf_function f) sp\n     (renum_pc (pnum f) (if b then ifso else ifnot)) rs m)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"constructor; auto.\neapply reach_succ; eauto.\nsimpl.\ndestruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : reach f (if b then ifso else ifnot).","conclusion":"reach f (if b then ifso else ifnot)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"eapply reach_succ; eauto.\nsimpl.\ndestruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : In (if b then ifso else ifnot)\n  (successors_instr (Icond cond args ifso ifnot)).","conclusion":"In (if b then ifso else ifnot)\n  (successors_instr (Icond cond args ifso ifnot))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"simpl.\ndestruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : ifso = (if b then ifso else ifnot) \\/\nifnot = (if b then ifso else ifnot) \\/ False.","conclusion":"ifso = (if b then ifso else ifnot) \\/\nifnot = (if b then ifso else ifnot) \\/ False","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot))) : renum_pc (pnum f) (if b then ifso else ifnot) =\n(if b then renum_pc (pnum f) ifso else renum_pc (pnum f) ifnot).","conclusion":"renum_pc (pnum f) (if b then ifso else ifnot) =\n(if b then renum_pc (pnum f) ifso else renum_pc (pnum f) ifnot)","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (cond : condition) (args : list reg) (ifso ifnot : node) (b : bool) (H : (fn_code f) ! pc = Some (Icond cond args ifso ifnot)) (H0 : eval_condition cond rs ## args m = Some b) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Icond cond args (renum_pc (pnum f) ifso) (renum_pc (pnum f) ifnot)))","proofString":"destruct b; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl))) : exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m) S2'.","conclusion":"exists S2' : state,\n  step tge (State stk' (transf_function f) sp (renum_pc (pnum f) pc) rs m) E0\n    S2' /\\ match_states (State s f sp pc' rs m) S2'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl)))","proofString":"econstructor; split.\neapply exec_Ijumptable; eauto.\nrewrite list_nth_z_map.\nrewrite H1.\nsimpl; eauto.\nconstructor; auto.\neapply reach_succ; eauto.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl))) : reach f pc'.","conclusion":"reach f pc'","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl)))","proofString":"eapply reach_succ; eauto.\nsimpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl))) : In pc' (successors_instr (Ijumptable arg tbl)).","conclusion":"In pc' (successors_instr (Ijumptable arg tbl))","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl)))","proofString":"simpl.\neapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl))) : In pc' tbl.","conclusion":"In pc' tbl","hypotheses":"(s : list stackframe) (f : function) (sp : val) (pc : positive) (rs : Regmap.t val) (m : mem) (arg : reg) (tbl : list node) (n : Integers.Int.int) (pc' : node) (H : (fn_code f) ! pc = Some (Ijumptable arg tbl)) (H0 : rs # arg = Vint n) (H1 : list_nth_z tbl (Integers.Int.unsigned n) = Some pc') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H2 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) =\nSome (Ijumptable arg (List.map (renum_pc (pnum f)) tbl)))","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) = Some (Ireturn or)) : exists S2' : state,\n  step tge\n    (State stk' (transf_function f) (Vptr stk Integers.Ptrofs.zero)\n       (renum_pc (pnum f) pc) rs m) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'.","conclusion":"exists S2' : state,\n  step tge\n    (State stk' (transf_function f) (Vptr stk Integers.Ptrofs.zero)\n       (renum_pc (pnum f) pc) rs m) E0 S2' /\\\n  match_states (Returnstate s (regmap_optget or Vundef rs) m') S2'","hypotheses":"(s : list stackframe) (f : function) (stk : block) (pc : positive) (rs : regset) (m : mem) (or : option reg) (m' : mem) (H : (fn_code f) ! pc = Some (Ireturn or)) (H0 : Mem.free m stk 0 (fn_stacksize f) = Some m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') (REACH : reach f pc) (H1 : (fn_code (transf_function f)) ! (renum_pc (pnum f) pc) = Some (Ireturn or))","proofString":"econstructor; split.\neapply exec_Ireturn; eauto.\nconstructor; auto."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : exists S2' : state,\n  step tge (Callstate stk' (transf_fundef (Internal f)) args m) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Integers.Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  step tge (Callstate stk' (transf_fundef (Internal f)) args m) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Integers.Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"simpl.\neconstructor; split.\neapply exec_function_internal; eauto.\nconstructor; auto.\nunfold reach.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : exists S2' : state,\n  step tge (Callstate stk' (Internal (transf_function f)) args m) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Integers.Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'.","conclusion":"exists S2' : state,\n  step tge (Callstate stk' (Internal (transf_function f)) args m) E0 S2' /\\\n  match_states\n    (State s f (Vptr stk Integers.Ptrofs.zero) (fn_entrypoint f)\n       (init_regs args (fn_params f)) m') S2'","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"econstructor; split.\neapply exec_function_internal; eauto.\nconstructor; auto.\nunfold reach.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : reach f (fn_entrypoint f).","conclusion":"reach f (fn_entrypoint f)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"unfold reach.\nconstructor."},{"statement":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : reachable (successors_map f) (fn_entrypoint f) (fn_entrypoint f).","conclusion":"reachable (successors_map f) (fn_entrypoint f) (fn_entrypoint f)","hypotheses":"(s : list stackframe) (f : function) (args : list val) (m : mem) (m' : Mem.mem') (stk : block) (H : Val.has_argtype_list args (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stacksize f) = (m', stk)) (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"constructor."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : exists S2' : state,\n  step tge (Callstate stk' (transf_fundef (External ef)) args m) t S2' /\\\n  match_states (Returnstate s res m') S2'.","conclusion":"exists S2' : state,\n  step tge (Callstate stk' (transf_fundef (External ef)) args m) t S2' /\\\n  match_states (Returnstate s res m') S2'","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"econstructor; split.\neapply exec_function_external; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\nconstructor; auto."},{"statement":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk') : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(s : list stackframe) (ef : external_function) (args : list val) (res : val) (t : trace) (m m' : mem) (H : external_call ef ge args m t res m') (stk' : list stackframe) (STACKS : list_forall2 match_frames s stk')","proofString":"apply senv_preserved."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (STACKS : list_forall2 match_frames (Stackframe res f sp pc rs :: s) stk') : exists S2' : state,\n  step tge (Returnstate stk' vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'.","conclusion":"exists S2' : state,\n  step tge (Returnstate stk' vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (stk' : list stackframe) (STACKS : list_forall2 match_frames (Stackframe res f sp pc rs :: s) stk')","proofString":"inv STACKS.\ninv H1.\neconstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_frames (Stackframe res f sp pc rs) b1) (H3 : list_forall2 match_frames s bl) : exists S2' : state,\n  step tge (Returnstate (b1 :: bl) vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'.","conclusion":"exists S2' : state,\n  step tge (Returnstate (b1 :: bl) vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (b1 : stackframe) (bl : list stackframe) (H1 : match_frames (Stackframe res f sp pc rs) b1) (H3 : list_forall2 match_frames s bl)","proofString":"inv H1.\neconstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bl : list stackframe) (H3 : list_forall2 match_frames s bl) (REACH : reach f pc) : exists S2' : state,\n  step tge\n    (Returnstate\n       (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc) rs :: bl)\n       vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'.","conclusion":"exists S2' : state,\n  step tge\n    (Returnstate\n       (Stackframe res (transf_function f) sp (renum_pc (pnum f) pc) rs :: bl)\n       vres m) E0 S2' /\\\n  match_states (State s f sp pc rs # res <- vres m) S2'","hypotheses":"(res : reg) (f : function) (sp : val) (pc : node) (rs : regset) (s : list stackframe) (vres : val) (m : mem) (bl : list stackframe) (H3 : list_forall2 match_frames s bl) (REACH : reach f pc)","proofString":"econstructor; split.\neapply exec_return; eauto.\nconstructor; auto."},{"statement":"(S1 : state) (H : initial_state prog S1) : exists S2 : state, initial_state tprog S2 /\\ match_states S1 S2.","conclusion":"exists S2 : state, initial_state tprog S2 /\\ match_states S1 S2","hypotheses":"(S1 : state) (H : initial_state prog S1)","proofString":"inv H.\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_transf TRANSL); eauto.\nrewrite symbols_preserved.\nrewrite (match_program_main TRANSL).\neauto.\neapply function_ptr_translated; eauto.\nrewrite <- H3; apply sig_preserved.\nconstructor.\nconstructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : list_forall2 match_frames nil nil.","conclusion":"list_forall2 match_frames nil nil","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main)","proofString":"constructor."},{"statement":"(S1 S2 : state) (r : Integers.Int.int) (H : match_states S1 S2) (H0 : final_state S1 r) : final_state S2 r.","conclusion":"final_state S2 r","hypotheses":"(S1 S2 : state) (r : Integers.Int.int) (H : match_states S1 S2) (H0 : final_state S1 r)","proofString":"inv H0.\ninv H.\ninv STACKS.\nconstructor."},{"statement":"(S2 : state) (r : Integers.Int.int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) S2) : final_state S2 r.","conclusion":"final_state S2 r","hypotheses":"(S2 : state) (r : Integers.Int.int) (m : mem) (H : match_states (Returnstate nil (Vint r) m) S2)","proofString":"inv H.\ninv STACKS.\nconstructor."},{"statement":"(r : Integers.Int.int) (m : mem) (stk' : list stackframe) (STACKS : list_forall2 match_frames nil stk') : final_state (Returnstate stk' (Vint r) m) r.","conclusion":"final_state (Returnstate stk' (Vint r) m) r","hypotheses":"(r : Integers.Int.int) (m : mem) (stk' : list stackframe) (STACKS : list_forall2 match_frames nil stk')","proofString":"inv STACKS.\nconstructor."},{"statement":"(r : Integers.Int.int) (m : mem) : final_state (Returnstate nil (Vint r) m) r.","conclusion":"final_state (Returnstate nil (Vint r) m) r","hypotheses":"(r : Integers.Int.int) (m : mem)","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id","hypotheses":"","proofString":"apply senv_preserved."}]}