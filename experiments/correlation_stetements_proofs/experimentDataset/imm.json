[{"statement":"Lemma ppo_in_ar : ppo G ⊆ ar.","proof":"rewrite ppo_in_ar_int.\nby arewrite (ar_int ⊆ ar).\n"},{"statement":"Lemma psc_hb: psc ⨾ hb ⨾ ⦗F∩₁Sc⦘ ⊆ psc.","proof":"unfold psc; generalize (@hb_trans G); basic_solver 20.\n"},{"statement":"Lemma hb_psc: ⦗F∩₁Sc⦘ ⨾ hb ⨾ psc ⊆ psc.","proof":"unfold psc; generalize (@hb_trans G); basic_solver 20.\n"},{"statement":"Lemma wf_pscE WF : psc ≡ ⦗E⦘ ⨾ psc ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold psc; rewrite (wf_hbE WF) at 1 2.\nbasic_solver 42.\n"},{"statement":"Lemma wf_scbE WF : scb ≡ ⦗E⦘ ⨾ scb ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold scb.\nrewrite wf_sbE at 1 2 3.\nrewrite (wf_hbE WF) at 1 2.\nrewrite (wf_coE WF) at 1.\nrewrite (wf_frE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_psc_baseE WF : psc_base ≡ ⦗E⦘ ⨾ psc_base ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold psc_base.\nrewrite (wf_hbE WF) at 1 2.\nrewrite (wf_scbE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_arE WF : ar ≡ ⦗E⦘ ⨾ ar ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold ar.\nrewrite (wf_pscE WF), (wf_ar_intE WF), (wf_rfeE WF) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_pscD : psc ≡ ⦗F∩₁Sc⦘ ⨾ psc ⨾ ⦗F∩₁Sc⦘.","proof":"split; [|basic_solver].\nunfold psc; basic_solver 42.\n"},{"statement":"Lemma wf_psc_baseD : psc_base ≡ ⦗Sc⦘ ⨾ psc_base ⨾ ⦗Sc⦘.","proof":"split; [|basic_solver].\nunfold psc_base; basic_solver 42.\n"},{"statement":"Lemma no_psc_to_init WF : psc ≡ psc ⨾  ⦗fun x => ~ is_init x⦘.","proof":"split; [|basic_solver].\nrewrite wf_pscD at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42.\n"},{"statement":"Lemma CoherentPSC WF PSC: irreflexive (co ⨾ rf^? ⨾ hb ⨾ psc ⨾ hb ⨾ rf⁻¹ ^?).","proof":"rewrite wf_pscD.\nrotate 4.\narewrite ((rf⁻¹)^? ⨾ co ⨾ rf^? ⊆ eco).\nby unfold Execution_eco.eco, Execution.fr; basic_solver 42.\narewrite (⦗F∩₁Sc⦘ ⨾ hb ⨾ eco ⨾ hb ⨾ ⦗F∩₁Sc⦘ ⊆ psc).\nunfolder; ins; desf.\neby eapply PSC, t_trans; apply t_step.\n"},{"statement":"Lemma C_EXT_helper2 WF: (psc ∪ rfe)⁺ ⊆ psc⁺ ∪ rfe.","proof":"apply ct_ind_left with (P:= fun r => r).\nby eauto with hahn.\nby unionL; vauto.\nins; rewrite H; relsf; unionL.\narewrite (psc ⊆ psc＊); relsf.\nrewrite ct_begin.\nrewrite (dom_l wf_pscD) at 1; rewrite (dom_r (wf_rfeD WF)); type_solver 12.\nrewrite (dom_r wf_pscD) at 1; rewrite (dom_l (wf_rfeD WF)); type_solver 12.\nrewrite (dom_r (wf_rfeD WF)) at 1; rewrite (dom_l (wf_rfeD WF)); type_solver 12.\n"},{"statement":"Lemma sw_in_ar_helper_old WF:\n  ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊ ⊆\n  (sb ∩ same_loc ⨾ ⦗W⦘)^? ∪ (sb ∩ same_loc)^? ⨾ (rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺.","proof":"rewrite rtE at 1; relsf; unionL; [basic_solver 21|].\nrewrite rfi_union_rfe; relsf.\nrewrite path_union.\nunionL.\n{\nrewrite (dom_r (wf_rmwD WF)) at 1.\nrewrite (rfi_in_sbloc' WF) at 1.\nrewrite (rmw_in_sb_loc WF) at 1.\ngeneralize (@sb_same_loc_trans G), (@sb_same_loc_W_trans G); ins; relsf.\n}\nrewrite ct_seq_swap, !seqA.\nrewrite (dom_r (wf_rmwD WF)) at 3.\nrewrite (rfi_in_sbloc' WF) at 1 2.\nrewrite (rmw_in_sb_loc WF) at 1 3.\ngeneralize (@sb_same_loc_trans G); intros HH; relsf.\narewrite ((sb ∩ same_loc) ⊆ sb) at 3.\nunionR right.\nrewrite (dom_l (wf_rfeD WF)), !seqA.\nrewrite <- seqA with (r2:= ⦗W⦘).\nrewrite ct_rotl, !seqA.\narewrite ((sb ∩ same_loc)^? ⨾ (sb ∩ same_loc)^? ⊆ (sb ∩ same_loc)^?).\n{\ngeneralize HH.\nbasic_solver 10.\n}\nhahn_frame.\narewrite ((sb ⨾ ⦗W⦘)＊ ⨾ (sb ∩ same_loc)^? ⊆ sb^?).\n{\narewrite_id ⦗W⦘.\nrewrite seq_id_r.\nrewrite rt_of_trans.\n2: by apply sb_trans.\ngeneralize sb_trans.\nbasic_solver 10.\n}\narewrite (rmw ⨾ (sb ⨾ ⦗W⦘)＊ ⊆ rmw ⨾ sb^? ⨾ ⦗W⦘).\n2: {\nrewrite (dom_l (wf_rfeD WF)) at 1 2; rewrite !seqA.\narewrite_id ⦗W⦘ at 1.\nrewrite seq_id_l.\napply ct_end.\n}\nrewrite rtE, seq_union_r.\nunionL.\n{\nrewrite (dom_r (wf_rmwD WF)) at 1.\nbasic_solver 10.\n}\nrewrite ct_of_trans.\n{\nbasic_solver 10.\n}\ngeneralize sb_trans.\nbasic_solver.\n"},{"statement":"Lemma ar_int_in_ar : ar_int ⊆ ar.","proof":"unfold ar.\neauto with hahn.\n"},{"statement":"Lemma rmw_sb_cr_W_in_ar WF : rmw ⨾ sb^? ⨾ ⦗W⦘ ⊆ ar.","proof":"rewrite <- ppo_in_ar.\nunfold imm_ppo.ppo.\nrewrite <- ct_step, (dom_l (wf_rmwD WF)).\nbasic_solver 21.\n"},{"statement":"Lemma fwbob_in_ar : fwbob G ⊆ ar.","proof":"unfold ar.\nunfold imm_ppo.ar_int.\nrewrite fwbob_in_bob.\nbasic_solver 10.\n"},{"statement":"Lemma sw_in_ar WF :\n  sw ⊆ sb^? ⨾ ⦗W⦘ ⨾ ar⁺ ⨾ (rmw ⨾ sb^?)^? ∪ sb.","proof":"assert ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ar^?) as BB.\n{\narewrite (⦗Acq⦘ ⊆ ⦗Acq/Rel⦘) by mode_solver.\nunfold ar, imm_ppo.ar_int, imm_bob.bob, imm_bob.fwbob.\nbasic_solver 21.\n}\nassert (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ sb^? ⨾ ⦗W⦘ ⨾ ar^?) as DD.\n{\nrewrite crE.\nrewrite !seq_union_l, !seq_union_r, seq_id_l.\nunionL.\n2: generalize (@sb_trans G); basic_solver 10.\nrewrite crE, seq_union_l, seq_id_l.\nunionR left.\narewrite (⦗Rel⦘ ⨾ ⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ ⦗W⦘ ⨾ fwbob G).\n{\nunfold fwbob.\nbasic_solver 10.\n}\nrewrite fwbob_in_ar.\nbasic_solver.\n}\nassert (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ sb^? ⨾ ⦗W⦘ ⨾ ar^?) as FF.\n{\nrewrite crE with (r:=sb ∩ same_loc).\nrewrite !seq_union_l, !seq_union_r, seq_id_l.\nrewrite DD.\nunionL; [|done].\nbasic_solver 10.\n}\nassert (⦗W⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⊆ ⦗W⦘ ⨾ sb ∩ same_loc) as UU.\n{\nunfold Events.same_loc.\nunfolder.\nins.\ndesf; eexists; splits; eauto.\n{\neapply sb_trans; eauto.\n}\netransitivity; eauto.\n}\nassert (ar^? ⨾ ar ⨾ ar^? ⊆ ar⁺) as WW.\n{\narewrite (ar ⊆ ar⁺) at 2.\nby rewrite ct_cr, cr_ct.\n}\nunfold imm_hb.sw, imm_hb.release, imm_hb.rs.\nrewrite (sw_in_ar_helper_old WF).\nrewrite (dom_l (wf_rfeD WF)).\nrewrite !seqA, inclusion_ct_seq_eqv_l.\narewrite ((sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ (sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ ⦗W⦘).\n{\nbasic_solver 10.\n}\narewrite (rfe ⊆ ar).\narewrite (rfi ⊆ sb).\narewrite ((sb ∩ same_loc ⨾ ⦗W⦘)^? ∪ (sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ ⦗W⦘ ⨾ (ar ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ⊆          (sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ (ar ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊).\n{\nbasic_solver 10.\n}\narewrite (sb ∩ same_loc ⨾ ⦗W⦘ ∪ (sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ (ar ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⊆               (sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ (ar ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊).\n{\nbasic_solver 10.\n}\nassert (⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc ⨾ ⦗W⦘)^? ⊆            ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘) as ZZ.\n{\nbasic_solver 20.\n}\nassert (rmw ⨾ sb^? ⨾ ⦗W⦘ ⊆ ppo G) as QQ.\n{\nrewrite crE, !seq_union_l, !seq_union_r.\nrewrite rmw_sb_W_in_ppo, rmw_in_ppo; auto.\nbasic_solver.\n}\nassert (ar ⨾ ar ⊆ ar⁺) as PP.\n{\narewrite (ar ⊆ ar⁺).\napply ct_unit.\n}\nrewrite rtE.\nrewrite !seq_union_l, !seq_union_r, !seq_id_l.\nunionL.\n{\nunionR right.\ngeneralize (@sb_trans G).\nbasic_solver 21.\n}\n{\nrewrite !seqA.\narewrite ((sb ∩ same_loc ⨾ ⦗W⦘)^? ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆              (sb ∩ same_loc)^? ⨾ ⦗W⦘).\n{\ngeneralize (@sb_same_loc_trans G).\nbasic_solver 10.\n}\nsin_rewrite FF.\nrewrite !seqA.\nrewrite BB.\nsin_rewrite WW.\nbasic_solver 10.\n}\n{\nsin_rewrite ZZ.\nsin_rewrite FF.\nrewrite !seqA.\nrewrite ct_end, !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆                  rmw ⨾ sb^?).\n{\ngeneralize (@sb_trans G).\nbasic_solver 10.\n}\nsin_rewrite QQ.\nrewrite ppo_in_ar.\narewrite (ar^? ⨾ (ar ⨾ ar)＊ ⨾ ar ⊆ ar⁺).\n2: basic_solver 20.\nsin_rewrite PP.\nrewrite rt_of_ct.\nrewrite <- ct_end.\napply cr_ct.\n}\nunionR left.\nsin_rewrite ZZ.\nsin_rewrite FF.\nrewrite !seqA.\nrewrite ct_end, !seqA.\nrewrite BB.\nassert (sb^? ⨾ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⊆ sb^? ⨾ ⦗W⦘) as TT.\n{\ngeneralize (@sb_trans G).\nbasic_solver 10.\n}\nsin_rewrite TT.\nrewrite !seqA.\nrepeat sin_rewrite QQ.\nrewrite ppo_in_ar.\nrepeat sin_rewrite PP.\nrewrite rt_of_ct.\nsin_rewrite ct_unit.\nsin_rewrite ct_cr.\nsin_rewrite rt_ct.\nsin_rewrite cr_ct.\nbasic_solver 10.\n"},{"statement":"Lemma f_sc_hb_f_sc_in_ar WF : \n  ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ ar⁺.","proof":"unfold imm_hb.hb.\nrewrite (dom_r (wf_swD WF)).\nrewrite (sw_in_ar WF); relsf.\narewrite ((sb ∪ ((sb^? ⨾ ⦗W⦘ ⨾ ar⁺ ⨾ (rmw ⨾ sb^?)^?) ⨾ ⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘      ∪ sb ⨾ ⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘)) ⊆ sb ∪ sb^? ⨾ ⦗W⦘ ⨾ ar⁺ ⨾ (rmw ⨾ sb^?)^? ⨾ ⦗FR ∩₁ Acq⦘).\nby basic_solver 21.\nrewrite path_union.\ngeneralize (@sb_trans G); ins; relsf; unionL.\nby rewrite <- ct_step; unfold ar, imm_ppo.ar_int, imm_bob.bob, imm_bob.fwbob; mode_solver 21.\nrewrite ct_seq_swap, !seqA.\nrewrite ct_rotl, !seqA.\narewrite ((rmw ⨾ sb^?)^? ⨾ ⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ar^?).\n{\ncase_refl (rmw ⨾ sb^?).\n- arewrite (⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘ ⊆ ⦗R ∩₁ Acq⦘ ∪ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\nunfold ar, imm_ppo.ar_int, imm_bob.bob, imm_bob.fwbob; basic_solver 15.\n- arewrite_id ⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘.\nrewrite seq_id_l.\narewrite (sb^? ⨾ sb^? ⊆ sb^?).\n{\ngeneralize (@sb_trans G).\nbasic_solver.\n}\nrewrite rmw_sb_cr_W_in_ar; auto.\neauto with hahn.\n}\narewrite ((rmw ⨾ sb^?)^? ⨾ ⦗F ∩₁ Acq ∪₁ R ∩₁ Acq⦘ ⨾ sb^? ⊆ sb^?).\nby rewrite (rmw_in_sb WF); basic_solver.\narewrite (sb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ ar^?).\nby unfold ar, imm_ppo.ar_int, imm_bob.bob, imm_bob.fwbob; mode_solver 21.\narewrite (⦗F ∩₁ Sc⦘ ⨾ sb^? ⨾ ⦗W⦘ ⊆ ar^?).\nby unfold ar, imm_ppo.ar_int, imm_bob.bob, imm_bob.fwbob; mode_solver 21.\nrelsf.\n"},{"statement":"Lemma acyc_ext_helper WF :\n  acyclic (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘) -> acyc_ext.","proof":"intros AC.\ngeneralize (@sb_trans G); intro SBT.\nred.\nunfold ar.\napply acyclic_mon with (r:= ar_int ∪ (psc ∪ rfe)).\n2: by basic_solver 12.\napply acyclic_union1.\n{\nby rewrite (ar_int_in_sb WF); apply sb_acyclic.\n}\n{\neapply acyclic_mon; [edone|basic_solver 12].\n}\nrewrite (C_EXT_helper2 WF); unionL.\narewrite (psc ⊆ sb^? ⨾ psc ⨾ sb^?) by basic_solver 12.\nrelsf.\nrewrite (ar_int_in_sb WF) at 1; relsf.\nrewrite ct_begin, !seqA; relsf.\narewrite (sb ⊆ sb^?) at 1.\nrewrite <- !seqA, <- ct_begin, !seqA.\napply acyclic_union1.\n{\nred; rels; eapply acyclic_mon; [edone|basic_solver 12].\n}\n{\nrewrite (dom_l (wf_rfeD WF)), <- seqA, acyclic_rotl.\nrewrite (dom_r (wf_rfeD WF)), !seqA.\napply acyclic_seq_from_union.\nred; rels; eapply acyclic_mon; [edone|basic_solver 12].\n}\nrelsf.\nrewrite (ct_begin (ar_int⁺ ⨾ rfe)).\nrewrite (ar_int_in_sb WF) at 1.\nrewrite !seqA; relsf.\narewrite ((sb^? ⨾ psc ⨾ sb^?)⁺ ⨾ sb ⊆ (sb^? ⨾ psc ⨾ sb^?)⁺).\n{\nrewrite ct_end at 1; rewrite !seqA.\narewrite (sb^? ⨾ sb ⊆ sb^?).\nby generalize (@sb_trans G); basic_solver.\nby rewrite <- ct_end.\n}\nrewrite (dom_l (wf_rfeD WF)) at 2.\narewrite (rfe ⨾ (ar_int⁺ ⨾ ⦗W⦘ ⨾ rfe)＊ ⊆ (rfe ⨾ ar_int⁺ ⨾ ⦗W⦘)＊ ⨾ rfe).\n{\nby rewrite <- seqA; apply rt_seq_swap.\n}\nrewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite !seqA.\narewrite ((sb^? ⨾ psc ⨾ sb^?)⁺ ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)⁺).\narewrite (rfe ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 2.\narewrite (⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘ ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 3.\nrelsf.\narewrite (rfe ⊆ (sb^? ⨾ psc ⨾ sb^? ∪ rfe ∪ ⦗R⦘ ⨾ ar_int⁺ ⨾ ⦗W⦘)＊) at 2.\nrelsf; red; rels.\n"},{"statement":"Lemma psc_base_in_psc_f WF (SC_F : Sc ⊆₁ F∩₁Sc): \n  psc_base ⊆ psc_f.","proof":"unfold psc_base, scb.\narewrite (sb \\ same_loc ⊆ sb).\narewrite (sb ⊆ hb).\narewrite (hb ⨾ hb ⨾ hb ⊆ hb).\n{\nunfold imm_hb.hb.\nby rewrite !ct_ct.\n}\narewrite (hb ∪ hb ∪ hb ∩ same_loc ⊆ hb).\nrewrite co_in_eco, fr_in_eco.\nrewrite unionA, unionK.\nrewrite SC_F.\nrewrite !seq_union_l, !seq_union_r.\narewrite ((⦗F⦘ ⨾ hb)^? ⨾ hb ⨾ (hb ⨾ ⦗F⦘)^? ⊆ hb).\n{\ngeneralize (@hb_trans G).\nbasic_solver 10.\n}\nunionL.\n{\nunfold psc_f.\nbasic_solver 10.\n}\nrewrite (wf_ecoD WF), !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⨾ (⦗F⦘ ⨾ hb)^? ⨾ ⦗RW⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ hb)    by type_solver 10.\narewrite (⦗RW⦘ ⨾ (hb ⨾ ⦗F⦘)^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ hb ⨾ ⦗F ∩₁ Sc⦘)    by type_solver 10.\nunfold psc_f.\nbasic_solver 10.\n"}]