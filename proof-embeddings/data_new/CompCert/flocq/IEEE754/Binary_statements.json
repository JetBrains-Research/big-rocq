{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/IEEE754/Binary.v","fileSamples":[{"statement":"(x : binary_float) : BinarySingleNaN.B2R (B2BSN x) = B2R x.","conclusion":"BinarySingleNaN.B2R (B2BSN x) = B2R x","hypotheses":"(x : binary_float)","proofString":"now destruct x."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (H : valid_binary (B2FF (B754_nan sx plx Hplx)) = true) : FF2B (B2FF (B754_nan sx plx Hplx)) H = B754_nan sx plx Hplx.","conclusion":"FF2B (B2FF (B754_nan sx plx Hplx)) H = B754_nan sx plx Hplx","hypotheses":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (H : valid_binary (B2FF (B754_nan sx plx Hplx)) = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : valid_binary (B2FF (B754_finite sx mx ex Hx)) = true) : FF2B (B2FF (B754_finite sx mx ex Hx)) H = B754_finite sx mx ex Hx.","conclusion":"FF2B (B2FF (B754_finite sx mx ex Hx)) H = B754_finite sx mx ex Hx","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : valid_binary (B2FF (B754_finite sx mx ex Hx)) = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(x : binary_float) : FF2B (B2FF x) (valid_binary_B2FF x) = x.","conclusion":"FF2B (B2FF x) (valid_binary_B2FF x) = x","hypotheses":"(x : binary_float)","proofString":"apply FF2B_B2FF."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true) : canonical radix2 (SpecFloat.fexp prec emax)\n  {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 (SpecFloat.fexp prec emax)\n  {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true)","proofString":"now apply canonical_canonical_mantissa."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : generic_format radix2 (SpecFloat.fexp prec emax)\n  (B2R (B754_finite sx mx ex Hx)).","conclusion":"generic_format radix2 (SpecFloat.fexp prec emax)\n  (B2R (B754_finite sx mx ex Hx))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\napply generic_format_canonical.\nnow apply canonical_bounded."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : canonical radix2 (SpecFloat.fexp prec emax)\n  {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 (SpecFloat.fexp prec emax)\n  {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"now apply canonical_bounded."},{"statement":"(x : binary_float) : generic_format radix2 (FLT_exp (SpecFloat.emin prec emax) prec) (B2R x).","conclusion":"generic_format radix2 (FLT_exp (SpecFloat.emin prec emax) prec) (B2R x)","hypotheses":"(x : binary_float)","proofString":"apply generic_format_B2R."},{"statement":"(sx sy : bool) : B2FF (B754_zero sx) = B2FF (B754_zero sy) -> B754_zero sx = B754_zero sy.","conclusion":"B2FF (B754_zero sx) = B2FF (B754_zero sy) -> B754_zero sx = B754_zero sy","hypotheses":"(sx sy : bool)","proofString":"intros H.\nnow inversion H."},{"statement":"(sx sy : bool) (H : B2FF (B754_zero sx) = B2FF (B754_zero sy)) : B754_zero sx = B754_zero sy.","conclusion":"B754_zero sx = B754_zero sy","hypotheses":"(sx sy : bool) (H : B2FF (B754_zero sx) = B2FF (B754_zero sy))","proofString":"now inversion H."},{"statement":"(sx sy : bool) : B2FF (B754_infinity sx) = B2FF (B754_infinity sy) ->\nB754_infinity sx = B754_infinity sy.","conclusion":"B2FF (B754_infinity sx) = B2FF (B754_infinity sy) ->\nB754_infinity sx = B754_infinity sy","hypotheses":"(sx sy : bool)","proofString":"intros H.\nnow inversion H."},{"statement":"(sx sy : bool) (H : B2FF (B754_infinity sx) = B2FF (B754_infinity sy)) : B754_infinity sx = B754_infinity sy.","conclusion":"B754_infinity sx = B754_infinity sy","hypotheses":"(sx sy : bool) (H : B2FF (B754_infinity sx) = B2FF (B754_infinity sy))","proofString":"now inversion H."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) : B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply) ->\nB754_nan sx plx Hplx = B754_nan sy ply Hply.","conclusion":"B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply) ->\nB754_nan sx plx Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true)","proofString":"intros H.\ninversion H.\nclear H.\nrevert Hplx.\nrewrite H2.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H : B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply)) : B754_nan sx plx Hplx = B754_nan sy ply Hply.","conclusion":"B754_nan sx plx Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H : B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply))","proofString":"inversion H.\nclear H.\nrevert Hplx.\nrewrite H2.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H : B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply)) (H1 : sx = sy) (H2 : plx = ply) : B754_nan sy plx Hplx = B754_nan sy ply Hply.","conclusion":"B754_nan sy plx Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H : B2FF (B754_nan sx plx Hplx) = B2FF (B754_nan sy ply Hply)) (H1 : sx = sy) (H2 : plx = ply)","proofString":"clear H.\nrevert Hplx.\nrewrite H2.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply) : B754_nan sy plx Hplx = B754_nan sy ply Hply.","conclusion":"B754_nan sy plx Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (Hplx : nan_pl plx = true) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply)","proofString":"revert Hplx.\nrewrite H2.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply) : forall Hplx : nan_pl plx = true, B754_nan sy plx Hplx = B754_nan sy ply Hply.","conclusion":"forall Hplx : nan_pl plx = true, B754_nan sy plx Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply)","proofString":"rewrite H2.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply) : forall Hplx : nan_pl ply = true, B754_nan sy ply Hplx = B754_nan sy ply Hply.","conclusion":"forall Hplx : nan_pl ply = true, B754_nan sy ply Hplx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply)","proofString":"intros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply) (Hx : nan_pl ply = true) : B754_nan sy ply Hx = B754_nan sy ply Hply.","conclusion":"B754_nan sy ply Hx = B754_nan sy ply Hply","hypotheses":"(sx : bool) (plx : positive) (sy : bool) (ply : positive) (Hply : nan_pl ply = true) (H1 : sx = sy) (H2 : plx = ply) (Hx : nan_pl ply = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"intros H.\ninversion H.\nclear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy)) : B754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy))","proofString":"inversion H.\nclear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy)) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : B754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2FF (B754_finite sx mx ex Hx) = B2FF (B754_finite sy my ey Hy)) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"clear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : B754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"revert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : forall Hx : bounded mx ex = true,\nB754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"forall Hx : bounded mx ex = true,\nB754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"rewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : forall Hx : bounded my ey = true,\nB754_finite sy my ey Hx = B754_finite sy my ey Hy.","conclusion":"forall Hx : bounded my ey = true,\nB754_finite sy my ey Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"intros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) (Hx : bounded my ey = true) : B754_finite sy my ey Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy my ey Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) (Hx : bounded my ey = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(x : binary_float) : BinarySingleNaN.is_finite_strict (B2BSN x) = is_finite_strict x.","conclusion":"BinarySingleNaN.is_finite_strict (B2BSN x) = is_finite_strict x","hypotheses":"(x : binary_float)","proofString":"now destruct x."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : is_finite_strict (B754_finite sx mx ex Hx) = true ->\nis_finite_strict (B754_finite sy my ey Hy) = true ->\nB2R (B754_finite sx mx ex Hx) = B2R (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"is_finite_strict (B754_finite sx mx ex Hx) = true ->\nis_finite_strict (B754_finite sy my ey Hy) = true ->\nB2R (B754_finite sx mx ex Hx) = B2R (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"simpl.\nintros _ _ Heq.\nassert (Hs: sx = sy).\nrevert Heq.\nclear.\ncase sx ; case sy ; try easy ;  intros Heq ; apply False_ind ; revert Heq.\napply Rlt_not_eq.\napply Rlt_trans with R0.\nnow apply F2R_lt_0.\nnow apply F2R_gt_0.\napply Rgt_not_eq.\napply Rgt_trans with R0.\nnow apply F2R_gt_0.\nnow apply F2R_lt_0.\nassert (mx = my /\\ ex = ey).\nrefine (_ (canonical_unique _ fexp _ _ _ _ Heq)).\nrewrite Hs.\nnow case sy ; intro H ; injection H ; split.\nnow apply canonical_bounded.\nnow apply canonical_bounded.\nrevert Hx.\nrewrite Hs, (proj1 H), (proj2 H).\nintros Hx.\napply f_equal.\napply eqbool_irrelevance."},{"statement":"(x : binary_float) : BinarySingleNaN.is_finite (B2BSN x) = is_finite x.","conclusion":"BinarySingleNaN.is_finite (B2BSN x) = is_finite x","hypotheses":"(x : binary_float)","proofString":"now destruct x."},{"statement":"(x y : binary_float) (H : is_finite x = true) (H0 : is_finite y = true) (H1 : B2R x = B2R y) (H2 : Bsign x = Bsign y) : x = y.","conclusion":"x = y","hypotheses":"(x y : binary_float) (H : is_finite x = true) (H0 : is_finite y = true) (H1 : B2R x = B2R y) (H2 : Bsign x = Bsign y)","proofString":"destruct x, y; try (apply B2R_inj; now eauto).\nsimpl in H2.\ncongruence.\nsymmetry in H1.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : Bsign (B754_zero s) = Bsign (B754_zero s0)) : B754_zero s = B754_zero s0.","conclusion":"B754_zero s = B754_zero s0","hypotheses":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : Bsign (B754_zero s) = Bsign (B754_zero s0))","proofString":"simpl in H2.\ncongruence."},{"statement":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : s = s0) : B754_zero s = B754_zero s0.","conclusion":"B754_zero s = B754_zero s0","hypotheses":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : s = s0)","proofString":"congruence."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_zero s) = B2R (B754_finite s0 m e e0)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_zero s) = B2R (B754_finite s0 m e e0)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"symmetry in H1.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_finite s0 m e e0) = B2R (B754_zero s)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_finite s0 m e e0) = B2R (B754_zero s)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"apply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"pose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < bpow radix2 e)%R) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < bpow radix2 e)%R)","proofString":"rewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < 0)%R) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < 0)%R)","proofString":"apply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : False) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : False)","proofString":"destruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_finite s m e e0) = B2R (B754_zero s0)) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_finite s m e e0) = B2R (B754_zero s0)) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0))","proofString":"apply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0))","proofString":"pose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < bpow radix2 e)%R) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < bpow radix2 e)%R)","proofString":"rewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < 0)%R) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < 0)%R)","proofString":"apply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : False) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : False)","proofString":"destruct H3."},{"statement":"(x : {x0 : binary_float | is_nan x0 = true}) : nan_pl (get_nan_pl (proj1_sig x)) = true.","conclusion":"nan_pl (get_nan_pl (proj1_sig x)) = true","hypotheses":"(x : {x0 : binary_float | is_nan x0 = true})","proofString":"destruct x as [x H].\nassert (K: false = true -> nan_pl 1 = true) by (intros K ; now elim Bool.diff_false_true).\nsimpl.\nrevert H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx]; try apply K.\nintros _.\napply Px."},{"statement":"(x : binary_float) (H : is_nan x = true) (K : false = true -> nan_pl 1 = true) : nan_pl (get_nan_pl x) = true.","conclusion":"nan_pl (get_nan_pl x) = true","hypotheses":"(x : binary_float) (H : is_nan x = true) (K : false = true -> nan_pl 1 = true)","proofString":"revert H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx]; try apply K.\nintros _.\napply Px."},{"statement":"(x : binary_float) (K : false = true -> nan_pl 1 = true) : is_nan x = true -> nan_pl (get_nan_pl x) = true.","conclusion":"is_nan x = true -> nan_pl (get_nan_pl x) = true","hypotheses":"(x : binary_float) (K : false = true -> nan_pl 1 = true)","proofString":"destruct x as [sx|sx|sx px Px|sx mx ex Bx]; try apply K.\nintros _.\napply Px."},{"statement":"(sx : bool) (px : positive) (Px : nan_pl px = true) (K : false = true -> nan_pl 1 = true) : is_nan (B754_nan sx px Px) = true ->\nnan_pl (get_nan_pl (B754_nan sx px Px)) = true.","conclusion":"is_nan (B754_nan sx px Px) = true ->\nnan_pl (get_nan_pl (B754_nan sx px Px)) = true","hypotheses":"(sx : bool) (px : positive) (Px : nan_pl px = true) (K : false = true -> nan_pl 1 = true)","proofString":"intros _.\napply Px."},{"statement":"(sx : bool) (px : positive) (Px : nan_pl px = true) (K : false = true -> nan_pl 1 = true) : nan_pl (get_nan_pl (B754_nan sx px Px)) = true.","conclusion":"nan_pl (get_nan_pl (B754_nan sx px Px)) = true","hypotheses":"(sx : bool) (px : positive) (Px : nan_pl px = true) (K : false = true -> nan_pl 1 = true)","proofString":"apply Px."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (H : BinarySingleNaN.is_nan (BinarySingleNaN.B754_finite sx mx ex Bx) = false) : binary_float.","conclusion":"binary_float","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (H : BinarySingleNaN.is_nan (BinarySingleNaN.B754_finite sx mx ex Bx) = false)","proofString":"exact (B754_finite sx mx ex Bx)."},{"statement":"(s : bool) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool)","proofString":"exact (B754_zero s)."},{"statement":"(s : bool) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool)","proofString":"exact (B754_infinity s)."},{"statement":"(s : bool) (pl : positive) (H : nan_pl pl = true) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool) (pl : positive) (H : nan_pl pl = true)","proofString":"apply (B754_nan s pl).\ndestruct nan_pl.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (pl : positive) (H : nan_pl pl = true) : nan_pl pl = true.","conclusion":"nan_pl pl = true","hypotheses":"(s : bool) (pl : positive) (H : nan_pl pl = true)","proofString":"destruct nan_pl.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (pl : positive) (H : true = true) : true = true.","conclusion":"true = true","hypotheses":"(s : bool) (pl : positive) (H : true = true)","proofString":"apply eq_refl."},{"statement":"(s : bool) (pl : positive) (H : false = true) : false = true.","conclusion":"false = true","hypotheses":"(s : bool) (pl : positive) (H : false = true)","proofString":"exact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"apply (B754_finite s m e).\ndestruct bounded.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : bounded m e = true.","conclusion":"bounded m e = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"destruct bounded.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : true = true) : true = true.","conclusion":"true = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : true = true)","proofString":"apply eq_refl."},{"statement":"(s : bool) (m : positive) (e : Z) (H : false = true) : false = true.","conclusion":"false = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : false = true)","proofString":"exact H."},{"statement":"(s : bool) (pl : positive) (H : nan_pl pl = true) : B754_nan s pl\n  ((if nan_pl pl as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_nan s pl H.","conclusion":"B754_nan s pl\n  ((if nan_pl pl as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_nan s pl H","hypotheses":"(s : bool) (pl : positive) (H : nan_pl pl = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : B754_finite s m e\n  ((if bounded m e as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_finite s m e H.","conclusion":"B754_finite s m e\n  ((if bounded m e as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_finite s m e H","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(opp_nan : binary_float -> {x : binary_float | is_nan x = true}) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : (- B2R (B754_finite sx mx ex Hx))%R =\nB2R (Bopp opp_nan (B754_finite sx mx ex Hx)).","conclusion":"(- B2R (B754_finite sx mx ex Hx))%R =\nB2R (Bopp opp_nan (B754_finite sx mx ex Hx))","hypotheses":"(opp_nan : binary_float -> {x : binary_float | is_nan x = true}) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\nrewrite <- F2R_opp.\nnow case sx."},{"statement":"(abs_nan : binary_float -> {x : binary_float | is_nan x = true}) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : Rabs (B2R (B754_finite sx mx ex Hx)) =\nB2R (Babs abs_nan (B754_finite sx mx ex Hx)).","conclusion":"Rabs (B2R (B754_finite sx mx ex Hx)) =\nB2R (Babs abs_nan (B754_finite sx mx ex Hx))","hypotheses":"(abs_nan : binary_float -> {x : binary_float | is_nan x = true}) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\nrewrite <- F2R_abs.\nnow destruct sx."},{"statement":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true) : Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)).","conclusion":"Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2))","hypotheses":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true)","proofString":"unfold Bcompare.\nrewrite BinarySingleNaN.Bcompare_correct.\nnow rewrite 2!B2R_B2BSN.\nnow rewrite is_finite_B2BSN.\nnow rewrite is_finite_B2BSN."},{"statement":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true) : BinarySingleNaN.Bcompare (B2BSN f1) (B2BSN f2) =\nSome (Rcompare (B2R f1) (B2R f2)).","conclusion":"BinarySingleNaN.Bcompare (B2BSN f1) (B2BSN f2) =\nSome (Rcompare (B2R f1) (B2R f2))","hypotheses":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true)","proofString":"rewrite BinarySingleNaN.Bcompare_correct.\nnow rewrite 2!B2R_B2BSN.\nnow rewrite is_finite_B2BSN.\nnow rewrite is_finite_B2BSN."},{"statement":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true) : Some\n  (Rcompare (BinarySingleNaN.B2R (B2BSN f1)) (BinarySingleNaN.B2R (B2BSN f2))) =\nSome (Rcompare (B2R f1) (B2R f2)).","conclusion":"Some\n  (Rcompare (BinarySingleNaN.B2R (B2BSN f1)) (BinarySingleNaN.B2R (B2BSN f2))) =\nSome (Rcompare (B2R f1) (B2R f2))","hypotheses":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true)","proofString":"now rewrite 2!B2R_B2BSN."},{"statement":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true) : BinarySingleNaN.is_finite (B2BSN f1) = true.","conclusion":"BinarySingleNaN.is_finite (B2BSN f1) = true","hypotheses":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true)","proofString":"now rewrite is_finite_B2BSN."},{"statement":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true) : BinarySingleNaN.is_finite (B2BSN f2) = true.","conclusion":"BinarySingleNaN.is_finite (B2BSN f2) = true","hypotheses":"(f1 f2 : binary_float) (H1 : is_finite f1 = true) (H2 : is_finite f2 = true)","proofString":"now rewrite is_finite_B2BSN."},{"statement":"(x y : binary_float) : Bcompare y x =\nmatch Bcompare x y with\n| Some c => Some (CompOpp c)\n| None => None\nend.","conclusion":"Bcompare y x =\nmatch Bcompare x y with\n| Some c => Some (CompOpp c)\n| None => None\nend","hypotheses":"(x y : binary_float)","proofString":"apply BinarySingleNaN.Bcompare_swap."},{"statement":"(x : binary_float) : (Rabs (B2R x) <= bpow radix2 emax - bpow radix2 (emax - prec))%R.","conclusion":"(Rabs (B2R x) <= bpow radix2 emax - bpow radix2 (emax - prec))%R","hypotheses":"(x : binary_float)","proofString":"rewrite <- B2R_B2BSN.\nnow apply abs_B2R_le_emax_minus_prec."},{"statement":"(x : binary_float) : (Rabs (BinarySingleNaN.B2R (B2BSN x)) <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R.","conclusion":"(Rabs (BinarySingleNaN.B2R (B2BSN x)) <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R","hypotheses":"(x : binary_float)","proofString":"now apply abs_B2R_le_emax_minus_prec."},{"statement":"(x : binary_float) : (Rabs (B2R x) < bpow radix2 emax)%R.","conclusion":"(Rabs (B2R x) < bpow radix2 emax)%R","hypotheses":"(x : binary_float)","proofString":"rewrite <- B2R_B2BSN.\nnow apply abs_B2R_lt_emax."},{"statement":"(x : binary_float) : (Rabs (BinarySingleNaN.B2R (B2BSN x)) < bpow radix2 emax)%R.","conclusion":"(Rabs (BinarySingleNaN.B2R (B2BSN x)) < bpow radix2 emax)%R","hypotheses":"(x : binary_float)","proofString":"now apply abs_B2R_lt_emax."},{"statement":"(x : binary_float) : is_finite_strict x = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <= Rabs (B2R x))%R.","conclusion":"is_finite_strict x = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <= Rabs (B2R x))%R","hypotheses":"(x : binary_float)","proofString":"rewrite <- is_finite_strict_B2BSN.\nrewrite <- B2R_B2BSN.\nnow apply abs_B2R_ge_emin."},{"statement":"(x : binary_float) : BinarySingleNaN.is_finite_strict (B2BSN x) = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <= Rabs (B2R x))%R.","conclusion":"BinarySingleNaN.is_finite_strict (B2BSN x) = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <= Rabs (B2R x))%R","hypotheses":"(x : binary_float)","proofString":"rewrite <- B2R_B2BSN.\nnow apply abs_B2R_ge_emin."},{"statement":"(x : binary_float) : BinarySingleNaN.is_finite_strict (B2BSN x) = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <=\n Rabs (BinarySingleNaN.B2R (B2BSN x)))%R.","conclusion":"BinarySingleNaN.is_finite_strict (B2BSN x) = true ->\n(bpow radix2 (SpecFloat.emin prec emax) <=\n Rabs (BinarySingleNaN.B2R (B2BSN x)))%R","hypotheses":"(x : binary_float)","proofString":"now apply abs_B2R_ge_emin."},{"statement":"(m e : Z) (l : location) : (0 <= m)%Z ->\nSpecFloat.shr_fexp prec emax m e l =\n(let\n '(m', e', l') := truncate radix2 (SpecFloat.fexp prec emax) (m, e, l) in\n  (shr_record_of_loc m' l', e')).","conclusion":"(0 <= m)%Z ->\nSpecFloat.shr_fexp prec emax m e l =\n(let\n '(m', e', l') := truncate radix2 (SpecFloat.fexp prec emax) (m, e, l) in\n  (shr_record_of_loc m' l', e'))","hypotheses":"(m e : Z) (l : location)","proofString":"now apply shr_fexp_truncate."},{"statement":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s) : x = binary_overflow m s.","conclusion":"x = binary_overflow m s","hypotheses":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s)","proofString":"unfold binary_overflow.\nrewrite <- H.\napply eq_sym, SF2FF_FF2SF.\nrewrite <- is_nan_FF2SF, H.\napply is_nan_binary_overflow."},{"statement":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s) : x = SF2FF (BinarySingleNaN.binary_overflow prec emax m s).","conclusion":"x = SF2FF (BinarySingleNaN.binary_overflow prec emax m s)","hypotheses":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s)","proofString":"rewrite <- H.\napply eq_sym, SF2FF_FF2SF.\nrewrite <- is_nan_FF2SF, H.\napply is_nan_binary_overflow."},{"statement":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s) : x = SF2FF (FF2SF x).","conclusion":"x = SF2FF (FF2SF x)","hypotheses":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s)","proofString":"apply eq_sym, SF2FF_FF2SF.\nrewrite <- is_nan_FF2SF, H.\napply is_nan_binary_overflow."},{"statement":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s) : is_nan_FF x = false.","conclusion":"is_nan_FF x = false","hypotheses":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s)","proofString":"rewrite <- is_nan_FF2SF, H.\napply is_nan_binary_overflow."},{"statement":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s) : is_nan_SF (BinarySingleNaN.binary_overflow prec emax m s) = false.","conclusion":"is_nan_SF (BinarySingleNaN.binary_overflow prec emax m s) = false","hypotheses":"(x : full_float) (m : mode) (s : bool) (H : FF2SF x = BinarySingleNaN.binary_overflow prec emax m s)","proofString":"apply is_nan_binary_overflow."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : let z := binary_round_aux mode (Rlt_bool x 0) mx ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0)).","conclusion":"let z := binary_round_aux mode (Rlt_bool x 0) mx ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"generalize (binary_round_aux_correct' prec emax _ _ mode x mx ex lx Px Bx Ex).\nunfold binary_round_aux.\ndestruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : (let z :=\n   BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx in\n valid_binary_SF z = true /\\\n (if\n   Rlt_bool\n     (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n     (bpow radix2 emax)\n  then\n   SF2R radix2 z =\n   round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n   is_finite_SF z = true /\\ sign_SF z = Rlt_bool x 0\n  else z = BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) ->\nlet z := binary_round_aux mode (Rlt_bool x 0) mx ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0)).","conclusion":"(let z :=\n   BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx in\n valid_binary_SF z = true /\\\n (if\n   Rlt_bool\n     (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n     (bpow radix2 emax)\n  then\n   SF2R radix2 z =\n   round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n   is_finite_SF z = true /\\ sign_SF z = Rlt_bool x 0\n  else z = BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) ->\nlet z := binary_round_aux mode (Rlt_bool x 0) mx ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"unfold binary_round_aux.\ndestruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  SF2R radix2\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  true /\\\n  sign_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  Rlt_bool x 0\n else\n  BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) = true /\\\n  sign_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) = Rlt_bool x 0\n else\n  SF2FF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  binary_overflow mode (Rlt_bool x 0)).","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  SF2R radix2\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  true /\\\n  sign_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  Rlt_bool x 0\n else\n  BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) = true /\\\n  sign_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) mx ex lx)) = Rlt_bool x 0\n else\n  SF2FF\n    (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\n  binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"destruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nSF2R radix2\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nsign_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nRlt_bool x 0 ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nFF2R radix2\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nsign_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\nRlt_bool x 0.","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nSF2R radix2\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nsign_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nRlt_bool x 0 ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nFF2R radix2\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nsign_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\nRlt_bool x 0","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"now destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez]."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nBinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx =\nBinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nSF2FF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nbinary_overflow mode (Rlt_bool x 0).","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\ntrue /\\\nBinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx =\nBinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx)) =\ntrue /\\\nSF2FF\n  (BinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) mx ex lx) =\nbinary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"intros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0).","conclusion":"valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"split.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue.","conclusion":"valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"rewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) = true.","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) = true","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"now apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z) : SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0).","conclusion":"SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx ex : Z) (lx : location) (Px : x <> 0%R) (Bx : inbetween_float radix2 mx ex (Rabs x) lx) (Ex : (ex <= cexp radix2 (SpecFloat.fexp prec emax) x)%Z)","proofString":"easy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : let z := binary_round_aux mode (Rlt_bool x 0) (Z.pos mx) ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0)).","conclusion":"let z := binary_round_aux mode (Rlt_bool x 0) (Z.pos mx) ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"generalize (binary_round_aux_correct prec emax _ _ mode x mx ex lx Bx Ex).\nunfold binary_round_aux.\ndestruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : (let z :=\n   BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx in\n valid_binary_SF z = true /\\\n (if\n   Rlt_bool\n     (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n     (bpow radix2 emax)\n  then\n   SF2R radix2 z =\n   round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n   is_finite_SF z = true /\\ sign_SF z = Rlt_bool x 0\n  else z = BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) ->\nlet z := binary_round_aux mode (Rlt_bool x 0) (Z.pos mx) ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0)).","conclusion":"(let z :=\n   BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx in\n valid_binary_SF z = true /\\\n (if\n   Rlt_bool\n     (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n     (bpow radix2 emax)\n  then\n   SF2R radix2 z =\n   round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n   is_finite_SF z = true /\\ sign_SF z = Rlt_bool x 0\n  else z = BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) ->\nlet z := binary_round_aux mode (Rlt_bool x 0) (Z.pos mx) ex lx in\nvalid_binary z = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2 z = round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF z = true /\\ sign_FF z = Rlt_bool x 0\n else z = binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"unfold binary_round_aux.\ndestruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  SF2R radix2\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\n  sign_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = Rlt_bool x 0\n else\n  BinarySingleNaN.binary_round_aux prec emax mode \n    (Rlt_bool x 0) (Z.pos mx) ex lx =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\n  sign_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) = Rlt_bool x 0\n else\n  SF2FF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = binary_overflow mode (Rlt_bool x 0)).","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  SF2R radix2\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\n  sign_SF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = Rlt_bool x 0\n else\n  BinarySingleNaN.binary_round_aux prec emax mode \n    (Rlt_bool x 0) (Z.pos mx) ex lx =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\n(if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x))\n    (bpow radix2 emax)\n then\n  FF2R radix2\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\n  is_finite_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\n  sign_FF\n    (SF2FF\n       (BinarySingleNaN.binary_round_aux prec emax mode \n          (Rlt_bool x 0) (Z.pos mx) ex lx)) = Rlt_bool x 0\n else\n  SF2FF\n    (BinarySingleNaN.binary_round_aux prec emax mode \n       (Rlt_bool x 0) (Z.pos mx) ex lx) = binary_overflow mode (Rlt_bool x 0))","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"destruct (Rlt_bool (Rabs _) _).\nnow destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez].\nintros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nSF2R radix2\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nsign_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = Rlt_bool x 0 ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nFF2R radix2\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nsign_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = Rlt_bool x 0.","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nSF2R radix2\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nsign_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = Rlt_bool x 0 ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nFF2R radix2\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) x /\\\nis_finite_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nsign_FF\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = Rlt_bool x 0","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"now destruct BinarySingleNaN.binary_round_aux as [sz|sz| |sz mz ez]."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nBinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) \n  (Z.pos mx) ex lx =\nBinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nSF2FF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = binary_overflow mode (Rlt_bool x 0).","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = true /\\\nBinarySingleNaN.binary_round_aux prec emax mode (Rlt_bool x 0) \n  (Z.pos mx) ex lx =\nBinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0) ->\nvalid_binary\n  (SF2FF\n     (BinarySingleNaN.binary_round_aux prec emax mode \n        (Rlt_bool x 0) (Z.pos mx) ex lx)) = true /\\\nSF2FF\n  (BinarySingleNaN.binary_round_aux prec emax mode \n     (Rlt_bool x 0) (Z.pos mx) ex lx) = binary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"intros [_ ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0).","conclusion":"valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"split.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue.","conclusion":"valid_binary\n  (SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0))) =\ntrue","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"rewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : valid_binary_SF\n  (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) = true.","conclusion":"valid_binary_SF\n  (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) = true","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"now apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z) : SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0).","conclusion":"SF2FF (BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool x 0)) =\nbinary_overflow mode (Rlt_bool x 0)","hypotheses":"(mode : BinarySingleNaN.mode) (x : R) (mx : positive) (ex : Z) (lx : location) (Bx : inbetween_float radix2 (Z.pos mx) ex (Rabs x) lx) (Ex : (ex <= SpecFloat.fexp prec emax (Zdigits radix2 (Z.pos mx) + ex))%Z)","proofString":"easy."},{"statement":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float)","proofString":"generalize (Bmult_correct prec emax _ _ mode (B2BSN x) (B2BSN y)).\nreplace (BinarySingleNaN.Bmult _ _ _) with (B2BSN (Bmult mult_nan mode x y)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|sx|sx plx Hplx|sx mx ex Hx] ;  destruct y as [sy|sy|sy ply Hply|sy my ey Hy] ;  try ( rewrite ?Rmult_0_r, ?Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ try easy | apply bpow_gt_0 | now auto with typeclass_instances ]).\nrevert H.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n  (BinarySingleNaN.is_nan (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n   false ->\n   BinarySingleNaN.Bsign (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n  (BinarySingleNaN.is_nan (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n   false ->\n   BinarySingleNaN.Bsign (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bmult mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float)","proofString":"replace (BinarySingleNaN.Bmult _ _ _) with (B2BSN (Bmult mult_nan mode x y)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|sx|sx plx Hplx|sx mx ex Hx] ;  destruct y as [sy|sy|sy ply Hply|sy my ey Hy] ;  try ( rewrite ?Rmult_0_r, ?Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ try easy | apply bpow_gt_0 | now auto with typeclass_instances ]).\nrevert H.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bmult mult_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bmult mult_nan mode x y)) =\n  (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bmult mult_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bmult mult_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bmult mult_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bmult mult_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bmult mult_nan mode x y)) =\n  (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bmult mult_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bmult mult_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bmult mult_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float)","proofString":"intros H.\ndestruct x as [sx|sx|sx plx Hplx|sx mx ex Hx] ;  destruct y as [sy|sy|sy ply Hply|sy my ey Hy] ;  try ( rewrite ?Rmult_0_r, ?Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ try easy | apply bpow_gt_0 | now auto with typeclass_instances ]).\nrevert H.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (H : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n   (bpow radix2 emax)\nthen\n BinarySingleNaN.B2R (B2BSN (Bmult mult_nan mode x y)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n BinarySingleNaN.is_finite (B2BSN (Bmult mult_nan mode x y)) =\n (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n (BinarySingleNaN.is_nan (B2BSN (Bmult mult_nan mode x y)) = false ->\n  BinarySingleNaN.Bsign (B2BSN (Bmult mult_nan mode x y)) =\n  xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\nelse\n BinarySingleNaN.B2SF (B2BSN (Bmult mult_nan mode x y)) =\n BinarySingleNaN.binary_overflow prec emax mode\n   (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y))) (bpow radix2 emax)\nthen\n B2R (Bmult mult_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * B2R y) /\\\n is_finite (Bmult mult_nan mode x y) = (is_finite x && is_finite y)%bool /\\\n (is_nan (Bmult mult_nan mode x y) = false ->\n  Bsign (Bmult mult_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bmult mult_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (H : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y))))\n   (bpow radix2 emax)\nthen\n BinarySingleNaN.B2R (B2BSN (Bmult mult_nan mode x y)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y)) /\\\n BinarySingleNaN.is_finite (B2BSN (Bmult mult_nan mode x y)) =\n (BinarySingleNaN.is_finite (B2BSN x) && BinarySingleNaN.is_finite (B2BSN y))%bool /\\\n (BinarySingleNaN.is_nan (B2BSN (Bmult mult_nan mode x y)) = false ->\n  BinarySingleNaN.Bsign (B2BSN (Bmult mult_nan mode x y)) =\n  xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\nelse\n BinarySingleNaN.B2SF (B2BSN (Bmult mult_nan mode x y)) =\n BinarySingleNaN.binary_overflow prec emax mode\n   (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y))))","proofString":"destruct x as [sx|sx|sx plx Hplx|sx mx ex Hx] ;  destruct y as [sy|sy|sy ply Hply|sy my ey Hy] ;  try ( rewrite ?Rmult_0_r, ?Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ try easy | apply bpow_gt_0 | now auto with typeclass_instances ]).\nrevert H.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n          BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n   (bpow radix2 emax)\nthen\n BinarySingleNaN.B2R\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n    BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n BinarySingleNaN.is_finite\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n  BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n (BinarySingleNaN.is_nan\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) = false ->\n  BinarySingleNaN.Bsign\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n    (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\nelse\n BinarySingleNaN.B2SF\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n BinarySingleNaN.binary_overflow prec emax mode\n   (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n      (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n          BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n   (bpow radix2 emax)\nthen\n BinarySingleNaN.B2R\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n    BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n BinarySingleNaN.is_finite\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n  BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n (BinarySingleNaN.is_nan\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) = false ->\n  BinarySingleNaN.Bsign\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n    (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\nelse\n BinarySingleNaN.B2SF\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n BinarySingleNaN.binary_overflow prec emax mode\n   (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n      (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))))","proofString":"revert H.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n           BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n     BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n   BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n           BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n     BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n   BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"rewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n   BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  (BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n   BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n          (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"destruct Rlt_bool.\nnow destruct Bmult.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : BinarySingleNaN.B2R\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\nBinarySingleNaN.is_finite\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n(BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n(BinarySingleNaN.is_nan\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n   (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2R (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\nis_finite\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n(is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n(is_nan\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n false ->\n Bsign\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"BinarySingleNaN.B2R\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\nBinarySingleNaN.is_finite\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n(BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) &&\n BinarySingleNaN.is_finite (B2BSN (B754_finite sy my ey Hy)))%bool /\\\n(BinarySingleNaN.is_nan\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN\n      (Bmult mult_nan mode (B754_finite sx mx ex Hx)\n         (B754_finite sy my ey Hy))) =\n xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n   (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2R (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\nis_finite\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n(is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n(is_nan\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n false ->\n Bsign\n   (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"now destruct Bmult."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2FF\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2FF\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"intros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) : B2FF\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"B2FF\n  (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))))","proofString":"apply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) : FF2SF\n  (B2FF\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"FF2SF\n  (B2FF\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(mult_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bmult mult_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))))","proofString":"now rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true /\\\nBinarySingleNaN.binary_round prec emax mode sx mx ex =\nBinarySingleNaN.binary_overflow prec emax mode sx ->\nvalid_binary (SF2FF (BinarySingleNaN.binary_round prec emax mode sx mx ex)) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_round prec emax mode sx mx ex) =\nbinary_overflow mode sx.","conclusion":"valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true /\\\nBinarySingleNaN.binary_round prec emax mode sx mx ex =\nBinarySingleNaN.binary_overflow prec emax mode sx ->\nvalid_binary (SF2FF (BinarySingleNaN.binary_round prec emax mode sx mx ex)) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_round prec emax mode sx mx ex) =\nbinary_overflow mode sx","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z)","proofString":"intros [H1 ->].\nsplit.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true) : valid_binary (SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx)) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode sx) =\nbinary_overflow mode sx.","conclusion":"valid_binary (SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx)) =\ntrue /\\\nSF2FF (BinarySingleNaN.binary_overflow prec emax mode sx) =\nbinary_overflow mode sx","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true)","proofString":"split.\nrewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct.\neasy."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true) : valid_binary (SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx)) =\ntrue.","conclusion":"valid_binary (SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx)) =\ntrue","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true)","proofString":"rewrite valid_binary_SF2FF by apply is_nan_binary_overflow.\nnow apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true) : valid_binary_SF (BinarySingleNaN.binary_overflow prec emax mode sx) = true.","conclusion":"valid_binary_SF (BinarySingleNaN.binary_overflow prec emax mode sx) = true","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true)","proofString":"now apply binary_overflow_correct."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true) : SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx) =\nbinary_overflow mode sx.","conclusion":"SF2FF (BinarySingleNaN.binary_overflow prec emax mode sx) =\nbinary_overflow mode sx","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (H1 : valid_binary_SF (BinarySingleNaN.binary_round prec emax mode sx mx ex) = true)","proofString":"easy."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true)","proofString":"rewrite <- is_finite_B2BSN in Fx, Fy.\ngeneralize (Bplus_correct prec emax _ _ mode _ _ Fx Fy).\nreplace (BinarySingleNaN.Bplus _ _ _) with (B2BSN (Bplus plus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"generalize (Bplus_correct prec emax _ _ mode _ _ Fx Fy).\nreplace (BinarySingleNaN.Bplus _ _ _) with (B2BSN (Bplus plus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bplus mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"replace (BinarySingleNaN.Bplus _ _ _) with (B2BSN (Bplus plus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) + BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x) || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ => (Bsign x && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || BinarySingleNaN.Bsign (B2BSN y))%bool\n      | _ => (Bsign x && BinarySingleNaN.Bsign (B2BSN y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = BinarySingleNaN.Bsign (B2BSN y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || Bsign y)%bool\n      | _ => (Bsign x && Bsign y)%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = Bsign y) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y.","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x + B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\n  match Rcompare (B2R x + B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || Bsign y)%bool\n      | _ => (Bsign x && Bsign y)%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = Bsign y) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x + B2R y))) (bpow radix2 emax)\nthen\n B2R (Bplus plus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\n is_finite (Bplus plus_nan mode x y) = true /\\\n Bsign (Bplus plus_nan mode x y) =\n match Rcompare (B2R x + B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || Bsign y)%bool\n     | _ => (Bsign x && Bsign y)%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"destruct Rlt_bool.\nnow destruct Bplus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\nBinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\nmatch Rcompare (B2R x + B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || Bsign y)%bool\n    | _ => (Bsign x && Bsign y)%bool\n    end\n| Lt => true\n| Gt => false\nend ->\nB2R (Bplus plus_nan mode x y) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\nis_finite (Bplus plus_nan mode x y) = true /\\\nBsign (Bplus plus_nan mode x y) =\nmatch Rcompare (B2R x + B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || Bsign y)%bool\n    | _ => (Bsign x && Bsign y)%bool\n    end\n| Lt => true\n| Gt => false\nend.","conclusion":"BinarySingleNaN.B2R (B2BSN (Bplus plus_nan mode x y)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\nBinarySingleNaN.is_finite (B2BSN (Bplus plus_nan mode x y)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bplus plus_nan mode x y)) =\nmatch Rcompare (B2R x + B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || Bsign y)%bool\n    | _ => (Bsign x && Bsign y)%bool\n    end\n| Lt => true\n| Gt => false\nend ->\nB2R (Bplus plus_nan mode x y) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x + B2R y) /\\\nis_finite (Bplus plus_nan mode x y) = true /\\\nBsign (Bplus plus_nan mode x y) =\nmatch Rcompare (B2R x + B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || Bsign y)%bool\n    | _ => (Bsign x && Bsign y)%bool\n    end\n| Lt => true\n| Gt => false\nend","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"now destruct Bplus."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\ \nBsign x = Bsign y ->\nB2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = Bsign y.","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\ \nBsign x = Bsign y ->\nB2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"intros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y) : B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = Bsign y.","conclusion":"B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = Bsign y","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y)","proofString":"refine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y) : B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x).","conclusion":"B2FF (Bplus plus_nan mode x y) = binary_overflow mode (Bsign x)","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y)","proofString":"apply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y) : FF2SF (B2FF (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x).","conclusion":"FF2SF (B2FF (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)","hypotheses":"(plus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bplus plus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = Bsign y)","proofString":"now rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true)","proofString":"rewrite <- is_finite_B2BSN in Fx, Fy.\ngeneralize (Bminus_correct prec emax _ _ mode _ _ Fx Fy).\nreplace (BinarySingleNaN.Bminus _ _ _) with (B2BSN (Bminus minus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"generalize (Bminus_correct prec emax _ _ mode _ _ Fx Fy).\nreplace (BinarySingleNaN.Bminus _ _ _) with (B2BSN (Bminus minus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bminus mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"replace (BinarySingleNaN.Bminus _ _ _) with (B2BSN (Bminus minus_nan mode x y)) by apply B2BSN_BSN2B.\nrewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match\n    Rcompare (BinarySingleNaN.B2R (B2BSN x) - BinarySingleNaN.B2R (B2BSN y))\n      0\n  with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite 2!B2R_B2BSN.\nrewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN =>\n          (BinarySingleNaN.Bsign (B2BSN x)\n           || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ =>\n          (BinarySingleNaN.Bsign (B2BSN x) &&\n           negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x)) /\\\n  BinarySingleNaN.Bsign (B2BSN x) = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite (Bsign_B2BSN x) by (clear -Fx ; now destruct x).\nrewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ => (Bsign x && negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      | _ => (Bsign x && negb (BinarySingleNaN.Bsign (B2BSN y)))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = negb (BinarySingleNaN.Bsign (B2BSN y))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"rewrite (Bsign_B2BSN y) by (clear -Fy ; now destruct y).\ndestruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || negb (Bsign y))%bool\n      | _ => (Bsign x && negb (Bsign y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = negb (Bsign y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x - B2R y))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\n  match Rcompare (B2R x - B2R y) 0 with\n  | Eq =>\n      match mode with\n      | mode_DN => (Bsign x || negb (Bsign y))%bool\n      | _ => (Bsign x && negb (Bsign y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\n  Bsign x = negb (Bsign y)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x - B2R y))) (bpow radix2 emax)\nthen\n B2R (Bminus minus_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\n is_finite (Bminus minus_nan mode x y) = true /\\\n Bsign (Bminus minus_nan mode x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match mode with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"destruct Rlt_bool.\nnow destruct Bminus.\nintros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\nBinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\nmatch Rcompare (B2R x - B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || negb (Bsign y))%bool\n    | _ => (Bsign x && negb (Bsign y))%bool\n    end\n| Lt => true\n| Gt => false\nend ->\nB2R (Bminus minus_nan mode x y) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\nis_finite (Bminus minus_nan mode x y) = true /\\\nBsign (Bminus minus_nan mode x y) =\nmatch Rcompare (B2R x - B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || negb (Bsign y))%bool\n    | _ => (Bsign x && negb (Bsign y))%bool\n    end\n| Lt => true\n| Gt => false\nend.","conclusion":"BinarySingleNaN.B2R (B2BSN (Bminus minus_nan mode x y)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\nBinarySingleNaN.is_finite (B2BSN (Bminus minus_nan mode x y)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bminus minus_nan mode x y)) =\nmatch Rcompare (B2R x - B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || negb (Bsign y))%bool\n    | _ => (Bsign x && negb (Bsign y))%bool\n    end\n| Lt => true\n| Gt => false\nend ->\nB2R (Bminus minus_nan mode x y) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x - B2R y) /\\\nis_finite (Bminus minus_nan mode x y) = true /\\\nBsign (Bminus minus_nan mode x y) =\nmatch Rcompare (B2R x - B2R y) 0 with\n| Eq =>\n    match mode with\n    | mode_DN => (Bsign x || negb (Bsign y))%bool\n    | _ => (Bsign x && negb (Bsign y))%bool\n    end\n| Lt => true\n| Gt => false\nend","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"now destruct Bminus."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\nBsign x = negb (Bsign y) ->\nB2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = negb (Bsign y).","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x) /\\\nBsign x = negb (Bsign y) ->\nB2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true)","proofString":"intros [H1 H2].\nrefine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y)) : B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = negb (Bsign y).","conclusion":"B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x) /\\\nBsign x = negb (Bsign y)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y))","proofString":"refine (conj _ H2).\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y)) : B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x).","conclusion":"B2FF (Bminus minus_nan mode x y) = binary_overflow mode (Bsign x)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y))","proofString":"apply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y)) : FF2SF (B2FF (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x).","conclusion":"FF2SF (B2FF (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)","hypotheses":"(minus_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (H1 : BinarySingleNaN.B2SF (B2BSN (Bminus minus_nan mode x y)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)) (H2 : Bsign x = negb (Bsign y))","proofString":"now rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (Fz : is_finite z = true) : let res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0).","conclusion":"let res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (Fz : is_finite z = true)","proofString":"rewrite <- is_finite_B2BSN in Fx, Fy, Fz.\ngeneralize (Bfma_correct prec emax _ _ mode _ _ _ Fx Fy Fz).\nreplace (BinarySingleNaN.Bfma _ _ _ _) with (B2BSN (Bfma fma_nan mode x y z)) by apply B2BSN_BSN2B.\nrewrite 3!B2R_B2BSN.\ncbv zeta.\ndestruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : let res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0).","conclusion":"let res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"generalize (Bfma_correct prec emax _ _ mode _ _ _ Fx Fy Fz).\nreplace (BinarySingleNaN.Bfma _ _ _ _) with (B2BSN (Bfma fma_nan mode x y z)) by apply B2BSN_BSN2B.\nrewrite 3!B2R_B2BSN.\ncbv zeta.\ndestruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : (let res :=\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y) +\n    BinarySingleNaN.B2R (B2BSN z))%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) = true /\\\n  BinarySingleNaN.Bsign\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0).","conclusion":"(let res :=\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y) +\n    BinarySingleNaN.B2R (B2BSN z))%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) = true /\\\n  BinarySingleNaN.Bsign\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF\n    (BinarySingleNaN.Bfma mode (B2BSN x) (B2BSN y) (B2BSN z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"replace (BinarySingleNaN.Bfma _ _ _ _) with (B2BSN (Bfma fma_nan mode x y z)) by apply B2BSN_BSN2B.\nrewrite 3!B2R_B2BSN.\ncbv zeta.\ndestruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : (let res :=\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y) +\n    BinarySingleNaN.B2R (B2BSN z))%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0).","conclusion":"(let res :=\n   (BinarySingleNaN.B2R (B2BSN x) * BinarySingleNaN.B2R (B2BSN y) +\n    BinarySingleNaN.B2R (B2BSN z))%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"rewrite 3!B2R_B2BSN.\ncbv zeta.\ndestruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : (let res := (B2R x * B2R y + B2R z)%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0).","conclusion":"(let res := (B2R x * B2R y + B2R z)%R in\n if\n  Rlt_bool\n    (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare res 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode (Rlt_bool res 0)) ->\nlet res := (B2R x * B2R y + B2R z)%R in\nif\n Rlt_bool\n   (Rabs (round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res))\n   (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) res /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare res 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse B2FF (Bfma fma_nan mode x y z) = binary_overflow mode (Rlt_bool res 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"cbv zeta.\ndestruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x * B2R y + B2R z))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R x * B2R y + B2R z) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare (B2R x * B2R y + B2R z) 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (Rlt_bool (B2R x * B2R y + B2R z) 0)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y + B2R z))) (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * B2R y + B2R z) /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare (B2R x * B2R y + B2R z) 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bfma fma_nan mode x y z) =\n binary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x * B2R y + B2R z))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R x * B2R y + B2R z) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\n  match Rcompare (B2R x * B2R y + B2R z) 0 with\n  | Eq =>\n      BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n  | Lt => true\n  | Gt => false\n  end\n else\n  BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (Rlt_bool (B2R x * B2R y + B2R z) 0)) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * B2R y + B2R z))) (bpow radix2 emax)\nthen\n B2R (Bfma fma_nan mode x y z) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * B2R y + B2R z) /\\\n is_finite (Bfma fma_nan mode x y z) = true /\\\n Bsign (Bfma fma_nan mode x y z) =\n match Rcompare (B2R x * B2R y + B2R z) 0 with\n | Eq => Bfma_szero mode x y z\n | Lt => true\n | Gt => false\n end\nelse\n B2FF (Bfma fma_nan mode x y z) =\n binary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"destruct Rlt_bool.\nnow destruct Bfma.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * B2R y + B2R z) /\\\nBinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\nmatch Rcompare (B2R x * B2R y + B2R z) 0 with\n| Eq =>\n    BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n| Lt => true\n| Gt => false\nend ->\nB2R (Bfma fma_nan mode x y z) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * B2R y + B2R z) /\\\nis_finite (Bfma fma_nan mode x y z) = true /\\\nBsign (Bfma fma_nan mode x y z) =\nmatch Rcompare (B2R x * B2R y + B2R z) 0 with\n| Eq => Bfma_szero mode x y z\n| Lt => true\n| Gt => false\nend.","conclusion":"BinarySingleNaN.B2R (B2BSN (Bfma fma_nan mode x y z)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * B2R y + B2R z) /\\\nBinarySingleNaN.is_finite (B2BSN (Bfma fma_nan mode x y z)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bfma fma_nan mode x y z)) =\nmatch Rcompare (B2R x * B2R y + B2R z) 0 with\n| Eq =>\n    BinarySingleNaN.Bfma_szero prec emax mode (B2BSN x) (B2BSN y) (B2BSN z)\n| Lt => true\n| Gt => false\nend ->\nB2R (Bfma fma_nan mode x y z) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * B2R y + B2R z) /\\\nis_finite (Bfma fma_nan mode x y z) = true /\\\nBsign (Bfma fma_nan mode x y z) =\nmatch Rcompare (B2R x * B2R y + B2R z) 0 with\n| Eq => Bfma_szero mode x y z\n| Lt => true\n| Gt => false\nend","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"now destruct Bfma."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) : BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0) ->\nB2FF (Bfma fma_nan mode x y z) =\nbinary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0).","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0) ->\nB2FF (Bfma fma_nan mode x y z) =\nbinary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true)","proofString":"intros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) (H : BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0)) : B2FF (Bfma fma_nan mode x y z) =\nbinary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0).","conclusion":"B2FF (Bfma fma_nan mode x y z) =\nbinary_overflow mode (Rlt_bool (B2R x * B2R y + B2R z) 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) (H : BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0))","proofString":"apply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) (H : BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0)) : FF2SF (B2FF (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0).","conclusion":"FF2SF (B2FF (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0)","hypotheses":"(fma_nan : binary_float ->\nbinary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y z : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) (Fy : BinarySingleNaN.is_finite (B2BSN y) = true) (Fz : BinarySingleNaN.is_finite (B2BSN z) = true) (H : BinarySingleNaN.B2SF (B2BSN (Bfma fma_nan mode x y z)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (Rlt_bool (B2R x * B2R y + B2R z) 0))","proofString":"now rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : B2R y <> 0%R) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : B2R y <> 0%R)","proofString":"rewrite <- B2R_B2BSN in Zy.\ngeneralize (Bdiv_correct prec emax _ _ mode (B2BSN x) _ Zy).\nreplace (BinarySingleNaN.Bdiv _ _ _) with (B2BSN (Bdiv div_nan mode x y)) by apply B2BSN_BSN2B.\nunfold Rdiv.\ndestruct y as [sy|sy|sy ply|sy my ey Hy] ; try now elim Zy.\ndestruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R)","proofString":"generalize (Bdiv_correct prec emax _ _ mode (B2BSN x) _ Zy).\nreplace (BinarySingleNaN.Bdiv _ _ _) with (B2BSN (Bdiv div_nan mode x y)) by apply B2BSN_BSN2B.\nunfold Rdiv.\ndestruct y as [sy|sy|sy ply|sy my ey Hy] ; try now elim Zy.\ndestruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n   false ->\n   BinarySingleNaN.Bsign (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n   false ->\n   BinarySingleNaN.Bsign (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bdiv mode (B2BSN x) (B2BSN y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R)","proofString":"replace (BinarySingleNaN.Bdiv _ _ _) with (B2BSN (Bdiv div_nan mode x y)) by apply B2BSN_BSN2B.\nunfold Rdiv.\ndestruct y as [sy|sy|sy ply|sy my ey Hy] ; try now elim Zy.\ndestruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bdiv div_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bdiv div_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bdiv div_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bdiv div_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R)","proofString":"unfold Rdiv.\ndestruct y as [sy|sy|sy ply|sy my ey Hy] ; try now elim Zy.\ndestruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bdiv div_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bdiv div_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y)).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * / BinarySingleNaN.B2R (B2BSN y))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x y)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * / BinarySingleNaN.B2R (B2BSN y)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan (B2BSN (Bdiv div_nan mode x y)) = false ->\n   BinarySingleNaN.Bsign (B2BSN (Bdiv div_nan mode x y)) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))\n else\n  BinarySingleNaN.B2SF (B2BSN (Bdiv div_nan mode x y)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x)) (BinarySingleNaN.Bsign (B2BSN y)))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * / B2R y))) (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x y) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode) (B2R x * / B2R y) /\\\n is_finite (Bdiv div_nan mode x y) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x y) = false ->\n  Bsign (Bdiv div_nan mode x y) = xorb (Bsign x) (Bsign y))\nelse\n B2FF (Bdiv div_nan mode x y) =\n binary_overflow mode (xorb (Bsign x) (Bsign y))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x y : binary_float) (Zy : BinarySingleNaN.B2R (B2BSN y) <> 0%R)","proofString":"destruct y as [sy|sy|sy ply|sy my ey Hy] ; try now elim Zy.\ndestruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) *\n           / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) *\n     / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv div_nan mode x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n binary_overflow mode (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy))).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) *\n           / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) *\n     / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN x))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN (Bdiv div_nan mode x (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN x))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv div_nan mode x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv div_nan mode x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF (Bdiv div_nan mode x (B754_finite sy my ey Hy)) =\n binary_overflow mode (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R)","proofString":"destruct x as [sx|sx|sx plx Hx|sx mx ex Hx] ;  try ( simpl ; rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\ndestruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n           / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n     / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bdiv div_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bdiv div_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n is_finite (B754_finite sx mx ex Hx) /\\\n (is_nan\n    (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n           / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)))))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n     / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\n  BinarySingleNaN.is_finite\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n  (BinarySingleNaN.is_nan\n     (B2BSN\n        (Bdiv div_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) = false ->\n   BinarySingleNaN.Bsign\n     (B2BSN\n        (Bdiv div_nan mode (B754_finite sx mx ex Hx)\n           (B754_finite sy my ey Hy))) =\n   xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))\n else\n  BinarySingleNaN.B2SF\n    (B2BSN\n       (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n       (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n is_finite (B754_finite sx mx ex Hx) /\\\n (is_nan\n    (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign\n    (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow mode\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R)","proofString":"destruct Rlt_bool.\nnow destruct Bdiv.\nintros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) : BinarySingleNaN.B2R\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n   / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n(BinarySingleNaN.is_nan\n   (B2BSN\n      (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n false ->\n BinarySingleNaN.Bsign\n   (B2BSN\n      (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n   (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2R (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\nis_finite\n  (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n false ->\n Bsign\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"BinarySingleNaN.B2R\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)) *\n   / BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n(BinarySingleNaN.is_nan\n   (B2BSN\n      (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n false ->\n BinarySingleNaN.Bsign\n   (B2BSN\n      (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\n xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n   (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2R (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\nis_finite\n  (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n false ->\n Bsign\n   (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R)","proofString":"now destruct Bdiv."},{"statement":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))) ->\nB2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R)","proofString":"intros H.\napply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) : B2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"B2FF (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\nbinary_overflow mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))))","proofString":"apply eq_binary_overflow_FF2SF.\nnow rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy))))) : FF2SF\n  (B2FF\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"FF2SF\n  (B2FF\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(div_nan : binary_float -> binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : BinarySingleNaN.B2R (B2BSN (B754_finite sy my ey Hy)) <> 0%R) (H : BinarySingleNaN.B2SF\n  (B2BSN\n     (Bdiv div_nan mode (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy))) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (xorb (BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))\n     (BinarySingleNaN.Bsign (B2BSN (B754_finite sy my ey Hy)))))","proofString":"now rewrite FF2SF_B2FF, <- B2SF_B2BSN."},{"statement":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : B2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x).","conclusion":"B2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x)","hypotheses":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"generalize (Bsqrt_correct prec emax _ _ mode (B2BSN x)).\nreplace (BinarySingleNaN.Bsqrt _ _) with (B2BSN (Bsqrt sqrt_nan mode x)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bsqrt."},{"statement":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : BinarySingleNaN.B2R (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (BinarySingleNaN.Bsqrt mode (B2BSN x)) = false ->\n BinarySingleNaN.Bsign (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x).","conclusion":"BinarySingleNaN.B2R (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (BinarySingleNaN.Bsqrt mode (B2BSN x)) = false ->\n BinarySingleNaN.Bsign (BinarySingleNaN.Bsqrt mode (B2BSN x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x)","hypotheses":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"replace (BinarySingleNaN.Bsqrt _ _) with (B2BSN (Bsqrt sqrt_nan mode x)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bsqrt."},{"statement":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsqrt sqrt_nan mode x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (B2BSN (Bsqrt sqrt_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bsqrt sqrt_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x).","conclusion":"BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsqrt sqrt_nan mode x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (B2BSN (Bsqrt sqrt_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bsqrt sqrt_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x)","hypotheses":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"intros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bsqrt."},{"statement":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (H : BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsqrt sqrt_nan mode x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (B2BSN (Bsqrt sqrt_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bsqrt sqrt_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x))) : B2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x).","conclusion":"B2R (Bsqrt sqrt_nan mode x) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode) (sqrt (B2R x)) /\\\nis_finite (Bsqrt sqrt_nan mode x) =\nmatch x with\n| B754_zero _ | B754_finite false _ _ _ => true\n| _ => false\nend /\\\n(is_nan (Bsqrt sqrt_nan mode x) = false ->\n Bsign (Bsqrt sqrt_nan mode x) = Bsign x)","hypotheses":"(sqrt_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (H : BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode x)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN x))) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsqrt sqrt_nan mode x)) =\nmatch B2BSN x with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan (B2BSN (Bsqrt sqrt_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bsqrt sqrt_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)))","proofString":"destruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bsqrt."},{"statement":"(sqrt_nan : binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\nmatch B2BSN (B754_finite sx mx ex Hx) with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan\n   (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\n BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))) : B2R (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (B2R (B754_finite sx mx ex Hx))) /\\\nis_finite (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\n(if sx then false else true) /\\\n(is_nan (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx)).","conclusion":"B2R (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (B2R (B754_finite sx mx ex Hx))) /\\\nis_finite (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\n(if sx then false else true) /\\\n(is_nan (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx))","hypotheses":"(sqrt_nan : binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : BinarySingleNaN.B2R (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (sqrt (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx)))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\nmatch B2BSN (B754_finite sx mx ex Hx) with\n| BinarySingleNaN.B754_zero _ | BinarySingleNaN.B754_finite false _ _ _ =>\n    true\n| _ => false\nend /\\\n(BinarySingleNaN.is_nan\n   (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN (Bsqrt sqrt_nan mode (B754_finite sx mx ex Hx))) =\n BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx))))","proofString":"now destruct Bsqrt."},{"statement":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : B2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x).","conclusion":"B2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x)","hypotheses":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"generalize (Bnearbyint_correct prec emax _ mode (B2BSN x)).\nreplace (BinarySingleNaN.Bnearbyint _ _) with (B2BSN (Bnearbyint nearbyint_nan mode x)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bnearbyint."},{"statement":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : BinarySingleNaN.B2R (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (BinarySingleNaN.Bnearbyint mode (B2BSN x)) = false ->\n BinarySingleNaN.Bsign (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x).","conclusion":"BinarySingleNaN.B2R (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (BinarySingleNaN.Bnearbyint mode (B2BSN x)) = false ->\n BinarySingleNaN.Bsign (BinarySingleNaN.Bnearbyint mode (B2BSN x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x)","hypotheses":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"replace (BinarySingleNaN.Bnearbyint _ _) with (B2BSN (Bnearbyint nearbyint_nan mode x)) by apply B2BSN_BSN2B.\nintros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bnearbyint."},{"statement":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) : BinarySingleNaN.B2R (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (B2BSN (Bnearbyint nearbyint_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bnearbyint nearbyint_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x).","conclusion":"BinarySingleNaN.B2R (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (B2BSN (Bnearbyint nearbyint_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bnearbyint nearbyint_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)) ->\nB2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x)","hypotheses":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float)","proofString":"intros H.\ndestruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bnearbyint."},{"statement":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (H : BinarySingleNaN.B2R (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (B2BSN (Bnearbyint nearbyint_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bnearbyint nearbyint_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x))) : B2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x).","conclusion":"B2R (Bnearbyint nearbyint_nan mode x) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R x) /\\\nis_finite (Bnearbyint nearbyint_nan mode x) = is_finite x /\\\n(is_nan (Bnearbyint nearbyint_nan mode x) = false ->\n Bsign (Bnearbyint nearbyint_nan mode x) = Bsign x)","hypotheses":"(nearbyint_nan : binary_float -> {x0 : binary_float | is_nan x0 = true}) (mode : BinarySingleNaN.mode) (x : binary_float) (H : BinarySingleNaN.B2R (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nround radix2 (FIX_exp 0) (round_mode mode) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bnearbyint nearbyint_nan mode x)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\n(BinarySingleNaN.is_nan (B2BSN (Bnearbyint nearbyint_nan mode x)) = false ->\n BinarySingleNaN.Bsign (B2BSN (Bnearbyint nearbyint_nan mode x)) =\n BinarySingleNaN.Bsign (B2BSN x)))","proofString":"destruct x as [sx|[|]|sx plx Hplx|sx mx ex Hx] ; try easy.\nnow destruct Bnearbyint."},{"statement":"(nearbyint_nan : binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : BinarySingleNaN.B2R\n  (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\nround radix2 (FIX_exp 0) (round_mode mode)\n  (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n(BinarySingleNaN.is_nan\n   (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\n BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx)))) : B2R (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx)).","conclusion":"B2R (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\nround radix2 (FIX_exp 0) (round_mode mode) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx))","hypotheses":"(nearbyint_nan : binary_float -> {x : binary_float | is_nan x = true}) (mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : BinarySingleNaN.B2R\n  (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\nround radix2 (FIX_exp 0) (round_mode mode)\n  (BinarySingleNaN.B2R (B2BSN (B754_finite sx mx ex Hx))) /\\\nBinarySingleNaN.is_finite\n  (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Hx)) /\\\n(BinarySingleNaN.is_nan\n   (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) = false ->\n BinarySingleNaN.Bsign\n   (B2BSN (Bnearbyint nearbyint_nan mode (B754_finite sx mx ex Hx))) =\n BinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Hx))))","proofString":"now destruct Bnearbyint."},{"statement":"(x : binary_float) : IZR (Btrunc x) = round radix2 (FIX_exp 0) Ztrunc (B2R x).","conclusion":"IZR (Btrunc x) = round radix2 (FIX_exp 0) Ztrunc (B2R x)","hypotheses":"(x : binary_float)","proofString":"rewrite <-B2R_B2BSN.\nnow apply Btrunc_correct."},{"statement":"(x : binary_float) : IZR (Btrunc x) =\nround radix2 (FIX_exp 0) Ztrunc (BinarySingleNaN.B2R (B2BSN x)).","conclusion":"IZR (Btrunc x) =\nround radix2 (FIX_exp 0) Ztrunc (BinarySingleNaN.B2R (B2BSN x))","hypotheses":"(x : binary_float)","proofString":"now apply Btrunc_correct."},{"statement":"B2R\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = 1%R.","conclusion":"B2R\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = 1%R","hypotheses":"","proofString":"rewrite B2R_BSN2B'.\napply Bone_correct."},{"statement":"BinarySingleNaN.B2R BinarySingleNaN.Bone = 1%R.","conclusion":"BinarySingleNaN.B2R BinarySingleNaN.Bone = 1%R","hypotheses":"","proofString":"apply Bone_correct."},{"statement":"is_finite\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = true.","conclusion":"is_finite\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = true","hypotheses":"","proofString":"rewrite is_finite_BSN2B'.\napply is_finite_Bone."},{"statement":"BinarySingleNaN.is_finite BinarySingleNaN.Bone = true.","conclusion":"BinarySingleNaN.is_finite BinarySingleNaN.Bone = true","hypotheses":"","proofString":"apply is_finite_Bone."},{"statement":"Bsign\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = false.","conclusion":"Bsign\n  (BSN2B' BinarySingleNaN.Bone\n     (is_nan_Bone prec emax prec_gt_0_ prec_lt_emax_)) = false","hypotheses":"","proofString":"rewrite Bsign_BSN2B'.\napply Bsign_Bone."},{"statement":"BinarySingleNaN.Bsign BinarySingleNaN.Bone = false.","conclusion":"BinarySingleNaN.Bsign BinarySingleNaN.Bone = false","hypotheses":"","proofString":"apply Bsign_Bone."},{"statement":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = true) : binary_float.","conclusion":"binary_float","hypotheses":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = true)","proofString":"exact x."},{"statement":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = false) : binary_float.","conclusion":"binary_float","hypotheses":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = false)","proofString":"now apply (BSN2B' y)."},{"statement":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan x) : B2BSN (lift x y Ny) = y.","conclusion":"B2BSN (lift x y Ny) = y","hypotheses":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan x)","proofString":"unfold lift.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl ; try apply B2BSN_BSN2B'.\nnow destruct y."},{"statement":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan x) : B2BSN\n  ((if is_nan x as b return (BinarySingleNaN.is_nan y = b -> binary_float)\n    then fun _ : BinarySingleNaN.is_nan y = true => x\n    else fun Ny0 : BinarySingleNaN.is_nan y = false => BSN2B' y Ny0) Ny) = y.","conclusion":"B2BSN\n  ((if is_nan x as b return (BinarySingleNaN.is_nan y = b -> binary_float)\n    then fun _ : BinarySingleNaN.is_nan y = true => x\n    else fun Ny0 : BinarySingleNaN.is_nan y = false => BSN2B' y Ny0) Ny) = y","hypotheses":"(x : binary_float) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan x)","proofString":"destruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl ; try apply B2BSN_BSN2B'.\nnow destruct y."},{"statement":"(sx : bool) (px : positive) (Px : nan_pl px = true) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan (B754_nan sx px Px)) : BinarySingleNaN.B754_nan = y.","conclusion":"BinarySingleNaN.B754_nan = y","hypotheses":"(sx : bool) (px : positive) (Px : nan_pl px = true) (y : BinarySingleNaN.binary_float prec emax) (Ny : BinarySingleNaN.is_nan y = is_nan (B754_nan sx px Px))","proofString":"now destruct y."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : BinarySingleNaN.is_nan (Bldexp mode (B2BSN x) e) = is_nan x.","conclusion":"BinarySingleNaN.is_nan (Bldexp mode (B2BSN x) e) = is_nan x","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"rewrite <- is_nan_B2BSN.\napply is_nan_Bldexp."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : BinarySingleNaN.is_nan (Bldexp mode (B2BSN x) e) =\nBinarySingleNaN.is_nan (B2BSN x).","conclusion":"BinarySingleNaN.is_nan (Bldexp mode (B2BSN x) e) =\nBinarySingleNaN.is_nan (B2BSN x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"apply is_nan_Bldexp."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"generalize (Bldexp_correct prec emax _ _ mode (B2BSN x) e).\nreplace (BinarySingleNaN.Bldexp _ _ _) with (B2BSN (Bldexp mode x e)) by apply B2BSN_lift.\nrewrite B2R_B2BSN.\ndestruct Rlt_bool.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; try easy.\nnow destruct Bldexp.\nintros H.\napply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bldexp mode (B2BSN x) e) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"replace (BinarySingleNaN.Bldexp _ _ _) with (B2BSN (Bldexp mode x e)) by apply B2BSN_lift.\nrewrite B2R_B2BSN.\ndestruct Rlt_bool.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; try easy.\nnow destruct Bldexp.\nintros H.\napply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (BinarySingleNaN.B2R (B2BSN x) * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"rewrite B2R_B2BSN.\ndestruct Rlt_bool.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; try easy.\nnow destruct Bldexp.\nintros H.\napply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x * bpow radix2 e))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R x * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n          (B2R x * bpow radix2 e))) (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\n  round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n    (B2R x * bpow radix2 e) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.is_finite (B2BSN x) /\\\n  BinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.Bsign (B2BSN x)\n else\n  BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\n  BinarySingleNaN.binary_overflow prec emax mode\n    (BinarySingleNaN.Bsign (B2BSN x))) ->\nif\n Rlt_bool\n   (Rabs\n      (round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n         (B2R x * bpow radix2 e))) (bpow radix2 emax)\nthen\n B2R (Bldexp mode x e) =\n round radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n   (B2R x * bpow radix2 e) /\\\n is_finite (Bldexp mode x e) = is_finite x /\\\n Bsign (Bldexp mode x e) = Bsign x\nelse B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"destruct Rlt_bool.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; try easy.\nnow destruct Bldexp.\nintros H.\napply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * bpow radix2 e) /\\\nBinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\nBinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.Bsign (B2BSN x) ->\nB2R (Bldexp mode x e) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * bpow radix2 e) /\\\nis_finite (Bldexp mode x e) = is_finite x /\\\nBsign (Bldexp mode x e) = Bsign x.","conclusion":"BinarySingleNaN.B2R (B2BSN (Bldexp mode x e)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * bpow radix2 e) /\\\nBinarySingleNaN.is_finite (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.is_finite (B2BSN x) /\\\nBinarySingleNaN.Bsign (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.Bsign (B2BSN x) ->\nB2R (Bldexp mode x e) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R x * bpow radix2 e) /\\\nis_finite (Bldexp mode x e) = is_finite x /\\\nBsign (Bldexp mode x e) = Bsign x","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"destruct x as [sx|sx|sx px Px|sx mx ex Bx] ; try easy.\nnow destruct Bldexp."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z) : BinarySingleNaN.B2R (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Bx) * bpow radix2 e) /\\\nBinarySingleNaN.is_finite (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Bx)) /\\\nBinarySingleNaN.Bsign (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nBinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Bx)) ->\nB2R (Bldexp mode (B754_finite sx mx ex Bx) e) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Bx) * bpow radix2 e) /\\\nis_finite (Bldexp mode (B754_finite sx mx ex Bx) e) =\nis_finite (B754_finite sx mx ex Bx) /\\\nBsign (Bldexp mode (B754_finite sx mx ex Bx) e) =\nBsign (B754_finite sx mx ex Bx).","conclusion":"BinarySingleNaN.B2R (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Bx) * bpow radix2 e) /\\\nBinarySingleNaN.is_finite (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nBinarySingleNaN.is_finite (B2BSN (B754_finite sx mx ex Bx)) /\\\nBinarySingleNaN.Bsign (B2BSN (Bldexp mode (B754_finite sx mx ex Bx) e)) =\nBinarySingleNaN.Bsign (B2BSN (B754_finite sx mx ex Bx)) ->\nB2R (Bldexp mode (B754_finite sx mx ex Bx) e) =\nround radix2 (SpecFloat.fexp prec emax) (round_mode mode)\n  (B2R (B754_finite sx mx ex Bx) * bpow radix2 e) /\\\nis_finite (Bldexp mode (B754_finite sx mx ex Bx) e) =\nis_finite (B754_finite sx mx ex Bx) /\\\nBsign (Bldexp mode (B754_finite sx mx ex Bx) e) =\nBsign (B754_finite sx mx ex Bx)","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z)","proofString":"now destruct Bldexp."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) : BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)) ->\nB2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)) ->\nB2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z)","proofString":"intros H.\napply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x))) : B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x).","conclusion":"B2FF (Bldexp mode x e) = binary_overflow mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)))","proofString":"apply eq_binary_overflow_FF2SF.\nrewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x))) : FF2SF (B2FF (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x).","conclusion":"FF2SF (B2FF (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : BinarySingleNaN.B2SF (B2BSN (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)))","proofString":"rewrite B2SF_B2BSN in H.\nrewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : B2SF (Bldexp mode x e) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x))) : FF2SF (B2FF (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x).","conclusion":"FF2SF (B2FF (Bldexp mode x e)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : B2SF (Bldexp mode x e) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)))","proofString":"rewrite FF2SF_B2FF, H.\ndestruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : B2SF (Bldexp mode x e) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x))) : BinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x).","conclusion":"BinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign x)","hypotheses":"(mode : BinarySingleNaN.mode) (x : binary_float) (e : Z) (H : B2SF (Bldexp mode x e) =\nBinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN x)))","proofString":"destruct x as [sx|sx|sx px Px|sx mx ex Bx] ; simpl in H ; try easy.\ncontradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z) (H : S754_nan = BinarySingleNaN.binary_overflow prec emax mode false) : BinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN (B754_nan sx px Px))) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign (B754_nan sx px Px)).","conclusion":"BinarySingleNaN.binary_overflow prec emax mode\n  (BinarySingleNaN.Bsign (B2BSN (B754_nan sx px Px))) =\nBinarySingleNaN.binary_overflow prec emax mode (Bsign (B754_nan sx px Px))","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z) (H : S754_nan = BinarySingleNaN.binary_overflow prec emax mode false)","proofString":"contradict H.\nunfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z) : S754_nan <> BinarySingleNaN.binary_overflow prec emax mode false.","conclusion":"S754_nan <> BinarySingleNaN.binary_overflow prec emax mode false","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z)","proofString":"unfold BinarySingleNaN.binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z) : S754_nan <>\n(if overflow_to_inf mode false\n then S754_infinity false\n else S754_finite false (Z.to_pos (2 ^ prec - 1)) (emax - prec)).","conclusion":"S754_nan <>\n(if overflow_to_inf mode false\n then S754_infinity false\n else S754_finite false (Z.to_pos (2 ^ prec - 1)) (emax - prec))","hypotheses":"(mode : BinarySingleNaN.mode) (sx : bool) (px : positive) (Px : nan_pl px = true) (e : Z)","proofString":"now destruct overflow_to_inf."},{"statement":"(x : binary_float) (Fx : is_finite_strict x = true) : let x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0.","conclusion":"let x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0","hypotheses":"(x : binary_float) (Fx : is_finite_strict x = true)","proofString":"rewrite <- is_finite_strict_B2BSN in Fx.\ngeneralize (Bfrexp_correct prec emax _ (B2BSN x) Fx).\nsimpl.\nrewrite <- B2R_B2BSN.\nrewrite B2BSN_lift.\ndestruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) : let x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0.","conclusion":"let x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true)","proofString":"generalize (Bfrexp_correct prec emax _ (B2BSN x) Fx).\nsimpl.\nrewrite <- B2R_B2BSN.\nrewrite B2BSN_lift.\ndestruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) : (let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\nlet x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0.","conclusion":"(let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\nlet x0 := B2R x in\nlet z := fst (Bfrexp x) in\nlet e := snd (Bfrexp x) in\n(/ 2 <= Rabs (B2R z) < 1)%R /\\\nx0 = (B2R z * bpow radix2 e)%R /\\ e = mag radix2 x0","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true)","proofString":"simpl.\nrewrite <- B2R_B2BSN.\nrewrite B2BSN_lift.\ndestruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) : (let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <=\n Rabs\n   (B2R\n      (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n         (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n            (fun b : bool =>\n             BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) =\n             b) (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n            (is_nan x) (is_nan_B2BSN x)))) < 1)%R /\\\nB2R x =\n(B2R\n   (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n      (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n         (fun b : bool =>\n          BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) = b)\n         (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n         (is_nan x) (is_nan_B2BSN x))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x).","conclusion":"(let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <=\n Rabs\n   (B2R\n      (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n         (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n            (fun b : bool =>\n             BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) =\n             b) (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n            (is_nan x) (is_nan_B2BSN x)))) < 1)%R /\\\nB2R x =\n(B2R\n   (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n      (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n         (fun b : bool =>\n          BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) = b)\n         (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n         (is_nan x) (is_nan_B2BSN x))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x)","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true)","proofString":"rewrite <- B2R_B2BSN.\nrewrite B2BSN_lift.\ndestruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) : (let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <=\n Rabs\n   (BinarySingleNaN.B2R\n      (B2BSN\n         (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n            (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n               (fun b : bool =>\n                BinarySingleNaN.is_nan\n                  (fst (BinarySingleNaN.Bfrexp (B2BSN x))) = b)\n               (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n               (is_nan x) (is_nan_B2BSN x))))) < 1)%R /\\\nB2R x =\n(BinarySingleNaN.B2R\n   (B2BSN\n      (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n         (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n            (fun b : bool =>\n             BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) =\n             b) (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n            (is_nan x) (is_nan_B2BSN x)))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x).","conclusion":"(let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <=\n Rabs\n   (BinarySingleNaN.B2R\n      (B2BSN\n         (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n            (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n               (fun b : bool =>\n                BinarySingleNaN.is_nan\n                  (fst (BinarySingleNaN.Bfrexp (B2BSN x))) = b)\n               (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n               (is_nan x) (is_nan_B2BSN x))))) < 1)%R /\\\nB2R x =\n(BinarySingleNaN.B2R\n   (B2BSN\n      (lift x (fst (BinarySingleNaN.Bfrexp (B2BSN x)))\n         (eq_ind (BinarySingleNaN.is_nan (B2BSN x))\n            (fun b : bool =>\n             BinarySingleNaN.is_nan (fst (BinarySingleNaN.Bfrexp (B2BSN x))) =\n             b) (is_nan_Bfrexp prec emax prec_gt_0_ (B2BSN x)) \n            (is_nan x) (is_nan_B2BSN x)))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x)","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true)","proofString":"rewrite B2BSN_lift.\ndestruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) : (let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (BinarySingleNaN.Bfrexp (B2BSN x)))) <\n 1)%R /\\\nB2R x =\n(BinarySingleNaN.B2R (fst (BinarySingleNaN.Bfrexp (B2BSN x))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x).","conclusion":"(let (z, e) := BinarySingleNaN.Bfrexp (B2BSN x) in\n BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n ((2 < emax)%Z ->\n  (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n  e = mag radix2 (BinarySingleNaN.B2R (B2BSN x)))) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (BinarySingleNaN.Bfrexp (B2BSN x)))) <\n 1)%R /\\\nB2R x =\n(BinarySingleNaN.B2R (fst (BinarySingleNaN.Bfrexp (B2BSN x))) *\n bpow radix2 (snd (BinarySingleNaN.Bfrexp (B2BSN x))))%R /\\\nsnd (BinarySingleNaN.Bfrexp (B2BSN x)) = mag radix2 (B2R x)","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true)","proofString":"destruct BinarySingleNaN.Bfrexp as [z e].\nrewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) (z : BinarySingleNaN.binary_float prec emax) (e : Z) : BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n e = mag radix2 (BinarySingleNaN.B2R (B2BSN x))) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (z, e))) < 1)%R /\\\nB2R x = (BinarySingleNaN.B2R (fst (z, e)) * bpow radix2 (snd (z, e)))%R /\\\nsnd (z, e) = mag radix2 (B2R x).","conclusion":"BinarySingleNaN.B2R (B2BSN x) = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\\n e = mag radix2 (BinarySingleNaN.B2R (B2BSN x))) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (z, e))) < 1)%R /\\\nB2R x = (BinarySingleNaN.B2R (fst (z, e)) * bpow radix2 (snd (z, e)))%R /\\\nsnd (z, e) = mag radix2 (B2R x)","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) (z : BinarySingleNaN.binary_float prec emax) (e : Z)","proofString":"rewrite B2R_B2BSN.\nnow intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) (z : BinarySingleNaN.binary_float prec emax) (e : Z) : B2R x = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\ e = mag radix2 (B2R x)) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (z, e))) < 1)%R /\\\nB2R x = (BinarySingleNaN.B2R (fst (z, e)) * bpow radix2 (snd (z, e)))%R /\\\nsnd (z, e) = mag radix2 (B2R x).","conclusion":"B2R x = (BinarySingleNaN.B2R z * bpow radix2 e)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (BinarySingleNaN.B2R z) < 1)%R /\\ e = mag radix2 (B2R x)) ->\n(/ 2 <= Rabs (BinarySingleNaN.B2R (fst (z, e))) < 1)%R /\\\nB2R x = (BinarySingleNaN.B2R (fst (z, e)) * bpow radix2 (snd (z, e)))%R /\\\nsnd (z, e) = mag radix2 (B2R x)","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite_strict (B2BSN x) = true) (z : BinarySingleNaN.binary_float prec emax) (e : Z)","proofString":"now intros [H1 [H2 H3]]."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bulp (B2BSN x)) = is_nan x.","conclusion":"BinarySingleNaN.is_nan (Bulp (B2BSN x)) = is_nan x","hypotheses":"(x : binary_float)","proofString":"rewrite <- is_nan_B2BSN.\napply is_nan_Bulp."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bulp (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x).","conclusion":"BinarySingleNaN.is_nan (Bulp (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x)","hypotheses":"(x : binary_float)","proofString":"apply is_nan_Bulp."},{"statement":"(x : binary_float) (Fx : is_finite x = true) : B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false.","conclusion":"B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false","hypotheses":"(x : binary_float) (Fx : is_finite x = true)","proofString":"rewrite <- is_finite_B2BSN in Fx.\ngeneralize (Bulp_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bulp (B2BSN x)) with (B2BSN (Bulp x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\nnow destruct Bulp."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false.","conclusion":"B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"generalize (Bulp_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bulp (B2BSN x)) with (B2BSN (Bulp x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\nnow destruct Bulp."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : BinarySingleNaN.B2R (BinarySingleNaN.Bulp (B2BSN x)) =\nulp radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bulp (B2BSN x)) = true /\\\nBinarySingleNaN.Bsign (BinarySingleNaN.Bulp (B2BSN x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false.","conclusion":"BinarySingleNaN.B2R (BinarySingleNaN.Bulp (B2BSN x)) =\nulp radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (BinarySingleNaN.Bulp (B2BSN x)) = true /\\\nBinarySingleNaN.Bsign (BinarySingleNaN.Bulp (B2BSN x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"replace (BinarySingleNaN.Bulp (B2BSN x)) with (B2BSN (Bulp x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\nnow destruct Bulp."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : BinarySingleNaN.B2R (B2BSN (Bulp x)) =\nulp radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bulp x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bulp x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false.","conclusion":"BinarySingleNaN.B2R (B2BSN (Bulp x)) =\nulp radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\nBinarySingleNaN.is_finite (B2BSN (Bulp x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bulp x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite 2!B2R_B2BSN.\nnow destruct Bulp."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bulp x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bulp x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false.","conclusion":"B2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bulp x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bulp x)) = false ->\nB2R (Bulp x) = ulp radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"now destruct Bulp."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bsucc (B2BSN x)) = is_nan x.","conclusion":"BinarySingleNaN.is_nan (Bsucc (B2BSN x)) = is_nan x","hypotheses":"(x : binary_float)","proofString":"rewrite <- is_nan_B2BSN.\napply is_nan_Bsucc."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bsucc (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x).","conclusion":"BinarySingleNaN.is_nan (Bsucc (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x)","hypotheses":"(x : binary_float)","proofString":"apply is_nan_Bsucc."},{"statement":"(x : binary_float) (Fx : is_finite x = true) : if\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false.","conclusion":"if\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : is_finite x = true)","proofString":"rewrite <- is_finite_B2BSN in Fx.\ngeneralize (Bsucc_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bsucc (B2BSN x)) with (B2BSN (Bsucc x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc.\nnow destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : if\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false.","conclusion":"if\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"generalize (Bsucc_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bsucc (B2BSN x)) with (B2BSN (Bsucc x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc.\nnow destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool\n    (succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bsucc (B2BSN x)) =\n  succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bsucc (B2BSN x)) = true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bsucc (B2BSN x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bsucc (B2BSN x)) =\n  S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false.","conclusion":"(if\n  Rlt_bool\n    (succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bsucc (B2BSN x)) =\n  succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bsucc (B2BSN x)) = true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bsucc (B2BSN x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bsucc (B2BSN x)) =\n  S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"replace (BinarySingleNaN.Bsucc (B2BSN x)) with (B2BSN (Bsucc x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc.\nnow destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool\n    (succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bsucc x)) =\n  succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false.","conclusion":"(if\n  Rlt_bool\n    (succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n    (bpow radix2 emax)\n then\n  BinarySingleNaN.B2R (B2BSN (Bsucc x)) =\n  succ radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc.\nnow destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x))\n    (bpow radix2 emax)\n then\n  B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false.","conclusion":"(if\n  Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x))\n    (bpow radix2 emax)\n then\n  B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n  (BinarySingleNaN.Bsign (B2BSN x) &&\n   BinarySingleNaN.is_finite_strict (B2BSN x))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false) ->\nif\n Rlt_bool (succ radix2 (SpecFloat.fexp prec emax) (B2R x)) (bpow radix2 emax)\nthen\n B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bsucc x) = true /\\\n Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool\nelse B2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"destruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc.\nnow destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(BinarySingleNaN.Bsign (B2BSN x) &&\n BinarySingleNaN.is_finite_strict (B2BSN x))%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool.","conclusion":"B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(BinarySingleNaN.Bsign (B2BSN x) &&\n BinarySingleNaN.is_finite_strict (B2BSN x))%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bsucc."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(Bsign x && BinarySingleNaN.is_finite_strict (B2BSN x))%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool.","conclusion":"B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(Bsign x && BinarySingleNaN.is_finite_strict (B2BSN x))%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite is_finite_strict_B2BSN.\nnow destruct Bsucc."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(Bsign x && is_finite_strict x)%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool.","conclusion":"B2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bsucc x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bsucc x)) =\n(Bsign x && is_finite_strict x)%bool ->\nB2R (Bsucc x) = succ radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bsucc x) = true /\\\nBsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"now destruct Bsucc."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false ->\nB2FF (Bsucc x) = F754_infinity false.","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bsucc x)) = S754_infinity false ->\nB2FF (Bsucc x) = F754_infinity false","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"now destruct Bsucc as [|[|]| |]."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bpred (B2BSN x)) = is_nan x.","conclusion":"BinarySingleNaN.is_nan (Bpred (B2BSN x)) = is_nan x","hypotheses":"(x : binary_float)","proofString":"rewrite <- is_nan_B2BSN.\napply is_nan_Bpred."},{"statement":"(x : binary_float) : BinarySingleNaN.is_nan (Bpred (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x).","conclusion":"BinarySingleNaN.is_nan (Bpred (B2BSN x)) = BinarySingleNaN.is_nan (B2BSN x)","hypotheses":"(x : binary_float)","proofString":"apply is_nan_Bpred."},{"statement":"(x : binary_float) (Fx : is_finite x = true) : if\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true.","conclusion":"if\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true)","proofString":"rewrite <- is_finite_B2BSN in Fx.\ngeneralize (Bpred_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bpred (B2BSN x)) with (B2BSN (Bpred x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred.\nnow destruct Bpred as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : if\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true.","conclusion":"if\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"generalize (Bpred_correct prec emax _ _ _ Fx).\nreplace (BinarySingleNaN.Bpred (B2BSN x)) with (B2BSN (Bpred x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred.\nnow destruct Bpred as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bpred (B2BSN x)) =\n  pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bpred (B2BSN x)) = true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bpred (B2BSN x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bpred (B2BSN x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true.","conclusion":"(if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n then\n  BinarySingleNaN.B2R (BinarySingleNaN.Bpred (B2BSN x)) =\n  pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (BinarySingleNaN.Bpred (B2BSN x)) = true /\\\n  BinarySingleNaN.Bsign (BinarySingleNaN.Bpred (B2BSN x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else\n  BinarySingleNaN.B2SF (BinarySingleNaN.Bpred (B2BSN x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"replace (BinarySingleNaN.Bpred (B2BSN x)) with (B2BSN (Bpred x)) by apply B2BSN_lift.\nrewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred.\nnow destruct Bpred as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n then\n  BinarySingleNaN.B2R (B2BSN (Bpred x)) =\n  pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true.","conclusion":"(if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)))\n then\n  BinarySingleNaN.B2R (B2BSN (Bpred x)) =\n  pred radix2 (SpecFloat.fexp prec emax) (BinarySingleNaN.B2R (B2BSN x)) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite 2!B2R_B2BSN.\ndestruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred.\nnow destruct Bpred as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : (if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\n then\n  B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true.","conclusion":"(if\n  Rlt_bool (- bpow radix2 emax)\n    (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\n then\n  B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n  BinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\n  BinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n  (BinarySingleNaN.Bsign (B2BSN x)\n   || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool\n else BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true) ->\nif\n Rlt_bool (- bpow radix2 emax)\n   (pred radix2 (SpecFloat.fexp prec emax) (B2R x))\nthen\n B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"destruct Rlt_bool.\nrewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred.\nnow destruct Bpred as [|[|]| |]."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(BinarySingleNaN.Bsign (B2BSN x)\n || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(BinarySingleNaN.Bsign (B2BSN x)\n || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite (Bsign_B2BSN x) by now destruct x.\nrewrite is_finite_strict_B2BSN.\nnow destruct Bpred."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(Bsign x || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(Bsign x || negb (BinarySingleNaN.is_finite_strict (B2BSN x)))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"rewrite is_finite_strict_B2BSN.\nnow destruct Bpred."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(Bsign x || negb (is_finite_strict x))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"B2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nBinarySingleNaN.is_finite (B2BSN (Bpred x)) = true /\\\nBinarySingleNaN.Bsign (B2BSN (Bpred x)) =\n(Bsign x || negb (is_finite_strict x))%bool ->\nB2R (Bpred x) = pred radix2 (SpecFloat.fexp prec emax) (B2R x) /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"now destruct Bpred."},{"statement":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true) : BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true ->\nB2FF (Bpred x) = F754_infinity true.","conclusion":"BinarySingleNaN.B2SF (B2BSN (Bpred x)) = S754_infinity true ->\nB2FF (Bpred x) = F754_infinity true","hypotheses":"(x : binary_float) (Fx : BinarySingleNaN.is_finite (B2BSN x) = true)","proofString":"now destruct Bpred as [|[|]| |]."}]}