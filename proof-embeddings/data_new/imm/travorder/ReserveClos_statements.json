{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/travorder/ReserveClos.v","fileSamples":[{"statement":"(s s' : trav_label -> Prop) : s ∪₁ s' ∪₁ eq ta_reserve <*> issued (s ∪₁ s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s').","conclusion":"s ∪₁ s' ∪₁ eq ta_reserve <*> issued (s ∪₁ s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s')","hypotheses":"(s s' : trav_label -> Prop)","proofString":"rewrite !issued_union.\nrewrite set_pair_union_r.\nclear.\nbasic_solver 10."},{"statement":"(s s' : trav_label -> Prop) : s ∪₁ s' ∪₁ eq ta_reserve <*> (issued s ∪₁ issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s').","conclusion":"s ∪₁ s' ∪₁ eq ta_reserve <*> (issued s ∪₁ issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s')","hypotheses":"(s s' : trav_label -> Prop)","proofString":"rewrite set_pair_union_r.\nclear.\nbasic_solver 10."},{"statement":"(s s' : trav_label -> Prop) : s ∪₁ s' ∪₁ (eq ta_reserve <*> issued s ∪₁ eq ta_reserve <*> issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s').","conclusion":"s ∪₁ s' ∪₁ (eq ta_reserve <*> issued s ∪₁ eq ta_reserve <*> issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s')","hypotheses":"(s s' : trav_label -> Prop)","proofString":"clear.\nbasic_solver 10."},{"statement":"(s s' : trav_label -> Prop) : s ∪₁ s' ∪₁ (eq ta_reserve <*> issued s ∪₁ eq ta_reserve <*> issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s').","conclusion":"s ∪₁ s' ∪₁ (eq ta_reserve <*> issued s ∪₁ eq ta_reserve <*> issued s')\n≡₁ s ∪₁ eq ta_reserve <*> issued s ∪₁ (s' ∪₁ eq ta_reserve <*> issued s')","hypotheses":"(s s' : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : tls_coherent G (tc ∪₁ eq ta_reserve <*> issued tc).","conclusion":"tls_coherent G (tc ∪₁ eq ta_reserve <*> issued tc)","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"apply tls_coherent_ext_union; auto.\nunfold exec_tls.\narewrite (issued tc ≡₁ issued tc ∩₁ (is_init ∪₁ set_compl is_init)).\nnow rewrite <- set_full_split, set_inter_full_r.\nrewrite issued_EW; eauto.\nrewrite !set_inter_union_r, set_pair_union_r.\nunionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> issued tc ⊆₁ init_tls G ∪₁ exec_tls G.","conclusion":"eq ta_reserve <*> issued tc ⊆₁ init_tls G ∪₁ exec_tls G","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"unfold exec_tls.\narewrite (issued tc ≡₁ issued tc ∩₁ (is_init ∪₁ set_compl is_init)).\nnow rewrite <- set_full_split, set_inter_full_r.\nrewrite issued_EW; eauto.\nrewrite !set_inter_union_r, set_pair_union_r.\nunionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> issued tc\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*> issued tc\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"arewrite (issued tc ≡₁ issued tc ∩₁ (is_init ∪₁ set_compl is_init)).\nnow rewrite <- set_full_split, set_inter_full_r.\nrewrite issued_EW; eauto.\nrewrite !set_inter_union_r, set_pair_union_r.\nunionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : issued tc\n≡₁ issued tc\n   ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a)).","conclusion":"issued tc\n≡₁ issued tc\n   ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"now rewrite <- set_full_split, set_inter_full_r."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*>\n(issued tc\n ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a)))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*>\n(issued tc\n ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a)))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"rewrite issued_EW; eauto.\nrewrite !set_inter_union_r, set_pair_union_r.\nunionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*>\n(E ∩₁ W\n ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a)))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*>\n(E ∩₁ W\n ∩₁ ((fun a : actid => is_init a) ∪₁ set_compl (fun a : actid => is_init a)))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"rewrite !set_inter_union_r, set_pair_union_r.\nunionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n∪₁ eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n∪₁ eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"unionL.\ntransitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver.\nunionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"transitivity (init_tls G); eauto with hahn.\nunfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a)) ⊆₁ init_tls G.","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a)) ⊆₁ init_tls G","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"unfold init_tls.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a)).","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ (fun a : actid => is_init a))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"apply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : E ∩₁ W ∩₁ (fun a : actid => is_init a) ⊆₁ E ∩₁ (fun a : actid => is_init a).","conclusion":"E ∩₁ W ∩₁ (fun a : actid => is_init a) ⊆₁ E ∩₁ (fun a : actid => is_init a)","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"clear.\nbasic_solver."},{"statement":"E ∩₁ W ∩₁ (fun a : actid => is_init a) ⊆₁ E ∩₁ (fun a : actid => is_init a).","conclusion":"E ∩₁ W ∩₁ (fun a : actid => is_init a) ⊆₁ E ∩₁ (fun a : actid => is_init a)","hypotheses":"","proofString":"basic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)).","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ init_tls G\n   ∪₁ (eq ta_cover <*> (E \\₁ (fun a : actid => is_init a))\n       ∪₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n          ((E \\₁ (fun a : actid => is_init a)) ∩₁ W))","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"unionR right -> right.\napply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   ((E \\₁ (fun a : actid => is_init a)) ∩₁ W).","conclusion":"eq ta_reserve <*> (E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a))\n⊆₁ (eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   ((E \\₁ (fun a : actid => is_init a)) ∩₁ W)","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"apply set_pair_mori; eauto with hahn.\nclear.\nbasic_solver."},{"statement":"(tc : trav_label -> Prop) (COH : tls_coherent G tc) : E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W.","conclusion":"E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W","hypotheses":"(tc : trav_label -> Prop) (COH : tls_coherent G tc)","proofString":"clear.\nbasic_solver."},{"statement":"E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W.","conclusion":"E ∩₁ W ∩₁ set_compl (fun a : actid => is_init a)\n⊆₁ (E \\₁ (fun a : actid => is_init a)) ∩₁ W","hypotheses":"","proofString":"basic_solver."},{"statement":"(tc : trav_label -> Prop) : covered (reserve_clos tc) ≡₁ covered tc.","conclusion":"covered (reserve_clos tc) ≡₁ covered tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfold reserve_clos.\nrewrite covered_union, covered_ta_reserve.\nnow rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : covered (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ covered tc.","conclusion":"covered (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ covered tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"rewrite covered_union, covered_ta_reserve.\nnow rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : covered tc ∪₁ ∅ ≡₁ covered tc.","conclusion":"covered tc ∪₁ ∅ ≡₁ covered tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"now rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : issued (reserve_clos tc) ≡₁ issued tc.","conclusion":"issued (reserve_clos tc) ≡₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfold reserve_clos.\nrewrite issued_union, issued_ta_reserve.\nnow rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : issued (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ issued tc.","conclusion":"issued (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"rewrite issued_union, issued_ta_reserve.\nnow rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : issued tc ∪₁ ∅ ≡₁ issued tc.","conclusion":"issued tc ∪₁ ∅ ≡₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"now rewrite set_union_empty_r."},{"statement":"(tc : trav_label -> Prop) : reserved (reserve_clos tc) ≡₁ reserved tc ∪₁ issued tc.","conclusion":"reserved (reserve_clos tc) ≡₁ reserved tc ∪₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"unfold reserve_clos.\nnow rewrite reserved_union, reserved_ta_reserve."},{"statement":"(tc : trav_label -> Prop) : reserved (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ reserved tc ∪₁ issued tc.","conclusion":"reserved (tc ∪₁ eq ta_reserve <*> issued tc) ≡₁ reserved tc ∪₁ issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"now rewrite reserved_union, reserved_ta_reserve."},{"statement":"(w : actid) : reserve_clos (eq (ta_cover, w)) ≡₁ eq (ta_cover, w).","conclusion":"reserve_clos (eq (ta_cover, w)) ≡₁ eq (ta_cover, w)","hypotheses":"(w : actid)","proofString":"unfold reserve_clos.\nrewrite issued_eq_ta_cover.\nunfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_cover, w) ∪₁ eq ta_reserve <*> issued (eq (ta_cover, w))\n≡₁ eq (ta_cover, w).","conclusion":"eq (ta_cover, w) ∪₁ eq ta_reserve <*> issued (eq (ta_cover, w))\n≡₁ eq (ta_cover, w)","hypotheses":"(w : actid)","proofString":"rewrite issued_eq_ta_cover.\nunfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_cover, w) ∪₁ eq ta_reserve <*> ∅ ≡₁ eq (ta_cover, w).","conclusion":"eq (ta_cover, w) ∪₁ eq ta_reserve <*> ∅ ≡₁ eq (ta_cover, w)","hypotheses":"(w : actid)","proofString":"unfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_cover, w)\n∪₁ (fun ab : trav_action * actid => let (a, b) := ab in ta_reserve = a /\\ ∅ b)\n≡₁ eq (ta_cover, w).","conclusion":"eq (ta_cover, w)\n∪₁ (fun ab : trav_action * actid => let (a, b) := ab in ta_reserve = a /\\ ∅ b)\n≡₁ eq (ta_cover, w)","hypotheses":"(w : actid)","proofString":"unfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : (forall x : trav_label,\n (ta_cover, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False) ->\n (ta_cover, w) = x) /\\\n(forall x : trav_label,\n (ta_cover, w) = x ->\n (ta_cover, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False)).","conclusion":"(forall x : trav_label,\n (ta_cover, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False) ->\n (ta_cover, w) = x) /\\\n(forall x : trav_label,\n (ta_cover, w) = x ->\n (ta_cover, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False))","hypotheses":"(w : actid)","proofString":"split; ins; do 2 desf; eauto."},{"statement":"(w : actid) : reserve_clos (eq (ta_issue, w)) ≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w).","conclusion":"reserve_clos (eq (ta_issue, w)) ≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"unfold reserve_clos.\nrewrite issued_singleton.\napply set_union_more; eauto with hahn.\nnow rewrite set_pair_exact."},{"statement":"(w : actid) : eq (ta_issue, w) ∪₁ eq ta_reserve <*> issued (eq (ta_issue, w))\n≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w).","conclusion":"eq (ta_issue, w) ∪₁ eq ta_reserve <*> issued (eq (ta_issue, w))\n≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"rewrite issued_singleton.\napply set_union_more; eauto with hahn.\nnow rewrite set_pair_exact."},{"statement":"(w : actid) : eq (ta_issue, w) ∪₁ eq ta_reserve <*> eq w\n≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w).","conclusion":"eq (ta_issue, w) ∪₁ eq ta_reserve <*> eq w\n≡₁ eq (ta_issue, w) ∪₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"apply set_union_more; eauto with hahn.\nnow rewrite set_pair_exact."},{"statement":"(w : actid) : eq ta_reserve <*> eq w ≡₁ eq (ta_reserve, w).","conclusion":"eq ta_reserve <*> eq w ≡₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"now rewrite set_pair_exact."},{"statement":"(w : actid) : reserve_clos (eq (ta_reserve, w)) ≡₁ eq (ta_reserve, w).","conclusion":"reserve_clos (eq (ta_reserve, w)) ≡₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"unfold reserve_clos.\nrewrite issued_eq_ta_reserve.\nunfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_reserve, w) ∪₁ eq ta_reserve <*> issued (eq (ta_reserve, w))\n≡₁ eq (ta_reserve, w).","conclusion":"eq (ta_reserve, w) ∪₁ eq ta_reserve <*> issued (eq (ta_reserve, w))\n≡₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"rewrite issued_eq_ta_reserve.\nunfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_reserve, w) ∪₁ eq ta_reserve <*> ∅ ≡₁ eq (ta_reserve, w).","conclusion":"eq (ta_reserve, w) ∪₁ eq ta_reserve <*> ∅ ≡₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"unfold set_pair.\nunfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : eq (ta_reserve, w)\n∪₁ (fun ab : trav_action * actid => let (a, b) := ab in ta_reserve = a /\\ ∅ b)\n≡₁ eq (ta_reserve, w).","conclusion":"eq (ta_reserve, w)\n∪₁ (fun ab : trav_action * actid => let (a, b) := ab in ta_reserve = a /\\ ∅ b)\n≡₁ eq (ta_reserve, w)","hypotheses":"(w : actid)","proofString":"unfolder.\nsplit; ins; do 2 desf; eauto."},{"statement":"(w : actid) : (forall x : trav_label,\n (ta_reserve, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False) ->\n (ta_reserve, w) = x) /\\\n(forall x : trav_label,\n (ta_reserve, w) = x ->\n (ta_reserve, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False)).","conclusion":"(forall x : trav_label,\n (ta_reserve, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False) ->\n (ta_reserve, w) = x) /\\\n(forall x : trav_label,\n (ta_reserve, w) = x ->\n (ta_reserve, w) = x \\/ (let (a, _) := x in ta_reserve = a /\\ False))","hypotheses":"(w : actid)","proofString":"split; ins; do 2 desf; eauto."},{"statement":"(tc : trav_label -> Prop) : tc ⊆₁ tc ∪₁ eq ta_reserve <*> issued tc.","conclusion":"tc ⊆₁ tc ∪₁ eq ta_reserve <*> issued tc","hypotheses":"(tc : trav_label -> Prop)","proofString":"eauto with hahn."},{"statement":"reserve_clos (init_tls G) ⊆₁ init_tls G.","conclusion":"reserve_clos (init_tls G) ⊆₁ init_tls G","hypotheses":"","proofString":"unfold reserve_clos.\nunionL; eauto with hahn.\nunfold init_tls at 1.\nrewrite !set_pair_union_l, !issued_union.\nrewrite !issued_ta_reserve, !issued_ta_issue, !issued_ta_cover,          !issued_is_ta_propagate_to_G.\nrewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"init_tls G ∪₁ eq ta_reserve <*> issued (init_tls G) ⊆₁ init_tls G.","conclusion":"init_tls G ∪₁ eq ta_reserve <*> issued (init_tls G) ⊆₁ init_tls G","hypotheses":"","proofString":"unionL; eauto with hahn.\nunfold init_tls at 1.\nrewrite !set_pair_union_l, !issued_union.\nrewrite !issued_ta_reserve, !issued_ta_issue, !issued_ta_cover,          !issued_is_ta_propagate_to_G.\nrewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*> issued (init_tls G) ⊆₁ init_tls G.","conclusion":"eq ta_reserve <*> issued (init_tls G) ⊆₁ init_tls G","hypotheses":"","proofString":"unfold init_tls at 1.\nrewrite !set_pair_union_l, !issued_union.\nrewrite !issued_ta_reserve, !issued_ta_issue, !issued_ta_cover,          !issued_is_ta_propagate_to_G.\nrewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*>\nissued\n  ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a))) ⊆₁ init_tls G.","conclusion":"eq ta_reserve <*>\nissued\n  ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a))) ⊆₁ init_tls G","hypotheses":"","proofString":"rewrite !set_pair_union_l, !issued_union.\nrewrite !issued_ta_reserve, !issued_ta_issue, !issued_ta_cover,          !issued_is_ta_propagate_to_G.\nrewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*>\n(issued (eq ta_cover <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (eq ta_issue <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (is_ta_propagate_to_G G <*> (E ∩₁ (fun a : actid => is_init a))))\n⊆₁ init_tls G.","conclusion":"eq ta_reserve <*>\n(issued (eq ta_cover <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (eq ta_issue <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a)))\n ∪₁ issued (is_ta_propagate_to_G G <*> (E ∩₁ (fun a : actid => is_init a))))\n⊆₁ init_tls G","hypotheses":"","proofString":"rewrite !issued_ta_reserve, !issued_ta_issue, !issued_ta_cover,          !issued_is_ta_propagate_to_G.\nrewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*> (∅ ∪₁ E ∩₁ (fun a : actid => is_init a) ∪₁ ∅ ∪₁ ∅)\n⊆₁ init_tls G.","conclusion":"eq ta_reserve <*> (∅ ∪₁ E ∩₁ (fun a : actid => is_init a) ∪₁ ∅ ∪₁ ∅)\n⊆₁ init_tls G","hypotheses":"","proofString":"rewrite !set_union_empty_l, !set_union_empty_r.\nunfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a)) ⊆₁ init_tls G.","conclusion":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a)) ⊆₁ init_tls G","hypotheses":"","proofString":"unfold init_tls.\nrewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a)).","conclusion":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n⊆₁ (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n   (E ∩₁ (fun a : actid => is_init a))","hypotheses":"","proofString":"rewrite !set_pair_union_l.\neauto with hahn."},{"statement":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n⊆₁ eq ta_cover <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ eq ta_issue <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ is_ta_propagate_to_G G <*> (E ∩₁ (fun a : actid => is_init a)).","conclusion":"eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n⊆₁ eq ta_cover <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ eq ta_issue <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ eq ta_reserve <*> (E ∩₁ (fun a : actid => is_init a))\n   ∪₁ is_ta_propagate_to_G G <*> (E ∩₁ (fun a : actid => is_init a))","hypotheses":"","proofString":"eauto with hahn."},{"statement":"(s : actid -> Prop) : eq ta_reserve <*> s ∪₁ eq ta_reserve <*> issued (eq ta_reserve <*> s)\n≡₁ eq ta_reserve <*> s.","conclusion":"eq ta_reserve <*> s ∪₁ eq ta_reserve <*> issued (eq ta_reserve <*> s)\n≡₁ eq ta_reserve <*> s","hypotheses":"(s : actid -> Prop)","proofString":"now autorewrite with cir_simplify."}]}