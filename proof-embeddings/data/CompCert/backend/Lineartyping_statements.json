{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Lineartyping.v","fileSamples":[{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) : Val.has_type (Locmap.set (R r) v ls l) (Loc.type l).","proofString":"unfold Locmap.set.\ndestruct (Loc.eq (R r) l).\nsubst l; auto.\ndestruct (Loc.diff_dec (R r) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) : Val.has_type\n  (if Loc.eq (R r) l\n   then v\n   else if Loc.diff_dec (R r) l then ls l else Vundef) \n  (Loc.type l).","proofString":"destruct (Loc.eq (R r) l).\nsubst l; auto.\ndestruct (Loc.diff_dec (R r) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) (e : R r = l) : Val.has_type v (Loc.type l).","proofString":"subst l; auto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) (n : R r <> l) : Val.has_type (if Loc.diff_dec (R r) l then ls l else Vundef) (Loc.type l).","proofString":"destruct (Loc.diff_dec (R r) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) (n : R r <> l) (d : Loc.diff (R r) l) : Val.has_type (ls l) (Loc.type l).","proofString":"auto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) (n : R r <> l) (n0 : ~ Loc.diff (R r) l) : Val.has_type Vundef (Loc.type l).","proofString":"red.\nauto."},{"statement":"(ls : locset) (r : mreg) (v : val) (H : Val.has_type v (mreg_type r)) (H0 : wt_locset ls) (l : loc) (n : R r <> l) (n0 : ~ Loc.diff (R r) l) : True.","proofString":"auto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) : Val.has_type (Locmap.set (S sl ofs ty) v ls l) (Loc.type l).","proofString":"unfold Locmap.set.\ndestruct (Loc.eq (S sl ofs ty) l).\nsubst l.\nsimpl.\ngeneralize (Val.load_result_type (chunk_of_type ty) v).\nreplace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec (S sl ofs ty) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) : Val.has_type\n  (if Loc.eq (S sl ofs ty) l\n   then Val.load_result (chunk_of_type ty) v\n   else if Loc.diff_dec (S sl ofs ty) l then ls l else Vundef) \n  (Loc.type l).","proofString":"destruct (Loc.eq (S sl ofs ty) l).\nsubst l.\nsimpl.\ngeneralize (Val.load_result_type (chunk_of_type ty) v).\nreplace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity.\ndestruct (Loc.diff_dec (S sl ofs ty) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) (e : S sl ofs ty = l) : Val.has_type (Val.load_result (chunk_of_type ty) v) (Loc.type l).","proofString":"subst l.\nsimpl.\ngeneralize (Val.load_result_type (chunk_of_type ty) v).\nreplace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) : Val.has_type (Val.load_result (chunk_of_type ty) v) (Loc.type (S sl ofs ty)).","proofString":"simpl.\ngeneralize (Val.load_result_type (chunk_of_type ty) v).\nreplace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) : Val.has_type (Val.load_result (chunk_of_type ty) v) ty.","proofString":"generalize (Val.load_result_type (chunk_of_type ty) v).\nreplace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) : Val.has_type (Val.load_result (chunk_of_type ty) v)\n  (type_of_chunk (chunk_of_type ty)) ->\nVal.has_type (Val.load_result (chunk_of_type ty) v) ty.","proofString":"replace (type_of_chunk (chunk_of_type ty)) with ty.\nauto.\ndestruct ty; reflexivity."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) : Val.has_type (Val.load_result (chunk_of_type ty) v) ty ->\nVal.has_type (Val.load_result (chunk_of_type ty) v) ty.","proofString":"auto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) : ty = type_of_chunk (chunk_of_type ty).","proofString":"destruct ty; reflexivity."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) (n : S sl ofs ty <> l) : Val.has_type (if Loc.diff_dec (S sl ofs ty) l then ls l else Vundef)\n  (Loc.type l).","proofString":"destruct (Loc.diff_dec (S sl ofs ty) l).\nauto.\nred.\nauto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) (n : S sl ofs ty <> l) (d : Loc.diff (S sl ofs ty) l) : Val.has_type (ls l) (Loc.type l).","proofString":"auto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) (n : S sl ofs ty <> l) (n0 : ~ Loc.diff (S sl ofs ty) l) : Val.has_type Vundef (Loc.type l).","proofString":"red.\nauto."},{"statement":"(ls : locset) (sl : slot) (ofs : Z) (ty : typ) (v : val) (H : wt_locset ls) (l : loc) (n : S sl ofs ty <> l) (n0 : ~ Loc.diff (S sl ofs ty) l) : True.","proofString":"auto."},{"statement":"(ls : locset) (H : wt_locset ls) : wt_locset ls.","proofString":"auto."},{"statement":"(a : mreg) (rs : list mreg) (IHrs : forall ls0 : locset, wt_locset ls0 -> wt_locset (undef_regs rs ls0)) (ls : locset) (H : wt_locset ls) : wt_locset (Locmap.set (R a) Vundef (undef_regs rs ls)).","proofString":"apply wt_setreg; auto.\nred; auto."},{"statement":"(a : mreg) (rs : list mreg) (IHrs : forall ls0 : locset, wt_locset ls0 -> wt_locset (undef_regs rs ls0)) (ls : locset) (H : wt_locset ls) : Val.has_type Vundef (mreg_type a).","proofString":"red; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (l : loc) : Val.has_type (call_regs ls l) (Loc.type l).","proofString":"unfold call_regs.\ndestruct l.\nauto.\ndestruct sl.\nred; auto.\nchange (Loc.type (S Incoming pos ty)) with (Loc.type (S Outgoing pos ty)).\nauto.\nred; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (l : loc) : Val.has_type\n  match l with\n  | R r => ls (R r)\n  | S Incoming ofs ty => ls (S Outgoing ofs ty)\n  | _ => Vundef\n  end (Loc.type l).","proofString":"destruct l.\nauto.\ndestruct sl.\nred; auto.\nchange (Loc.type (S Incoming pos ty)) with (Loc.type (S Outgoing pos ty)).\nauto.\nred; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (r : mreg) : Val.has_type (ls (R r)) (Loc.type (R r)).","proofString":"auto."},{"statement":"(ls : locset) (H : wt_locset ls) (sl : slot) (pos : Z) (ty : typ) : Val.has_type\n  match sl with\n  | Incoming => ls (S Outgoing pos ty)\n  | _ => Vundef\n  end (Loc.type (S sl pos ty)).","proofString":"destruct sl.\nred; auto.\nchange (Loc.type (S Incoming pos ty)) with (Loc.type (S Outgoing pos ty)).\nauto.\nred; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (pos : Z) (ty : typ) : Val.has_type Vundef (Loc.type (S Local pos ty)).","proofString":"red; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (pos : Z) (ty : typ) : Val.has_type (ls (S Outgoing pos ty)) (Loc.type (S Incoming pos ty)).","proofString":"change (Loc.type (S Incoming pos ty)) with (Loc.type (S Outgoing pos ty)).\nauto."},{"statement":"(ls : locset) (H : wt_locset ls) (pos : Z) (ty : typ) : Val.has_type (ls (S Outgoing pos ty)) (Loc.type (S Outgoing pos ty)).","proofString":"auto."},{"statement":"(ls : locset) (H : wt_locset ls) (pos : Z) (ty : typ) : Val.has_type Vundef (Loc.type (S Outgoing pos ty)).","proofString":"red; auto."},{"statement":"(caller callee : locset) (H : wt_locset caller) (H0 : wt_locset callee) (l : loc) : Val.has_type (return_regs caller callee l) (Loc.type l).","proofString":"unfold return_regs.\ndestruct l.\ndestruct (is_callee_save r); auto.\ndestruct sl; auto; red; auto."},{"statement":"(caller callee : locset) (H : wt_locset caller) (H0 : wt_locset callee) (l : loc) : Val.has_type\n  match l with\n  | R r => if is_callee_save r then caller (R r) else callee (R r)\n  | S (Local as sl) ofs ty | S (Incoming as sl) ofs ty =>\n      caller (S sl ofs ty)\n  | S Outgoing _ _ => Vundef\n  end (Loc.type l).","proofString":"destruct l.\ndestruct (is_callee_save r); auto.\ndestruct sl; auto; red; auto."},{"statement":"(caller callee : locset) (H : wt_locset caller) (H0 : wt_locset callee) (r : mreg) : Val.has_type (if is_callee_save r then caller (R r) else callee (R r))\n  (Loc.type (R r)).","proofString":"destruct (is_callee_save r); auto."},{"statement":"(caller callee : locset) (H : wt_locset caller) (H0 : wt_locset callee) (sl : slot) (pos : Z) (ty : typ) : Val.has_type\n  match sl with\n  | Outgoing => Vundef\n  | _ => caller (S sl pos ty)\n  end (Loc.type (S sl pos ty)).","proofString":"destruct sl; auto; red; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (l : loc) : Val.has_type (undef_caller_save_regs ls l) (Loc.type l).","proofString":"unfold undef_caller_save_regs.\ndestruct l.\ndestruct (is_callee_save r); auto; simpl; auto.\ndestruct sl; auto; red; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (l : loc) : Val.has_type\n  match l with\n  | R r => if is_callee_save r then ls (R r) else Vundef\n  | S (Local as sl) ofs ty | S (Incoming as sl) ofs ty => ls (S sl ofs ty)\n  | S Outgoing _ _ => Vundef\n  end (Loc.type l).","proofString":"destruct l.\ndestruct (is_callee_save r); auto; simpl; auto.\ndestruct sl; auto; red; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (r : mreg) : Val.has_type (if is_callee_save r then ls (R r) else Vundef) (Loc.type (R r)).","proofString":"destruct (is_callee_save r); auto; simpl; auto."},{"statement":"(ls : locset) (H : wt_locset ls) (sl : slot) (pos : Z) (ty : typ) : Val.has_type match sl with\n             | Outgoing => Vundef\n             | _ => ls (S sl pos ty)\n             end (Loc.type (S sl pos ty)).","proofString":"destruct sl; auto; red; auto."},{"statement":"(l : loc) : Val.has_type (Locmap.init Vundef l) (Loc.type l).","proofString":"unfold Locmap.init.\nred; auto."},{"statement":"(l : loc) : Val.has_type Vundef (Loc.type l).","proofString":"red; auto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) : wt_locset (Locmap.setpair (loc_result sg) v rs).","proofString":"generalize (loc_result_pair sg) (loc_result_type sg).\ndestruct (loc_result sg); simpl Locmap.setpair.\nintros.\napply wt_setreg; auto.\neapply Val.has_subtype; eauto.\nintros A B.\ndecompose [and] A.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) : match loc_result sg with\n| One _ => True\n| Twolong r1 r2 =>\n    r1 <> r2 /\\\n    proj_sig_res sg = Tlong /\\\n    subtype Tint (mreg_type r1) = true /\\\n    subtype Tint (mreg_type r2) = true /\\ Archi.ptr64 = false\nend ->\nsubtype (proj_sig_res sg) (typ_rpair mreg_type (loc_result sg)) = true ->\nwt_locset (Locmap.setpair (loc_result sg) v rs).","proofString":"destruct (loc_result sg); simpl Locmap.setpair.\nintros.\napply wt_setreg; auto.\neapply Val.has_subtype; eauto.\nintros A B.\ndecompose [and] A.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (r : mreg) : True ->\nsubtype (proj_sig_res sg) (typ_rpair mreg_type (One r)) = true ->\nwt_locset (Locmap.set (R r) v rs).","proofString":"intros.\napply wt_setreg; auto.\neapply Val.has_subtype; eauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (r : mreg) (H1 : True) (H2 : subtype (proj_sig_res sg) (typ_rpair mreg_type (One r)) = true) : wt_locset (Locmap.set (R r) v rs).","proofString":"apply wt_setreg; auto.\neapply Val.has_subtype; eauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (r : mreg) (H1 : True) (H2 : subtype (proj_sig_res sg) (typ_rpair mreg_type (One r)) = true) : Val.has_type v (mreg_type r).","proofString":"eapply Val.has_subtype; eauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false ->\nsubtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true ->\nwt_locset\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) rs)).","proofString":"intros A B.\ndecompose [and] A.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) : wt_locset\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) rs)).","proofString":"decompose [and] A.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : wt_locset\n  (Locmap.set (R rlo) (Val.loword v) (Locmap.set (R rhi) (Val.hiword v) rs)).","proofString":"apply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\napply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : Val.has_type (Val.loword v) (mreg_type rlo).","proofString":"eapply Val.has_subtype; eauto.\ndestruct v; exact I."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : Val.has_type (Val.loword v) Tint.","proofString":"destruct v; exact I."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : wt_locset (Locmap.set (R rhi) (Val.hiword v) rs).","proofString":"apply wt_setreg.\neapply Val.has_subtype; eauto.\ndestruct v; exact I.\nauto."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : Val.has_type (Val.hiword v) (mreg_type rhi).","proofString":"eapply Val.has_subtype; eauto.\ndestruct v; exact I."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : Val.has_type (Val.hiword v) Tint.","proofString":"destruct v; exact I."},{"statement":"(sg : signature) (v : val) (rs : locset) (H : Val.has_type v (proj_sig_res sg)) (H0 : wt_locset rs) (rhi rlo : mreg) (A : rhi <> rlo /\\\nproj_sig_res sg = Tlong /\\\nsubtype Tint (mreg_type rhi) = true /\\\nsubtype Tint (mreg_type rlo) = true /\\ Archi.ptr64 = false) (B : subtype (proj_sig_res sg) (typ_rpair mreg_type (Twolong rhi rlo)) = true) (H1 : rhi <> rlo) (H3 : proj_sig_res sg = Tlong) (H2 : subtype Tint (mreg_type rhi) = true) (H4 : subtype Tint (mreg_type rlo) = true) (H6 : Archi.ptr64 = false) : wt_locset rs.","proofString":"auto."},{"statement":"(x : mreg) (ty : typ) (v : val) (rs : locset) (H : subtype ty (mreg_type x) = true) (H0 : Val.has_type v ty) (H1 : wt_locset rs) : wt_locset (Locmap.set (R x) v rs).","proofString":"apply wt_setreg; auto.\neapply Val.has_subtype; eauto."},{"statement":"(x : mreg) (ty : typ) (v : val) (rs : locset) (H : subtype ty (mreg_type x) = true) (H0 : Val.has_type v ty) (H1 : wt_locset rs) : Val.has_type v (mreg_type x).","proofString":"eapply Val.has_subtype; eauto."},{"statement":"(ty : typ) (v : val) (rs : locset) (H : true = true) (H0 : Val.has_type v ty) (H1 : wt_locset rs) : wt_locset rs.","proofString":"auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res1 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res1 v0 rs0)) (IHres2 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res2 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res2 v0 rs0)) (ty : typ) (v : val) (rs : locset) (H : wt_builtin_res Tint res1 && wt_builtin_res Tint res2 = true) (H0 : Val.has_type v ty) (H1 : wt_locset rs) : wt_locset\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) rs)).","proofString":"InvBooleans.\neapply IHres2; eauto.\ndestruct v; exact I.\neapply IHres1; eauto.\ndestruct v; exact I."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res1 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res1 v0 rs0)) (IHres2 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res2 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res2 v0 rs0)) (ty : typ) (v : val) (rs : locset) (H0 : Val.has_type v ty) (H1 : wt_locset rs) (H2 : wt_builtin_res Tint res1 = true) (H3 : wt_builtin_res Tint res2 = true) : wt_locset\n  (Locmap.setres res2 (Val.loword v) (Locmap.setres res1 (Val.hiword v) rs)).","proofString":"eapply IHres2; eauto.\ndestruct v; exact I.\neapply IHres1; eauto.\ndestruct v; exact I."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res1 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res1 v0 rs0)) (IHres2 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res2 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res2 v0 rs0)) (ty : typ) (v : val) (rs : locset) (H0 : Val.has_type v ty) (H1 : wt_locset rs) (H2 : wt_builtin_res Tint res1 = true) (H3 : wt_builtin_res Tint res2 = true) : Val.has_type (Val.loword v) Tint.","proofString":"destruct v; exact I."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res1 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res1 v0 rs0)) (IHres2 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res2 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res2 v0 rs0)) (ty : typ) (v : val) (rs : locset) (H0 : Val.has_type v ty) (H1 : wt_locset rs) (H2 : wt_builtin_res Tint res1 = true) (H3 : wt_builtin_res Tint res2 = true) : wt_locset (Locmap.setres res1 (Val.hiword v) rs).","proofString":"eapply IHres1; eauto.\ndestruct v; exact I."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res1 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res1 v0 rs0)) (IHres2 : forall (ty0 : typ) (v0 : val) (rs0 : locset),\nwt_builtin_res ty0 res2 = true ->\nVal.has_type v0 ty0 -> wt_locset rs0 -> wt_locset (Locmap.setres res2 v0 rs0)) (ty : typ) (v : val) (rs : locset) (H0 : Val.has_type v ty) (H1 : wt_locset rs) (H2 : wt_builtin_res Tint res1 = true) (H3 : wt_builtin_res Tint res2 = true) : Val.has_type (Val.hiword v) Tint.","proofString":"destruct v; exact I."},{"statement":"(f : function) (lbl : label) (c : code) : wt_code f (fn_code f) = true ->\nfind_label lbl (fn_code f) = Some c -> wt_code f c = true.","proofString":"generalize (fn_code f).\ninduction c0; simpl; intros.\ndiscriminate.\nInvBooleans.\ndestruct (is_label lbl a).\ncongruence.\nauto."},{"statement":"(f : function) (lbl : label) (c : code) : forall c0 : code,\nwt_code f c0 = true -> find_label lbl c0 = Some c -> wt_code f c = true.","proofString":"induction c0; simpl; intros.\ndiscriminate.\nInvBooleans.\ndestruct (is_label lbl a).\ncongruence.\nauto."},{"statement":"(f : function) (lbl : label) (c : code) (H : true = true) (H0 : None = Some c) : wt_code f c = true.","proofString":"discriminate."},{"statement":"(f : function) (lbl : label) (c : code) (a : instruction) (c0 : list instruction) (IHc0 : wt_code f c0 = true -> find_label lbl c0 = Some c -> wt_code f c = true) (H : wt_instr f a && wt_code f c0 = true) (H0 : (if is_label lbl a then Some c0 else find_label lbl c0) = Some c) : wt_code f c = true.","proofString":"InvBooleans.\ndestruct (is_label lbl a).\ncongruence.\nauto."},{"statement":"(f : function) (lbl : label) (c : code) (a : instruction) (c0 : list instruction) (IHc0 : wt_code f c0 = true -> find_label lbl c0 = Some c -> wt_code f c = true) (H0 : (if is_label lbl a then Some c0 else find_label lbl c0) = Some c) (H1 : wt_instr f a = true) (H2 : wt_code f c0 = true) : wt_code f c = true.","proofString":"destruct (is_label lbl a).\ncongruence.\nauto."},{"statement":"(f : function) (lbl : label) (c : code) (a : instruction) (c0 : list instruction) (IHc0 : wt_code f c0 = true -> find_label lbl c0 = Some c -> wt_code f c = true) (H0 : Some c0 = Some c) (H1 : wt_instr f a = true) (H2 : wt_code f c0 = true) : wt_code f c = true.","proofString":"congruence."},{"statement":"(f : function) (lbl : label) (c : code) (a : instruction) (c0 : list instruction) (IHc0 : wt_code f c0 = true -> find_label lbl c0 = Some c -> wt_code f c = true) (H0 : find_label lbl c0 = Some c) (H1 : wt_instr f a = true) (H2 : wt_code f c0 = true) : wt_code f c = true.","proofString":"auto."},{"statement":"wt_locset (Locmap.init Vundef).","proofString":"apply wt_init."},{"statement":"(f : function) (sp : val) (rs : locset) (c : code) (s : list stackframe) (H : wt_callstack s) (WTF : wt_function f = true) (WTC : wt_code f c = true) (WTRS : wt_locset rs) (IHwt_callstack : wt_locset (parent_locset s)) : wt_locset rs.","proofString":"auto."},{"statement":"(ros : mreg + ident) (rs : locset) (f : fundef) (H : find_function ge ros rs = Some f) : wt_fundef f.","proofString":"assert (X: exists i, In (i, Gfun f) prog.(prog_defs)).\ndestruct ros as [r | s]; simpl in H.\neapply Genv.find_funct_inversion; eauto.\ndestruct (Genv.find_symbol ge s) as [b|]; try discriminate.\neapply Genv.find_funct_ptr_inversion; eauto.\ndestruct X as [i IN].\neapply wt_prog; eauto."},{"statement":"(ros : mreg + ident) (rs : locset) (f : fundef) (H : find_function ge ros rs = Some f) : exists i : ident, In (i, Gfun f) (prog_defs prog).","proofString":"destruct ros as [r | s]; simpl in H.\neapply Genv.find_funct_inversion; eauto.\ndestruct (Genv.find_symbol ge s) as [b|]; try discriminate.\neapply Genv.find_funct_ptr_inversion; eauto."},{"statement":"(r : mreg) (rs : locset) (f : fundef) (H : Genv.find_funct ge (rs (R r)) = Some f) : exists i : ident, In (i, Gfun f) (prog_defs prog).","proofString":"eapply Genv.find_funct_inversion; eauto."},{"statement":"(s : ident) (rs : locset) (f : fundef) (H : match Genv.find_symbol ge s with\n| Some b => Genv.find_funct_ptr ge b\n| None => None\nend = Some f) : exists i : ident, In (i, Gfun f) (prog_defs prog).","proofString":"destruct (Genv.find_symbol ge s) as [b|]; try discriminate.\neapply Genv.find_funct_ptr_inversion; eauto."},{"statement":"(s : ident) (rs : locset) (f : fundef) (b : block) (H : Genv.find_funct_ptr ge b = Some f) : exists i : ident, In (i, Gfun f) (prog_defs prog).","proofString":"eapply Genv.find_funct_ptr_inversion; eauto."},{"statement":"(ros : mreg + ident) (rs : locset) (f : fundef) (H : find_function ge ros rs = Some f) (X : exists i : ident, In (i, Gfun f) (prog_defs prog)) : wt_fundef f.","proofString":"destruct X as [i IN].\neapply wt_prog; eauto."},{"statement":"(ros : mreg + ident) (rs : locset) (f : fundef) (H : find_function ge ros rs = Some f) (i : ident) (IN : In (i, Gfun f) (prog_defs prog)) : wt_fundef f.","proofString":"eapply wt_prog; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : funsig f = signature_main) : wt_callstack nil.","proofString":"constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some f) (H2 : funsig f = signature_main) : wt_fundef f.","proofString":"exploit Genv.find_funct_ptr_inversion; eauto.\nintros [id IN].\neapply wt_prog; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some f) (H2 : funsig f = signature_main) : (exists id : ident, In (id, Gfun f) (prog_defs prog)) -> wt_fundef f.","proofString":"intros [id IN].\neapply wt_prog; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr (Genv.globalenv prog) b = Some f) (H2 : funsig f = signature_main) (id : ident) (IN : In (id, Gfun f) (prog_defs prog)) : wt_fundef f.","proofString":"eapply wt_prog; eauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : funsig f = signature_main) : wt_locset (Locmap.init Vundef).","proofString":"apply wt_init."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : funsig f = signature_main) : agree_callee_save (Locmap.init Vundef) (parent_locset nil).","proofString":"red; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : funsig f = signature_main) : agree_outgoing_arguments (funsig f) (Locmap.init Vundef) (parent_locset nil).","proofString":"red; auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (rd : mreg) (c : list instruction) (rs : locset) (m : mem) (H : wt_state (State s f sp (Lgetstack sl ofs ty rd :: c) rs m)) : slot_valid f sl ofs ty = true.","proofString":"inv H.\nsimpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (rd : mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTC : wt_code f (Lgetstack sl ofs ty rd :: c) = true) (WTRS : wt_locset rs) : slot_valid f sl ofs ty = true.","proofString":"simpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (rd : mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTRS : wt_locset rs) (H0 : wt_code f c = true) (H1 : subtype ty (mreg_type rd) = true) (H2 : slot_valid f sl ofs ty = true) : slot_valid f sl ofs ty = true.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (r : mreg) (c : list instruction) (rs : locset) (m : mem) (H : wt_state (State s f sp (Lsetstack r sl ofs ty :: c) rs m)) : slot_valid f sl ofs ty = true /\\ slot_writable sl = true.","proofString":"inv H.\nsimpl in WTC; InvBooleans.\nintuition."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (r : mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTC : wt_code f (Lsetstack r sl ofs ty :: c) = true) (WTRS : wt_locset rs) : slot_valid f sl ofs ty = true /\\ slot_writable sl = true.","proofString":"simpl in WTC; InvBooleans.\nintuition."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sl : slot) (ofs : Z) (ty : typ) (r : mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTRS : wt_locset rs) (H0 : wt_code f c = true) (H1 : slot_valid f sl ofs ty = true) (H2 : slot_writable sl = true) : slot_valid f sl ofs ty = true /\\ slot_writable sl = true.","proofString":"intuition."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sg : signature) (ros : mreg + ident) (c : list instruction) (rs : locset) (m : mem) (H : wt_state (State s f sp (Ltailcall sg ros :: c) rs m)) : size_arguments sg = 0.","proofString":"inv H.\nsimpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sg : signature) (ros : mreg + ident) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTC : wt_code f (Ltailcall sg ros :: c) = true) (WTRS : wt_locset rs) : size_arguments sg = 0.","proofString":"simpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (sg : signature) (ros : mreg + ident) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTRS : wt_locset rs) (H0 : wt_code f c = true) (H : size_arguments sg = 0) : size_arguments sg = 0.","proofString":"auto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (c : list instruction) (rs : locset) (m : mem) (H : wt_state (State s f sp (Lbuiltin ef args res :: c) rs m)) : forallb (loc_valid f) (params_of_builtin_args args) = true.","proofString":"inv H.\nsimpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTC : wt_code f (Lbuiltin ef args res :: c) = true) (WTRS : wt_locset rs) : forallb (loc_valid f) (params_of_builtin_args args) = true.","proofString":"simpl in WTC; InvBooleans.\nauto."},{"statement":"(s : list stackframe) (f : function) (sp : val) (ef : external_function) (args : list (builtin_arg loc)) (res : builtin_res mreg) (c : list instruction) (rs : locset) (m : mem) (WTSTK : wt_callstack s) (WTF : wt_function f = true) (WTRS : wt_locset rs) (H0 : wt_code f c = true) (H1 : wt_builtin_res (proj_sig_res (ef_sig ef)) res = true) (H2 : forallb (loc_valid f) (params_of_builtin_args args) = true) : forallb (loc_valid f) (params_of_builtin_args args) = true.","proofString":"auto."},{"statement":"(s : list stackframe) (f : fundef) (rs : locset) (m : mem) (H : wt_state (Callstate s f rs m)) (r : mreg) : Val.has_type (rs (R r)) (mreg_type r).","proofString":"inv H.\napply WTRS."},{"statement":"(s : list stackframe) (f : fundef) (rs : locset) (m : mem) (r : mreg) (WTSTK : wt_callstack s) (WTFD : wt_fundef f) (WTRS : wt_locset rs) (AGCS : agree_callee_save rs (parent_locset s)) (AGARGS : agree_outgoing_arguments (funsig f) rs (parent_locset s)) : Val.has_type (rs (R r)) (mreg_type r).","proofString":"apply WTRS."},{"statement":"(s : list stackframe) (f : fundef) (rs : locset) (m : mem) (H : wt_state (Callstate s f rs m)) : agree_callee_save rs (parent_locset s) /\\\nagree_outgoing_arguments (funsig f) rs (parent_locset s).","proofString":"inv H; auto."},{"statement":"(s : list stackframe) (rs : locset) (m : mem) (H : wt_state (Returnstate s rs m)) : agree_callee_save rs (parent_locset s) /\\ outgoing_undef rs.","proofString":"inv H; auto."}]}