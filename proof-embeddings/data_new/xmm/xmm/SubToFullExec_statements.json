{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/xmm/SubToFullExec.v","fileSamples":[{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : eq_dom E lab' delta_lab /\\ eq_dom (eq e) lab' delta_lab.","conclusion":"eq_dom E lab' delta_lab /\\ eq_dom (eq e) lab' delta_lab","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"split.\nunfolder.\nunfold delta_lab.\nins.\nrupd; [|congruence].\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nunfold delta_lab.\nunfolder.\nins.\ndesf.\nnow rupd."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : eq_dom E lab' delta_lab.","conclusion":"eq_dom E lab' delta_lab","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"unfolder.\nunfold delta_lab.\nins.\nrupd; [|congruence].\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : forall x : actid, E x -> lab' x = delta_lab x.","conclusion":"forall x : actid, E x -> lab' x = delta_lab x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"unfold delta_lab.\nins.\nrupd; [|congruence].\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : forall x : actid, E x -> lab' x = upd lab e (lab' e) x.","conclusion":"forall x : actid, E x -> lab' x = upd lab e (lab' e) x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"ins.\nrupd; [|congruence].\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x) : lab' x = upd lab e (lab' e) x.","conclusion":"lab' x = upd lab e (lab' e) x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x)","proofString":"rupd; [|congruence].\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x) : lab' x = lab x.","conclusion":"lab' x = lab x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x)","proofString":"rewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x) : ((fun a : actid => is_init a) ∪₁ E) x.","conclusion":"((fun a : actid => is_init a) ∪₁ E) x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : E x)","proofString":"basic_solver."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : eq_dom (eq e) lab' delta_lab.","conclusion":"eq_dom (eq e) lab' delta_lab","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"unfold delta_lab.\nunfolder.\nins.\ndesf.\nnow rupd."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : eq_dom (eq e) lab' (upd lab e (lab' e)).","conclusion":"eq_dom (eq e) lab' (upd lab e (lab' e))","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"unfolder.\nins.\ndesf.\nnow rupd."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') : forall x : actid, e = x -> lab' x = upd lab e (lab' e) x.","conclusion":"forall x : actid, e = x -> lab' x = upd lab e (lab' e) x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X')","proofString":"ins.\ndesf.\nnow rupd."},{"statement":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : e = x) : lab' x = upd lab e (lab' e) x.","conclusion":"lab' x = upd lab e (lab' e) x","hypotheses":"(NOTINE : ~ E e) (PFX : prefix X X') (x : actid) (DX : e = x)","proofString":"desf.\nnow rupd."},{"statement":"(x : actid) (NOTINE : ~ E x) (PFX : prefix X X') : lab' x = upd lab x (lab' x) x.","conclusion":"lab' x = upd lab x (lab' x) x","hypotheses":"(x : actid) (NOTINE : ~ E x) (PFX : prefix X X')","proofString":"now rupd."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') : E ∪₁ eq e ⊆₁ E'.","conclusion":"E ∪₁ eq e ⊆₁ E'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X')","proofString":"apply set_subset_union_l; split; [| basic_solver].\napply PFX."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') : E ⊆₁ E'.","conclusion":"E ⊆₁ E'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X')","proofString":"apply PFX."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : prefix delta_X X'.","conclusion":"prefix delta_X X'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"unfold delta_X, delta_G, delta_sc,         delta_E, delta_lab.\nconstructor; ins.\nrewrite <- (prf_init PFX).\nbasic_solver.\napply PFX.\nrewrite <- set_unionA.\napply eq_dom_union.\nunfolder; split; [| now ins; desf; rupd].\nintros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder.\nunfolder.\nintros x XIN.\nrupd; [| congruence].\nnow apply (prf_lab_extra PFX).\nrewrite id_union, seq_union_r at 1.\napply inclusion_union_l.\nrewrite (prf_sb PFX).\nunfold sb; ins.\nbasic_solver.\nrewrite EMAX.\nunfold sb.\nins.\nrewrite !seqA.\nseq_rewrite <- !id_inter.\nrewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : prefix\n  {|\n    WCore.G :=\n      {|\n        acts_set := E ∪₁ eq e;\n        threads_set := threads_set;\n        lab := upd lab e (lab' e);\n        rmw := restr_rel (E ∪₁ eq e) rmw';\n        data := data';\n        addr := addr';\n        ctrl := ctrl';\n        rmw_dep := rmw_dep';\n        rf := restr_rel (E ∪₁ eq e) rf';\n        co := restr_rel (E ∪₁ eq e) co'\n      |};\n    WCore.sc := sc'\n  |} X'.","conclusion":"prefix\n  {|\n    WCore.G :=\n      {|\n        acts_set := E ∪₁ eq e;\n        threads_set := threads_set;\n        lab := upd lab e (lab' e);\n        rmw := restr_rel (E ∪₁ eq e) rmw';\n        data := data';\n        addr := addr';\n        ctrl := ctrl';\n        rmw_dep := rmw_dep';\n        rf := restr_rel (E ∪₁ eq e) rf';\n        co := restr_rel (E ∪₁ eq e) co'\n      |};\n    WCore.sc := sc'\n  |} X'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"constructor; ins.\nrewrite <- (prf_init PFX).\nbasic_solver.\napply PFX.\nrewrite <- set_unionA.\napply eq_dom_union.\nunfolder; split; [| now ins; desf; rupd].\nintros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder.\nunfolder.\nintros x XIN.\nrupd; [| congruence].\nnow apply (prf_lab_extra PFX).\nrewrite id_union, seq_union_r at 1.\napply inclusion_union_l.\nrewrite (prf_sb PFX).\nunfold sb; ins.\nbasic_solver.\nrewrite EMAX.\nunfold sb.\nins.\nrewrite !seqA.\nseq_rewrite <- !id_inter.\nrewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : (fun a : actid => is_init a) ⊆₁ E ∪₁ eq e.","conclusion":"(fun a : actid => is_init a) ⊆₁ E ∪₁ eq e","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"rewrite <- (prf_init PFX).\nbasic_solver."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : (fun a : actid => is_init a) ⊆₁ (fun a : actid => is_init a) ∪₁ eq e.","conclusion":"(fun a : actid => is_init a) ⊆₁ (fun a : actid => is_init a) ∪₁ eq e","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"basic_solver."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : threads_set ≡₁ threads_set'.","conclusion":"threads_set ≡₁ threads_set'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"apply PFX."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : eq_dom ((fun a : actid => is_init a) ∪₁ (E ∪₁ eq e)) \n  (upd lab e (lab' e)) lab'.","conclusion":"eq_dom ((fun a : actid => is_init a) ∪₁ (E ∪₁ eq e)) \n  (upd lab e (lab' e)) lab'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"rewrite <- set_unionA.\napply eq_dom_union.\nunfolder; split; [| now ins; desf; rupd].\nintros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : eq_dom ((fun a : actid => is_init a) ∪₁ E ∪₁ eq e) (upd lab e (lab' e)) lab'.","conclusion":"eq_dom ((fun a : actid => is_init a) ∪₁ E ∪₁ eq e) (upd lab e (lab' e)) lab'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"apply eq_dom_union.\nunfolder; split; [| now ins; desf; rupd].\nintros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : eq_dom ((fun a : actid => is_init a) ∪₁ E) (upd lab e (lab' e)) lab' /\\\neq_dom (eq e) (upd lab e (lab' e)) lab'.","conclusion":"eq_dom ((fun a : actid => is_init a) ∪₁ E) (upd lab e (lab' e)) lab' /\\\neq_dom (eq e) (upd lab e (lab' e)) lab'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"unfolder; split; [| now ins; desf; rupd].\nintros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : forall x : actid, is_init x \\/ E x -> upd lab e (lab' e) x = lab' x.","conclusion":"forall x : actid, is_init x \\/ E x -> upd lab e (lab' e) x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"intros x XIN.\nrupd; [| desf; congruence].\napply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x) : upd lab e (lab' e) x = lab' x.","conclusion":"upd lab e (lab' e) x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x)","proofString":"rupd; [| desf; congruence].\napply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x) : lab x = lab' x.","conclusion":"lab x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x)","proofString":"apply PFX.\nnow unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x) : ((fun a : actid => is_init a) ∪₁ E) x.","conclusion":"((fun a : actid => is_init a) ∪₁ E) x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : is_init x \\/ E x)","proofString":"now unfolder."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : eq_dom (set_compl E') (upd lab e (lab' e)) lab'.","conclusion":"eq_dom (set_compl E') (upd lab e (lab' e)) lab'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"unfolder.\nintros x XIN.\nrupd; [| congruence].\nnow apply (prf_lab_extra PFX)."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : forall x : actid, ~ E' x -> upd lab e (lab' e) x = lab' x.","conclusion":"forall x : actid, ~ E' x -> upd lab e (lab' e) x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"intros x XIN.\nrupd; [| congruence].\nnow apply (prf_lab_extra PFX)."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : ~ E' x) : upd lab e (lab' e) x = lab' x.","conclusion":"upd lab e (lab' e) x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : ~ E' x)","proofString":"rupd; [| congruence].\nnow apply (prf_lab_extra PFX)."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : ~ E' x) : lab x = lab' x.","conclusion":"lab x = lab' x","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') (x : actid) (XIN : ~ E' x)","proofString":"now apply (prf_lab_extra PFX)."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘.","conclusion":"⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"basic_solver."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq e⦘\n⊆ ⦗acts_set\n     {|\n       acts_set := E ∪₁ eq e;\n       threads_set := threads_set;\n       lab := upd lab e (lab' e);\n       rmw := restr_rel (E ∪₁ eq e) rmw';\n       data := data';\n       addr := addr';\n       ctrl := ctrl';\n       rmw_dep := rmw_dep';\n       rf := restr_rel (E ∪₁ eq e) rf';\n       co := restr_rel (E ∪₁ eq e) co'\n     |}⦘\n  ⨾ ext_sb\n    ⨾ ⦗acts_set\n         {|\n           acts_set := E ∪₁ eq e;\n           threads_set := threads_set;\n           lab := upd lab e (lab' e);\n           rmw := restr_rel (E ∪₁ eq e) rmw';\n           data := data';\n           addr := addr';\n           ctrl := ctrl';\n           rmw_dep := rmw_dep';\n           rf := restr_rel (E ∪₁ eq e) rf';\n           co := restr_rel (E ∪₁ eq e) co'\n         |}⦘.","conclusion":"⦗E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq e⦘\n⊆ ⦗acts_set\n     {|\n       acts_set := E ∪₁ eq e;\n       threads_set := threads_set;\n       lab := upd lab e (lab' e);\n       rmw := restr_rel (E ∪₁ eq e) rmw';\n       data := data';\n       addr := addr';\n       ctrl := ctrl';\n       rmw_dep := rmw_dep';\n       rf := restr_rel (E ∪₁ eq e) rf';\n       co := restr_rel (E ∪₁ eq e) co'\n     |}⦘\n  ⨾ ext_sb\n    ⨾ ⦗acts_set\n         {|\n           acts_set := E ∪₁ eq e;\n           threads_set := threads_set;\n           lab := upd lab e (lab' e);\n           rmw := restr_rel (E ∪₁ eq e) rmw';\n           data := data';\n           addr := addr';\n           ctrl := ctrl';\n           rmw_dep := rmw_dep';\n           rf := restr_rel (E ∪₁ eq e) rf';\n           co := restr_rel (E ∪₁ eq e) co'\n         |}⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"ins.\nrewrite !seqA.\nseq_rewrite <- !id_inter.\nrewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘.","conclusion":"⦗E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"rewrite !seqA.\nseq_rewrite <- !id_inter.\nrewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E⦘ ⨾ ⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘.","conclusion":"⦗E⦘ ⨾ ⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘ ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"seq_rewrite <- !id_inter.\nrewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E ∩₁ E'⦘ ⨾ ext_sb ⨾ ⦗E' ∩₁ eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘.","conclusion":"⦗E ∩₁ E'⦘ ⨾ ext_sb ⨾ ⦗E' ∩₁ eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"rewrite set_inter_absorb_r, set_inter_absorb_l.\nbasic_solver.\nbasic_solver.\napply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : ⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘.","conclusion":"⦗E⦘ ⨾ ext_sb ⨾ ⦗eq e⦘ ⊆ ⦗E ∪₁ eq e⦘ ⨾ ext_sb ⨾ ⦗E ∪₁ eq e⦘","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"basic_solver."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : eq e ⊆₁ E'.","conclusion":"eq e ⊆₁ E'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"basic_solver."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E') : E ⊆₁ E'.","conclusion":"E ⊆₁ E'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ∪₁ eq e ⊆₁ E')","proofString":"apply set_subset_union_l in SUBE.\ndesf."},{"statement":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ⊆₁ E' /\\ eq e ⊆₁ E') : E ⊆₁ E'.","conclusion":"E ⊆₁ E'","hypotheses":"(INE : E' e) (NOTINE : ~ E e) (NINIT : ~ is_init e) (EMAX : sb' ⨾ ⦗eq e⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq e⦘) (PFX : prefix X X') (SUBE : E ⊆₁ E' /\\ eq e ⊆₁ E')","proofString":"desf."},{"statement":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l) : forall x : actid, E' x /\\ ~ E x -> ~ is_init x.","conclusion":"forall x : actid, E' x /\\ ~ E x -> ~ is_init x","hypotheses":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l)","proofString":"intros x [INE' NOTINE] INIT.\napply NOTINE, (prf_init PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l) (x : actid) (INE' : E' x) (NOTINE : ~ E x) (INIT : is_init x) : False.","conclusion":"False","hypotheses":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l) (x : actid) (INE' : E' x) (NOTINE : ~ E x) (INIT : is_init x)","proofString":"apply NOTINE, (prf_init PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l) (x : actid) (INE' : E' x) (NOTINE : ~ E x) (INIT : is_init x) : is_init x.","conclusion":"is_init x","hypotheses":"(l : list actid) (PFX : prefix X X') (ENUM : enumd_diff l) (x : actid) (INE' : E' x) (NOTINE : ~ E x) (INIT : is_init x)","proofString":"basic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : rf_complete (SubExecution.restrict G' cmt).","conclusion":"rf_complete (SubExecution.restrict G' cmt)","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"apply XWF."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E' ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"E' ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"arewrite (E' ≡₁ E' \\₁ E ∪₁ E).\napply set_union_minus, PFX.\nrewrite set_inter_union_l.\napply set_subset_union_l.\nsplit.\nrewrite (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver.\narewrite (E ∩₁ R' ⊆₁ E ∩₁ R).\nunfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nrewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E' ≡₁ E' \\₁ E ∪₁ E.","conclusion":"E' ≡₁ E' \\₁ E ∪₁ E","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"apply set_union_minus, PFX."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : (E' \\₁ E ∪₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"(E' \\₁ E ∪₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"rewrite set_inter_union_l.\napply set_subset_union_l.\nsplit.\nrewrite (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver.\narewrite (E ∩₁ R' ⊆₁ E ∩₁ R).\nunfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nrewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : (E' \\₁ E) ∩₁ (fun a : actid => R' a) ∪₁ E ∩₁ (fun a : actid => R' a)\n⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"(E' \\₁ E) ∩₁ (fun a : actid => R' a) ∪₁ E ∩₁ (fun a : actid => R' a)\n⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"apply set_subset_union_l.\nsplit.\nrewrite (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver.\narewrite (E ∩₁ R' ⊆₁ E ∩₁ R).\nunfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nrewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : (E' \\₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt /\\\nE ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"(E' \\₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt /\\\nE ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"split.\nrewrite (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver.\narewrite (E ∩₁ R' ⊆₁ E ∩₁ R).\nunfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nrewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : (E' \\₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"(E' \\₁ E) ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"rewrite (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : codom_rel rf' ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"codom_rel rf' ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"basic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"E ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"arewrite (E ∩₁ R' ⊆₁ E ∩₁ R).\nunfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver.\nrewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E ∩₁ (fun a : actid => R' a) ⊆₁ E ∩₁ (fun a : actid => R a).","conclusion":"E ∩₁ (fun a : actid => R' a) ⊆₁ E ∩₁ (fun a : actid => R a)","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"unfold is_r.\nunfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E\n∩₁ (fun a : actid =>\n    match lab' a with\n    | Aload _ _ _ _ => true\n    | _ => false\n    end)\n⊆₁ E\n   ∩₁ (fun a : actid =>\n       match lab a with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end).","conclusion":"E\n∩₁ (fun a : actid =>\n    match lab' a with\n    | Aload _ _ _ _ => true\n    | _ => false\n    end)\n⊆₁ E\n   ∩₁ (fun a : actid =>\n       match lab a with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end)","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"unfolder.\nintros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : forall x : actid,\nE x /\\ match lab' x with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end ->\nE x /\\ match lab x with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end.","conclusion":"forall x : actid,\nE x /\\ match lab' x with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end ->\nE x /\\ match lab x with\n       | Aload _ _ _ _ => true\n       | _ => false\n       end","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"intros x (XIN & XISR).\nsplit; ins.\nrewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (x : actid) (XIN : E x) (XISR : match lab' x with\n| Aload _ _ _ _ => true\n| _ => false\nend) : match lab x with\n| Aload _ _ _ _ => true\n| _ => false\nend.","conclusion":"match lab x with\n| Aload _ _ _ _ => true\n| _ => false\nend","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (x : actid) (XIN : E x) (XISR : match lab' x with\n| Aload _ _ _ _ => true\n| _ => false\nend)","proofString":"rewrite (prf_lab PFX); ins.\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (x : actid) (XIN : E x) (XISR : match lab' x with\n| Aload _ _ _ _ => true\n| _ => false\nend) : ((fun a : actid => is_init a) ∪₁ E) x.","conclusion":"((fun a : actid => is_init a) ∪₁ E) x","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (x : actid) (XIN : E x) (XISR : match lab' x with\n| Aload _ _ _ _ => true\n| _ => false\nend)","proofString":"basic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : E ∩₁ (fun a : actid => R a) ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"E ∩₁ (fun a : actid => R a) ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"rewrite (WCore.wf_sub_rfD XWF), (prf_rf PFX).\nbasic_solver."},{"statement":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : codom_rel (restr_rel E rf') ∪₁ cmt ⊆₁ codom_rel rf' ∪₁ cmt.","conclusion":"codom_rel (restr_rel E rf') ∪₁ cmt ⊆₁ codom_rel rf' ∪₁ cmt","hypotheses":"(l : list actid) (PFX : prefix X X') (WF : Wf G') (XWF : WCore.wf X X' cmt) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"basic_solver."},{"statement":"(l : list actid) (WF : Wf G') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : WCore.wf X' X' cmt.","conclusion":"WCore.wf X' X' cmt","hypotheses":"(l : list actid) (WF : Wf G') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"apply sub_to_full_exec_end_wf with l; ins."},{"statement":"(l : list actid) (WF : Wf G') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (WF' : WCore.wf X' X' cmt) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(l : list actid) (WF : Wf G') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) (WF' : WCore.wf X' X' cmt)","proofString":"generalize X XWF PFX ENUM.\nclear      X XWF PFX ENUM.\ninduction l as [ | h t IHl]; ins.\nassert (FULL : E ≡₁ E').\nrewrite set_union_minus with (s := E') (s' := E)           by apply PFX.\nrewrite (SubToFullExecInternal.diff_elems ENUM).\nbasic_solver.\narewrite (X = X'); [| apply rt_refl].\narewrite (X = {| WCore.G := G; WCore.sc := sc; |}); [destruct X; ins |].\narewrite (X' = {| WCore.G := G'; WCore.sc := sc'; |}); [destruct X'; ins |].\nrewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins.\nassert (HINE : E' h) by (apply ENUM; ins; eauto).\nassert (NINE : ~E h) by (apply ENUM; ins; eauto).\nassert (HNINIT : ~is_init h).\napply (SubToFullExecInternal.diff_no_init PFX ENUM).\nbasic_solver.\nassert (HTID : tid h <> tid_init).\napply ENUM.\nbasic_solver.\nassert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt [])","proofString":"assert (FULL : E ≡₁ E').\nrewrite set_union_minus with (s := E') (s' := E)           by apply PFX.\nrewrite (SubToFullExecInternal.diff_elems ENUM).\nbasic_solver.\narewrite (X = X'); [| apply rt_refl].\narewrite (X = {| WCore.G := G; WCore.sc := sc; |}); [destruct X; ins |].\narewrite (X' = {| WCore.G := G'; WCore.sc := sc'; |}); [destruct X'; ins |].\nrewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) : E ≡₁ E'.","conclusion":"E ≡₁ E'","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt [])","proofString":"rewrite set_union_minus with (s := E') (s' := E)           by apply PFX.\nrewrite (SubToFullExecInternal.diff_elems ENUM).\nbasic_solver."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) : E ≡₁ E' \\₁ E ∪₁ E.","conclusion":"E ≡₁ E' \\₁ E ∪₁ E","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt [])","proofString":"rewrite (SubToFullExecInternal.diff_elems ENUM).\nbasic_solver."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) : E ≡₁ (fun x : actid => In x []) ∪₁ E.","conclusion":"E ≡₁ (fun x : actid => In x []) ∪₁ E","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt [])","proofString":"basic_solver."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E') : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E')","proofString":"arewrite (X = X'); [| apply rt_refl].\narewrite (X = {| WCore.G := G; WCore.sc := sc; |}); [destruct X; ins |].\narewrite (X' = {| WCore.G := G'; WCore.sc := sc'; |}); [destruct X'; ins |].\nrewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E') : X = X'.","conclusion":"X = X'","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E')","proofString":"arewrite (X = {| WCore.G := G; WCore.sc := sc; |}); [destruct X; ins |].\narewrite (X' = {| WCore.G := G'; WCore.sc := sc'; |}); [destruct X'; ins |].\nrewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E') : {| WCore.G := G; WCore.sc := sc |} = X'.","conclusion":"{| WCore.G := G; WCore.sc := sc |} = X'","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E')","proofString":"arewrite (X' = {| WCore.G := G'; WCore.sc := sc'; |}); [destruct X'; ins |].\nrewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E') : {| WCore.G := G; WCore.sc := sc |} = {| WCore.G := G'; WCore.sc := sc' |}.","conclusion":"{| WCore.G := G; WCore.sc := sc |} = {| WCore.G := G'; WCore.sc := sc' |}","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E')","proofString":"rewrite prefix_full_G with (X' := X'); ins.\nrewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E') : {| WCore.G := G'; WCore.sc := sc |} = {| WCore.G := G'; WCore.sc := sc' |}.","conclusion":"{| WCore.G := G'; WCore.sc := sc |} = {| WCore.G := G'; WCore.sc := sc' |}","hypotheses":"(WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt []) (FULL : E ≡₁ E')","proofString":"rewrite prefix_full_sc with (X' := X'); ins."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t))","proofString":"assert (HINE : E' h) by (apply ENUM; ins; eauto).\nassert (NINE : ~E h) by (apply ENUM; ins; eauto).\nassert (HNINIT : ~is_init h).\napply (SubToFullExecInternal.diff_no_init PFX ENUM).\nbasic_solver.\nassert (HTID : tid h <> tid_init).\napply ENUM.\nbasic_solver.\nassert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h)","proofString":"assert (NINE : ~E h) by (apply ENUM; ins; eauto).\nassert (HNINIT : ~is_init h).\napply (SubToFullExecInternal.diff_no_init PFX ENUM).\nbasic_solver.\nassert (HTID : tid h <> tid_init).\napply ENUM.\nbasic_solver.\nassert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h)","proofString":"assert (HNINIT : ~is_init h).\napply (SubToFullExecInternal.diff_no_init PFX ENUM).\nbasic_solver.\nassert (HTID : tid h <> tid_init).\napply ENUM.\nbasic_solver.\nassert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) : ~ is_init h.","conclusion":"~ is_init h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h)","proofString":"apply (SubToFullExecInternal.diff_no_init PFX ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) : (E' \\₁ E) h.","conclusion":"(E' \\₁ E) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h)","proofString":"assert (HTID : tid h <> tid_init).\napply ENUM.\nbasic_solver.\nassert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) : tid h <> tid_init.","conclusion":"tid h <> tid_init","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h)","proofString":"apply ENUM.\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) : (E' \\₁ E) h.","conclusion":"(E' \\₁ E) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"assert (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘).\narewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf.\nassert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"arewrite (sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) at 1.\nrewrite set_compl_union_id.\nbasic_solver.\nrewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"sb' ⨾ ⦗eq h⦘ ⊆ ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"rewrite set_compl_union_id.\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : sb' ⨾ ⦗eq h⦘ ⊆ ⦗⊤₁⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"sb' ⨾ ⦗eq h⦘ ⊆ ⦗⊤₁⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : ⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"⦗E ∪₁ set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"rewrite id_union, seq_union_l.\napply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ∪ ⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ∪ ⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"apply inclusion_union_l; ins.\narewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : ⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘.","conclusion":"⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"arewrite (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂); [| basic_solver].\nintros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) : ⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂.","conclusion":"⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘ ⊆ ∅₂","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init)","proofString":"intros x y HREL.\neapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y) : False.","conclusion":"False","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y)","proofString":"eapply list_min_elt with (b := x); [apply ENUM |].\napply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y) : total_order_from_list (h :: t) x h.","conclusion":"total_order_from_list (h :: t) x h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y)","proofString":"apply (SubToFullExecInternal.diff_sb ENUM).\nunfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y) : restr_rel (E' \\₁ E) sb' x h.","conclusion":"restr_rel (E' \\₁ E) sb' x h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ sb' ⨾ ⦗eq h⦘) x y)","proofString":"unfold sb in *.\nunfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq h⦘) x y) : restr_rel (E' \\₁ E) (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) x h.","conclusion":"restr_rel (E' \\₁ E) (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) x h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq h⦘) x y)","proofString":"unfolder.\nunfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq h⦘) x y) : (E' x /\\ ext_sb x h /\\ E' h) /\\ (E' x /\\ ~ E x) /\\ E' h /\\ ~ E h.","conclusion":"(E' x /\\ ext_sb x h /\\ E' h) /\\ (E' x /\\ ~ E x) /\\ E' h /\\ ~ E h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : (⦗set_compl E⦘ ⨾ (⦗E'⦘ ⨾ ext_sb ⨾ ⦗E'⦘) ⨾ ⦗eq h⦘) x y)","proofString":"unfolder in HREL.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : ~ E x /\\\n(exists z : actid,\n   (x = z /\\ E' x) /\\ (exists z0 : actid, ext_sb z z0 /\\ z0 = y /\\ E' z0)) /\\\nh = y) : (E' x /\\ ext_sb x h /\\ E' h) /\\ (E' x /\\ ~ E x) /\\ E' h /\\ ~ E h.","conclusion":"(E' x /\\ ext_sb x h /\\ E' h) /\\ (E' x /\\ ~ E x) /\\ E' h /\\ ~ E h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (x y : actid) (HREL : ~ E x /\\\n(exists z : actid,\n   (x = z /\\ E' x) /\\ (exists z0 : actid, ext_sb z z0 /\\ z0 = y /\\ E' z0)) /\\\nh = y)","proofString":"desf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"assert (STEP : WCore.guided_step cmt X' X (delta_X h)).\nexists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf.\nassert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : WCore.guided_step cmt X' X (delta_X h).","conclusion":"WCore.guided_step cmt X' X (delta_X h)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"exists h, (lab' h).\napply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : WCore.guided_step_gen cmt X' X (delta_X h) h (lab' h).","conclusion":"WCore.guided_step_gen cmt X' X (delta_X h) h (lab' h)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"apply SubToFullExecInternal.delta_guided_add_step; ins.\nsin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver.\ndestruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : ⦗eq h⦘ ⨾ sb' ⨾ ⦗E⦘ ⊆ ∅₂.","conclusion":"⦗eq h⦘ ⨾ sb' ⨾ ⦗E⦘ ⊆ ∅₂","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"sin_rewrite (prf_sb PFX).\nunfold sb.\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : ⦗eq h⦘ ⨾ sb ⊆ ∅₂.","conclusion":"⦗eq h⦘ ⨾ sb ⊆ ∅₂","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"unfold sb.\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : ⦗eq h⦘ ⨾ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ⊆ ∅₂.","conclusion":"⦗eq h⦘ ⨾ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘ ⊆ ∅₂","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) : eq h ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt.","conclusion":"eq h ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘)","proofString":"destruct (classic (cmt h)) as [CMT|NCMT]; [basic_solver |].\nintros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) : eq h ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt.","conclusion":"eq h ∩₁ (fun a : actid => R' a) ⊆₁ codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h)","proofString":"intros h' (HIR & EQH).\nsubst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (h' : actid) (HIR : h = h') (EQH : R' h') : (codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h'.","conclusion":"(codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (h' : actid) (HIR : h = h') (EQH : R' h')","proofString":"subst h'.\ndestruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) : (codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h.","conclusion":"(codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h)","proofString":"destruct (SubToFullExecInternal.diff_rf_d ENUM) with (x := h)          as (w & RF).\nbasic_solver.\nleft.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) : ((E' \\₁ E) ∩₁ (fun x : actid => R' x)) h.","conclusion":"((E' \\₁ E) ∩₁ (fun x : actid => R' x)) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) : (codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h.","conclusion":"(codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) ∪₁ cmt) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h)","proofString":"left.\nexists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) : codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) h.","conclusion":"codom_rel (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h)","proofString":"exists w.\nunfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) : (⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) w h.","conclusion":"(⦗E⦘ ⨾ rf' ⨾ ⦗eq h⦘) w h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h)","proofString":"unfolder; splits; ins.\ndestruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) : E w.","conclusion":"E w","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h)","proofString":"destruct (classic (E w)) as [WINE|WNINE]; ins.\nexfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w) : E w.","conclusion":"E w","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w)","proofString":"exfalso.\neapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w) : False.","conclusion":"False","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w)","proofString":"eapply list_min_elt with (b := w); [apply ENUM |].\napply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w) : total_order_from_list (h :: t) w h.","conclusion":"total_order_from_list (h :: t) w h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w)","proofString":"apply (SubToFullExecInternal.diff_rf ENUM).\nunfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w) : restr_rel (E' \\₁ E) (rf' ⨾ ⦗E' \\₁ cmt⦘) w h.","conclusion":"restr_rel (E' \\₁ E) (rf' ⨾ ⦗E' \\₁ cmt⦘) w h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w)","proofString":"unfolder; splits; ins.\napply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w) : E' w.","conclusion":"E' w","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : rf' w h) (WNINE : ~ E w)","proofString":"apply (wf_rfE WF) in RF.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) w h) (WNINE : ~ E w) : E' w.","conclusion":"E' w","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (RF : (⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) w h) (WNINE : ~ E w)","proofString":"unfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (WNINE : ~ E w) (RF : E' w /\\ rf' w h /\\ E' h) : E' w.","conclusion":"E' w","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (NCMT : ~ cmt h) (EQH : R' h) (w : actid) (WNINE : ~ E w) (RF : E' w /\\ rf' w h /\\ E' h)","proofString":"desf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h))","proofString":"assert (NDELTA : forall x (NDELTA : ~delta_E h x), ~E x).\nunfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto.\neapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) : forall x : actid, ~ delta_E h x -> ~ E x.","conclusion":"forall x : actid, ~ delta_E h x -> ~ E x","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h))","proofString":"unfold SubToFullExecInternal.delta_E.\nunfolder.\nrepeat intros; eauto."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) : forall x : actid, ~ (E ∪₁ eq h) x -> ~ E x.","conclusion":"forall x : actid, ~ (E ∪₁ eq h) x -> ~ E x","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h))","proofString":"unfolder.\nrepeat intros; eauto."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) : forall x : actid, ~ (E x \\/ h = x) -> ~ E x.","conclusion":"forall x : actid, ~ (E x \\/ h = x) -> ~ E x","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h))","proofString":"repeat intros; eauto."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"eapply rt_trans; [apply rt_step; eauto |].\napply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (WCore.guided_step cmt X')＊ (delta_X h) X'.","conclusion":"(WCore.guided_step cmt X')＊ (delta_X h) X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"apply IHl.\nred in STEP; desf; apply STEP.\napply SubToFullExecInternal.delta_G_prefix; ins.\nconstructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : WCore.wf (delta_X h) X' cmt.","conclusion":"WCore.wf (delta_X h) X' cmt","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"red in STEP; desf; apply STEP."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : prefix (delta_X h) X'.","conclusion":"prefix (delta_X h) X'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"apply SubToFullExecInternal.delta_G_prefix; ins."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : SubToFullExecInternal.enumd_diff (delta_X h) X' cmt t.","conclusion":"SubToFullExecInternal.enumd_diff (delta_X h) X' cmt t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"constructor; ins.\neapply nodup_consD, ENUM.\narewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l.\nrewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf.\nunfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf.\nrewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : NoDup t.","conclusion":"NoDup t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"eapply nodup_consD, ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : E' \\₁ delta_E h ≡₁ (fun x : actid => In x t).","conclusion":"E' \\₁ delta_E h ≡₁ (fun x : actid => In x t)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"arewrite ((fun x => In x t) ≡₁ (fun x => In x (h :: t)) \\₁ eq h).\nsplit; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM.\nunfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (fun x : actid => In x t) ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h.","conclusion":"(fun x : actid => In x t) ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"split; [| basic_solver].\nunfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (fun x : actid => In x t) ⊆₁ (fun x : actid => In x (h :: t)) \\₁ eq h.","conclusion":"(fun x : actid => In x t) ⊆₁ (fun x : actid => In x (h :: t)) \\₁ eq h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"unfolder; ins.\nsplit; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t) : (h = x \\/ In x t) /\\ h <> x.","conclusion":"(h = x \\/ In x t) /\\ h <> x","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t)","proofString":"split; eauto.\napply nodup_not_in with (t := t); ins.\napply ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t) : h <> x.","conclusion":"h <> x","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t)","proofString":"apply nodup_not_in with (t := t); ins.\napply ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t) : NoDup (h :: t).","conclusion":"NoDup (h :: t)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x : actid) (H : In x t)","proofString":"apply ENUM."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : E' \\₁ delta_E h ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h.","conclusion":"E' \\₁ delta_E h ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"unfold SubToFullExecInternal.delta_E.\nnow rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : E' \\₁ (E ∪₁ eq h) ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h.","conclusion":"E' \\₁ (E ∪₁ eq h) ≡₁ (fun x : actid => In x (h :: t)) \\₁ eq h","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"now rewrite <- (SubToFullExecInternal.diff_elems ENUM),            set_minus_minus_l."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : E' \\₁ delta_E h ⊆₁ (fun x : actid => tid x <> tid_init).","conclusion":"E' \\₁ delta_E h ⊆₁ (fun x : actid => tid x <> tid_init)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"rewrite <- (SubToFullExecInternal.diff_elemst ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : E' \\₁ delta_E h ⊆₁ E' \\₁ E.","conclusion":"E' \\₁ delta_E h ⊆₁ E' \\₁ E","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"basic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel (E' \\₁ delta_E h) sb' ⊆ total_order_from_list t.","conclusion":"restr_rel (E' \\₁ delta_E h) sb' ⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"unfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel (E' \\₁ (E ∪₁ eq h)) sb' ⊆ total_order_from_list t.","conclusion":"restr_rel (E' \\₁ (E ∪₁ eq h)) sb' ⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"rewrite set_minus_union_r.\nintros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' ⊆ total_order_from_list t.","conclusion":"restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' ⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"intros x y SB.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y)","proofString":"assert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB.\napply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) : total_order_from_list (h :: t) x y.","conclusion":"total_order_from_list (h :: t) x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y)","proofString":"eapply SubToFullExecInternal.diff_sb; eauto.\nred.\nsplits; apply SB."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) : restr_rel (E' \\₁ E) sb' x y.","conclusion":"restr_rel (E' \\₁ E) sb' x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y)","proofString":"red.\nsplits; apply SB."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) : sb' x y /\\ (E' \\₁ E) x /\\ (E' \\₁ E) y.","conclusion":"sb' x y /\\ (E' \\₁ E) x /\\ (E' \\₁ E) y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y)","proofString":"splits; apply SB."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) (LT : total_order_from_list (h :: t) x y) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) sb' x y) (LT : total_order_from_list (h :: t) x y)","proofString":"apply total_order_from_list_cons in LT; desf.\nunfolder in SB.\ndesf."},{"statement":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq x)) sb' x y) (LT0 : In y t) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (SB : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq x)) sb' x y) (LT0 : In y t)","proofString":"unfolder in SB.\ndesf."},{"statement":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (SB : sb' x y /\\\n((E' x /\\ ~ E x) /\\ E' x /\\ x <> x) /\\ (E' y /\\ ~ E y) /\\ E' y /\\ x <> y) (LT0 : In y t) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (SB : sb' x y /\\\n((E' x /\\ ~ E x) /\\ E' x /\\ x <> x) /\\ (E' y /\\ ~ E y) /\\ E' y /\\ x <> y) (LT0 : In y t)","proofString":"desf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel (E' \\₁ delta_E h) (rf' ⨾ ⦗E' \\₁ cmt⦘) ⊆ total_order_from_list t.","conclusion":"restr_rel (E' \\₁ delta_E h) (rf' ⨾ ⦗E' \\₁ cmt⦘) ⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"unfold SubToFullExecInternal.delta_E.\nrewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel (E' \\₁ (E ∪₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) ⊆ total_order_from_list t.","conclusion":"restr_rel (E' \\₁ (E ∪₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) ⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"rewrite set_minus_union_r.\nintros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘)\n⊆ total_order_from_list t.","conclusion":"restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘)\n⊆ total_order_from_list t","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"intros x y RF.\nassert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y)","proofString":"assert (LT : total_order_from_list (h :: t) x y).\neapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF.\napply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) : total_order_from_list (h :: t) x y.","conclusion":"total_order_from_list (h :: t) x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y)","proofString":"eapply SubToFullExecInternal.diff_rf; eauto.\nred.\nsplits; apply RF."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) : restr_rel (E' \\₁ E) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y.","conclusion":"restr_rel (E' \\₁ E) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y)","proofString":"red.\nsplits; apply RF."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) : (rf' ⨾ ⦗E' \\₁ cmt⦘) x y /\\ (E' \\₁ E) x /\\ (E' \\₁ E) y.","conclusion":"(rf' ⨾ ⦗E' \\₁ cmt⦘) x y /\\ (E' \\₁ E) x /\\ (E' \\₁ E) y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y)","proofString":"splits; apply RF."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) (LT : total_order_from_list (h :: t) x y) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x0 : actid, ~ delta_E h x0 -> ~ E x0) (x y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq h)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) (LT : total_order_from_list (h :: t) x y)","proofString":"apply total_order_from_list_cons in LT; desf.\nunfolder in RF.\ndesf."},{"statement":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq x)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) (LT0 : In y t) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (RF : restr_rel ((E' \\₁ E) ∩₁ (E' \\₁ eq x)) (rf' ⨾ ⦗E' \\₁ cmt⦘) x y) (LT0 : In y t)","proofString":"unfolder in RF.\ndesf."},{"statement":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (LT0 : In y t) (RF : (rf' x y /\\ E' y /\\ ~ cmt y) /\\\n((E' x /\\ ~ E x) /\\ E' x /\\ x <> x) /\\ (E' y /\\ ~ E y) /\\ E' y /\\ x <> y) : total_order_from_list t x y.","conclusion":"total_order_from_list t x y","hypotheses":"(t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (x : actid) (NDELTA : forall x0 : actid, ~ delta_E x x0 -> ~ E x0) (STEP : WCore.guided_step cmt X' X (delta_X x)) (HMAX : sb' ⨾ ⦗eq x⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq x⦘) (HTID : tid x <> tid_init) (HNINIT : ~ is_init x) (NINE : ~ E x) (HINE : E' x) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (x :: t)) (y : actid) (LT0 : In y t) (RF : (rf' x y /\\ E' y /\\ ~ cmt y) /\\\n((E' x /\\ ~ E x) /\\ E' x /\\ x <> x) /\\ (E' y /\\ ~ E y) /\\ E' y /\\ x <> y)","proofString":"desf."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (E' \\₁ delta_E h) ∩₁ (fun x : actid => R' x) ⊆₁ codom_rel rf'.","conclusion":"(E' \\₁ delta_E h) ∩₁ (fun x : actid => R' x) ⊆₁ codom_rel rf'","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"rewrite <- (SubToFullExecInternal.diff_rf_d ENUM).\nbasic_solver."},{"statement":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x) : (E' \\₁ delta_E h) ∩₁ (fun x : actid => R' x)\n⊆₁ (E' \\₁ E) ∩₁ (fun x : actid => R' x).","conclusion":"(E' \\₁ delta_E h) ∩₁ (fun x : actid => R' x)\n⊆₁ (E' \\₁ E) ∩₁ (fun x : actid => R' x)","hypotheses":"(h : actid) (t : list actid) (WF : Wf G') (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (WF' : WCore.wf X' X' cmt) (IHl : forall X0 : WCore.t,\nWCore.wf X0 X' cmt ->\nprefix X0 X' ->\nSubToFullExecInternal.enumd_diff X0 X' cmt t ->\n(WCore.guided_step cmt X')＊ X0 X') (XWF : WCore.wf X X' cmt) (PFX : prefix X X') (ENUM : SubToFullExecInternal.enumd_diff X X' cmt (h :: t)) (HINE : E' h) (NINE : ~ E h) (HNINIT : ~ is_init h) (HTID : tid h <> tid_init) (HMAX : sb' ⨾ ⦗eq h⦘ ⊆ ⦗E⦘ ⨾ sb' ⨾ ⦗eq h⦘) (STEP : WCore.guided_step cmt X' X (delta_X h)) (NDELTA : forall x : actid, ~ delta_E h x -> ~ E x)","proofString":"basic_solver."},{"statement":"(XWF : WCore.wf X X' cmt) (RFCO : rf_complete G') (CONS : WCore.is_cons G') (FIN : set_finite (E' \\₁ E)) (PFX : prefix X X') (WF : Wf G') (NTID : E' \\₁ E ⊆₁ (fun x : actid => tid x <> tid_init)) (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) (l : list actid) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l) : (WCore.guided_step cmt X')＊ X X'.","conclusion":"(WCore.guided_step cmt X')＊ X X'","hypotheses":"(XWF : WCore.wf X X' cmt) (RFCO : rf_complete G') (CONS : WCore.is_cons G') (FIN : set_finite (E' \\₁ E)) (PFX : prefix X X') (WF : Wf G') (NTID : E' \\₁ E ⊆₁ (fun x : actid => tid x <> tid_init)) (NDATA : data' ⊆ ∅₂) (NADDR : addr' ⊆ ∅₂) (NCTRL : ctrl' ⊆ ∅₂) (NRMWDEP : rmw_dep' ⊆ ∅₂) (STAB : WCore.stable_uncmt_reads_gen X' cmt thrdle) (l : list actid) (ENUM : SubToFullExecInternal.enumd_diff X X' cmt l)","proofString":"apply sub_to_full_exec with l; ins."}]}