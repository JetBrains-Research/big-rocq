[{"statement":"Lemma IN_I: I ⊆₁ E ∩₁ W.","proof":"rewrite <- IT; basic_solver 21.\n"},{"statement":"Lemma IN_T: T ⊆₁ E ∩₁ W.","proof":"rewrite <- IT; basic_solver 21.\n"},{"statement":"Lemma col_in_co l : col l ⊆ co.","proof":"unfold col; basic_solver.\n"},{"statement":"Lemma co_in_col x y : co x y -> exists l, col l x y.","proof":"unfold new_co, col; ins; unfolder; ins; desf.\nhahn_rewrite (dom_l wf_coD) in H; unfolder in H; desc.\ngeneralize (is_w_loc lab x H); ins; desf.\neexists; splits; eauto.\neexists; splits; eauto.\neexists; splits; eauto.\napply wf_col in H0; unfold Events.same_loc in H0; congruence.\n"},{"statement":"Lemma wf_colE l : col l ≡ ⦗E⦘ ⨾ col l ⨾ ⦗E⦘.","proof":"apply dom_helper_3; unfold col; rewrite wf_coE; basic_solver.\n"},{"statement":"Lemma wf_colD l : col l ≡ ⦗W_ l⦘ ⨾ col l ⨾ ⦗W_ l⦘.","proof":"apply dom_helper_3; unfold col; rewrite wf_coD; basic_solver.\n"},{"statement":"Lemma wf_coll l : col l ⊆ same_loc.","proof":"unfold col; rewrite wf_col; basic_solver.\n"},{"statement":"Lemma col_trans l : transitive (col l).","proof":"unfold col.\nrewrite <- restr_relE.\nby apply transitive_restr.\n"},{"statement":"Lemma wf_col_total l : is_total (E ∩₁ W ∩₁ Loc_ l) (col l).","proof":"rewrite wf_colD, wf_colE.\nunfold col; rewrite !seqA.\narewrite (⦗W_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗Loc_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\narewrite (⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\nrewrite <- restr_relE.\napply is_total_restr.\napply wf_co_total.\n"},{"statement":"Lemma col_irr l: irreflexive (col l).","proof":"unfold col.\nrewrite <- restr_relE.\nby apply irreflexive_restr.\n"},{"statement":"Lemma acyclic_new_col l : acyclic (new_col l).","proof":"eapply acyclic_pref_union with (dom:=I ∩₁ Loc_ l).\n- unfold col0.\narewrite_id ⦗I⦘.\narewrite_id ⦗T⦘.\nrelsf.\ngeneralize (@col_trans l); ins; relsf; apply col_irr.\n- unfold col0; relsf.\n- assert (XX: restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l).\nby unfold col0; rewrite <- ct_step; basic_solver 21.\nrewrite <- XX.\napply is_total_restr.\nrewrite IN_I.\neapply wf_col_total.\n- unfolder; ins; desf; splits; eauto; intro; desf.\n"},{"statement":"Lemma wf_new_colE l : new_col l ≡ ⦗E⦘ ⨾ new_col l ⨾ ⦗E⦘.","proof":"apply dom_helper_3.\nunfold new_col, pref_union, col0; unfolder; ins; desf.\n2: by generalize (IN_I H); basic_solver 12.\ninduction H; [|basic_solver].\ndesf; apply (wf_colE l) in H0; unfolder in H0; desf; eauto.\n"},{"statement":"Lemma wf_new_colD l : new_col l ≡ ⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘.","proof":"apply dom_helper_3.\nunfold new_col, pref_union, col0; unfolder; ins; desf.\n2: by generalize (IN_I H); basic_solver 12.\ninduction H; [|basic_solver].\ndesf; apply (wf_colD l) in H0; unfolder in H0; desf; eauto.\n"},{"statement":"Lemma wf_new_coll l : new_col l ⊆ same_loc.","proof":"rewrite wf_new_colD; unfold Events.same_loc.\nunfolder; ins; desf; congruence.\n"},{"statement":"Lemma wf_new_col_total l : is_total (E ∩₁ W ∩₁ Loc_ l) (new_col l).","proof":"unfold new_col, pref_union.\nunfolder; ins; desf.\ndestruct (classic (col0 l a b)) as [|X]; eauto 8.\ndestruct (classic (col0 l b a)) as [|Y]; eauto 8.\nassert (XX: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b).\nby intro; eapply X; vauto.\nassert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\n- exfalso; unfolder in XX; basic_solver 22.\n- exfalso; unfolder in YY; basic_solver 22.\n- exfalso; unfolder in XX; basic_solver 22.\n- eauto 20.\n- eauto 20.\n- exfalso; unfolder in YY; basic_solver 22.\n- exfalso; unfolder in XX; basic_solver 22.\n- exfalso; unfolder in YY; basic_solver 22.\n"},{"statement":"Lemma new_col_trans l : transitive (new_col l).","proof":"apply transitiveI; unfolder; ins; desf.\neapply tot_ex.\n- apply wf_new_col_total.\n- hahn_rewrite wf_new_colE in H0.\nhahn_rewrite wf_new_colD in H0.\nunfolder in H0; basic_solver 21.\n- hahn_rewrite wf_new_colE in H.\nhahn_rewrite wf_new_colD in H.\nunfolder in H; basic_solver 21.\n- intro.\neapply acyclic_new_col.\neapply t_trans, t_trans; vauto.\n- intro.\neapply acyclic_new_col.\neapply t_trans; vauto.\n"},{"statement":"Lemma new_col_irr l : irreflexive (new_col l).","proof":"red; ins; eapply acyclic_new_col; vauto.\n"},{"statement":"Lemma wf_new_coE : new_co ≡ ⦗E⦘ ⨾ new_co ⨾ ⦗E⦘.","proof":"unfold new_co; unfolder; ins; desf; splits; ins; desf; eauto.\napply (wf_new_colE l) in H; unfolder in H; desf; eauto.\n"},{"statement":"Lemma wf_new_coD : new_co ≡ ⦗W⦘ ⨾ new_co ⨾ ⦗W⦘.","proof":"unfold new_co; unfolder; ins; desf; splits; ins; desf; eauto.\napply (wf_new_colD l) in H; unfolder in H; desf; eauto.\n"},{"statement":"Lemma wf_new_col : new_co ⊆ same_loc.","proof":"unfold new_co; unfolder; ins; desf; splits; ins; desf; eauto.\napply (@wf_new_coll l) in H; unfolder in H; desf; eauto.\n"},{"statement":"Lemma new_co_trans : transitive new_co.","proof":"unfold new_co; unfolder; ins; desf; splits; ins; desf; eauto.\nhahn_rewrite wf_new_colD in H0.\nhahn_rewrite wf_new_colD in H.\nunfolder in H0; unfolder in H; desf.\nexists l; eapply new_col_trans; eauto.\n"},{"statement":"Lemma wf_new_co_total : forall ol, is_total (E ∩₁ W ∩₁ (fun x => loc x = ol)) new_co.","proof":"unfold new_co; ins; unfolder; ins; desf.\ngeneralize (is_w_loc lab a IWa1); ins; desf.\ncut (new_col l a b \\/ new_col l b a); [by basic_solver 21|].\napply wf_new_col_total; auto.\nbasic_solver.\nunfolder; splits; ins; desf; congruence.\n"},{"statement":"Lemma new_co_irr : irreflexive new_co.","proof":"unfold new_co; ins; unfolder; ins; desf.\neapply new_col_irr; eauto.\n"},{"statement":"Lemma new_co_I : new_co ⨾ ⦗ I ⦘  ⊆ co ⨾ ⦗ I ⦘.","proof":"unfolder; intros x y [R K]; desf.\nunfold new_co in R; desc.\nhahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\n- apply wf_co_total.\n- basic_solver.\n- unfolder; splits; eauto; congruence.\n- intro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\n* eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\n* eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\n- intro; subst.\neby eapply new_col_irr.\n"},{"statement":"Lemma T_new_co : ⦗ T ⦘ ⨾ new_co  ⊆ ⦗ T ⦘ ⨾ co.","proof":"unfolder; intros x y [K1 R]; desf.\nunfold new_co in R; desc.\nhahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\n- apply wf_co_total.\n- basic_solver.\n- unfolder; splits; eauto; congruence.\n- intro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\n* eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\n* eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\n- intro; subst.\neby eapply new_col_irr.\n"},{"statement":"Lemma new_co_in : new_co  ⊆ co ⨾ ⦗ I ⦘ ∪ \n⦗ T ⦘ ⨾ co ∪ ⦗ I \\₁ T ⦘ ⨾ new_co ⨾ ⦗ T \\₁ I ⦘.","proof":"rewrite (wf_new_coD), (wf_new_coE) at 1.\nrewrite !seqA.\narewrite (⦗W⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\narewrite (⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\nrewrite <- IT.\narewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21.\n"},{"statement":"Lemma T_I_col0_I_T l : \n  ⦗ T \\₁ I ⦘ ⨾ col0 l ⨾ ⦗ I \\₁ T ⦘  ⊆ \n  ⦗ T \\₁ I ⦘ ⨾ col l ⨾ ⦗ I ∩₁ T ⦘ ⨾ col l ⨾ ⦗ I \\₁ T ⦘.","proof":"unfold col0 at 1.\narewrite (⦗T⦘ ⊆ ⦗T \\₁ I⦘ ∪ ⦗I ∩₁ T⦘) at 2.\nunfolder; ins ;desf; tauto.\nrelsf.\nrewrite <- !unionA.\nrewrite unionC.\nrewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\n- transitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\n- arewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21.\n"},{"statement":"Lemma T_I_new_col_I_T l : \n  ⦗ T \\₁ I ⦘ ⨾ new_col l ⨾ ⦗ I \\₁ T ⦘  ⊆ \n  col l ⨾ ⦗ I ∩₁ T ⦘ ⨾ col l.","proof":"unfold new_col, pref_union.\nunfolder; ins; desf.\nassert (A: (⦗ T \\₁ I ⦘ ⨾ col0 l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_col0_I_T in A; unfolder in A; basic_solver 10.\n"},{"statement":"Lemma T_I_new_co_I_T : \n  ⦗ T \\₁ I ⦘ ⨾ new_co ⨾ ⦗ I \\₁ T ⦘  ⊆ \n  co ⨾ ⦗ I ∩₁ T ⦘ ⨾ co.","proof":"clear wf_coD wf_coE.\nunfold new_co.\nunfolder; ins; desf.\nassert (A: (⦗ T \\₁ I ⦘ ⨾ new_col l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_new_col_I_T in A; unfolder in A; desf.\nunfold col in *; unfolder in *; desf; eauto 10.\n"},{"statement":"Lemma co_for_split: codom_rel (⦗set_compl I⦘ ⨾ (immediate new_co)) ⊆₁ T.","proof":"unfolder; ins; desf.\ndestruct (classic (T x)) as [|X]; auto.\nexfalso.\nhahn_rewrite wf_new_coE in H0.\nhahn_rewrite wf_new_coD in H0.\nunfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12.\n"},{"statement":"Lemma new_col_helper l : ⦗ T ⦘ ⨾ col l ⨾ ⦗ I ∩₁ T ⦘ ⨾ col l ⨾ ⦗ I ⦘ ⊆ new_col l.","proof":"unfold new_col, pref_union, col0.\nunfolder; ins; left; desf.\neapply t_trans; apply t_step; eauto 15.\n"},{"statement":"Lemma new_co_helper : ⦗ T ⦘ ⨾ co ⨾ ⦗ I ∩₁ T ⦘ ⨾ co ⨾ ⦗ I ⦘ ⊆ new_co.","proof":"clear wf_coE.\nunfold new_co.\nunfolder; ins; desf.\napply co_in_col in H0.\napply co_in_col in H2.\ndesf.\nassert (l = l0); subst.\n{\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\n}\nexists l0.\napply new_col_helper.\nbasic_solver 12.\n"},{"statement":"Lemma I_co_in_new_co : ⦗ I ⦘ ⨾ co ⊆ new_co.","proof":"unfold new_co.\nunfolder; ins; desf.\napply co_in_col in H0.\ndesf.\nexists l.\nunfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf.\n"}]