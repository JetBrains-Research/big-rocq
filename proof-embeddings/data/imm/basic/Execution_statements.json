{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/basic/Execution.v","fileSamples":[{"statement":"(x y z : actid) (H : E x) (H3 : ext_sb x y) (H4 H0 : E y) (H1 : ext_sb y z) (H2 : E z) : ext_sb x z.","proofString":"eby eapply ext_sb_trans."},{"statement":"sb ∩ same_loc ⨾ sb ∩ same_loc ⊆ sb ∩ same_loc.","proofString":"unfold Events.same_loc.\nunfolder; ins; desf; eauto.\nsplits.\ngeneralize sb_trans; basic_solver 21.\ncongruence."},{"statement":"sb ∩ (fun x y : actid => loc x = loc y)\n⨾ sb ∩ (fun x y : actid => loc x = loc y)\n⊆ sb ∩ (fun x y : actid => loc x = loc y).","proofString":"unfolder; ins; desf; eauto.\nsplits.\ngeneralize sb_trans; basic_solver 21.\ncongruence."},{"statement":"(x y z : actid) (H : sb x z) (H2 : loc x = loc z) (H0 : sb z y) (H1 : loc z = loc y) : sb x y /\\ loc x = loc y.","proofString":"splits.\ngeneralize sb_trans; basic_solver 21.\ncongruence."},{"statement":"(x y z : actid) (H : sb x z) (H2 : loc x = loc z) (H0 : sb z y) (H1 : loc z = loc y) : sb x y.","proofString":"generalize sb_trans; basic_solver 21."},{"statement":"(x y z : actid) (H : sb x z) (H2 : loc x = loc z) (H0 : sb z y) (H1 : loc z = loc y) : loc x = loc y.","proofString":"congruence."},{"statement":"(forall x y z : actid,\n (sb ∩ same_loc) x y -> (sb ∩ same_loc) y z -> (sb ∩ same_loc) x z) ->\nforall x y z : actid,\n(sb ∩ same_loc ⨾ ⦗W⦘) x y ->\n(sb ∩ same_loc ⨾ ⦗W⦘) y z -> (sb ∩ same_loc ⨾ ⦗W⦘) x z.","proofString":"basic_solver 21."},{"statement":"(FACQREL : E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a)) : E ∩₁ E ⊆₁ RW ∪₁ F ∩₁ (fun a : actid => Acq/Rel a).","proofString":"arewrite (E ⊆₁ R ∪₁ W ∪₁ F) at 2 by type_solver.\nrewrite set_inter_union_r.\ngeneralize FACQREL.\nclear.\nbasic_solver 10."},{"statement":"(FACQREL : E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a)) : E ∩₁ (RW ∪₁ F) ⊆₁ RW ∪₁ F ∩₁ (fun a : actid => Acq/Rel a).","proofString":"rewrite set_inter_union_r.\ngeneralize FACQREL.\nclear.\nbasic_solver 10."},{"statement":"(FACQREL : E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a)) : E ∩₁ RW ∪₁ E ∩₁ F ⊆₁ RW ∪₁ F ∩₁ (fun a : actid => Acq/Rel a).","proofString":"generalize FACQREL.\nclear.\nbasic_solver 10."},{"statement":"(FACQREL : E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a)) : E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a) ->\nE ∩₁ RW ∪₁ E ∩₁ F ⊆₁ RW ∪₁ F ∩₁ (fun a : actid => Acq/Rel a).","proofString":"clear.\nbasic_solver 10."},{"statement":"E ∩₁ F ⊆₁ (fun a : actid => Acq/Rel a) ->\nE ∩₁ RW ∪₁ E ∩₁ F ⊆₁ RW ∪₁ F ∩₁ (fun a : actid => Acq/Rel a).","proofString":"basic_solver 10."},{"statement":"(WF : Wf) : forall a b : actid, fr a b -> loc a = loc b.","proofString":"unfold fr; unfolder; ins; desf.\ngeneralize (loceq_co WF), (loceq_rf WF).\ntransitivity (loc z); [symmetry; eauto|eauto]."},{"statement":"(WF : Wf) (a b z : actid) (H : rf z a) (H0 : co z b) : loc a = loc b.","proofString":"generalize (loceq_co WF), (loceq_rf WF).\ntransitivity (loc z); [symmetry; eauto|eauto]."},{"statement":"(WF : Wf) (a b z : actid) (H : rf z a) (H0 : co z b) : funeq loc co -> funeq loc rf -> loc a = loc b.","proofString":"transitivity (loc z); [symmetry; eauto|eauto]."},{"statement":"(WF : Wf) : rf⁻¹ ⨾ co ⊆ same_loc.","proofString":"rewrite (wf_rfl WF), (wf_col WF).\nunfold Events.same_loc.\nunfolder; ins; desc; congruence."},{"statement":"(WF : Wf) : same_loc⁻¹ ⨾ same_loc ⊆ same_loc.","proofString":"unfold Events.same_loc.\nunfolder; ins; desc; congruence."},{"statement":"(WF : Wf) : (fun x y : actid => loc x = loc y)⁻¹ ⨾ (fun x y : actid => loc x = loc y)\n⊆ (fun x y : actid => loc x = loc y).","proofString":"unfolder; ins; desc; congruence."},{"statement":"sb ⊆ ⦗E⦘ ⨾ sb ⨾ ⦗E⦘.","proofString":"unfold sb; basic_solver 42."},{"statement":"(WF : Wf) : data ⊆ ⦗E⦘ ⨾ data ⨾ ⦗E⦘.","proofString":"arewrite (data ⊆ data ∩ data) at 1.\nrewrite (data_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : data ∩ data ⊆ ⦗E⦘ ⨾ data ⨾ ⦗E⦘.","proofString":"rewrite (data_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : sb ∩ data ⊆ ⦗E⦘ ⨾ data ⨾ ⦗E⦘.","proofString":"rewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ∩ data ⊆ ⦗E⦘ ⨾ data ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : addr ⊆ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘.","proofString":"arewrite (addr ⊆ addr ∩ addr) at 1.\nrewrite (addr_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : addr ∩ addr ⊆ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘.","proofString":"rewrite (addr_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : sb ∩ addr ⊆ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘.","proofString":"rewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ∩ addr ⊆ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : ctrl ⊆ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘.","proofString":"arewrite (ctrl ⊆ ctrl ∩ ctrl) at 1.\nrewrite (ctrl_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ctrl ∩ ctrl ⊆ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘.","proofString":"rewrite (ctrl_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : sb ∩ ctrl ⊆ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘.","proofString":"rewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ∩ ctrl ⊆ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : rmw_dep ⊆ ⦗E⦘ ⨾ rmw_dep ⨾ ⦗E⦘.","proofString":"arewrite (rmw_dep ⊆ rmw_dep ∩ rmw_dep) at 1.\nrewrite (rmw_dep_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : rmw_dep ∩ rmw_dep ⊆ ⦗E⦘ ⨾ rmw_dep ⨾ ⦗E⦘.","proofString":"rewrite (rmw_dep_in_sb WF) at 1.\nrewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : sb ∩ rmw_dep ⊆ ⦗E⦘ ⨾ rmw_dep ⨾ ⦗E⦘.","proofString":"rewrite wf_sbE at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ∩ rmw_dep ⊆ ⦗E⦘ ⨾ rmw_dep ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : deps ⊆ ⦗E⦘ ⨾ deps ⨾ ⦗E⦘.","proofString":"unfold deps.\nrewrite (wf_dataE WF) at 1.\nrewrite (wf_ctrlE WF) at 1.\nrewrite (wf_addrE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : data ∪ addr ∪ ctrl ⊆ ⦗E⦘ ⨾ (data ∪ addr ∪ ctrl) ⨾ ⦗E⦘.","proofString":"rewrite (wf_dataE WF) at 1.\nrewrite (wf_ctrlE WF) at 1.\nrewrite (wf_addrE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗E⦘ ⨾ data ⨾ ⦗E⦘ ∪ addr ∪ ctrl ⊆ ⦗E⦘ ⨾ (data ∪ addr ∪ ctrl) ⨾ ⦗E⦘.","proofString":"rewrite (wf_ctrlE WF) at 1.\nrewrite (wf_addrE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗E⦘ ⨾ data ⨾ ⦗E⦘ ∪ addr ∪ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ (data ∪ addr ∪ ctrl) ⨾ ⦗E⦘.","proofString":"rewrite (wf_addrE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗E⦘ ⨾ data ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ addr ⨾ ⦗E⦘ ∪ ⦗E⦘ ⨾ ctrl ⨾ ⦗E⦘\n⊆ ⦗E⦘ ⨾ (data ∪ addr ∪ ctrl) ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : rmw ⊆ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proofString":"arewrite (rmw ⊆ rmw ∩ rmw) at 1.\nrewrite (wf_rmwi WF) at 1.\narewrite (immediate sb ⊆ sb).\nrewrite wf_sbE.\nbasic_solver."},{"statement":"(WF : Wf) : rmw ∩ rmw ⊆ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proofString":"rewrite (wf_rmwi WF) at 1.\narewrite (immediate sb ⊆ sb).\nrewrite wf_sbE.\nbasic_solver."},{"statement":"(WF : Wf) : immediate sb ∩ rmw ⊆ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proofString":"arewrite (immediate sb ⊆ sb).\nrewrite wf_sbE.\nbasic_solver."},{"statement":"(WF : Wf) : sb ∩ rmw ⊆ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proofString":"rewrite wf_sbE.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ∩ rmw ⊆ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : fr ⊆ ⦗E⦘ ⨾ fr ⨾ ⦗E⦘.","proofString":"unfold fr.\nrewrite (wf_rfE WF) at 1.\nrewrite (wf_coE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : rf⁻¹ ⨾ co ⊆ ⦗E⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E⦘.","proofString":"rewrite (wf_rfE WF) at 1.\nrewrite (wf_coE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)⁻¹ ⨾ co ⊆ ⦗E⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E⦘.","proofString":"rewrite (wf_coE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)⁻¹ ⨾ ⦗E⦘ ⨾ co ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : fr ⊆ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘.","proofString":"unfold fr.\nrewrite (wf_rfD WF) at 1.\nrewrite (wf_coD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : rf⁻¹ ⨾ co ⊆ ⦗R⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗W⦘.","proofString":"rewrite (wf_rfD WF) at 1.\nrewrite (wf_coD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)⁻¹ ⨾ co ⊆ ⦗R⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗W⦘.","proofString":"rewrite (wf_coD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗W⦘ ⨾ rf ⨾ ⦗R⦘)⁻¹ ⨾ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ⊆ ⦗R⦘ ⨾ (rf⁻¹ ⨾ co) ⨾ ⦗W⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : deps ⊆ ⦗R⦘ ⨾ deps.","proofString":"unfold deps.\nrewrite (wf_dataD WF) at 1.\nrewrite (wf_ctrlD WF) at 1.\nrewrite (wf_addrD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : data ∪ addr ∪ ctrl ⊆ ⦗R⦘ ⨾ (data ∪ addr ∪ ctrl).","proofString":"rewrite (wf_dataD WF) at 1.\nrewrite (wf_ctrlD WF) at 1.\nrewrite (wf_addrD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗R⦘ ⨾ data ⨾ ⦗W⦘ ∪ addr ∪ ctrl ⊆ ⦗R⦘ ⨾ (data ∪ addr ∪ ctrl).","proofString":"rewrite (wf_ctrlD WF) at 1.\nrewrite (wf_addrD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗R⦘ ⨾ data ⨾ ⦗W⦘ ∪ addr ∪ ⦗R⦘ ⨾ ctrl ⊆ ⦗R⦘ ⨾ (data ∪ addr ∪ ctrl).","proofString":"rewrite (wf_addrD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗R⦘ ⨾ data ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ addr ⨾ ⦗RW⦘ ∪ ⦗R⦘ ⨾ ctrl\n⊆ ⦗R⦘ ⨾ (data ∪ addr ∪ ctrl).","proofString":"basic_solver."},{"statement":"(x : actid) (H : E x) (H0 : ext_sb x x) (H1 : E x) : False.","proofString":"eby eapply ext_sb_irr."},{"statement":"well_founded (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘).","proofString":"rewrite <- restr_relE.\neapply wf_mon; [by apply inclusion_restr| ].\napply Wf_nat.well_founded_lt_compat    with (f := fun (e: actid) => if e then 0 else index e + 1).\nintros x y SB.\ndestruct x, y; simpl in *; lia."},{"statement":"well_founded (restr_rel E ext_sb).","proofString":"eapply wf_mon; [by apply inclusion_restr| ].\napply Wf_nat.well_founded_lt_compat    with (f := fun (e: actid) => if e then 0 else index e + 1).\nintros x y SB.\ndestruct x, y; simpl in *; lia."},{"statement":"well_founded ext_sb.","proofString":"apply Wf_nat.well_founded_lt_compat    with (f := fun (e: actid) => if e then 0 else index e + 1).\nintros x y SB.\ndestruct x, y; simpl in *; lia."},{"statement":"forall x y : actid,\next_sb x y -> (if x then 0 else index x + 1) < (if y then 0 else index y + 1).","proofString":"intros x y SB.\ndestruct x, y; simpl in *; lia."},{"statement":"(x y : actid) (SB : ext_sb x y) : (if x then 0 else index x + 1) < (if y then 0 else index y + 1).","proofString":"destruct x, y; simpl in *; lia."},{"statement":"(WF : Wf) (x : actid) (H : is_init x) : is_w lab x.","proofString":"unfold is_init in *; destruct x; desf.\nspecialize (wf_init_lab WF l); unfold is_w; desf."},{"statement":"(WF : Wf) (l : location) (H : true) : is_w lab (InitEvent l).","proofString":"specialize (wf_init_lab WF l); unfold is_w; desf."},{"statement":"(WF : Wf) (x : actid) (H : is_init x) : Pln x.","proofString":"unfold is_init in *; destruct x; desf.\nspecialize (wf_init_lab WF l); unfold is_only_pln, Events.mod; desf."},{"statement":"(WF : Wf) (l : location) (H : true) : Pln (InitEvent l).","proofString":"specialize (wf_init_lab WF l); unfold is_only_pln, Events.mod; desf."},{"statement":"(WF : Wf) (a : actid) (A : R a \\/ F a) : (is_init a -> is_w lab a) -> ~ is_init a.","proofString":"type_solver."},{"statement":"sb ⊆ sb ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"unfold sb; rewrite ext_sb_to_non_init at 1; basic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ sb^? ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (sb ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ sb^? ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : rf ⊆ rf ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"rewrite (wf_rfD WF) at 1.\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ⦗W⦘ ⨾ rf ⨾ ⦗R⦘ ⊆ rf ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"generalize (read_or_fence_is_not_init WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : (forall a : actid, is_r lab a \\/ is_f lab a -> ~ is_init a) ->\n⦗W⦘ ⨾ rf ⨾ ⦗R⦘ ⊆ rf ⨾ ⦗fun x : actid => ~ is_init x⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : rmw ⊆ ⦗fun x : actid => ~ is_init x⦘ ⨾ rmw.","proofString":"rewrite (wf_rmwD WF).\ngeneralize (read_or_fence_is_not_init WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘ ⊆ ⦗fun x : actid => ~ is_init x⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘.","proofString":"generalize (read_or_fence_is_not_init WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : (forall a : actid, is_r lab a \\/ is_f lab a -> ~ is_init a) ->\n⦗R⦘ ⨾ rmw ⨾ ⦗W⦘ ⊆ ⦗fun x : actid => ~ is_init x⦘ ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : rmw\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"rewrite (rmw_from_non_init WF) at 1.\nrewrite <- seqA.\napply codom_rel_helper.\nrewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗fun x : actid => ~ is_init x⦘ ⨾ rmw\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘\n  ⨾ rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"rewrite <- seqA.\napply codom_rel_helper.\nrewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗fun x : actid => ~ is_init x⦘ ⨾ rmw\n⊆ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rmw)\n  ⨾ ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"apply codom_rel_helper.\nrewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"(WF : Wf) : codom_rel (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rmw)\n⊆₁ set_compl (fun a : actid => is_init a).","proofString":"rewrite (rmw_in_sb WF).\nrewrite no_sb_to_init.\nbasic_solver."},{"statement":"(WF : Wf) : codom_rel (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n⊆₁ set_compl (fun a : actid => is_init a).","proofString":"rewrite no_sb_to_init.\nbasic_solver."},{"statement":"(WF : Wf) : codom_rel\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sb ⨾ ⦗fun x : actid => ~ is_init x⦘)\n⊆₁ set_compl (fun a : actid => is_init a).","proofString":"basic_solver."},{"statement":"(WF : Wf) (l l0 : location) (A : is_init (InitEvent l)) (B : is_init (InitEvent l0)) (LOC : loc (InitEvent l) = loc (InitEvent l0)) : InitEvent l = InitEvent l0.","proofString":"cut (l = l0); [by ins; subst|].\nunfold Events.loc in LOC.\nrewrite (wf_init_lab WF l), (wf_init_lab WF l0) in LOC; desf."},{"statement":"(WF : Wf) (l l0 : location) (A : is_init (InitEvent l)) (B : is_init (InitEvent l0)) (LOC : loc (InitEvent l) = loc (InitEvent l0)) : l = l0.","proofString":"unfold Events.loc in LOC.\nrewrite (wf_init_lab WF l), (wf_init_lab WF l0) in LOC; desf."},{"statement":"(WF : Wf) (l l0 : location) (A : is_init (InitEvent l)) (B : is_init (InitEvent l0)) (LOC : match lab (InitEvent l) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend =\nmatch lab (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend) : l = l0.","proofString":"rewrite (wf_init_lab WF l), (wf_init_lab WF l0) in LOC; desf."},{"statement":"(WF : Wf) : (fun a : actid => Rel a) ⊆₁ set_compl (fun a : actid => Pln a).","proofString":"mode_solver."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init x) (NEQ : y <> z) (XZ : E x) (XZ0 : ext_sb x z) (XZ1 : E z) (XY : E x) (XY0 : ext_sb x y) (XY1 : E y) : (exists z0 : actid,\n   (y = z0 /\\ E y) /\\ (exists z1 : actid, ext_sb z0 z1 /\\ z1 = z /\\ E z1)) \\/\n(exists z0 : actid,\n   (z = z0 /\\ E z) /\\ (exists z1 : actid, ext_sb z0 z1 /\\ z1 = y /\\ E z1)).","proofString":"cut (ext_sb y z \\/ ext_sb z y); [basic_solver 12|].\neapply ext_sb_semi_total_l; eauto.\neapply WF; splits; eauto.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init x) (NEQ : y <> z) (XZ : E x) (XZ0 : ext_sb x z) (XZ1 : E z) (XY : E x) (XY0 : ext_sb x y) (XY1 : E y) : ext_sb y z \\/ ext_sb z y.","proofString":"eapply ext_sb_semi_total_l; eauto.\neapply WF; splits; eauto.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init x) (NEQ : y <> z) (XZ : E x) (XZ0 : ext_sb x z) (XZ1 : E z) (XY : E x) (XY0 : ext_sb x y) (XY1 : E y) : index y <> index z.","proofString":"eapply WF; splits; eauto.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf.\nby unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init x) (NEQ : y <> z) (XZ : E x) (XZ0 : ext_sb x z) (XZ1 : E z) (XY : E x) (XY0 : ext_sb x y) (XY1 : E y) : tid y = tid z.","proofString":"by unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init x) (NEQ : y <> z) (XZ : E x) (XZ0 : ext_sb x z) (XZ1 : E z) (XY : E x) (XY0 : ext_sb x y) (XY1 : E y) : ~ is_init y.","proofString":"by unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XY : sb y x) (XZ : sb z x) : (sb ∪ sb⁻¹) y z.","proofString":"unfold sb in *; unfolder in *; desf.\ndestruct (classic (is_init y)).\nunfold ext_sb; basic_solver.\ncut (ext_sb y z \\/ ext_sb z y); [basic_solver|].\neapply ext_sb_semi_total_r; eauto.\neapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) : E y /\\ ext_sb y z /\\ E z \\/ E z /\\ ext_sb z y /\\ E y.","proofString":"destruct (classic (is_init y)).\nunfold ext_sb; basic_solver.\ncut (ext_sb y z \\/ ext_sb z y); [basic_solver|].\neapply ext_sb_semi_total_r; eauto.\neapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) (H : is_init y) : E y /\\ ext_sb y z /\\ E z \\/ E z /\\ ext_sb z y /\\ E y.","proofString":"unfold ext_sb; basic_solver."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) (H : ~ is_init y) : E y /\\ ext_sb y z /\\ E z \\/ E z /\\ ext_sb z y /\\ E y.","proofString":"cut (ext_sb y z \\/ ext_sb z y); [basic_solver|].\neapply ext_sb_semi_total_r; eauto.\neapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) (H : ~ is_init y) : ext_sb y z \\/ ext_sb z y.","proofString":"eapply ext_sb_semi_total_r; eauto.\neapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) (H : ~ is_init y) : index y <> index z.","proofString":"eapply WF; splits; eauto.\nunfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y z : actid) (WF : Wf) (N : ~ is_init z) (NEQ : y <> z) (XZ : E z) (XZ0 : ext_sb z x) (XZ1 : E x) (XY : E y) (XY0 : ext_sb y x) (XY1 : E x) (H : ~ is_init y) : tid y = tid z.","proofString":"unfold ext_sb in *; destruct y,z; ins; desf; desf."},{"statement":"(x y : actid) (SB : (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘) x y) : (forall x0 y0 : actid, ext_sb x0 y0 -> tid x0 = tid y0 \\/ is_init x0) ->\ntid x = tid y \\/ is_init x.","proofString":"unfolder in *; basic_solver."},{"statement":"(thread : BinNums.positive) : dom_rel\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗E⦘ ⨾ sb) ⨾ ⦗E ∩₁ NTid_ thread⦘) ⊆₁ E ∩₁ NTid_ thread.","proofString":"unfolder.\nins.\ndesf.\nsplits; auto.\nmatch goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) : forall x : actid,\n(exists y : actid, (~ is_init x /\\ E x) /\\ sb x y /\\ E y /\\ tid y <> thread) ->\nE x /\\ tid x <> thread.","proofString":"ins.\ndesf.\nsplits; auto.\nmatch goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x : actid) (H : exists y : actid, (~ is_init x /\\ E x) /\\ sb x y /\\ E y /\\ tid y <> thread) : E x /\\ tid x <> thread.","proofString":"desf.\nsplits; auto.\nmatch goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (H0 : sb x y) (H1 : E y) (H2 : tid y <> thread) : E x /\\ tid x <> thread.","proofString":"splits; auto.\nmatch goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (H0 : sb x y) (H1 : E y) (H2 : tid y <> thread) : tid x <> thread.","proofString":"match goal with  | H : sb _ _ |- _ => rename H into SB  end.\napply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (SB : sb x y) (H1 : E y) (H2 : tid y <> thread) : tid x <> thread.","proofString":"apply sb_tid_init in SB.\ndesf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (SB : tid x = tid y \\/ is_init x) (H1 : E y) (H2 : tid y <> thread) : tid x <> thread.","proofString":"desf.\nintros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (SB : tid x = tid y) (H1 : E y) (H2 : tid y <> thread) : tid x <> thread.","proofString":"intros BB.\nrewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (SB : tid x = tid y) (H1 : E y) (H2 : tid y <> thread) (BB : tid x = thread) : False.","proofString":"rewrite BB in *.\ndesf."},{"statement":"(thread : BinNums.positive) (x y : actid) (H : ~ is_init x) (H3 : E x) (SB : thread = tid y) (H1 : E y) (H2 : tid y <> thread) (BB : tid x = thread) : False.","proofString":"desf."},{"statement":"sb ⊆ sb ∩ same_tid ∪ ⦗fun a : actid => is_init a⦘ ⨾ sb.","proofString":"unfold sb.\nrewrite ext_sb_tid_init' at 1.\nbasic_solver 42."},{"statement":"⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘) ∩ same_tid\n  ∪ ⦗fun a : actid => is_init a⦘ ⨾ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘.","proofString":"rewrite ext_sb_tid_init' at 1.\nbasic_solver 42."},{"statement":"⦗E⦘ ⨾ (ext_sb ∩ same_tid ∪ ⦗fun a : actid => is_init a⦘ ⨾ ext_sb) ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘) ∩ same_tid\n  ∪ ⦗fun a : actid => is_init a⦘ ⨾ ⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (sb ∩ same_tid ∪ ⦗fun a : actid => is_init a⦘ ⨾ sb) ⊆ same_tid.","proofString":"basic_solver."},{"statement":"forall x y z : actid, same_tid x y -> same_tid y z -> same_tid x z.","proofString":"unfold same_tid.\nins.\netransitivity; eauto."},{"statement":"forall x y z : actid, tid x = tid y -> tid y = tid z -> tid x = tid z.","proofString":"ins.\netransitivity; eauto."},{"statement":"(x y z : actid) (H : tid x = tid y) (H0 : tid y = tid z) : tid x = tid z.","proofString":"etransitivity; eauto."},{"statement":"⦗E⦘ ⨾ same_tid ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)^? ∪ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)⁻¹\n  ∪ (fun a : actid => is_init a) × (fun a : actid => is_init a).","proofString":"rewrite tid_ext_sb.\nbasic_solver 21."},{"statement":"⦗E⦘\n⨾ (ext_sb^? ∪ ext_sb⁻¹\n   ∪ (fun a : actid => is_init a) × (fun a : actid => is_init a)) ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)^? ∪ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)⁻¹\n  ∪ (fun a : actid => is_init a) × (fun a : actid => is_init a).","proofString":"basic_solver 21."},{"statement":"⦗E⦘ ⨾ same_tid ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)^? ∪ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)⁻¹.","proofString":"sin_rewrite tid_n_init_ext_sb.\nbasic_solver 21."},{"statement":"⦗E⦘ ⨾ (ext_sb^? ∪ ext_sb⁻¹) ⨾ ⦗E⦘\n⊆ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)^? ∪ (⦗E⦘ ⨾ ext_sb ⨾ ⦗E⦘)⁻¹.","proofString":"basic_solver 21."},{"statement":"(x y : actid) (X : E x) (Y : E y) (NINIT : ~ is_init x) (ST : tid x = tid y) : sb^? y x \\/ sb x y.","proofString":"generalize tid_n_init_sb.\nunfold same_tid; basic_solver 10."},{"statement":"(x y : actid) (X : E x) (Y : E y) (NINIT : ~ is_init x) (ST : tid x = tid y) : ⦗E⦘ ⨾ same_tid ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗E⦘ ⊆ sb^? ∪ sb⁻¹ ->\nsb^? y x \\/ sb x y.","proofString":"unfold same_tid; basic_solver 10."},{"statement":"(WF : Wf) : ⦗fun a : actid => ~ is_init a⦘ ⨾ sb ⨾ sb⁻¹ ⊆ sb^? ∪ sb⁻¹.","proofString":"unfolder; ins; desf; destruct (classic (x=y)); auto.\nforward (apply (@sb_semi_total_r z y x)); eauto; tauto."},{"statement":"(WF : Wf) (x y : actid) (H : ~ is_init x) (z : actid) (H0 : sb x z) (H1 : sb y z) (H2 : x <> y) : (x = y \\/ sb x y) \\/ sb y x.","proofString":"forward (apply (@sb_semi_total_r z y x)); eauto; tauto."},{"statement":"(WF : Wf) : sb⁻¹ ⨾ ⦗fun a : actid => ~ is_init a⦘ ⨾ sb ⊆ sb^? ∪ sb⁻¹.","proofString":"unfolder; ins; desf; destruct (classic (x=y)); auto.\nforward (apply (@sb_semi_total_l z y x)); eauto; tauto."},{"statement":"(WF : Wf) (x y z : actid) (H : sb z x) (H0 : ~ is_init z) (H1 : sb z y) (H2 : x <> y) : (x = y \\/ sb x y) \\/ sb y x.","proofString":"forward (apply (@sb_semi_total_l z y x)); eauto; tauto."},{"statement":"(WF : Wf) : transitive sb.","proofString":"apply sb_trans."},{"statement":"(WF : Wf) : irreflexive sb.","proofString":"apply sb_irr."},{"statement":"(WF : Wf) : sb ⨾ (⦗fun x : actid => ~ is_init x⦘ ⨾ rmw)⁻¹ ⊆ sb^?.","proofString":"rewrite (wf_rmwi WF); clear -WF.\nrewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver."},{"statement":"(WF : Wf) : sb ⨾ (⦗fun x : actid => ~ is_init x⦘ ⨾ immediate sb)⁻¹ ⊆ sb^?.","proofString":"rewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver."},{"statement":"(WF : Wf) : sb ⨾ (⦗fun a : actid => ~ is_init a⦘ ⨾ adjacent sb ∩ sb)⁻¹ ⊆ sb^?.","proofString":"unfold adjacent; basic_solver."},{"statement":"(WF : Wf) : (⦗fun x : actid => ~ is_init x⦘ ⨾ rmw)⁻¹ ⨾ sb ⊆ sb^?.","proofString":"rewrite (wf_rmwi WF); clear -WF.\nrewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver."},{"statement":"(WF : Wf) : (⦗fun x : actid => ~ is_init x⦘ ⨾ immediate sb)⁻¹ ⨾ sb ⊆ sb^?.","proofString":"rewrite (sb_immediate_adjacent WF).\nunfold adjacent; basic_solver."},{"statement":"(WF : Wf) : (⦗fun a : actid => ~ is_init a⦘ ⨾ adjacent sb ∩ sb)⁻¹ ⨾ sb ⊆ sb^?.","proofString":"unfold adjacent; basic_solver."},{"statement":"(WF : Wf) : ⦗fun x : actid => ~ is_init x⦘ ⨾ rmw ⊆ same_tid.","proofString":"rewrite (rmw_in_sb WF), sb_tid_init'.\nbasic_solver."},{"statement":"(WF : Wf) : ⦗fun x : actid => ~ is_init x⦘\n⨾ (sb ∩ same_tid ∪ ⦗fun a : actid => is_init a⦘ ⨾ sb) ⊆ same_tid.","proofString":"basic_solver."},{"statement":"(WF : Wf) : functional (⦗fun x : actid => ~ is_init x⦘ ⨾ rmw).","proofString":"rewrite (wf_rmwi WF).\nrewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique1; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) : functional (⦗fun x : actid => ~ is_init x⦘ ⨾ immediate sb).","proofString":"rewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique1; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) : functional (⦗fun a : actid => ~ is_init a⦘ ⨾ adjacent sb ∩ sb).","proofString":"unfolder; ins; desc.\neapply adjacent_unique1; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) (x y z : actid) (H : ~ is_init x) (H3 : adjacent sb x y) (H4 : sb x y) (H0 : ~ is_init x) (H1 : adjacent sb x z) (H2 : sb x z) : y = z.","proofString":"eapply adjacent_unique1; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) (x y z : actid) (H : ~ is_init x) (H3 : adjacent sb x y) (H4 : sb x y) (H0 : ~ is_init x) (H1 : adjacent sb x z) (H2 : sb x z) : acyclic sb.","proofString":"apply sb_acyclic."},{"statement":"(WF : Wf) : functional (⦗fun x : actid => ~ is_init x⦘ ⨾ rmw)⁻¹.","proofString":"rewrite (wf_rmwi WF).\nrewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique2; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) : functional (⦗fun x : actid => ~ is_init x⦘ ⨾ immediate sb)⁻¹.","proofString":"rewrite (sb_immediate_adjacent WF).\nunfolder; ins; desc.\neapply adjacent_unique2; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) : functional (⦗fun a : actid => ~ is_init a⦘ ⨾ adjacent sb ∩ sb)⁻¹.","proofString":"unfolder; ins; desc.\neapply adjacent_unique2; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) (x y z : actid) (H : ~ is_init y) (H3 : adjacent sb y x) (H4 : sb y x) (H0 : ~ is_init z) (H1 : adjacent sb z x) (H2 : sb z x) : y = z.","proofString":"eapply adjacent_unique2; eauto.\napply sb_acyclic."},{"statement":"(WF : Wf) (x y z : actid) (H : ~ is_init y) (H3 : adjacent sb y x) (H4 : sb y x) (H0 : ~ is_init z) (H1 : adjacent sb z x) (H2 : sb z x) : acyclic sb.","proofString":"apply sb_acyclic."},{"statement":"(WF : Wf) : rfi ⊆ ⦗E⦘ ⨾ rfi ⨾ ⦗E⦘.","proofString":"apply (ri_dom (wf_rfE WF))."},{"statement":"(WF : Wf) : coi ⊆ ⦗E⦘ ⨾ coi ⨾ ⦗E⦘.","proofString":"apply (ri_dom (wf_coE WF))."},{"statement":"(WF : Wf) : fri ⊆ ⦗E⦘ ⨾ fri ⨾ ⦗E⦘.","proofString":"apply (ri_dom (wf_frE WF))."},{"statement":"(WF : Wf) : rfe ⊆ ⦗E⦘ ⨾ rfe ⨾ ⦗E⦘.","proofString":"apply (re_dom (wf_rfE WF))."},{"statement":"(WF : Wf) : coe ⊆ ⦗E⦘ ⨾ coe ⨾ ⦗E⦘.","proofString":"apply (re_dom (wf_coE WF))."},{"statement":"(WF : Wf) : fre ⊆ ⦗E⦘ ⨾ fre ⨾ ⦗E⦘.","proofString":"apply (re_dom (wf_frE WF))."},{"statement":"(WF : Wf) : rfi ⊆ ⦗W⦘ ⨾ rfi ⨾ ⦗R⦘.","proofString":"apply (ri_dom (wf_rfD WF))."},{"statement":"(WF : Wf) : coi ⊆ ⦗W⦘ ⨾ coi ⨾ ⦗W⦘.","proofString":"apply (ri_dom (wf_coD WF))."},{"statement":"(WF : Wf) : fri ⊆ ⦗R⦘ ⨾ fri ⨾ ⦗W⦘.","proofString":"apply (ri_dom (wf_frD WF))."},{"statement":"(WF : Wf) : rfe ⊆ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘.","proofString":"apply (re_dom (wf_rfD WF))."},{"statement":"(WF : Wf) : coe ⊆ ⦗W⦘ ⨾ coe ⨾ ⦗W⦘.","proofString":"apply (re_dom (wf_coD WF))."},{"statement":"(WF : Wf) : fre ⊆ ⦗R⦘ ⨾ fre ⨾ ⦗W⦘.","proofString":"apply (re_dom (wf_frD WF))."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⊆ same_tid.","proofString":"apply ninit_sb_same_tid."},{"statement":"(WF : Wf) : coi ⨾ coi ⊆ coi.","proofString":"generalize sb_trans (co_trans WF).\nintros SB CO.\nunfold coi.\nunfolder.\nins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) : transitive sb -> transitive co -> coi ⨾ coi ⊆ coi.","proofString":"intros SB CO.\nunfold coi.\nunfolder.\nins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) (SB : transitive sb) (CO : transitive co) : coi ⨾ coi ⊆ coi.","proofString":"unfold coi.\nunfolder.\nins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) (SB : transitive sb) (CO : transitive co) : co ∩ sb ⨾ co ∩ sb ⊆ co ∩ sb.","proofString":"unfolder.\nins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) (SB : transitive sb) (CO : transitive co) : forall x y : actid,\n(exists z : actid, (co x z /\\ sb x z) /\\ co z y /\\ sb z y) ->\nco x y /\\ sb x y.","proofString":"ins.\ndesf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) (SB : transitive sb) (CO : transitive co) (x y : actid) (H : exists z : actid, (co x z /\\ sb x z) /\\ co z y /\\ sb z y) : co x y /\\ sb x y.","proofString":"desf.\nsplit; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) (SB : transitive sb) (CO : transitive co) (x y z : actid) (H : co x z) (H2 : sb x z) (H0 : co z y) (H1 : sb z y) : co x y /\\ sb x y.","proofString":"split; [eapply CO|eapply SB]; eauto."},{"statement":"(WF : Wf) : fr ∩ sb ⨾ co ∩ sb ⊆ fr ∩ sb.","proofString":"unfolder.\nins.\ndesf.\nsplit.\napply fr_co; auto.\nbasic_solver.\neapply sb_trans; eauto."},{"statement":"(WF : Wf) : forall x y : actid,\n(exists z : actid, (fr x z /\\ sb x z) /\\ co z y /\\ sb z y) ->\nfr x y /\\ sb x y.","proofString":"ins.\ndesf.\nsplit.\napply fr_co; auto.\nbasic_solver.\neapply sb_trans; eauto."},{"statement":"(WF : Wf) (x y : actid) (H : exists z : actid, (fr x z /\\ sb x z) /\\ co z y /\\ sb z y) : fr x y /\\ sb x y.","proofString":"desf.\nsplit.\napply fr_co; auto.\nbasic_solver.\neapply sb_trans; eauto."},{"statement":"(WF : Wf) (x y z : actid) (H : fr x z) (H2 : sb x z) (H0 : co z y) (H1 : sb z y) : fr x y /\\ sb x y.","proofString":"split.\napply fr_co; auto.\nbasic_solver.\neapply sb_trans; eauto."},{"statement":"(WF : Wf) (x y z : actid) (H : fr x z) (H2 : sb x z) (H0 : co z y) (H1 : sb z y) : fr x y.","proofString":"apply fr_co; auto.\nbasic_solver."},{"statement":"(WF : Wf) (x y z : actid) (H : fr x z) (H2 : sb x z) (H0 : co z y) (H1 : sb z y) : (fr ⨾ co) x y.","proofString":"basic_solver."},{"statement":"(WF : Wf) (x y z : actid) (H : fr x z) (H2 : sb x z) (H0 : co z y) (H1 : sb z y) : sb x y.","proofString":"eapply sb_trans; eauto."},{"statement":"(WF : Wf) : codom_rel (rf ∩ sb) ∩₁ codom_rel (rf \\ sb) ⊆₁ ∅.","proofString":"unfolder.\nins.\ndesf.\nassert (x0 = x1); subst; eauto.\neapply (wf_rff WF); eauto."},{"statement":"(WF : Wf) : forall x : actid,\n(exists x0 : actid, rf x0 x /\\ sb x0 x) /\\\n(exists x0 : actid, rf x0 x /\\ ~ sb x0 x) -> False.","proofString":"ins.\ndesf.\nassert (x0 = x1); subst; eauto.\neapply (wf_rff WF); eauto."},{"statement":"(WF : Wf) (x : actid) (H : (exists x0 : actid, rf x0 x /\\ sb x0 x) /\\\n(exists x0 : actid, rf x0 x /\\ ~ sb x0 x)) : False.","proofString":"desf.\nassert (x0 = x1); subst; eauto.\neapply (wf_rff WF); eauto."},{"statement":"(WF : Wf) (x x1 : actid) (H : rf x1 x) (H2 : sb x1 x) (x0 : actid) (H0 : rf x0 x) (H1 : ~ sb x0 x) : False.","proofString":"assert (x0 = x1); subst; eauto.\neapply (wf_rff WF); eauto."},{"statement":"(WF : Wf) (x x1 : actid) (H : rf x1 x) (H2 : sb x1 x) (x0 : actid) (H0 : rf x0 x) (H1 : ~ sb x0 x) : x0 = x1.","proofString":"eapply (wf_rff WF); eauto."},{"statement":"(r1 r2 r3 : relation actid) (A : r1 ⨾ r2 ⊆ r3) : transitive sb -> r1 ∩ sb ⨾ r2 ∩ sb ⊆ r3 ∩ sb.","proofString":"unfolder in *; basic_solver 21."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r) (IRR2 : irreflexive (r ⨾ sb)) (N : r ⊆ r ⨾ ⦗fun x : actid => ~ is_init x⦘) : (r ⨾ ⦗fun x : actid => ~ is_init x⦘ \\ sb) ⨾ r' ∩ sb ⊆ r ⨾ r' \\ sb.","proofString":"unfolder; ins; desf; splits; eauto.\nintro.\neapply sb_semi_total_r with (x:=y) (y:=x) in H1; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r) (IRR2 : irreflexive (r ⨾ sb)) (N : r ⊆ r ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) (x y z : actid) (H : r x z) (H3 : ~ is_init z) (H2 : ~ sb x z) (H0 : r' z y) (H1 : sb z y) : ~ sb x y.","proofString":"intro.\neapply sb_semi_total_r with (x:=y) (y:=x) in H1; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r) (IRR2 : irreflexive (r ⨾ sb)) (N : r ⊆ r ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) (x y z : actid) (H : r x z) (H3 : ~ is_init z) (H2 : ~ sb x z) (H0 : r' z y) (H1 : sb z y) (H4 : sb x y) : False.","proofString":"eapply sb_semi_total_r with (x:=y) (y:=x) in H1; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r) (IRR2 : irreflexive (r ⨾ sb)) (N : r ⊆ r ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) (x y z : actid) (H : r x z) (H3 : ~ is_init z) (H2 : ~ sb x z) (H0 : r' z y) (H1 : sb x z \\/ sb z x) (H4 : sb x y) : False.","proofString":"by desf; revert IRR2; basic_solver."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r) (IRR2 : irreflexive (r ⨾ sb)) (N : r ⊆ r ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) (x y z : actid) (H : r x z) (H3 : ~ is_init z) (H2 : ~ sb x z) (H0 : r' z y) (H1 : sb z y) (H4 : sb x y) : x <> z.","proofString":"eby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r') (IRR2 : irreflexive (r' ⨾ sb)) (x y : actid) (H : ~ is_init x) (z : actid) (H0 : r x z) (H3 : sb x z) (H1 : r' z y) (H2 : ~ sb z y) : ~ sb x y.","proofString":"intro.\neapply sb_semi_total_l with (x:=x) (y:=z) (z:=y) in H4; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r') (IRR2 : irreflexive (r' ⨾ sb)) (x y : actid) (H : ~ is_init x) (z : actid) (H0 : r x z) (H3 : sb x z) (H1 : r' z y) (H2 : ~ sb z y) (H4 : sb x y) : False.","proofString":"eapply sb_semi_total_l with (x:=x) (y:=z) (z:=y) in H4; eauto.\nby desf; revert IRR2; basic_solver.\neby intro; subst; eapply IRR."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r') (IRR2 : irreflexive (r' ⨾ sb)) (x y : actid) (H : ~ is_init x) (z : actid) (H0 : r x z) (H3 : sb x z) (H1 : r' z y) (H2 : ~ sb z y) (H4 : sb z y \\/ sb y z) : False.","proofString":"by desf; revert IRR2; basic_solver."},{"statement":"(WF : Wf) (r r' : relation actid) (IRR : irreflexive r') (IRR2 : irreflexive (r' ⨾ sb)) (x y : actid) (H : ~ is_init x) (z : actid) (H0 : r x z) (H3 : sb x z) (H1 : r' z y) (H2 : ~ sb z y) (H4 : sb x y) : z <> y.","proofString":"eby intro; subst; eapply IRR."},{"statement":"(WF : Wf) : fr ∩ same_loc ∩ sb ⊆ restr_eq_rel loc sb.","proofString":"unfolder; unfold Events.same_loc in *.\nins; desf; splits; eauto; congruence."},{"statement":"(WF : Wf) : forall x y : actid,\n(fr x y /\\ loc x = loc y) /\\ sb x y -> sb x y /\\ loc x = loc y.","proofString":"ins; desf; splits; eauto; congruence."},{"statement":"(WF : Wf) : (rf \\ sb) ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rf ∩ sb ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ \\ sb)\n⊆ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘.","proofString":"unionL; [by unfold rfe; basic_solver 12|].\nrewrite (rmw_in_sb WF) at 1.\narewrite (sb ⨾ sb^? ⨾ ⦗W⦘ ⊆ sb) by generalize sb_trans; basic_solver 21.\nrelsf."},{"statement":"(WF : Wf) : rf ∩ sb ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ \\ sb) ⊆ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘.","proofString":"rewrite (rmw_in_sb WF) at 1.\narewrite (sb ⨾ sb^? ⨾ ⦗W⦘ ⊆ sb) by generalize sb_trans; basic_solver 21.\nrelsf."},{"statement":"(WF : Wf) : rf ∩ sb ⨾ (sb ⨾ sb^? ⨾ ⦗W⦘ \\ sb) ⊆ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘.","proofString":"arewrite (sb ⨾ sb^? ⨾ ⦗W⦘ ⊆ sb) by generalize sb_trans; basic_solver 21.\nrelsf."},{"statement":"(WF : Wf) : rf ∩ sb ⨾ (sb \\ sb) ⊆ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘.","proofString":"relsf."},{"statement":"(WF : Wf) : (rf ∪ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ⨾ rf) \\ sb\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)＊.","proofString":"rewrite rtE, minus_union_l.\nrelsf; unionL; [by unfold rfe; basic_solver 12|].\nrewrite (seq_minus_transitive sb_trans).\nunionL; [|by unfold rfe; basic_solver 12].\nunionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : rf \\ sb ∪ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ⨾ rf \\ sb\n⊆ sb^? ⨾ rfe ⨾ (⦗fun _ : actid => True⦘ ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺).","proofString":"relsf; unionL; [by unfold rfe; basic_solver 12|].\nrewrite (seq_minus_transitive sb_trans).\nunionL; [|by unfold rfe; basic_solver 12].\nunionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ⨾ rf \\ sb\n⊆ sb^? ⨾ rfe ∪ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite (seq_minus_transitive sb_trans).\nunionL; [|by unfold rfe; basic_solver 12].\nunionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ \\ sb) ⨾ rf\n∪ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ∩ sb ⨾ (rf \\ sb)\n⊆ sb^? ⨾ rfe ∪ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"unionL; [|by unfold rfe; basic_solver 12].\nunionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ \\ sb) ⨾ rf\n⊆ sb^? ⨾ rfe ∪ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"unionR right.\nrewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ \\ sb) ⨾ rf ⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite (ct_minus_transitive sb_trans).\narewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : (((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb)＊\n ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ \\ sb) ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊) ⨾ rf\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"arewrite ((rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ∩ sb ⊆ sb).\ngeneralize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : sb＊ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ \\ sb) ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"generalize sb_trans; ins; relsf.\nrewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : sb^? ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ \\ sb) ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite (rf_rmw_sb_minus_sb WF).\nrewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : sb^? ⨾ (rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘) ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite !seqA.\narewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : sb^? ⨾ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf\n⊆ sb^? ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"arewrite (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf )⁺); [|done].\nrewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)＊ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite rtE; relsf; unionL; [by econs|].\nrewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘)⁺ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite ct_seq_swap, !seqA.\nrewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺ ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺.","proofString":"rewrite ct_begin at 2.\nby rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) (H : transitive sb) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺\n⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)＊.","proofString":"by rewrite inclusion_t_rt, !seqA."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rf.","proofString":"hahn_frame; vauto."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rf\n⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rf.","proofString":"rewrite ct_begin; hahn_frame; relsf.\narewrite (rfe ⊆ rf) at 2.\nseq_rewrite (rf_rf WF).\nrelsf.\nrewrite rfi_union_rfe; relsf; unionL.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n∪ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"arewrite (rfe ⊆ rf) at 2.\nseq_rewrite (rf_rf WF).\nrelsf.\nrewrite rfi_union_rfe; relsf; unionL.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n∪ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ rf ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"seq_rewrite (rf_rf WF).\nrelsf.\nrewrite rfi_union_rfe; relsf; unionL.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n∪ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ ∅₂ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"relsf.\nrewrite rfi_union_rfe; relsf; unionL.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"rewrite rfi_union_rfe; relsf; unionL.\narewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21.\nrewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rfi ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"arewrite (rfi ⊆ sb).\nrewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"rewrite (rmw_in_sb WF) at 2.\narewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"arewrite (sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?).\ngeneralize sb_trans; basic_solver 21.\nbasic_solver 21."},{"statement":"(WF : Wf) : sb^? ⨾ ⦗W⦘ ⨾ sb ⨾ sb ⨾ sb^? ⊆ sb^?.","proofString":"generalize sb_trans; basic_solver 21."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"basic_solver 21."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"rewrite rt_begin at 2.\nrewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw\n  ⨾ sb^?\n    ⨾ ⦗W⦘\n      ⨾ (⦗fun _ : actid => True⦘\n         ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊)\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"rewrite rt_begin at 2.\nbasic_solver 42."},{"statement":"(WF : Wf) : rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rfe ⨾ rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊\n⊆ rmw\n  ⨾ sb^?\n    ⨾ ⦗W⦘\n      ⨾ (⦗fun _ : actid => True⦘\n         ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)\n           ⨾ (⦗fun _ : actid => True⦘\n              ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe) ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊))\n  ∪ rfe ⨾ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ⨾ rf)⁺ ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"rewrite (rmw_rf_ct WF).\nrewrite rfi_union_rfe; relsf.\nrewrite inclusion_t_rt.\nrelsf; unionL.\nbasic_solver 12.\nrewrite rt_end at 2; basic_solver 12."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rf ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"rewrite rfi_union_rfe; relsf.\nrewrite inclusion_t_rt.\nrelsf; unionL.\nbasic_solver 12.\nrewrite rt_end at 2; basic_solver 12."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rfi ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)⁺ ⨾ rfe\n⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"rewrite inclusion_t_rt.\nrelsf; unionL.\nbasic_solver 12.\nrewrite rt_end at 2; basic_solver 12."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi ∪ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfe\n⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"relsf; unionL.\nbasic_solver 12.\nrewrite rt_end at 2; basic_solver 12."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"basic_solver 12."},{"statement":"(WF : Wf) : (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfe ⊆ (rmw ⨾ sb^? ⨾ ⦗W⦘ ∪ rfe)＊ ⨾ rfi^?.","proofString":"rewrite rt_end at 2; basic_solver 12."},{"statement":"(WF : Wf) : detour ⊆ ⦗E⦘ ⨾ detour ⨾ ⦗E⦘.","proofString":"unfold detour.\nsin_rewrite (wf_coeE WF).\nsin_rewrite (wf_rfeE WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : (coe ⨾ rfe) ∩ sb ⊆ ⦗E⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗E⦘.","proofString":"sin_rewrite (wf_coeE WF).\nsin_rewrite (wf_rfeE WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ((⦗E⦘ ⨾ coe ⨾ ⦗E⦘) ⨾ rfe) ∩ sb ⊆ ⦗E⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗E⦘.","proofString":"sin_rewrite (wf_rfeE WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ((⦗E⦘ ⨾ coe ⨾ ⦗E⦘) ⨾ ⦗E⦘ ⨾ rfe ⨾ ⦗E⦘) ∩ sb ⊆ ⦗E⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : detour ⊆ ⦗W⦘ ⨾ detour ⨾ ⦗R⦘.","proofString":"unfold detour.\nsin_rewrite (wf_coeD WF).\nsin_rewrite (wf_rfeD WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : (coe ⨾ rfe) ∩ sb ⊆ ⦗W⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗R⦘.","proofString":"sin_rewrite (wf_coeD WF).\nsin_rewrite (wf_rfeD WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ((⦗W⦘ ⨾ coe ⨾ ⦗W⦘) ⨾ rfe) ∩ sb ⊆ ⦗W⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗R⦘.","proofString":"sin_rewrite (wf_rfeD WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : ((⦗W⦘ ⨾ coe ⨾ ⦗W⦘) ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘) ∩ sb ⊆ ⦗W⦘ ⨾ (coe ⨾ rfe) ∩ sb ⨾ ⦗R⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : ((co \\ sb) ⨾ (rf \\ sb)) ∩ sb ⨾ fr ⊆ co.","proofString":"generalize (rf_fr WF) (co_trans WF).\nbasic_solver 42."},{"statement":"(WF : Wf) : rf ⨾ fr ⊆ co -> transitive co -> ((co \\ sb) ⨾ (rf \\ sb)) ∩ sb ⨾ fr ⊆ co.","proofString":"basic_solver 42."},{"statement":"(WF : Wf) : (coe ⨾ (rf \\ sb)) ∩ sb ⨾ (rf ∩ sb)⁻¹ ⊆ ∅₂.","proofString":"unfolder; ins; desf.\nassert (y=z0); subst; auto.\neapply WF; basic_solver."},{"statement":"(WF : Wf) (x y z z0 : actid) (H : coe x z0) (H3 : rf z0 z) (H4 : ~ sb z0 z) (H2 : sb x z) (H0 : rf y z) (H1 : sb y z) : False.","proofString":"assert (y=z0); subst; auto.\neapply WF; basic_solver."},{"statement":"(WF : Wf) (x y z z0 : actid) (H : coe x z0) (H3 : rf z0 z) (H4 : ~ sb z0 z) (H2 : sb x z) (H0 : rf y z) (H1 : sb y z) : y = z0.","proofString":"eapply WF; basic_solver."},{"statement":"(WF : Wf) : (coe ⨾ (rf \\ sb)) ∩ sb ⊆ (coe ⨾ (rf \\ sb)) ∩ sb ⨾ ⦗codom_rel (rf \\ sb)⦘.","proofString":"unfolder; ins; desf; eauto 20."},{"statement":"(WF : Wf) : forall x : actid, W_ex x -> ~ is_init x.","proofString":"ins.\ndesf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (H : W_ex x) : ~ is_init x.","proofString":"desf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (H : W_ex x) : ~ is_init x.","proofString":"match goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (WEX : W_ex x) : ~ is_init x.","proofString":"destruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : rmw z x) : ~ is_init x.","proofString":"apply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : sb z x) : ~ is_init x.","proofString":"apply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : (sb ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) z x) : ~ is_init x.","proofString":"unfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : sb z x /\\ ~ is_init x) : ~ is_init x.","proofString":"desf."},{"statement":"(WF : Wf) : codom_rel rmw ⊆₁ E.","proofString":"rewrite (dom_r (wf_rmwE WF)).\nbasic_solver."},{"statement":"(WF : Wf) : codom_rel (rmw ⨾ ⦗E⦘) ⊆₁ E.","proofString":"basic_solver."},{"statement":"(WF : Wf) : W_ex ⊆₁ E -> W_ex ≡₁ E ∩₁ W ∩₁ W_ex.","proofString":"generalize (W_ex_in_W WF).\nclear.\nbasic_solver 10."},{"statement":"(WF : Wf) : W_ex ⊆₁ W -> W_ex ⊆₁ E -> W_ex ≡₁ E ∩₁ W ∩₁ W_ex.","proofString":"clear.\nbasic_solver 10."},{"statement":"W_ex ⊆₁ W -> W_ex ⊆₁ E -> W_ex ≡₁ E ∩₁ W ∩₁ W_ex.","proofString":"basic_solver 10."},{"statement":"(WF : Wf) : forall x : actid, W_ex x /\\ is_xacq lab x -> ~ is_init x.","proofString":"ins.\ndesf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (H : W_ex x /\\ is_xacq lab x) : ~ is_init x.","proofString":"desf.\nmatch goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (H : W_ex x) (H0 : is_xacq lab x) : ~ is_init x.","proofString":"match goal with  | H : W_ex _ |- _ => rename H into WEX  end.\ndestruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x : actid) (WEX : W_ex x) (H0 : is_xacq lab x) : ~ is_init x.","proofString":"destruct WEX as [z WEX].\napply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : rmw z x) (H0 : is_xacq lab x) : ~ is_init x.","proofString":"apply (rmw_in_sb WF) in WEX.\napply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : sb z x) (H0 : is_xacq lab x) : ~ is_init x.","proofString":"apply no_sb_to_init in WEX.\nunfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (WEX : (sb ⨾ ⦗fun x0 : actid => ~ is_init x0⦘) z x) (H0 : is_xacq lab x) : ~ is_init x.","proofString":"unfolder in WEX.\ndesf."},{"statement":"(WF : Wf) (x z : actid) (H0 : is_xacq lab x) (WEX : sb z x /\\ ~ is_init x) : ~ is_init x.","proofString":"desf."},{"statement":"(WF : Wf) : rf ⨾ rmw ⊆ ⦗E⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗E⦘.","proofString":"rewrite (wf_rfE WF) at 1.\nrewrite (wf_rmwE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ rf ⨾ ⦗E⦘) ⨾ rmw ⊆ ⦗E⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗E⦘.","proofString":"rewrite (wf_rmwE WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗E⦘ ⨾ rf ⨾ ⦗E⦘) ⨾ ⦗E⦘ ⨾ rmw ⨾ ⦗E⦘ ⊆ ⦗E⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗E⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : rf ⨾ rmw ⊆ ⦗W⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗W⦘.","proofString":"rewrite (wf_rfD WF) at 1.\nrewrite (wf_rmwD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗W⦘ ⨾ rf ⨾ ⦗R⦘) ⨾ rmw ⊆ ⦗W⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗W⦘.","proofString":"rewrite (wf_rmwD WF) at 1.\nbasic_solver."},{"statement":"(WF : Wf) : (⦗W⦘ ⨾ rf ⨾ ⦗R⦘) ⨾ ⦗R⦘ ⨾ rmw ⨾ ⦗W⦘ ⊆ ⦗W⦘ ⨾ (rf ⨾ rmw) ⨾ ⦗W⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf) : same_loc ⨾ same_loc ⊆ same_loc.","proofString":"generalize same_loc_trans; basic_solver."},{"statement":"(WF : Wf) : functional (rmw⁻¹ ⨾ rf⁻¹).","proofString":"by apply functional_seq; [apply wf_rmw_invf|apply WF]."},{"statement":"(WF : Wf) : functional (rf ⨾ rmw)⁻¹.","proofString":"eapply wf_rfrmwf; eauto."},{"statement":"(WF : Wf) : functional (rf ⨾ rmw)⁻¹.","proofString":"eapply wf_rfrmwf; eauto."},{"statement":"⦗fun _ : actid => True⦘ ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"basic_solver 12."},{"statement":"forall k : relation actid,\nk ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊ ->\n(rf ⨾ rmw) ⨾ k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"intros k H.\nrewrite !seqA, H.\nrewrite rfi_union_rfe; relsf; unionL.\nrewrite rt_begin at 3.\nbasic_solver 21.\nrewrite (rt_begin (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)) at 2.\nbasic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : (rf ⨾ rmw) ⨾ k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"rewrite !seqA, H.\nrewrite rfi_union_rfe; relsf; unionL.\nrewrite rt_begin at 3.\nbasic_solver 21.\nrewrite (rt_begin (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)) at 2.\nbasic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : rf ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊\n⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"rewrite rfi_union_rfe; relsf; unionL.\nrewrite rt_begin at 3.\nbasic_solver 21.\nrewrite (rt_begin (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)) at 2.\nbasic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : rfi ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊\n⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"rewrite rt_begin at 3.\nbasic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : rfi ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊\n⊆ (⦗fun _ : actid => True⦘ ∪ (rfi ⨾ rmw) ⨾ (rfi ⨾ rmw)＊)\n  ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"basic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊\n⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊.","proofString":"rewrite (rt_begin (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)) at 2.\nbasic_solver 21."},{"statement":"(k : relation actid) (H : k ⊆ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊) : rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊ ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊\n⊆ (rfi ⨾ rmw)＊\n  ⨾ (⦗fun _ : actid => True⦘\n     ∪ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊) ⨾ (rfe ⨾ rmw ⨾ (rfi ⨾ rmw)＊)＊).","proofString":"basic_solver 21."},{"statement":"(WF : Wf) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rfi ⨾ same_tid ⊆ same_tid.","proofString":"sin_rewrite ninit_rfi_same_tid.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) : same_tid ⨾ same_tid ⊆ same_tid.","proofString":"apply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) : transitive same_tid.","proofString":"apply same_tid_trans."},{"statement":"(WF : Wf) : good_ctx\n  (fun r : relation actid => ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ r).","proofString":"by eauto with hahn."},{"statement":"(WF : Wf) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘ ⊆ same_tid.","proofString":"unfold same_tid.\nbasic_solver 12."},{"statement":"(WF : Wf) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n⊆ (fun x y : actid => tid x = tid y).","proofString":"basic_solver 12."},{"statement":"(WF : Wf) : forall k : relation actid,\n⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid ->\n⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (rfi ⨾ rmw) ⨾ k ⊆ same_tid.","proofString":"intros k AA.\nrewrite !seqA.\nrewrite (dom_r (rmw_non_init_lr WF)).\nrewrite !seqA.\nrewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (rfi ⨾ rmw) ⨾ k ⊆ same_tid.","proofString":"rewrite !seqA.\nrewrite (dom_r (rmw_non_init_lr WF)).\nrewrite !seqA.\nrewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rfi ⨾ rmw ⨾ k ⊆ same_tid.","proofString":"rewrite (dom_r (rmw_non_init_lr WF)).\nrewrite !seqA.\nrewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ rfi ⨾ (rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ k ⊆ same_tid.","proofString":"rewrite !seqA.\nrewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ rfi ⨾ rmw ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid.","proofString":"rewrite AA.\nsin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rfi ⨾ rmw ⨾ same_tid ⊆ same_tid.","proofString":"sin_rewrite ninit_rfi_rmw_same_tid; auto.\napply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : same_tid ⨾ same_tid ⊆ same_tid.","proofString":"apply transitiveI.\napply same_tid_trans."},{"statement":"(WF : Wf) (k : relation actid) (AA : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ k ⊆ same_tid) : transitive same_tid.","proofString":"apply same_tid_trans."},{"statement":"(WF : Wf) : rf ⨾ rmw ⊆ (sb ∩ same_loc)^? ⨾ rf ⨾ rmw.","proofString":"basic_solver 10."},{"statement":"(WF : Wf) : ((sb ∩ same_loc)^? ⨾ rf ⨾ rmw)＊\n⊆ (sb ∩ same_loc ⨾ ⦗W⦘)^?\n  ∪ (sb ∩ same_loc)^? ⨾ (rfe ⨾ rmw ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘)⁺.","proofString":"apply (sw_in_ar_helper WF)."},{"statement":"(WF : Wf) : ((⦗F⦘ ⨾ sb)^? ⨾ co) ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⊆ (⦗F⦘ ⨾ sb)^? ⨾ co.","proofString":"rewrite !seqA.\nrewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⊆ (⦗F⦘ ⨾ sb)^? ⨾ co.","proofString":"rewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : (⦗F⦘ ⨾ sb)^? ⨾ (co ⨾ ⦗W⦘) ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘ ⊆ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"rewrite !seqA.\narewrite_id (⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘ ⊆ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"arewrite_id (⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗W⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗fun _ : actid => True⦘.","proofString":"type_solver."},{"statement":"(WF : Wf) : (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗fun _ : actid => True⦘ ⨾ co ⨾ ⦗W⦘\n⊆ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"rewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ co ⨾ ⦗W⦘ ⊆ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"by sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : (⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co)\n⨾ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co.","proofString":"rewrite !seqA.\nrewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗fun a : actid => Rel a⦘\n⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co.","proofString":"rewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗fun a : actid => Rel a⦘\n⨾ (⦗F⦘ ⨾ sb)^?\n  ⨾ (co ⨾ ⦗W⦘) ⨾ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"rewrite !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗fun a : actid => Rel a⦘\n⨾ (⦗F⦘ ⨾ sb)^?\n  ⨾ co ⨾ ⦗W⦘ ⨾ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"arewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\ntype_solver.\nrewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗W⦘ ⨾ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗fun _ : actid => True⦘.","proofString":"type_solver."},{"statement":"(WF : Wf) : ⦗fun a : actid => Rel a⦘\n⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗fun _ : actid => True⦘ ⨾ co ⨾ ⦗W⦘\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"rewrite seq_id_l.\nby sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ co ⨾ ⦗W⦘\n⊆ ⦗fun a : actid => Rel a⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co ⨾ ⦗W⦘.","proofString":"by sin_rewrite (co_co WF)."},{"statement":"(WF : Wf) : irreflexive ((⦗fun _ : actid => True⦘ ∪ ⦗F⦘ ⨾ sb) ⨾ co).","proofString":"rewrite seq_union_l, !seq_id_l.\napply irreflexive_union.\nsplit.\nby apply co_irr.\nrewrite (wf_coD WF).\ntype_solver."},{"statement":"(WF : Wf) : irreflexive (co ∪ (⦗F⦘ ⨾ sb) ⨾ co).","proofString":"apply irreflexive_union.\nsplit.\nby apply co_irr.\nrewrite (wf_coD WF).\ntype_solver."},{"statement":"(WF : Wf) : irreflexive co /\\ irreflexive ((⦗F⦘ ⨾ sb) ⨾ co).","proofString":"split.\nby apply co_irr.\nrewrite (wf_coD WF).\ntype_solver."},{"statement":"(WF : Wf) : irreflexive co.","proofString":"by apply co_irr."},{"statement":"(WF : Wf) : irreflexive ((⦗F⦘ ⨾ sb) ⨾ co).","proofString":"rewrite (wf_coD WF).\ntype_solver."},{"statement":"(WF : Wf) : irreflexive ((⦗F⦘ ⨾ sb) ⨾ ⦗W⦘ ⨾ co ⨾ ⦗W⦘).","proofString":"type_solver."},{"statement":"(WF : Wf) : irreflexive (⦗fun _ : actid => True⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ co).","proofString":"rewrite seq_id_l.\nby apply sb_co_irr."},{"statement":"(WF : Wf) : irreflexive ((⦗F⦘ ⨾ sb)^? ⨾ co).","proofString":"by apply sb_co_irr."},{"statement":"(WF : Wf) : rfi ⨾ rmw ⨾ ⦗W⦘ ⊆ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"rewrite rfi_in_sbloc', rmw_in_sb_loc; auto.\nsin_rewrite rewrite_trans; [done|].\napply sb_same_loc_trans."},{"statement":"(WF : Wf) : sb ∩ same_loc ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ⊆ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"sin_rewrite rewrite_trans; [done|].\napply sb_same_loc_trans."},{"statement":"(WF : Wf) : transitive (sb ∩ same_loc).","proofString":"apply sb_same_loc_trans."},{"statement":"(WF : Wf) : sb ∩ same_loc ⨾ ⦗W⦘ ⊆ sb ∩ same_loc.","proofString":"basic_solver."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (BB : (⦗set_compl P⦘ ⨾ immediate (co ⨾ ⦗P⦘)) z y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq_l BB as CC.\nset (DD := AA).\ndestruct DD as [DD _].\ndestruct_seq_l DD as PX.\nset (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"set (DD := AA).\ndestruct DD as [DD _].\ndestruct_seq_l DD as PX.\nset (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (DD : immediate (⦗P⦘ ⨾ co) x z) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct DD as [DD _].\ndestruct_seq_l DD as PX.\nset (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (DD : (⦗P⦘ ⨾ co) x z) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq_l DD as PX.\nset (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"set (EE := BB).\ndestruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : immediate (co ⨾ ⦗P⦘) z y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct EE as [EE _].\ndestruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : (co ⨾ ⦗P⦘) z y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq_r EE as PY.\nassert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"assert (co x y) as CO.\neapply (co_trans WF); eauto.\napply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) : co x y.","proofString":"eapply (co_trans WF); eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) (CO : co x y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply (wf_coD WF) in CO.\ndestruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) (CO : (⦗W⦘ ⨾ co ⨾ ⦗W⦘) x y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq CO as [WX WY].\napply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) (WX : is_w lab x) (CO : co x y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply (wf_coE WF) in CO.\ndestruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) (WX : is_w lab x) (CO : (⦗E⦘ ⨾ co ⨾ ⦗E⦘) x y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq CO as [EX EY].\napply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : co x z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply (wf_coD WF) in DD.\ndestruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (DD : (⦗W⦘ ⨾ co ⨾ ⦗W⦘) x z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq DD as [XLOC WZ].\napply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (XLOC : is_w lab x) (DD : co x z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply (wf_coE WF) in DD.\ndestruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (XLOC : is_w lab x) (DD : (⦗E⦘ ⨾ co ⨾ ⦗E⦘) x z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"destruct_seq DD as [EX' EZ].\napply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (XLOC : is_w lab x) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply is_w_loc in XLOC.\ndesf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (XLOC : exists l : location, loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"desf.\nassert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"assert (loc y = Some l /\\ loc z = Some l) as [YLOC ZLOC].\nsplit; rewrite <- XLOC; symmetry; by apply (wf_col WF).\nsplit.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) : loc y = Some l /\\ loc z = Some l.","proofString":"split; rewrite <- XLOC; symmetry; by apply (wf_col WF)."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) : immediate (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"split.\napply seq_eqv_lr.\nby splits.\nins.\ndestruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) : (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x y.","proofString":"apply seq_eqv_lr.\nby splits."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) : P x /\\ co x y /\\ P y.","proofString":"by splits."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (R1 : (⦗P⦘ ⨾ co ⨾ ⦗P⦘) x c) (R2 : (⦗P⦘ ⨾ co ⨾ ⦗P⦘) c y) : False.","proofString":"destruct_seq R1 as [A1 B1].\ndestruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 : P c) (R2 : (⦗P⦘ ⨾ co ⨾ ⦗P⦘) c y) : False.","proofString":"destruct_seq R2 as [A2 B2].\ndestruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) : False.","proofString":"destruct (classic (c = z)) as [|CNEQ]; desf.\nassert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) : False.","proofString":"assert (loc c = Some l) as LOCC.\nrewrite <- YLOC.\nby apply (wf_col WF).\nassert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) : loc c = Some l.","proofString":"rewrite <- YLOC.\nby apply (wf_col WF)."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) : loc c = loc y.","proofString":"by apply (wf_col WF)."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) : False.","proofString":"assert (E c) as EC.\nby apply P_in_E.\nassert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) : E c.","proofString":"by apply P_in_E."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) : False.","proofString":"assert (W c) as WC.\nby apply P_in_W.\nassert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) : is_w lab c.","proofString":"by apply P_in_W."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) : False.","proofString":"assert (c <> x /\\ c <> y) as [CNNEXT CNPREV].\nsplit; intros HH; subst; eapply (co_irr WF); eauto.\nassert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) : c <> x /\\ c <> y.","proofString":"split; intros HH; subst; eapply (co_irr WF); eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) (CNNEXT : c <> x) (CNPREV : c <> y) : False.","proofString":"assert (co c z \\/ co z c) as [QQ|QQ].\neapply (wf_co_total WF); eauto; unfolder; eauto.\neapply AA with (c:=c); apply seq_eqv_l; eauto.\neapply BB with (c:=c); apply seq_eqv_r; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) (CNNEXT : c <> x) (CNPREV : c <> y) : co c z \\/ co z c.","proofString":"eapply (wf_co_total WF); eauto; unfolder; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) (CNNEXT : c <> x) (CNPREV : c <> y) (QQ : co c z) : False.","proofString":"eapply AA with (c:=c); apply seq_eqv_l; eauto."},{"statement":"(WF : Wf) (P : actid -> Prop) (P_in_E : P ⊆₁ E) (P_in_W : P ⊆₁ W) (x y z : actid) (AA : immediate (⦗P⦘ ⨾ co) x z) (CC : set_compl P z) (BB : immediate (co ⨾ ⦗P⦘) z y) (PX : P x) (l : location) (XLOC : loc x = Some l) (EX' : E x) (DD : co x z) (EZ : E z) (WZ : is_w lab z) (EE : co z y) (PY : P y) (WX : is_w lab x) (EX : E x) (CO : co x y) (EY : E y) (WY : is_w lab y) (YLOC : loc y = Some l) (ZLOC : loc z = Some l) (c : actid) (A1 : P x) (R1 : co x c) (B1 A2 : P c) (R2 : co c y) (B2 : P y) (CNEQ : c <> z) (LOCC : loc c = Some l) (EC : E c) (WC : W c) (CNNEXT : c <> x) (CNPREV : c <> y) (QQ : co z c) : False.","proofString":"eapply BB with (c:=c); apply seq_eqv_r; eauto."}]}