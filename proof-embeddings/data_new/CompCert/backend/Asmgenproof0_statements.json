{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Asmgenproof0.v","fileSamples":[{"statement":"(r : mreg) (r' : ireg) (H : match preg_of r with\n| IR mr => OK mr\n| _ => Error (msg \"Asmgen.ireg_of\")\nend = OK r') : preg_of r = r'.","conclusion":"preg_of r = r'","hypotheses":"(r : mreg) (r' : ireg) (H : match preg_of r with\n| IR mr => OK mr\n| _ => Error (msg \"Asmgen.ireg_of\")\nend = OK r')","proofString":"destruct (preg_of r); inv H; auto."},{"statement":"(r : mreg) (r' : freg) (H : match preg_of r with\n| FR mr => OK mr\n| _ => Error (msg \"Asmgen.freg_of\")\nend = OK r') : preg_of r = r'.","conclusion":"preg_of r = r'","hypotheses":"(r : mreg) (r' : freg) (H : match preg_of r with\n| FR mr => OK mr\n| _ => Error (msg \"Asmgen.freg_of\")\nend = OK r')","proofString":"destruct (preg_of r); inv H; auto."},{"statement":"(r : mreg) : data_preg (preg_of r) = true.","conclusion":"data_preg (preg_of r) = true","hypotheses":"(r : mreg)","proofString":"destruct r; reflexivity."},{"statement":"(r : mreg) : preg_of r <> SP.","conclusion":"preg_of r <> SP","hypotheses":"(r : mreg)","proofString":"unfold preg_of; destruct r; simpl; congruence."},{"statement":"(r : mreg) : preg_of r <> PC.","conclusion":"preg_of r <> PC","hypotheses":"(r : mreg)","proofString":"apply data_diff; auto with asmgen."},{"statement":"(rs : regset) : nextinstr rs PC = Val.offset_ptr (rs PC) Ptrofs.one.","conclusion":"nextinstr rs PC = Val.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : regset)","proofString":"apply Pregmap.gss."},{"statement":"(r : preg) (rs : regset) (H : r <> PC) : nextinstr rs r = rs r.","conclusion":"nextinstr rs r = rs r","hypotheses":"(r : preg) (rs : regset) (H : r <> PC)","proofString":"unfold nextinstr.\napply Pregmap.gso.\nred; intro; subst.\nauto."},{"statement":"(r : preg) (rs : regset) (H : r <> PC) : rs # PC <- (Val.offset_ptr (rs PC) Ptrofs.one) r = rs r.","conclusion":"rs # PC <- (Val.offset_ptr (rs PC) Ptrofs.one) r = rs r","hypotheses":"(r : preg) (rs : regset) (H : r <> PC)","proofString":"apply Pregmap.gso.\nred; intro; subst.\nauto."},{"statement":"(r : preg) (rs : regset) (H : r <> PC) : r <> PC.","conclusion":"r <> PC","hypotheses":"(r : preg) (rs : regset) (H : r <> PC)","proofString":"red; intro; subst.\nauto."},{"statement":"(rs : regset) (H : PC <> PC) : False.","conclusion":"False","hypotheses":"(rs : regset) (H : PC <> PC)","proofString":"auto."},{"statement":"(r : preg) (rs : regset) (H : data_preg r = true) : nextinstr rs r = rs r.","conclusion":"nextinstr rs r = rs r","hypotheses":"(r : preg) (rs : regset) (H : data_preg r = true)","proofString":"apply nextinstr_inv.\nred; intro; subst; discriminate."},{"statement":"(r : preg) (rs : regset) (H : data_preg r = true) : r <> PC.","conclusion":"r <> PC","hypotheses":"(r : preg) (rs : regset) (H : data_preg r = true)","proofString":"red; intro; subst; discriminate."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : nextinstr rs # (preg_of m) <- v PC = Val.offset_ptr (rs PC) Ptrofs.one.","conclusion":"nextinstr rs # (preg_of m) <- v PC = Val.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"unfold nextinstr.\nrewrite Pregmap.gss.\nrewrite Pregmap.gso.\nauto.\napply not_eq_sym.\napply preg_of_not_PC."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : (rs # (preg_of m) <- v) # PC <-\n(Val.offset_ptr (rs # (preg_of m) <- v PC) Ptrofs.one) PC =\nVal.offset_ptr (rs PC) Ptrofs.one.","conclusion":"(rs # (preg_of m) <- v) # PC <-\n(Val.offset_ptr (rs # (preg_of m) <- v PC) Ptrofs.one) PC =\nVal.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"rewrite Pregmap.gss.\nrewrite Pregmap.gso.\nauto.\napply not_eq_sym.\napply preg_of_not_PC."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : Val.offset_ptr (rs # (preg_of m) <- v PC) Ptrofs.one =\nVal.offset_ptr (rs PC) Ptrofs.one.","conclusion":"Val.offset_ptr (rs # (preg_of m) <- v PC) Ptrofs.one =\nVal.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"rewrite Pregmap.gso.\nauto.\napply not_eq_sym.\napply preg_of_not_PC."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : Val.offset_ptr (rs PC) Ptrofs.one = Val.offset_ptr (rs PC) Ptrofs.one.","conclusion":"Val.offset_ptr (rs PC) Ptrofs.one = Val.offset_ptr (rs PC) Ptrofs.one","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"auto."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : PC <> preg_of m.","conclusion":"PC <> preg_of m","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"apply not_eq_sym.\napply preg_of_not_PC."},{"statement":"(rs : Pregmap.t val) (m : mreg) (v : val) : preg_of m <> PC.","conclusion":"preg_of m <> PC","hypotheses":"(rs : Pregmap.t val) (m : mreg) (v : val)","proofString":"apply preg_of_not_PC."},{"statement":"(r : preg) (rs : regset) (H : forall r' : preg, False -> r <> r') : rs r = rs r.","conclusion":"rs r = rs r","hypotheses":"(r : preg) (rs : regset) (H : forall r' : preg, False -> r <> r')","proofString":"auto."},{"statement":"(r a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\n(forall r' : preg, In r' rl -> r <> r') -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : forall r' : preg, a = r' \\/ In r' rl -> r <> r') : undef_regs rl rs # a <- Vundef r = rs r.","conclusion":"undef_regs rl rs # a <- Vundef r = rs r","hypotheses":"(r a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\n(forall r' : preg, In r' rl -> r <> r') -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : forall r' : preg, a = r' \\/ In r' rl -> r <> r')","proofString":"rewrite IHrl by auto.\nrewrite Pregmap.gso; auto."},{"statement":"(r a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\n(forall r' : preg, In r' rl -> r <> r') -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : forall r' : preg, a = r' \\/ In r' rl -> r <> r') : rs # a <- Vundef r = rs r.","conclusion":"rs # a <- Vundef r = rs r","hypotheses":"(r a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\n(forall r' : preg, In r' rl -> r <> r') -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : forall r' : preg, a = r' \\/ In r' rl -> r <> r')","proofString":"rewrite Pregmap.gso; auto."},{"statement":"(r : preg) : True <-> (forall mr : mreg, False -> r <> preg_of mr).","conclusion":"True <-> (forall mr : mreg, False -> r <> preg_of mr)","hypotheses":"(r : preg)","proofString":"tauto."},{"statement":"(r : preg) (a : mreg) (rl : list mreg) (IHrl : preg_notin r rl <-> (forall mr : mreg, In mr rl -> r <> preg_of mr)) : match rl with\n| nil => r <> preg_of a\n| _ :: _ => r <> preg_of a /\\ preg_notin r rl\nend <-> (forall mr : mreg, a = mr \\/ In mr rl -> r <> preg_of mr).","conclusion":"match rl with\n| nil => r <> preg_of a\n| _ :: _ => r <> preg_of a /\\ preg_notin r rl\nend <-> (forall mr : mreg, a = mr \\/ In mr rl -> r <> preg_of mr)","hypotheses":"(r : preg) (a : mreg) (rl : list mreg) (IHrl : preg_notin r rl <-> (forall mr : mreg, In mr rl -> r <> preg_of mr))","proofString":"destruct rl.\nsimpl.\nsplit.\nintros.\nintuition congruence.\nauto.\nrewrite IHrl.\nsplit.\nintros [A B].\nintros.\ndestruct H.\ncongruence.\nauto.\nauto."},{"statement":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr)) : r <> preg_of a <-> (forall mr : mreg, a = mr \\/ In mr nil -> r <> preg_of mr).","conclusion":"r <> preg_of a <-> (forall mr : mreg, a = mr \\/ In mr nil -> r <> preg_of mr)","hypotheses":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr))","proofString":"simpl.\nsplit.\nintros.\nintuition congruence.\nauto."},{"statement":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr)) : r <> preg_of a <-> (forall mr : mreg, a = mr \\/ False -> r <> preg_of mr).","conclusion":"r <> preg_of a <-> (forall mr : mreg, a = mr \\/ False -> r <> preg_of mr)","hypotheses":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr))","proofString":"split.\nintros.\nintuition congruence.\nauto."},{"statement":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr)) : r <> preg_of a -> forall mr : mreg, a = mr \\/ False -> r <> preg_of mr.","conclusion":"r <> preg_of a -> forall mr : mreg, a = mr \\/ False -> r <> preg_of mr","hypotheses":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr))","proofString":"intros.\nintuition congruence."},{"statement":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr0 : mreg, In mr0 nil -> r <> preg_of mr0)) (H : r <> preg_of a) (mr : mreg) (H0 : a = mr \\/ False) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr0 : mreg, In mr0 nil -> r <> preg_of mr0)) (H : r <> preg_of a) (mr : mreg) (H0 : a = mr \\/ False)","proofString":"intuition congruence."},{"statement":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr)) : (forall mr : mreg, a = mr \\/ False -> r <> preg_of mr) -> r <> preg_of a.","conclusion":"(forall mr : mreg, a = mr \\/ False -> r <> preg_of mr) -> r <> preg_of a","hypotheses":"(r : preg) (a : mreg) (IHrl : preg_notin r nil <-> (forall mr : mreg, In mr nil -> r <> preg_of mr))","proofString":"auto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) : r <> preg_of a /\\ preg_notin r (m :: rl) <->\n(forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr).","conclusion":"r <> preg_of a /\\ preg_notin r (m :: rl) <->\n(forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr)","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr))","proofString":"rewrite IHrl.\nsplit.\nintros [A B].\nintros.\ndestruct H.\ncongruence.\nauto.\nauto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) : r <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr) <->\n(forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr).","conclusion":"r <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr) <->\n(forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr)","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr))","proofString":"split.\nintros [A B].\nintros.\ndestruct H.\ncongruence.\nauto.\nauto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) : r <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr) ->\nforall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr.","conclusion":"r <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr) ->\nforall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr))","proofString":"intros [A B].\nintros.\ndestruct H.\ncongruence.\nauto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) (A : r <> preg_of a) (B : forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr) : forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr.","conclusion":"forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) (A : r <> preg_of a) (B : forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)","proofString":"intros.\ndestruct H.\ncongruence.\nauto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : a = mr \\/ In mr (m :: rl)) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : a = mr \\/ In mr (m :: rl))","proofString":"destruct H.\ncongruence.\nauto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : a = mr) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : a = mr)","proofString":"congruence."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : In mr (m :: rl)) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0)) (A : r <> preg_of a) (B : forall mr0 : mreg, In mr0 (m :: rl) -> r <> preg_of mr0) (mr : mreg) (H : In mr (m :: rl))","proofString":"auto."},{"statement":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)) : (forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr) ->\nr <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr).","conclusion":"(forall mr : mreg, a = mr \\/ In mr (m :: rl) -> r <> preg_of mr) ->\nr <> preg_of a /\\ (forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr)","hypotheses":"(r : preg) (a m : mreg) (rl : list mreg) (IHrl : preg_notin r (m :: rl) <->\n(forall mr : mreg, In mr (m :: rl) -> r <> preg_of mr))","proofString":"auto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) : undef_regs (map preg_of rl) rs r = rs r.","conclusion":"undef_regs (map preg_of rl) rs r = rs r","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl)","proofString":"apply undef_regs_other.\nintros.\nexploit list_in_map_inv; eauto.\nintros [mr [A B]].\nsubst.\nrewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) : forall r' : preg, In r' (map preg_of rl) -> r <> r'.","conclusion":"forall r' : preg, In r' (map preg_of rl) -> r <> r'","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl)","proofString":"intros.\nexploit list_in_map_inv; eauto.\nintros [mr [A B]].\nsubst.\nrewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl)) : r <> r'.","conclusion":"r <> r'","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl))","proofString":"exploit list_in_map_inv; eauto.\nintros [mr [A B]].\nsubst.\nrewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl)) : (exists x : mreg, r' = preg_of x /\\ In x rl) -> r <> r'.","conclusion":"(exists x : mreg, r' = preg_of x /\\ In x rl) -> r <> r'","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl))","proofString":"intros [mr [A B]].\nsubst.\nrewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl)) (mr : mreg) (A : r' = preg_of mr) (B : In mr rl) : r <> r'.","conclusion":"r <> r'","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (r' : preg) (H0 : In r' (map preg_of rl)) (mr : mreg) (A : r' = preg_of mr) (B : In mr rl)","proofString":"subst.\nrewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (mr : mreg) (H0 : In (preg_of mr) (map preg_of rl)) (B : In mr rl) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : preg_notin r rl) (mr : mreg) (H0 : In (preg_of mr) (map preg_of rl)) (B : In mr rl)","proofString":"rewrite preg_notin_charact in H.\nauto."},{"statement":"(r : preg) (rl : list mreg) (rs : regset) (H : forall mr0 : mreg, In mr0 rl -> r <> preg_of mr0) (mr : mreg) (H0 : In (preg_of mr) (map preg_of rl)) (B : In mr rl) : r <> preg_of mr.","conclusion":"r <> preg_of mr","hypotheses":"(r : preg) (rl : list mreg) (rs : regset) (H : forall mr0 : mreg, In mr0 rl -> r <> preg_of mr0) (mr : mreg) (H0 : In (preg_of mr) (map preg_of rl)) (B : In mr rl)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (H : agree ms sp rs) : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (H : agree ms sp rs)","proofString":"destruct H.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0)))","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"constructor."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l))) : Val.lessdef_list (ms a :: map ms l)\n  (rs (preg_of a) :: map rs (map preg_of l)).","conclusion":"Val.lessdef_list (ms a :: map ms l)\n  (rs (preg_of a) :: map rs (map preg_of l))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l)))","proofString":"constructor.\neapply preg_val; eauto.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l))) : Val.lessdef (ms a) (rs (preg_of a)).","conclusion":"Val.lessdef (ms a) (rs (preg_of a))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l)))","proofString":"eapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l))) : Val.lessdef_list (map ms l) (map rs (map preg_of l)).","conclusion":"Val.lessdef_list (map ms l) (map rs (map preg_of l))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (a : RegEq.t) (l : list RegEq.t) (IHl : Val.lessdef_list (map ms l) (map rs (map preg_of l)))","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : sp = rs SP.","conclusion":"sp = rs SP","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"destruct H; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : ireg) (H : agree ms sp rs) (H0 : ireg_of r = OK r') : Val.lessdef (ms r) (rs r').","conclusion":"Val.lessdef (ms r) (rs r')","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : ireg) (H : agree ms sp rs) (H0 : ireg_of r = OK r')","proofString":"rewrite <- (ireg_of_eq _ _ H0).\neapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : ireg) (H : agree ms sp rs) (H0 : ireg_of r = OK r') : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : ireg) (H : agree ms sp rs) (H0 : ireg_of r = OK r')","proofString":"eapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : freg) (H : agree ms sp rs) (H0 : freg_of r = OK r') : Val.lessdef (ms r) (rs r').","conclusion":"Val.lessdef (ms r) (rs r')","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : freg) (H : agree ms sp rs) (H0 : freg_of r = OK r')","proofString":"rewrite <- (freg_of_eq _ _ H0).\neapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : freg) (H : agree ms sp rs) (H0 : freg_of r = OK r') : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (r' : freg) (H : agree ms sp rs) (H0 : freg_of r = OK r')","proofString":"eapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (H : agree ms sp rs) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r) : agree ms sp rs'.","conclusion":"agree ms sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (H : agree ms sp rs) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r)","proofString":"destruct H.\nsplit; auto.\nrewrite H0; auto.\nauto.\nintros.\nrewrite H0; auto.\napply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r) : agree ms sp rs'.","conclusion":"agree ms sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r)","proofString":"split; auto.\nrewrite H0; auto.\nauto.\nintros.\nrewrite H0; auto.\napply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r) : rs' SP = sp.","conclusion":"rs' SP = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r)","proofString":"rewrite H0; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r) : forall r : mreg, Val.lessdef (ms r) (rs' (preg_of r)).","conclusion":"forall r : mreg, Val.lessdef (ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r)","proofString":"auto.\nintros.\nrewrite H0; auto.\napply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r) : forall r : mreg, Val.lessdef (ms r) (rs' (preg_of r)).","conclusion":"forall r : mreg, Val.lessdef (ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r : preg, data_preg r = true -> rs' r = rs r)","proofString":"intros.\nrewrite H0; auto.\napply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r0 : preg, data_preg r0 = true -> rs' r0 = rs r0) (r : mreg) : Val.lessdef (ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r0 : preg, data_preg r0 = true -> rs' r0 = rs r0) (r : mreg)","proofString":"rewrite H0; auto.\napply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r0 : preg, data_preg r0 = true -> rs' r0 = rs r0) (r : mreg) : data_preg (preg_of r) = true.","conclusion":"data_preg (preg_of r) = true","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r0 : preg, data_preg r0 = true -> rs' r0 = rs r0) (r : mreg)","proofString":"apply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : agree (Regmap.set r v ms) sp rs'.","conclusion":"agree (Regmap.set r v ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"destruct H.\nsplit; auto.\nrewrite H1; auto.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\nunfold Regmap.set.\ndestruct (RegEq.eq r0 r).\ncongruence.\nrewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : agree (Regmap.set r v ms) sp rs'.","conclusion":"agree (Regmap.set r v ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"split; auto.\nrewrite H1; auto.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\nunfold Regmap.set.\ndestruct (RegEq.eq r0 r).\ncongruence.\nrewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : rs' SP = sp.","conclusion":"rs' SP = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"rewrite H1; auto.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : SP <> preg_of r.","conclusion":"SP <> preg_of r","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"apply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : preg_of r <> SP.","conclusion":"preg_of r <> SP","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"apply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') : forall r0 : mreg, Val.lessdef (Regmap.set r v ms r0) (rs' (preg_of r0)).","conclusion":"forall r0 : mreg, Val.lessdef (Regmap.set r v ms r0) (rs' (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r')","proofString":"intros.\nunfold Regmap.set.\ndestruct (RegEq.eq r0 r).\ncongruence.\nrewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) : Val.lessdef (Regmap.set r v ms r0) (rs' (preg_of r0)).","conclusion":"Val.lessdef (Regmap.set r v ms r0) (rs' (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg)","proofString":"unfold Regmap.set.\ndestruct (RegEq.eq r0 r).\ncongruence.\nrewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) : Val.lessdef (if RegEq.eq r0 r then v else ms r0) (rs' (preg_of r0)).","conclusion":"Val.lessdef (if RegEq.eq r0 r then v else ms r0) (rs' (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg)","proofString":"destruct (RegEq.eq r0 r).\ncongruence.\nrewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (e : r0 = r) : Val.lessdef v (rs' (preg_of r0)).","conclusion":"Val.lessdef v (rs' (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (e : r0 = r)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) : Val.lessdef (ms r0) (rs' (preg_of r0)).","conclusion":"Val.lessdef (ms r0) (rs' (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r)","proofString":"rewrite H1.\nauto.\napply preg_of_data.\nred; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) : Val.lessdef (ms r0) (rs (preg_of r0)).","conclusion":"Val.lessdef (ms r0) (rs (preg_of r0))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) : data_preg (preg_of r0) = true.","conclusion":"data_preg (preg_of r0) = true","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r)","proofString":"apply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) : preg_of r0 <> preg_of r.","conclusion":"preg_of r0 <> preg_of r","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r)","proofString":"red; intros; elim n.\neapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) (H : preg_of r0 = preg_of r) : r0 = r.","conclusion":"r0 = r","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r1 : mreg, Val.lessdef (ms r1) (rs (preg_of r1))) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg, data_preg r' = true -> r' <> preg_of r -> rs' r' = rs r') (r0 : mreg) (n : r0 <> r) (H : preg_of r0 = preg_of r)","proofString":"eapply preg_of_injective; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Regmap.set r v ms) sp rs # (preg_of r) <- v'.","conclusion":"agree (Regmap.set r v ms) sp rs # (preg_of r) <- v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"eapply agree_set_mreg; eauto.\nrewrite Pregmap.gss; auto.\nintros; apply Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef v (rs # (preg_of r) <- v' (preg_of r)).","conclusion":"Val.lessdef v (rs # (preg_of r) <- v' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"rewrite Pregmap.gss; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> rs # (preg_of r) <- v' r' = rs r'.","conclusion":"forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> rs # (preg_of r) <- v' r' = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : RegEq.t) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"intros; apply Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) : agree ms sp rs # r <- v.","conclusion":"agree ms sp rs # r <- v","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false)","proofString":"apply agree_exten with rs.\nauto.\nintros.\napply Pregmap.gso.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) : agree ms sp rs.","conclusion":"agree ms sp rs","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) : forall r0 : preg, data_preg r0 = true -> rs # r <- v r0 = rs r0.","conclusion":"forall r0 : preg, data_preg r0 = true -> rs # r <- v r0 = rs r0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false)","proofString":"intros.\napply Pregmap.gso.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) (r0 : preg) (H1 : data_preg r0 = true) : rs # r <- v r0 = rs r0.","conclusion":"rs # r <- v r0 = rs r0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) (r0 : preg) (H1 : data_preg r0 = true)","proofString":"apply Pregmap.gso.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) (r0 : preg) (H1 : data_preg r0 = true) : r0 <> r.","conclusion":"r0 <> r","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : preg) (v : val) (H : agree ms sp rs) (H0 : data_preg r = false) (r0 : preg) (H1 : data_preg r0 = true)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : agree ms sp (nextinstr rs).","conclusion":"agree ms sp (nextinstr rs)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"unfold nextinstr.\napply agree_set_other.\nauto.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : agree ms sp rs # PC <- (Val.offset_ptr (rs PC) Ptrofs.one).","conclusion":"agree ms sp rs # PC <- (Val.offset_ptr (rs PC) Ptrofs.one)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"apply agree_set_other.\nauto.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : agree ms sp rs.","conclusion":"agree ms sp rs","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : data_preg PC = false.","conclusion":"data_preg PC = false","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"auto."},{"statement":"(sp : val) (p : rpair mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Mach.set_pair p v ms) sp (set_pair (map_rpair preg_of p) v' rs).","conclusion":"agree (Mach.set_pair p v ms) sp (set_pair (map_rpair preg_of p) v' rs)","hypotheses":"(sp : val) (p : rpair mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"destruct p; simpl.\napply agree_set_mreg_parallel; auto.\napply agree_set_mreg_parallel.\napply agree_set_mreg_parallel; auto.\napply Val.hiword_lessdef; auto.\napply Val.loword_lessdef; auto."},{"statement":"(sp : val) (r : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Regmap.set r v ms) sp rs # (preg_of r) <- v'.","conclusion":"agree (Regmap.set r v ms) sp rs # (preg_of r) <- v'","hypotheses":"(sp : val) (r : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply agree_set_mreg_parallel; auto."},{"statement":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Regmap.set rlo (Val.loword v) (Regmap.set rhi (Val.hiword v) ms)) sp\n  (rs # (preg_of rhi) <- (Val.hiword v')) # (preg_of rlo) <- (Val.loword v').","conclusion":"agree (Regmap.set rlo (Val.loword v) (Regmap.set rhi (Val.hiword v) ms)) sp\n  (rs # (preg_of rhi) <- (Val.hiword v')) # (preg_of rlo) <- (Val.loword v')","hypotheses":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply agree_set_mreg_parallel.\napply agree_set_mreg_parallel; auto.\napply Val.hiword_lessdef; auto.\napply Val.loword_lessdef; auto."},{"statement":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Regmap.set rhi (Val.hiword v) ms) sp\n  rs # (preg_of rhi) <- (Val.hiword v').","conclusion":"agree (Regmap.set rhi (Val.hiword v) ms) sp\n  rs # (preg_of rhi) <- (Val.hiword v')","hypotheses":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply agree_set_mreg_parallel; auto.\napply Val.hiword_lessdef; auto."},{"statement":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef (Val.hiword v) (Val.hiword v').","conclusion":"Val.lessdef (Val.hiword v) (Val.hiword v')","hypotheses":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply Val.hiword_lessdef; auto."},{"statement":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef (Val.loword v) (Val.loword v').","conclusion":"Val.lessdef (Val.loword v) (Val.loword v')","hypotheses":"(sp : val) (rhi rlo : mreg) (v v' : val) (ms : Mach.regset) (rs : regset) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply Val.loword_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, False -> data_preg r = false) : agree ms sp rs.","conclusion":"agree ms sp rs","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, False -> data_preg r = false)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) : agree ms sp (undef_regs rl rs # a <- Vundef).","conclusion":"agree ms sp (undef_regs rl rs # a <- Vundef)","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false)","proofString":"apply IHrl.\napply agree_exten with rs; auto.\nintros.\napply Pregmap.gso.\nred; intros; subst.\nassert (data_preg a = false) by auto.\ncongruence.\nintros.\napply H0; auto."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) : agree ms sp rs # a <- Vundef.","conclusion":"agree ms sp rs # a <- Vundef","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false)","proofString":"apply agree_exten with rs; auto.\nintros.\napply Pregmap.gso.\nred; intros; subst.\nassert (data_preg a = false) by auto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) : forall r : preg, data_preg r = true -> rs # a <- Vundef r = rs r.","conclusion":"forall r : preg, data_preg r = true -> rs # a <- Vundef r = rs r","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false)","proofString":"intros.\napply Pregmap.gso.\nred; intros; subst.\nassert (data_preg a = false) by auto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : data_preg r = true) : rs # a <- Vundef r = rs r.","conclusion":"rs # a <- Vundef r = rs r","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : data_preg r = true)","proofString":"apply Pregmap.gso.\nred; intros; subst.\nassert (data_preg a = false) by auto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : data_preg r = true) : r <> a.","conclusion":"r <> a","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : data_preg r = true)","proofString":"red; intros; subst.\nassert (data_preg a = false) by auto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) (H1 : data_preg a = true) : False.","conclusion":"False","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) (H1 : data_preg a = true)","proofString":"assert (data_preg a = false) by auto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) (H1 : data_preg a = true) (H2 : data_preg a = false) : False.","conclusion":"False","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) (H1 : data_preg a = true) (H2 : data_preg a = false)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false) : forall r : preg, In r rl -> data_preg r = false.","conclusion":"forall r : preg, In r rl -> data_preg r = false","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r : preg, In r rl -> data_preg r = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r : preg, a = r \\/ In r rl -> data_preg r = false)","proofString":"intros.\napply H0; auto."},{"statement":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : In r rl) : data_preg r = false.","conclusion":"data_preg r = false","hypotheses":"(ms : Mach.regset) (sp : val) (a : preg) (rl : list preg) (IHrl : forall rs0 : regset,\nagree ms sp rs0 ->\n(forall r0 : preg, In r0 rl -> data_preg r0 = false) ->\nagree ms sp (undef_regs rl rs0)) (rs : regset) (H : agree ms sp rs) (H0 : forall r0 : preg, a = r0 \\/ In r0 rl -> data_preg r0 = false) (r : preg) (H1 : In r rl)","proofString":"apply H0; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (H : agree ms sp rs) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : agree (Mach.undef_regs rl ms) sp rs'.","conclusion":"agree (Mach.undef_regs rl ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (H : agree ms sp rs) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"destruct H.\nsplit; auto.\nrewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite Mach.undef_regs_other; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : agree (Mach.undef_regs rl ms) sp rs'.","conclusion":"agree (Mach.undef_regs rl ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"split; auto.\nrewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite Mach.undef_regs_other; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : rs' SP = sp.","conclusion":"rs' SP = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"rewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : rs' SP = rs SP.","conclusion":"rs' SP = rs SP","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"apply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : preg_notin SP rl.","conclusion":"preg_notin SP rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"rewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : forall mr : mreg, In mr rl -> SP <> preg_of mr.","conclusion":"forall mr : mreg, In mr rl -> SP <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl) : SP <> preg_of mr.","conclusion":"SP <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl)","proofString":"apply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl) : preg_of mr <> SP.","conclusion":"preg_of mr <> SP","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl)","proofString":"apply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite Mach.undef_regs_other; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg)","proofString":"destruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite Mach.undef_regs_other; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (i : In r rl) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (i : In r rl)","proofString":"rewrite Mach.undef_regs_same; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"rewrite Mach.undef_regs_other; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : Val.lessdef (ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"rewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : data_preg (preg_of r) = true.","conclusion":"data_preg (preg_of r) = true","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"apply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : preg_notin (preg_of r) rl.","conclusion":"preg_notin (preg_of r) rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"rewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : forall mr : mreg, In mr rl -> preg_of r <> preg_of mr.","conclusion":"forall mr : mreg, In mr rl -> preg_of r <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"intros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : False.","conclusion":"False","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"elim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : In r rl.","conclusion":"In r rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"exploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : r = mr -> In r rl.","conclusion":"r = mr -> In r rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (H : agree (Mach.undef_regs rl ms) sp rs) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : agree (Mach.undef_regs rl ms) sp rs'.","conclusion":"agree (Mach.undef_regs rl ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (H : agree (Mach.undef_regs rl ms) sp rs) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"destruct H.\nsplit; auto.\nrewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : agree (Mach.undef_regs rl ms) sp rs'.","conclusion":"agree (Mach.undef_regs rl ms) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"split; auto.\nrewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP.\nintros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : rs' SP = sp.","conclusion":"rs' SP = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"rewrite <- agree_sp0.\napply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : rs' SP = rs SP.","conclusion":"rs' SP = rs SP","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"apply H0; auto.\nrewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : preg_notin SP rl.","conclusion":"preg_notin SP rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"rewrite preg_notin_charact.\nintros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : forall mr : mreg, In mr rl -> SP <> preg_of mr.","conclusion":"forall mr : mreg, In mr rl -> SP <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\napply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl) : SP <> preg_of mr.","conclusion":"SP <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl)","proofString":"apply not_eq_sym.\napply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl) : preg_of mr <> SP.","conclusion":"preg_of mr <> SP","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (mr : mreg) (H : In mr rl)","proofString":"apply preg_of_not_SP."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (Mach.undef_regs rl ms r) (rs (preg_of r))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\ndestruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg)","proofString":"destruct (In_dec mreg_eq r rl).\nrewrite Mach.undef_regs_same; auto.\nrewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (i : In r rl) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (i : In r rl)","proofString":"rewrite Mach.undef_regs_same; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r)).","conclusion":"Val.lessdef (Mach.undef_regs rl ms r) (rs' (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"rewrite H0; auto.\napply preg_of_data.\nrewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : data_preg (preg_of r) = true.","conclusion":"data_preg (preg_of r) = true","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"apply preg_of_data."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : preg_notin (preg_of r) rl.","conclusion":"preg_notin (preg_of r) rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"rewrite preg_notin_charact.\nintros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) : forall mr : mreg, In mr rl -> preg_of r <> preg_of mr.","conclusion":"forall mr : mreg, In mr rl -> preg_of r <> preg_of mr","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl)","proofString":"intros; red; intros.\nelim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : False.","conclusion":"False","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"elim n.\nexploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : In r rl.","conclusion":"In r rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"exploit preg_of_injective; eauto.\ncongruence."},{"statement":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr) : r = mr -> In r rl.","conclusion":"r = mr -> In r rl","hypotheses":"(ms : Mach.regset) (sp : val) (rl : list mreg) (rs : regset) (rs' : preg -> val) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (Mach.undef_regs rl ms r0) (rs (preg_of r0))) (H0 : forall r' : preg, data_preg r' = true -> preg_notin r' rl -> rs' r' = rs r') (r : mreg) (n : ~ In r rl) (mr : mreg) (H : In mr rl) (H1 : preg_of r = preg_of mr)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r') : agree (Regmap.set r v (Mach.undef_regs rl ms)) sp rs'.","conclusion":"agree (Regmap.set r v (Mach.undef_regs rl ms)) sp rs'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r')","proofString":"apply agree_set_mreg with (rs'#(preg_of r) <- (rs#(preg_of r))); auto.\napply agree_undef_regs with rs; auto.\nintros.\nunfold Pregmap.set.\ndestruct (PregEq.eq r' (preg_of r)).\ncongruence.\nauto.\nintros.\nrewrite Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r') : agree (Mach.undef_regs rl ms) sp rs' # (preg_of r) <- (rs (preg_of r)).","conclusion":"agree (Mach.undef_regs rl ms) sp rs' # (preg_of r) <- (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r')","proofString":"apply agree_undef_regs with rs; auto.\nintros.\nunfold Pregmap.set.\ndestruct (PregEq.eq r' (preg_of r)).\ncongruence.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r') : forall r' : preg,\ndata_preg r' = true ->\npreg_notin r' rl -> rs' # (preg_of r) <- (rs (preg_of r)) r' = rs r'.","conclusion":"forall r' : preg,\ndata_preg r' = true ->\npreg_notin r' rl -> rs' # (preg_of r) <- (rs (preg_of r)) r' = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\nunfold Pregmap.set.\ndestruct (PregEq.eq r' (preg_of r)).\ncongruence.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) : rs' # (preg_of r) <- (rs (preg_of r)) r' = rs r'.","conclusion":"rs' # (preg_of r) <- (rs (preg_of r)) r' = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl)","proofString":"unfold Pregmap.set.\ndestruct (PregEq.eq r' (preg_of r)).\ncongruence.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) : (if PregEq.eq r' (preg_of r) then rs (preg_of r) else rs' r') = rs r'.","conclusion":"(if PregEq.eq r' (preg_of r) then rs (preg_of r) else rs' r') = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl)","proofString":"destruct (PregEq.eq r' (preg_of r)).\ncongruence.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) (e : r' = preg_of r) : rs (preg_of r) = rs r'.","conclusion":"rs (preg_of r) = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) (e : r' = preg_of r)","proofString":"congruence."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) (n : r' <> preg_of r) : rs' r' = rs r'.","conclusion":"rs' r' = rs r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : preg_notin r' rl) (n : r' <> preg_of r)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r') : forall r' : preg,\ndata_preg r' = true ->\nr' <> preg_of r -> rs' r' = rs' # (preg_of r) <- (rs (preg_of r)) r'.","conclusion":"forall r' : preg,\ndata_preg r' = true ->\nr' <> preg_of r -> rs' r' = rs' # (preg_of r) <- (rs (preg_of r)) r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of r -> preg_notin r' rl -> rs' r' = rs r')","proofString":"intros.\nrewrite Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : r' <> preg_of r) : rs' r' = rs' # (preg_of r) <- (rs (preg_of r)) r'.","conclusion":"rs' r' = rs' # (preg_of r) <- (rs (preg_of r)) r'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (r : mreg) (v : val) (rl : list mreg) (rs' : preg -> val) (H : agree ms sp rs) (H0 : Val.lessdef v (rs' (preg_of r))) (H1 : forall r'0 : preg,\ndata_preg r'0 = true ->\nr'0 <> preg_of r -> preg_notin r'0 rl -> rs' r'0 = rs r'0) (r' : preg) (H2 : data_preg r' = true) (H3 : r' <> preg_of r)","proofString":"rewrite Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : agree (Mach.undef_caller_save_regs ms) sp (undef_caller_save_regs rs).","conclusion":"agree (Mach.undef_caller_save_regs ms) sp (undef_caller_save_regs rs)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs)","proofString":"destruct H.\nunfold Mach.undef_caller_save_regs, Asm.undef_caller_save_regs; split.\nunfold proj_sumbool; rewrite dec_eq_true.\nauto.\nauto.\nintros.\nunfold proj_sumbool.\nrewrite dec_eq_false by (apply preg_of_not_SP).\ndestruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : agree (Mach.undef_caller_save_regs ms) sp (undef_caller_save_regs rs).","conclusion":"agree (Mach.undef_caller_save_regs ms) sp (undef_caller_save_regs rs)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"unfold Mach.undef_caller_save_regs, Asm.undef_caller_save_regs; split.\nunfold proj_sumbool; rewrite dec_eq_true.\nauto.\nauto.\nintros.\nunfold proj_sumbool.\nrewrite dec_eq_false by (apply preg_of_not_SP).\ndestruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : (if\n  preg_eq SP SP\n  || in_dec preg_eq SP (map preg_of (filter is_callee_save all_mregs))\n then rs SP\n else Vundef) = sp.","conclusion":"(if\n  preg_eq SP SP\n  || in_dec preg_eq SP (map preg_of (filter is_callee_save all_mregs))\n then rs SP\n else Vundef) = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"unfold proj_sumbool; rewrite dec_eq_true.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : (if\n  true\n  || (if in_dec preg_eq SP (map preg_of (filter is_callee_save all_mregs))\n      then true\n      else false)\n then rs SP\n else Vundef) = sp.","conclusion":"(if\n  true\n  || (if in_dec preg_eq SP (map preg_of (filter is_callee_save all_mregs))\n      then true\n      else false)\n then rs SP\n else Vundef) = sp","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : sp <> Vundef.","conclusion":"sp <> Vundef","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : forall r : mreg,\nVal.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    preg_eq (preg_of r) SP\n    || in_dec preg_eq (preg_of r)\n         (map preg_of (filter is_callee_save all_mregs))\n   then rs (preg_of r)\n   else Vundef).","conclusion":"forall r : mreg,\nVal.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    preg_eq (preg_of r) SP\n    || in_dec preg_eq (preg_of r)\n         (map preg_of (filter is_callee_save all_mregs))\n   then rs (preg_of r)\n   else Vundef)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"intros.\nunfold proj_sumbool.\nrewrite dec_eq_false by (apply preg_of_not_SP).\ndestruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) : Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    preg_eq (preg_of r) SP\n    || in_dec preg_eq (preg_of r)\n         (map preg_of (filter is_callee_save all_mregs))\n   then rs (preg_of r)\n   else Vundef).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    preg_eq (preg_of r) SP\n    || in_dec preg_eq (preg_of r)\n         (map preg_of (filter is_callee_save all_mregs))\n   then rs (preg_of r)\n   else Vundef)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg)","proofString":"unfold proj_sumbool.\nrewrite dec_eq_false by (apply preg_of_not_SP).\ndestruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) : Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    (if preg_eq (preg_of r) SP then true else false)\n    || (if\n         in_dec preg_eq (preg_of r)\n           (map preg_of (filter is_callee_save all_mregs))\n        then true\n        else false)\n   then rs (preg_of r)\n   else Vundef).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    (if preg_eq (preg_of r) SP then true else false)\n    || (if\n         in_dec preg_eq (preg_of r)\n           (map preg_of (filter is_callee_save all_mregs))\n        then true\n        else false)\n   then rs (preg_of r)\n   else Vundef)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg)","proofString":"rewrite dec_eq_false by (apply preg_of_not_SP).\ndestruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) : Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    false\n    || (if\n         in_dec preg_eq (preg_of r)\n           (map preg_of (filter is_callee_save all_mregs))\n        then true\n        else false)\n   then rs (preg_of r)\n   else Vundef).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef)\n  (if\n    false\n    || (if\n         in_dec preg_eq (preg_of r)\n           (map preg_of (filter is_callee_save all_mregs))\n        then true\n        else false)\n   then rs (preg_of r)\n   else Vundef)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg)","proofString":"destruct (in_dec preg_eq (preg_of r) (List.map preg_of (List.filter is_callee_save all_mregs))); simpl.\napply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto.\ndestruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (i : In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (i : In (preg_of r) (map preg_of (filter is_callee_save all_mregs)))","proofString":"apply list_in_map_inv in i.\ndestruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (i : exists x : mreg,\n  preg_of r = preg_of x /\\ In x (filter is_callee_save all_mregs)) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (i : exists x : mreg,\n  preg_of r = preg_of x /\\ In x (filter is_callee_save all_mregs))","proofString":"destruct i as (mr & A & B).\nassert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r mr : mreg) (A : preg_of r = preg_of mr) (B : In mr (filter is_callee_save all_mregs)) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r mr : mreg) (A : preg_of r = preg_of mr) (B : In mr (filter is_callee_save all_mregs))","proofString":"assert (r = mr) by (apply preg_of_injective; auto).\nsubst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r mr : mreg) (A : preg_of r = preg_of mr) (B : In mr (filter is_callee_save all_mregs)) (H : r = mr) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r mr : mreg) (A : preg_of r = preg_of mr) (B : In mr (filter is_callee_save all_mregs)) (H : r = mr)","proofString":"subst mr; clear A.\napply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (B : In r (filter is_callee_save all_mregs)) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (B : In r (filter is_callee_save all_mregs))","proofString":"apply List.filter_In in B.\ndestruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (B : In r all_mregs /\\ is_callee_save r = true) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (B : In r all_mregs /\\ is_callee_save r = true)","proofString":"destruct B as [C D].\nrewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (C : In r all_mregs) (D : is_callee_save r = true) : Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r)).","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (C : In r all_mregs) (D : is_callee_save r = true)","proofString":"rewrite D.\nauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (C : In r all_mregs) (D : is_callee_save r = true) : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (C : In r all_mregs) (D : is_callee_save r = true)","proofString":"auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) : Val.lessdef (if is_callee_save r then ms r else Vundef) Vundef.","conclusion":"Val.lessdef (if is_callee_save r then ms r else Vundef) Vundef","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs)))","proofString":"destruct (is_callee_save r) eqn:CS; auto.\nelim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true) : Val.lessdef (ms r) Vundef.","conclusion":"Val.lessdef (ms r) Vundef","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true)","proofString":"elim n.\napply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true) : In (preg_of r) (map preg_of (filter is_callee_save all_mregs)).","conclusion":"In (preg_of r) (map preg_of (filter is_callee_save all_mregs))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true)","proofString":"apply List.in_map.\napply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true) : In r (filter is_callee_save all_mregs).","conclusion":"In r (filter is_callee_save all_mregs)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true)","proofString":"apply List.filter_In.\nauto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true) : In r all_mregs /\\ is_callee_save r = true.","conclusion":"In r all_mregs /\\ is_callee_save r = true","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (agree_sp0 : rs SP = sp) (agree_sp_def0 : sp <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) (n : ~ In (preg_of r) (map preg_of (filter is_callee_save all_mregs))) (CS : is_callee_save r = true)","proofString":"auto using all_mregs_complete."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (sp' : val) (H : agree ms sp rs) (H0 : sp' <> Vundef) : agree ms sp' rs # SP <- sp'.","conclusion":"agree ms sp' rs # SP <- sp'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (sp' : val) (H : agree ms sp rs) (H0 : sp' <> Vundef)","proofString":"inv H.\nsplit; auto.\nintros.\nrewrite Pregmap.gso; auto with asmgen."},{"statement":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : agree ms sp' rs # SP <- sp'.","conclusion":"agree ms sp' rs # SP <- sp'","hypotheses":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"split; auto.\nintros.\nrewrite Pregmap.gso; auto with asmgen."},{"statement":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r))) : forall r : mreg, Val.lessdef (ms r) (rs # SP <- sp' (preg_of r)).","conclusion":"forall r : mreg, Val.lessdef (ms r) (rs # SP <- sp' (preg_of r))","hypotheses":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r : mreg, Val.lessdef (ms r) (rs (preg_of r)))","proofString":"intros.\nrewrite Pregmap.gso; auto with asmgen."},{"statement":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg) : Val.lessdef (ms r) (rs # SP <- sp' (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs # SP <- sp' (preg_of r))","hypotheses":"(ms : Mach.regset) (rs : regset) (sp' : val) (H0 : sp' <> Vundef) (agree_sp_def0 : rs SP <> Vundef) (agree_mregs0 : forall r0 : mreg, Val.lessdef (ms r0) (rs (preg_of r0))) (r : mreg)","proofString":"rewrite Pregmap.gso; auto with asmgen."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (l : loc) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : Mach.extcall_arg ms m sp l v) : exists v' : val, extcall_arg rs m' l v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, extcall_arg rs m' l v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (l : loc) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : Mach.extcall_arg ms m sp l v)","proofString":"inv H1.\nexists (rs#(preg_of r)); split.\nconstructor.\neapply preg_val; eauto.\nunfold load_stack in H2.\nexploit Mem.loadv_extends; eauto.\nintros [v' [A B]].\nrewrite (sp_val _ _ _ H) in A.\nexists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg) : exists v' : val, extcall_arg rs m' (R r) v' /\\ Val.lessdef (ms r) v'.","conclusion":"exists v' : val, extcall_arg rs m' (R r) v' /\\ Val.lessdef (ms r) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg)","proofString":"exists (rs#(preg_of r)); split.\nconstructor.\neapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg) : extcall_arg rs m' (R r) (rs (preg_of r)).","conclusion":"extcall_arg rs m' (R r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg)","proofString":"constructor."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg) : Val.lessdef (ms r) (rs (preg_of r)).","conclusion":"Val.lessdef (ms r) (rs (preg_of r))","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (r : mreg)","proofString":"eapply preg_val; eauto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : load_stack m sp ty (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs)) = Some v) : exists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : load_stack m sp ty (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs)) = Some v)","proofString":"unfold load_stack in H2.\nexploit Mem.loadv_extends; eauto.\nintros [v' [A B]].\nrewrite (sp_val _ _ _ H) in A.\nexists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) : exists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v)","proofString":"exploit Mem.loadv_extends; eauto.\nintros [v' [A B]].\nrewrite (sp_val _ _ _ H) in A.\nexists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) : (exists v2 : val,\n   Mem.loadv (chunk_of_type ty) m'\n     (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\n   Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'.","conclusion":"(exists v2 : val,\n   Mem.loadv (chunk_of_type ty) m'\n     (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\n   Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v)","proofString":"intros [v' [A B]].\nrewrite (sp_val _ _ _ H) in A.\nexists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v') : exists v'0 : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v'0 /\\ Val.lessdef v v'0.","conclusion":"exists v'0 : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v'0 /\\ Val.lessdef v v'0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v')","proofString":"rewrite (sp_val _ _ _ H) in A.\nexists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr (rs SP) (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v') : exists v'0 : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v'0 /\\ Val.lessdef v v'0.","conclusion":"exists v'0 : val,\n  extcall_arg rs m' (Locations.S Outgoing ofs ty) v'0 /\\ Val.lessdef v v'0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr (rs SP) (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v')","proofString":"exists v'; split; auto.\neconstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr (rs SP) (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v') : extcall_arg rs m' (Locations.S Outgoing ofs ty) v'.","conclusion":"extcall_arg rs m' (Locations.S Outgoing ofs ty) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (ofs : Z) (ty : typ) (H2 : Mem.loadv (chunk_of_type ty) m\n  (Val.offset_ptr sp (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v) (v' : val) (A : Mem.loadv (chunk_of_type ty) m'\n  (Val.offset_ptr (rs SP) (Ptrofs.repr (Stacklayout.fe_ofs_arg + 4 * ofs))) =\nSome v') (B : Val.lessdef v v')","proofString":"econstructor.\neauto.\nassumption."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (p : rpair loc) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : Mach.extcall_arg_pair ms m sp p v) : exists v' : val, extcall_arg_pair rs m' p v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, extcall_arg_pair rs m' p v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (p : rpair loc) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : Mach.extcall_arg_pair ms m sp p v)","proofString":"inv H1.\nexploit extcall_arg_match; eauto.\nintros (v' & A & B).\nexists v'; split; auto.\nconstructor; auto.\nexploit extcall_arg_match.\neauto.\neauto.\neexact H2.\nintros (v1 & A1 & B1).\nexploit extcall_arg_match.\neauto.\neauto.\neexact H3.\nintros (v2 & A2 & B2).\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) : exists v' : val, extcall_arg_pair rs m' (One l) v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, extcall_arg_pair rs m' (One l) v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v)","proofString":"exploit extcall_arg_match; eauto.\nintros (v' & A & B).\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) : (exists v' : val, extcall_arg rs m' l v' /\\ Val.lessdef v v') ->\nexists v' : val, extcall_arg_pair rs m' (One l) v' /\\ Val.lessdef v v'.","conclusion":"(exists v' : val, extcall_arg rs m' l v' /\\ Val.lessdef v v') ->\nexists v' : val, extcall_arg_pair rs m' (One l) v' /\\ Val.lessdef v v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v)","proofString":"intros (v' & A & B).\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) (v' : val) (A : extcall_arg rs m' l v') (B : Val.lessdef v v') : exists v'0 : val, extcall_arg_pair rs m' (One l) v'0 /\\ Val.lessdef v v'0.","conclusion":"exists v'0 : val, extcall_arg_pair rs m' (One l) v'0 /\\ Val.lessdef v v'0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) (v' : val) (A : extcall_arg rs m' l v') (B : Val.lessdef v v')","proofString":"exists v'; split; auto.\nconstructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) (v' : val) (A : extcall_arg rs m' l v') (B : Val.lessdef v v') : extcall_arg_pair rs m' (One l) v'.","conclusion":"extcall_arg_pair rs m' (One l) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (v : val) (H : agree ms sp rs) (H0 : Mem.extends m m') (l : loc) (H2 : Mach.extcall_arg ms m sp l v) (v' : val) (A : extcall_arg rs m' l v') (B : Val.lessdef v v')","proofString":"constructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) : exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo)","proofString":"exploit extcall_arg_match.\neauto.\neauto.\neexact H2.\nintros (v1 & A1 & B1).\nexploit extcall_arg_match.\neauto.\neauto.\neexact H3.\nintros (v2 & A2 & B2).\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) : exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1)","proofString":"exploit extcall_arg_match.\neauto.\neauto.\neexact H3.\nintros (v2 & A2 & B2).\nexists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2) : exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'.","conclusion":"exists v' : val,\n  extcall_arg_pair rs m' (Twolong hi lo) v' /\\\n  Val.lessdef (Val.longofwords vhi vlo) v'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2)","proofString":"exists (Val.longofwords v1 v2); split.\nconstructor; auto.\napply Val.longofwords_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2) : extcall_arg_pair rs m' (Twolong hi lo) (Val.longofwords v1 v2).","conclusion":"extcall_arg_pair rs m' (Twolong hi lo) (Val.longofwords v1 v2)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2)","proofString":"constructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2) : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1 v2).","conclusion":"Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords v1 v2)","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (hi lo : loc) (vhi vlo : val) (H2 : Mach.extcall_arg ms m sp hi vhi) (H3 : Mach.extcall_arg ms m sp lo vlo) (v1 : val) (A1 : extcall_arg rs m' hi v1) (B1 : Val.lessdef vhi v1) (v2 : val) (A2 : extcall_arg rs m' lo v2) (B2 : Val.lessdef vlo v2)","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') nil vl' /\\ Val.lessdef_list nil vl'.","conclusion":"exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') nil vl' /\\ Val.lessdef_list nil vl'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m')","proofString":"exists (@nil val); split.\nconstructor.\nconstructor."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') : list_forall2 (extcall_arg_pair rs m') nil nil.","conclusion":"list_forall2 (extcall_arg_pair rs m') nil nil","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m')","proofString":"constructor."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') : Val.lessdef_list nil nil.","conclusion":"Val.lessdef_list nil nil","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m')","proofString":"constructor."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl') : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl')","proofString":"exploit extcall_arg_pair_match; eauto.\nintros [v1' [A B]].\ndestruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl') : (exists v' : val, extcall_arg_pair rs m' a1 v' /\\ Val.lessdef b1 v') ->\nexists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"(exists v' : val, extcall_arg_pair rs m' a1 v' /\\ Val.lessdef b1 v') ->\nexists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl')","proofString":"intros [v1' [A B]].\ndestruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl') (v1' : val) (A : extcall_arg_pair rs m' a1 v1') (B : Val.lessdef b1 v1') : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (IHlist_forall2 : exists vl' : list val,\n  list_forall2 (extcall_arg_pair rs m') al vl' /\\ Val.lessdef_list bl vl') (v1' : val) (A : extcall_arg_pair rs m' a1 v1') (B : Val.lessdef b1 v1')","proofString":"destruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (vl' : list val) (C : list_forall2 (extcall_arg_pair rs m') al vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : extcall_arg_pair rs m' a1 v1') (B : Val.lessdef b1 v1') : exists vl'0 : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  list_forall2 (extcall_arg_pair rs m') (a1 :: al) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : rpair loc) (al : list (rpair loc)) (b1 : val) (bl : list val) (H1 : Mach.extcall_arg_pair ms m sp a1 b1) (H2 : list_forall2 (Mach.extcall_arg_pair ms m sp) al bl) (vl' : list val) (C : list_forall2 (extcall_arg_pair rs m') al vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : extcall_arg_pair rs m' a1 v1') (B : Val.lessdef b1 v1')","proofString":"exists (v1' :: vl'); split; constructor; auto."},{"statement":"(ms : Mach.regset) (m m' : mem) (sp : val) (rs : regset) (sg : signature) (args : list val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : list_forall2 (Mach.extcall_arg_pair ms m sp) (loc_arguments sg) args) : exists args' : list val,\n  list_forall2 (extcall_arg_pair rs m') (loc_arguments sg) args' /\\\n  Val.lessdef_list args args'.","conclusion":"exists args' : list val,\n  list_forall2 (extcall_arg_pair rs m') (loc_arguments sg) args' /\\\n  Val.lessdef_list args args'","hypotheses":"(ms : Mach.regset) (m m' : mem) (sp : val) (rs : regset) (sg : signature) (args : list val) (H : agree ms sp rs) (H0 : Mem.extends m m') (H1 : list_forall2 (Mach.extcall_arg_pair ms m sp) (loc_arguments sg) args)","proofString":"eapply extcall_args_match; eauto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') : exists vl' : list val,\n  eval_builtin_args ge rs sp m' nil vl' /\\ Val.lessdef_list nil vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs sp m' nil vl' /\\ Val.lessdef_list nil vl'","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m')","proofString":"exists (@nil val); split; constructor."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl') : exists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl')","proofString":"exploit (@eval_builtin_arg_lessdef _ ge ms (fun r => rs (preg_of r))); eauto.\nintros; eapply preg_val; eauto.\nintros (v1' & A & B).\ndestruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto.\napply builtin_arg_match; auto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl') : forall x : RegEq.t, Val.lessdef (ms x) (rs (preg_of x)).","conclusion":"forall x : RegEq.t, Val.lessdef (ms x) (rs (preg_of x))","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl')","proofString":"intros; eapply preg_val; eauto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl') : (exists v2 : val,\n   eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v2 /\\\n   Val.lessdef b1 v2) ->\nexists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"(exists v2 : val,\n   eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v2 /\\\n   Val.lessdef b1 v2) ->\nexists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl')","proofString":"intros (v1' & A & B).\ndestruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto.\napply builtin_arg_match; auto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1') : exists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'.","conclusion":"exists vl' : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list (b1 :: bl) vl'","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (IHlist_forall2 : exists vl' : list val,\n  eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl' /\\\n  Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1')","proofString":"destruct IHlist_forall2 as [vl' [C D]].\nexists (v1' :: vl'); split; constructor; auto.\napply builtin_arg_match; auto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (vl' : list val) (C : eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1') : exists vl'0 : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0.","conclusion":"exists vl'0 : list val,\n  eval_builtin_args ge rs sp m'\n    (map_builtin_arg preg_of a1 :: map (map_builtin_arg preg_of) al) vl'0 /\\\n  Val.lessdef_list (b1 :: bl) vl'0","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (vl' : list val) (C : eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1')","proofString":"exists (v1' :: vl'); split; constructor; auto.\napply builtin_arg_match; auto."},{"statement":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (vl' : list val) (C : eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1') : eval_builtin_arg ge rs sp m' (map_builtin_arg preg_of a1) v1'.","conclusion":"eval_builtin_arg ge rs sp m' (map_builtin_arg preg_of a1) v1'","hypotheses":"(ge : Senv.t) (ms : Mach.regset) (sp : val) (rs : regset) (m m' : mem) (H : agree ms sp rs) (H0 : Mem.extends m m') (a1 : builtin_arg RegEq.t) (al : list (builtin_arg RegEq.t)) (b1 : val) (bl : list val) (H1 : eval_builtin_arg ge ms sp m a1 b1) (H2 : list_forall2 (eval_builtin_arg ge ms sp m) al bl) (vl' : list val) (C : eval_builtin_args ge rs sp m' (map (map_builtin_arg preg_of) al) vl') (D : Val.lessdef_list bl vl') (v1' : val) (A : eval_builtin_arg ge (fun r : RegEq.t => rs (preg_of r)) sp m' a1 v1') (B : Val.lessdef b1 v1')","proofString":"apply builtin_arg_match; auto."},{"statement":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Regmap.set x v ms) sp rs # (preg_of x) <- v'.","conclusion":"agree (Regmap.set x v ms) sp rs # (preg_of x) <- v'","hypotheses":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"eapply agree_set_mreg; eauto.\nrewrite Pregmap.gss.\nauto.\nintros.\napply Pregmap.gso; auto."},{"statement":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef v (rs # (preg_of x) <- v' (preg_of x)).","conclusion":"Val.lessdef v (rs # (preg_of x) <- v' (preg_of x))","hypotheses":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"rewrite Pregmap.gss.\nauto."},{"statement":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef v v'.","conclusion":"Val.lessdef v v'","hypotheses":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"auto."},{"statement":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : forall r' : preg,\ndata_preg r' = true -> r' <> preg_of x -> rs # (preg_of x) <- v' r' = rs r'.","conclusion":"forall r' : preg,\ndata_preg r' = true -> r' <> preg_of x -> rs # (preg_of x) <- v' r' = rs r'","hypotheses":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"intros.\napply Pregmap.gso; auto."},{"statement":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') (r' : preg) (H1 : data_preg r' = true) (H2 : r' <> preg_of x) : rs # (preg_of x) <- v' r' = rs r'.","conclusion":"rs # (preg_of x) <- v' r' = rs r'","hypotheses":"(x : mreg) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') (r' : preg) (H1 : data_preg r' = true) (H2 : r' <> preg_of x)","proofString":"apply Pregmap.gso; auto."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree ms sp rs.","conclusion":"agree ms sp rs","hypotheses":"(ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree\n  (Mach.set_res res2 (Val.loword v) (Mach.set_res res1 (Val.hiword v) ms)) sp\n  (set_res (map_builtin_res preg_of res2) (Val.loword v')\n     (set_res (map_builtin_res preg_of res1) (Val.hiword v') rs)).","conclusion":"agree\n  (Mach.set_res res2 (Val.loword v) (Mach.set_res res1 (Val.hiword v) ms)) sp\n  (set_res (map_builtin_res preg_of res2) (Val.loword v')\n     (set_res (map_builtin_res preg_of res1) (Val.hiword v') rs))","hypotheses":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply IHres2.\napply IHres1.\nauto.\napply Val.hiword_lessdef; auto.\napply Val.loword_lessdef; auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree (Mach.set_res res1 (Val.hiword v) ms) sp\n  (set_res (map_builtin_res preg_of res1) (Val.hiword v') rs).","conclusion":"agree (Mach.set_res res1 (Val.hiword v) ms) sp\n  (set_res (map_builtin_res preg_of res1) (Val.hiword v') rs)","hypotheses":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply IHres1.\nauto.\napply Val.hiword_lessdef; auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : agree ms sp rs.","conclusion":"agree ms sp rs","hypotheses":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef (Val.hiword v) (Val.hiword v').","conclusion":"Val.lessdef (Val.hiword v) (Val.hiword v')","hypotheses":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply Val.hiword_lessdef; auto."},{"statement":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v') : Val.lessdef (Val.loword v) (Val.loword v').","conclusion":"Val.lessdef (Val.loword v) (Val.loword v')","hypotheses":"(res1 res2 : builtin_res mreg) (IHres1 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res1 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res1) v'0 rs0)) (IHres2 : forall (ms0 : Mach.regset) (sp0 : val) (rs0 : regset) (v0 v'0 : val),\nagree ms0 sp0 rs0 ->\nVal.lessdef v0 v'0 ->\nagree (Mach.set_res res2 v0 ms0) sp0\n  (set_res (map_builtin_res preg_of res2) v'0 rs0)) (ms : Mach.regset) (sp : val) (rs : regset) (v v' : val) (H : agree ms sp rs) (H0 : Val.lessdef v v')","proofString":"apply Val.loword_lessdef; auto."},{"statement":"(r : preg) (x : mreg) (v : val) (rs : regset) (H : data_preg r = false) : rs # (preg_of x) <- v r = rs r.","conclusion":"rs # (preg_of x) <- v r = rs r","hypotheses":"(r : preg) (x : mreg) (v : val) (rs : regset) (H : data_preg r = false)","proofString":"apply Pregmap.gso.\nred; intros; subst r.\nrewrite preg_of_data in H; discriminate."},{"statement":"(r : preg) (x : mreg) (v : val) (rs : regset) (H : data_preg r = false) : r <> preg_of x.","conclusion":"r <> preg_of x","hypotheses":"(r : preg) (x : mreg) (v : val) (rs : regset) (H : data_preg r = false)","proofString":"red; intros; subst r.\nrewrite preg_of_data in H; discriminate."},{"statement":"(x : mreg) (v : val) (rs : regset) (H : data_preg (preg_of x) = false) : False.","conclusion":"False","hypotheses":"(x : mreg) (v : val) (rs : regset) (H : data_preg (preg_of x) = false)","proofString":"rewrite preg_of_data in H; discriminate."},{"statement":"(r : preg) (v : val) (rs : regset) (H : data_preg r = false) : rs r = rs r.","conclusion":"rs r = rs r","hypotheses":"(r : preg) (v : val) (rs : regset) (H : data_preg r = false)","proofString":"auto."},{"statement":"(r : preg) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (rs0 : regset),\ndata_preg r = false ->\nset_res (map_builtin_res preg_of res1) v0 rs0 r = rs0 r) (IHres2 : forall (v0 : val) (rs0 : regset),\ndata_preg r = false ->\nset_res (map_builtin_res preg_of res2) v0 rs0 r = rs0 r) (v : val) (rs : regset) (H : data_preg r = false) : set_res (map_builtin_res preg_of res2) (Val.loword v)\n  (set_res (map_builtin_res preg_of res1) (Val.hiword v) rs) r = \nrs r.","conclusion":"set_res (map_builtin_res preg_of res2) (Val.loword v)\n  (set_res (map_builtin_res preg_of res1) (Val.hiword v) rs) r = \nrs r","hypotheses":"(r : preg) (res1 res2 : builtin_res mreg) (IHres1 : forall (v0 : val) (rs0 : regset),\ndata_preg r = false ->\nset_res (map_builtin_res preg_of res1) v0 rs0 r = rs0 r) (IHres2 : forall (v0 : val) (rs0 : regset),\ndata_preg r = false ->\nset_res (map_builtin_res preg_of res2) v0 rs0 r = rs0 r) (v : val) (rs : regset) (H : data_preg r = false)","proofString":"rewrite IHres2, IHres1; auto."},{"statement":"Z -> forall i : instruction, None = Some i -> False.","conclusion":"Z -> forall i : instruction, None = Some i -> False","hypotheses":"","proofString":"intros; discriminate."},{"statement":"(a : instruction) (c : list instruction) (IHc : forall (pos : Z) (i : instruction), find_instr pos c = Some i -> In i c) : forall (pos : Z) (i : instruction),\n(if zeq pos 0 then Some a else find_instr (pos - 1) c) = Some i ->\na = i \\/ In i c.","conclusion":"forall (pos : Z) (i : instruction),\n(if zeq pos 0 then Some a else find_instr (pos - 1) c) = Some i ->\na = i \\/ In i c","hypotheses":"(a : instruction) (c : list instruction) (IHc : forall (pos : Z) (i : instruction), find_instr pos c = Some i -> In i c)","proofString":"intros until i.\ncase (zeq pos 0); intros.\nleft; congruence.\nright; eauto."},{"statement":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction) : (if zeq pos 0 then Some a else find_instr (pos - 1) c) = Some i ->\na = i \\/ In i c.","conclusion":"(if zeq pos 0 then Some a else find_instr (pos - 1) c) = Some i ->\na = i \\/ In i c","hypotheses":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction)","proofString":"case (zeq pos 0); intros.\nleft; congruence.\nright; eauto."},{"statement":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction) (e : pos = 0) (H : Some a = Some i) : a = i \\/ In i c.","conclusion":"a = i \\/ In i c","hypotheses":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction) (e : pos = 0) (H : Some a = Some i)","proofString":"left; congruence."},{"statement":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction) (n : pos <> 0) (H : find_instr (pos - 1) c = Some i) : a = i \\/ In i c.","conclusion":"a = i \\/ In i c","hypotheses":"(a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (i0 : instruction), find_instr pos0 c = Some i0 -> In i0 c) (pos : Z) (i : instruction) (n : pos <> 0) (H : find_instr (pos - 1) c = Some i)","proofString":"right; eauto."},{"statement":"(c : code) : 0 >= 0.","conclusion":"0 >= 0","hypotheses":"(c : code)","proofString":"lia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : pos >= 0) : pos + 1 >= 0.","conclusion":"pos + 1 >= 0","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : pos >= 0)","proofString":"lia."},{"statement":"(i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos nil (i :: c2)) : None = Some i.","conclusion":"None = Some i","hypotheses":"(i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos nil (i :: c2))","proofString":"inv H."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2)) : (if zeq pos 0 then Some a else find_instr (pos - 1) c1) = Some i.","conclusion":"(if zeq pos 0 then Some a else find_instr (pos - 1) c1) = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2))","proofString":"destruct (zeq pos 0).\nsubst pos.\ninv H.\nauto.\ngeneralize (code_tail_pos _ _ _ H4).\nintro.\nextlia.\ninv H.\ncongruence.\nreplace (pos0 + 1 - 1) with pos0 by lia.\neauto."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2)) (e : pos = 0) : Some a = Some i.","conclusion":"Some a = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2)) (e : pos = 0)","proofString":"subst pos.\ninv H.\nauto.\ngeneralize (code_tail_pos _ _ _ H4).\nintro.\nextlia."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (H : code_tail 0 (a :: c1) (i :: c2)) : Some a = Some i.","conclusion":"Some a = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (H : code_tail 0 (a :: c1) (i :: c2))","proofString":"inv H.\nauto.\ngeneralize (code_tail_pos _ _ _ H4).\nintro.\nextlia."},{"statement":"(c2 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c2 (i0 :: c0) -> find_instr pos c2 = Some i0) (i : instruction) : Some i = Some i.","conclusion":"Some i = Some i","hypotheses":"(c2 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c2 (i0 :: c0) -> find_instr pos c2 = Some i0) (i : instruction)","proofString":"auto."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0) : Some a = Some i.","conclusion":"Some a = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0)","proofString":"generalize (code_tail_pos _ _ _ H4).\nintro.\nextlia."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0) : pos >= 0 -> Some a = Some i.","conclusion":"pos >= 0 -> Some a = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0)","proofString":"intro.\nextlia."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0) (H : pos >= 0) : Some a = Some i.","conclusion":"Some a = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H4 : code_tail pos c1 (i :: c2)) (H0 : pos + 1 = 0) (H : pos >= 0)","proofString":"extlia."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2)) (n : pos <> 0) : find_instr (pos - 1) c1 = Some i.","conclusion":"find_instr (pos - 1) c1 = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos0 : Z),\ncode_tail pos0 c1 (i0 :: c0) -> find_instr pos0 c1 = Some i0) (i : instruction) (c2 : list instruction) (pos : Z) (H : code_tail pos (a :: c1) (i :: c2)) (n : pos <> 0)","proofString":"inv H.\ncongruence.\nreplace (pos0 + 1 - 1) with pos0 by lia.\neauto."},{"statement":"(c2 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c2 (i0 :: c0) -> find_instr pos c2 = Some i0) (i : instruction) (n : 0 <> 0) : find_instr (0 - 1) c2 = Some i.","conclusion":"find_instr (0 - 1) c2 = Some i","hypotheses":"(c2 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c2 (i0 :: c0) -> find_instr pos c2 = Some i0) (i : instruction) (n : 0 <> 0)","proofString":"congruence."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (pos0 : Z) (n : pos0 + 1 <> 0) (H4 : code_tail pos0 c1 (i :: c2)) : find_instr (pos0 + 1 - 1) c1 = Some i.","conclusion":"find_instr (pos0 + 1 - 1) c1 = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (pos0 : Z) (n : pos0 + 1 <> 0) (H4 : code_tail pos0 c1 (i :: c2))","proofString":"replace (pos0 + 1 - 1) with pos0 by lia.\neauto."},{"statement":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (pos0 : Z) (n : pos0 + 1 <> 0) (H4 : code_tail pos0 c1 (i :: c2)) : find_instr pos0 c1 = Some i.","conclusion":"find_instr pos0 c1 = Some i","hypotheses":"(a : instruction) (c1 : list instruction) (IHc1 : forall (i0 : instruction) (c0 : list instruction) (pos : Z),\ncode_tail pos c1 (i0 :: c0) -> find_instr pos c1 = Some i0) (i : instruction) (c2 : list instruction) (pos0 : Z) (n : pos0 + 1 <> 0) (H4 : code_tail pos0 c1 (i :: c2))","proofString":"eauto."},{"statement":"(c : code) : 0 <= 0 <= list_length_z c.","conclusion":"0 <= 0 <= list_length_z c","hypotheses":"(c : code)","proofString":"generalize (list_length_z_pos c).\nlia."},{"statement":"(c : code) : list_length_z c >= 0 -> 0 <= 0 <= list_length_z c.","conclusion":"list_length_z c >= 0 -> 0 <= 0 <= list_length_z c","hypotheses":"(c : code)","proofString":"lia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : 0 <= pos <= list_length_z c1) : 0 <= pos + 1 <= list_length_z (i :: c1).","conclusion":"0 <= pos + 1 <= list_length_z (i :: c1)","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : 0 <= pos <= list_length_z c1)","proofString":"rewrite list_length_z_cons.\nlia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : 0 <= pos <= list_length_z c1) : 0 <= pos + 1 <= list_length_z c1 + 1.","conclusion":"0 <= pos + 1 <= list_length_z c1 + 1","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : 0 <= pos <= list_length_z c1)","proofString":"lia."},{"statement":"forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> 0 <= ofs < list_length_z fn.","conclusion":"forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> 0 <= ofs < list_length_z fn","hypotheses":"","proofString":"induction 1; intros; simpl.\nrewrite H.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c').\nlia.\nrewrite list_length_z_cons.\ngeneralize (IHcode_tail _ _ H0).\nlia."},{"statement":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c') : 0 <= 0 < list_length_z c.","conclusion":"0 <= 0 < list_length_z c","hypotheses":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c')","proofString":"rewrite H.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c').\nlia."},{"statement":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c') : 0 <= 0 < list_length_z (i :: c').","conclusion":"0 <= 0 < list_length_z (i :: c')","hypotheses":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c')","proofString":"rewrite list_length_z_cons.\ngeneralize (list_length_z_pos c').\nlia."},{"statement":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c') : 0 <= 0 < list_length_z c' + 1.","conclusion":"0 <= 0 < list_length_z c' + 1","hypotheses":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c')","proofString":"generalize (list_length_z_pos c').\nlia."},{"statement":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c') : list_length_z c' >= 0 -> 0 <= 0 < list_length_z c' + 1.","conclusion":"list_length_z c' >= 0 -> 0 <= 0 < list_length_z c' + 1","hypotheses":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c')","proofString":"lia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c') : 0 <= pos + 1 < list_length_z (i :: c1).","conclusion":"0 <= pos + 1 < list_length_z (i :: c1)","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c')","proofString":"rewrite list_length_z_cons.\ngeneralize (IHcode_tail _ _ H0).\nlia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c') : 0 <= pos + 1 < list_length_z c1 + 1.","conclusion":"0 <= pos + 1 < list_length_z c1 + 1","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c')","proofString":"generalize (IHcode_tail _ _ H0).\nlia."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c') : 0 <= pos < list_length_z c1 -> 0 <= pos + 1 < list_length_z c1 + 1.","conclusion":"0 <= pos < list_length_z c1 -> 0 <= pos + 1 < list_length_z c1 + 1","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> 0 <= pos < list_length_z c1) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c')","proofString":"lia."},{"statement":"(H : forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> 0 <= ofs < list_length_z fn) : forall (fn : code) (ofs : Z) (i : instruction) (c : list instruction),\ncode_tail ofs fn (i :: c) -> 0 <= ofs < list_length_z fn.","conclusion":"forall (fn : code) (ofs : Z) (i : instruction) (c : list instruction),\ncode_tail ofs fn (i :: c) -> 0 <= ofs < list_length_z fn","hypotheses":"(H : forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> 0 <= ofs < list_length_z fn)","proofString":"eauto."},{"statement":"forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> code_tail (ofs + 1) fn c'.","conclusion":"forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> code_tail (ofs + 1) fn c'","hypotheses":"","proofString":"induction 1; intros.\nsubst c.\nconstructor.\nconstructor.\nconstructor.\neauto."},{"statement":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c') : code_tail (0 + 1) c c'.","conclusion":"code_tail (0 + 1) c c'","hypotheses":"(c : code) (i : instruction) (c' : list instruction) (H : c = i :: c')","proofString":"subst c.\nconstructor.\nconstructor."},{"statement":"(i : instruction) (c' : list instruction) : code_tail (0 + 1) (i :: c') c'.","conclusion":"code_tail (0 + 1) (i :: c') c'","hypotheses":"(i : instruction) (c' : list instruction)","proofString":"constructor.\nconstructor."},{"statement":"(i : instruction) (c' : list instruction) : code_tail 0 c' c'.","conclusion":"code_tail 0 c' c'","hypotheses":"(i : instruction) (c' : list instruction)","proofString":"constructor."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> code_tail (pos + 1) c1 c'0) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c') : code_tail (pos + 1 + 1) (i :: c1) c'.","conclusion":"code_tail (pos + 1 + 1) (i :: c1) c'","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> code_tail (pos + 1) c1 c'0) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c')","proofString":"constructor.\neauto."},{"statement":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> code_tail (pos + 1) c1 c'0) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c') : code_tail (pos + 1) c1 c'.","conclusion":"code_tail (pos + 1) c1 c'","hypotheses":"(pos : Z) (i : instruction) (c1 c2 : code) (H : code_tail pos c1 c2) (IHcode_tail : forall (i1 : instruction) (c'0 : list instruction),\nc2 = i1 :: c'0 -> code_tail (pos + 1) c1 c'0) (i0 : instruction) (c' : list instruction) (H0 : c2 = i0 :: c')","proofString":"eauto."},{"statement":"(H : forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> code_tail (ofs + 1) fn c') : forall (fn : code) (ofs : Z) (i : instruction) (c : list instruction),\ncode_tail ofs fn (i :: c) -> code_tail (ofs + 1) fn c.","conclusion":"forall (fn : code) (ofs : Z) (i : instruction) (c : list instruction),\ncode_tail ofs fn (i :: c) -> code_tail (ofs + 1) fn c","hypotheses":"(H : forall (ofs : Z) (fn c : code),\ncode_tail ofs fn c ->\nforall (i : instruction) (c' : list instruction),\nc = i :: c' -> code_tail (ofs + 1) fn c')","proofString":"eauto."},{"statement":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c)) : code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) fn c.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) fn c","hypotheses":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c))","proofString":"rewrite Ptrofs.add_unsigned, Ptrofs.unsigned_one.\nrewrite Ptrofs.unsigned_repr.\napply code_tail_next with i; auto.\ngeneralize (code_tail_bounds_2 _ _ _ _ H0).\nlia."},{"statement":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c)) : code_tail (Ptrofs.unsigned (Ptrofs.repr (Ptrofs.unsigned ofs + 1))) fn c.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.repr (Ptrofs.unsigned ofs + 1))) fn c","hypotheses":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c))","proofString":"rewrite Ptrofs.unsigned_repr.\napply code_tail_next with i; auto.\ngeneralize (code_tail_bounds_2 _ _ _ _ H0).\nlia."},{"statement":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c)) : code_tail (Ptrofs.unsigned ofs + 1) fn c.","conclusion":"code_tail (Ptrofs.unsigned ofs + 1) fn c","hypotheses":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c))","proofString":"apply code_tail_next with i; auto."},{"statement":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c)) : 0 <= Ptrofs.unsigned ofs + 1 <= Ptrofs.max_unsigned.","conclusion":"0 <= Ptrofs.unsigned ofs + 1 <= Ptrofs.max_unsigned","hypotheses":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c))","proofString":"generalize (code_tail_bounds_2 _ _ _ _ H0).\nlia."},{"statement":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c)) : 0 <= Ptrofs.unsigned ofs < list_length_z fn ->\n0 <= Ptrofs.unsigned ofs + 1 <= Ptrofs.max_unsigned.","conclusion":"0 <= Ptrofs.unsigned ofs < list_length_z fn ->\n0 <= Ptrofs.unsigned ofs + 1 <= Ptrofs.max_unsigned","hypotheses":"(fn : list instruction) (ofs : ptrofs) (i : instruction) (c : list instruction) (H : list_length_z fn <= Ptrofs.max_unsigned) (H0 : code_tail (Ptrofs.unsigned ofs) fn (i :: c))","proofString":"lia."},{"statement":"(f : Mach.function) (ep : bool) (k : code -> res code) : k nil = k nil.","conclusion":"k nil = k nil","hypotheses":"(f : Mach.function) (ep : bool) (k : code -> res code)","proofString":"auto."},{"statement":"(f : Mach.function) (a : Mach.instruction) (il : list Mach.instruction) (IHil : forall (ep0 : bool) (k0 : code -> res code),\ntransl_code_rec f il ep0 k0 = (do c <- transl_code f il ep0; k0 c)) (ep : bool) (k : code -> res code) : transl_code_rec f il (it1_is_parent ep a)\n  (fun c1 : code => do c2 <- transl_instr f a ep c1; k c2) =\n(do c <-\n (do k0 <- transl_code f il (it1_is_parent ep a); transl_instr f a ep k0);\n k c).","conclusion":"transl_code_rec f il (it1_is_parent ep a)\n  (fun c1 : code => do c2 <- transl_instr f a ep c1; k c2) =\n(do c <-\n (do k0 <- transl_code f il (it1_is_parent ep a); transl_instr f a ep k0);\n k c)","hypotheses":"(f : Mach.function) (a : Mach.instruction) (il : list Mach.instruction) (IHil : forall (ep0 : bool) (k0 : code -> res code),\ntransl_code_rec f il ep0 k0 = (do c <- transl_code f il ep0; k0 c)) (ep : bool) (k : code -> res code)","proofString":"rewrite IHil.\ndestruct (transl_code f il (it1_is_parent ep a)); simpl; auto."},{"statement":"(f : Mach.function) (a : Mach.instruction) (il : list Mach.instruction) (IHil : forall (ep0 : bool) (k0 : code -> res code),\ntransl_code_rec f il ep0 k0 = (do c <- transl_code f il ep0; k0 c)) (ep : bool) (k : code -> res code) : (do c <- transl_code f il (it1_is_parent ep a);\n do c2 <- transl_instr f a ep c; k c2) =\n(do c <-\n (do k0 <- transl_code f il (it1_is_parent ep a); transl_instr f a ep k0);\n k c).","conclusion":"(do c <- transl_code f il (it1_is_parent ep a);\n do c2 <- transl_instr f a ep c; k c2) =\n(do c <-\n (do k0 <- transl_code f il (it1_is_parent ep a); transl_instr f a ep k0);\n k c)","hypotheses":"(f : Mach.function) (a : Mach.instruction) (il : list Mach.instruction) (IHil : forall (ep0 : bool) (k0 : code -> res code),\ntransl_code_rec f il ep0 k0 = (do c <- transl_code f il ep0; k0 c)) (ep : bool) (k : code -> res code)","proofString":"destruct (transl_code f il (it1_is_parent ep a)); simpl; auto."},{"statement":"(f : Mach.function) (il : list Mach.instruction) (ep : bool) : transl_code' f il ep = transl_code f il ep.","conclusion":"transl_code' f il ep = transl_code f il ep","hypotheses":"(f : Mach.function) (il : list Mach.instruction) (ep : bool)","proofString":"unfold transl_code'.\nrewrite transl_code_rec_transl_code.\ndestruct (transl_code f il ep); auto."},{"statement":"(f : Mach.function) (il : list Mach.instruction) (ep : bool) : transl_code_rec f il ep (fun c : code => OK c) = transl_code f il ep.","conclusion":"transl_code_rec f il ep (fun c : code => OK c) = transl_code f il ep","hypotheses":"(f : Mach.function) (il : list Mach.instruction) (ep : bool)","proofString":"rewrite transl_code_rec_transl_code.\ndestruct (transl_code f il ep); auto."},{"statement":"(f : Mach.function) (il : list Mach.instruction) (ep : bool) : (do c <- transl_code f il ep; OK c) = transl_code f il ep.","conclusion":"(do c <- transl_code f il ep; OK c) = transl_code f il ep","hypotheses":"(f : Mach.function) (il : list Mach.instruction) (ep : bool)","proofString":"destruct (transl_code f il ep); auto."},{"statement":"(c : list instruction) : exists ofs : Z, code_tail ofs c c.","conclusion":"exists ofs : Z, code_tail ofs c c","hypotheses":"(c : list instruction)","proofString":"exists 0; constructor."},{"statement":"(i : instruction) (c1 c2 : list instruction) (H : is_tail c1 c2) (IHis_tail : exists ofs : Z, code_tail ofs c2 c1) : exists ofs : Z, code_tail ofs (i :: c2) c1.","conclusion":"exists ofs : Z, code_tail ofs (i :: c2) c1","hypotheses":"(i : instruction) (c1 c2 : list instruction) (H : is_tail c1 c2) (IHis_tail : exists ofs : Z, code_tail ofs c2 c1)","proofString":"destruct IHis_tail as [ofs CT].\nexists (ofs + 1); constructor; auto."},{"statement":"(i : instruction) (c1 c2 : list instruction) (H : is_tail c1 c2) (ofs : Z) (CT : code_tail ofs c2 c1) : exists ofs0 : Z, code_tail ofs0 (i :: c2) c1.","conclusion":"exists ofs0 : Z, code_tail ofs0 (i :: c2) c1","hypotheses":"(i : instruction) (c1 c2 : list instruction) (H : is_tail c1 c2) (ofs : Z) (CT : code_tail ofs c2 c1)","proofString":"exists (ofs + 1); constructor; auto."},{"statement":"(f : Mach.function) (c : list Mach.instruction) (tc2 : list instruction) (ep2 : bool) (H : transl_code f c ep2 = OK tc2) : exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c ep1 = OK tc1 /\\ is_tail tc1 tc2.","conclusion":"exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c ep1 = OK tc1 /\\ is_tail tc1 tc2","hypotheses":"(f : Mach.function) (c : list Mach.instruction) (tc2 : list instruction) (ep2 : bool) (H : transl_code f c ep2 = OK tc2)","proofString":"exists tc2; exists ep2; split; auto with coqlib."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (H0 : (do k <- transl_code f c2 (it1_is_parent ep2 i); transl_instr f i ep2 k) =\nOK tc2) : exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2.","conclusion":"exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (H0 : (do k <- transl_code f c2 (it1_is_parent ep2 i); transl_instr f i ep2 k) =\nOK tc2)","proofString":"monadInv H0.\nexploit IHis_tail; eauto.\nintros [tc1 [ep1 [A B]]].\nexists tc1; exists ep1; split.\nauto.\napply is_tail_trans with x.\nauto.\neapply transl_instr_tail; eauto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) : exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2.","conclusion":"exists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2)","proofString":"exploit IHis_tail; eauto.\nintros [tc1 [ep1 [A B]]].\nexists tc1; exists ep1; split.\nauto.\napply is_tail_trans with x.\nauto.\neapply transl_instr_tail; eauto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) : (exists (tc1 : list instruction) (ep1 : bool),\n   transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 x) ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2.","conclusion":"(exists (tc1 : list instruction) (ep1 : bool),\n   transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 x) ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc1 : list instruction) (ep1 : bool),\n  transl_code f c1 ep1 = OK tc1 /\\ is_tail tc1 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2)","proofString":"intros [tc1 [ep1 [A B]]].\nexists tc1; exists ep1; split.\nauto.\napply is_tail_trans with x.\nauto.\neapply transl_instr_tail; eauto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x) : exists (tc0 : list instruction) (ep0 : bool),\n  transl_code f c1 ep0 = OK tc0 /\\ is_tail tc0 tc2.","conclusion":"exists (tc0 : list instruction) (ep0 : bool),\n  transl_code f c1 ep0 = OK tc0 /\\ is_tail tc0 tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x)","proofString":"exists tc1; exists ep1; split.\nauto.\napply is_tail_trans with x.\nauto.\neapply transl_instr_tail; eauto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x) : transl_code f c1 ep1 = OK tc1.","conclusion":"transl_code f c1 ep1 = OK tc1","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x)","proofString":"auto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x) : is_tail tc1 tc2.","conclusion":"is_tail tc1 tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x)","proofString":"apply is_tail_trans with x.\nauto.\neapply transl_instr_tail; eauto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x) : is_tail tc1 x.","conclusion":"is_tail tc1 x","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x)","proofString":"auto."},{"statement":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x) : is_tail x tc2.","conclusion":"is_tail x tc2","hypotheses":"(f : Mach.function) (i : Mach.instruction) (c1 c2 : list Mach.instruction) (H : is_tail c1 c2) (IHis_tail : forall (tc0 : list instruction) (ep0 : bool),\ntransl_code f c2 ep0 = OK tc0 ->\nexists (tc3 : list instruction) (ep3 : bool),\n  transl_code f c1 ep3 = OK tc3 /\\ is_tail tc3 tc0) (tc2 : list instruction) (ep2 : bool) (x : list instruction) (EQ : transl_code f c2 (it1_is_parent ep2 i) = OK x) (EQ0 : transl_instr f i ep2 x = OK tc2) (tc1 : list instruction) (ep1 : bool) (A : transl_code f c1 ep1 = OK tc1) (B : is_tail tc1 x)","proofString":"eapply transl_instr_tail; eauto."},{"statement":"(a : instruction) (fn : list instruction) (IHfn : forall (c : code) (pos0 pos' : Z),\ncode_tail pos0 fn c -> code_tail pos' fn c -> pos0 = pos') (pos : Z) (H3 : code_tail pos fn (a :: fn)) : 0 = pos + 1.","conclusion":"0 = pos + 1","hypotheses":"(a : instruction) (fn : list instruction) (IHfn : forall (c : code) (pos0 pos' : Z),\ncode_tail pos0 fn c -> code_tail pos' fn c -> pos0 = pos') (pos : Z) (H3 : code_tail pos fn (a :: fn))","proofString":"generalize (code_tail_no_bigger _ _ _ H3); simpl; intro; lia."},{"statement":"(a : instruction) (fn : list instruction) (IHfn : forall (c : code) (pos pos' : Z),\ncode_tail pos fn c -> code_tail pos' fn c -> pos = pos') (pos0 : Z) (H3 : code_tail pos0 fn (a :: fn)) : pos0 + 1 = 0.","conclusion":"pos0 + 1 = 0","hypotheses":"(a : instruction) (fn : list instruction) (IHfn : forall (c : code) (pos pos' : Z),\ncode_tail pos fn c -> code_tail pos' fn c -> pos = pos') (pos0 : Z) (H3 : code_tail pos0 fn (a :: fn))","proofString":"generalize (code_tail_no_bigger _ _ _ H3); simpl; intro; lia."},{"statement":"(a : instruction) (fn : list instruction) (IHfn : forall (c0 : code) (pos1 pos' : Z),\ncode_tail pos1 fn c0 -> code_tail pos' fn c0 -> pos1 = pos') (c : code) (pos0 : Z) (H3 : code_tail pos0 fn c) (pos : Z) (H4 : code_tail pos fn c) : pos0 + 1 = pos + 1.","conclusion":"pos0 + 1 = pos + 1","hypotheses":"(a : instruction) (fn : list instruction) (IHfn : forall (c0 : code) (pos1 pos' : Z),\ncode_tail pos1 fn c0 -> code_tail pos' fn c0 -> pos1 = pos') (c : code) (pos0 : Z) (H3 : code_tail pos0 fn c) (pos : Z) (H4 : code_tail pos fn c)","proofString":"f_equal.\neauto."},{"statement":"(a : instruction) (fn : list instruction) (IHfn : forall (c0 : code) (pos1 pos' : Z),\ncode_tail pos1 fn c0 -> code_tail pos' fn c0 -> pos1 = pos') (c : code) (pos0 : Z) (H3 : code_tail pos0 fn c) (pos : Z) (H4 : code_tail pos fn c) : pos0 = pos.","conclusion":"pos0 = pos","hypotheses":"(a : instruction) (fn : list instruction) (IHfn : forall (c0 : code) (pos1 pos' : Z),\ncode_tail pos1 fn c0 -> code_tail pos' fn c0 -> pos1 = pos') (c : code) (pos0 : Z) (H3 : code_tail pos0 fn c) (pos : Z) (H4 : code_tail pos fn c)","proofString":"eauto."},{"statement":"(ge : Mach.genv) (b : block) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H : transl_code_at_pc ge (Vptr b ofs) fb f c false tf tc) (H0 : return_address_offset f c ofs') : ofs' = ofs.","conclusion":"ofs' = ofs","hypotheses":"(ge : Mach.genv) (b : block) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H : transl_code_at_pc ge (Vptr b ofs) fb f c false tf tc) (H0 : return_address_offset f c ofs')","proofString":"inv H.\nred in H0.\nexploit code_tail_unique.\neexact H12.\neapply H0; eauto.\nintro.\nrewrite <- (Ptrofs.repr_unsigned ofs).\nrewrite <- (Ptrofs.repr_unsigned ofs').\ncongruence."},{"statement":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : return_address_offset f c ofs') (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) : ofs' = ofs.","conclusion":"ofs' = ofs","hypotheses":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : return_address_offset f c ofs') (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc)","proofString":"red in H0.\nexploit code_tail_unique.\neexact H12.\neapply H0; eauto.\nintro.\nrewrite <- (Ptrofs.repr_unsigned ofs).\nrewrite <- (Ptrofs.repr_unsigned ofs').\ncongruence."},{"statement":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) : ofs' = ofs.","conclusion":"ofs' = ofs","hypotheses":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc)","proofString":"exploit code_tail_unique.\neexact H12.\neapply H0; eauto.\nintro.\nrewrite <- (Ptrofs.repr_unsigned ofs).\nrewrite <- (Ptrofs.repr_unsigned ofs').\ncongruence."},{"statement":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs') : ofs' = ofs.","conclusion":"ofs' = ofs","hypotheses":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs')","proofString":"rewrite <- (Ptrofs.repr_unsigned ofs).\nrewrite <- (Ptrofs.repr_unsigned ofs').\ncongruence."},{"statement":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs') : ofs' = Ptrofs.repr (Ptrofs.unsigned ofs).","conclusion":"ofs' = Ptrofs.repr (Ptrofs.unsigned ofs)","hypotheses":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs')","proofString":"rewrite <- (Ptrofs.repr_unsigned ofs').\ncongruence."},{"statement":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs') : Ptrofs.repr (Ptrofs.unsigned ofs') = Ptrofs.repr (Ptrofs.unsigned ofs).","conclusion":"Ptrofs.repr (Ptrofs.unsigned ofs') = Ptrofs.repr (Ptrofs.unsigned ofs)","hypotheses":"(ge : Mach.genv) (ofs : ptrofs) (fb : block) (f : Mach.function) (c : Mach.code) (tf : function) (tc : code) (ofs' : ptrofs) (H0 : forall (tf0 : function) (tc0 : list instruction),\ntransf_function f = OK tf0 ->\ntransl_code f c false = OK tc0 ->\ncode_tail (Ptrofs.unsigned ofs') (fn_code tf0) tc0) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H12 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H : Ptrofs.unsigned ofs = Ptrofs.unsigned ofs')","proofString":"congruence."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos c = Some pos' /\\\n  code_tail (pos' - pos) c c' /\\ pos < pos' <= pos + list_length_z c) : forall (pos : Z) (c' : code),\nfind_label lbl (a :: c) = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos (a :: c) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"forall (pos : Z) (c' : code),\nfind_label lbl (a :: c) = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos (a :: c) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos c = Some pos' /\\\n  code_tail (pos' - pos) c c' /\\ pos < pos' <= pos + list_length_z c)","proofString":"simpl; intros until c'.\ncase (is_label lbl a).\nintro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia.\nintros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : (if is_label lbl a then Some c else find_label lbl c) = Some c' ->\nexists pos' : Z,\n  (if is_label lbl a then Some (pos + 1) else label_pos lbl (pos + 1) c) =\n  Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"(if is_label lbl a then Some c else find_label lbl c) = Some c' ->\nexists pos' : Z,\n  (if is_label lbl a then Some (pos + 1) else label_pos lbl (pos + 1) c) =\n  Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code)","proofString":"case (is_label lbl a).\nintro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia.\nintros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : Some c = Some c' ->\nexists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"Some c = Some c' ->\nexists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code)","proofString":"intro EQ; injection EQ; intro; subst c'.\nexists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : exists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"exists pos' : Z,\n  Some (pos + 1) = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"exists (pos + 1).\nsplit.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : Some (pos + 1) = Some (pos + 1) /\\\ncode_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c).","conclusion":"Some (pos + 1) = Some (pos + 1) /\\\ncode_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"split.\nauto.\nsplit.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : Some (pos + 1) = Some (pos + 1).","conclusion":"Some (pos + 1) = Some (pos + 1)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c).","conclusion":"code_tail (pos + 1 - pos) (a :: c) c /\\\npos < pos + 1 <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"split.\nreplace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor.\nrewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (pos + 1 - pos) (a :: c) c.","conclusion":"code_tail (pos + 1 - pos) (a :: c) c","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"replace (pos + 1 - pos) with (0 + 1) by lia.\nconstructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail (0 + 1) (a :: c) c.","conclusion":"code_tail (0 + 1) (a :: c) c","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"constructor.\nconstructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : code_tail 0 c c.","conclusion":"code_tail 0 c c","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"constructor."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : pos < pos + 1 <= pos + list_length_z (a :: c).","conclusion":"pos < pos + 1 <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"rewrite list_length_z_cons.\ngeneralize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : pos < pos + 1 <= pos + (list_length_z c + 1).","conclusion":"pos < pos + 1 <= pos + (list_length_z c + 1)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"generalize (list_length_z_pos c).\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c) : list_length_z c >= 0 -> pos < pos + 1 <= pos + (list_length_z c + 1).","conclusion":"list_length_z c >= 0 -> pos < pos + 1 <= pos + (list_length_z c + 1)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c' : code),\nfind_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c' /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (EQ : Some c = Some c)","proofString":"lia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) : find_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"find_label lbl c = Some c' ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code)","proofString":"intros.\ngeneralize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') : exists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"exists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c')","proofString":"generalize (IHc (pos + 1) c' H).\nintros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') : (exists pos' : Z,\n   label_pos lbl (pos + 1) c = Some pos' /\\\n   code_tail (pos' - (pos + 1)) c c' /\\\n   pos + 1 < pos' <= pos + 1 + list_length_z c) ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c).","conclusion":"(exists pos' : Z,\n   label_pos lbl (pos + 1) c = Some pos' /\\\n   code_tail (pos' - (pos + 1)) c c' /\\\n   pos + 1 < pos' <= pos + 1 + list_length_z c) ->\nexists pos' : Z,\n  label_pos lbl (pos + 1) c = Some pos' /\\\n  code_tail (pos' - pos) (a :: c) c' /\\\n  pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos' : Z,\n  label_pos lbl pos0 c = Some pos' /\\\n  code_tail (pos' - pos0) c c'0 /\\ pos0 < pos' <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c')","proofString":"intros [pos' [A [B C]]].\nexists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : exists pos'0 : Z,\n  label_pos lbl (pos + 1) c = Some pos'0 /\\\n  code_tail (pos'0 - pos) (a :: c) c' /\\\n  pos < pos'0 <= pos + list_length_z (a :: c).","conclusion":"exists pos'0 : Z,\n  label_pos lbl (pos + 1) c = Some pos'0 /\\\n  code_tail (pos'0 - pos) (a :: c) c' /\\\n  pos < pos'0 <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"exists pos'.\nsplit.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : label_pos lbl (pos + 1) c = Some pos' /\\\ncode_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c).","conclusion":"label_pos lbl (pos + 1) c = Some pos' /\\\ncode_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"split.\nauto.\nsplit.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : label_pos lbl (pos + 1) c = Some pos'.","conclusion":"label_pos lbl (pos + 1) c = Some pos'","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c).","conclusion":"code_tail (pos' - pos) (a :: c) c' /\\\npos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"split.\nreplace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto.\nrewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - pos) (a :: c) c'.","conclusion":"code_tail (pos' - pos) (a :: c) c'","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"replace (pos' - pos) with ((pos' - (pos + 1)) + 1) by lia.\nconstructor.\nauto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - (pos + 1) + 1) (a :: c) c'.","conclusion":"code_tail (pos' - (pos + 1) + 1) (a :: c) c'","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"constructor.\nauto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : code_tail (pos' - (pos + 1)) c c'.","conclusion":"code_tail (pos' - (pos + 1)) c c'","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"auto."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : pos < pos' <= pos + list_length_z (a :: c).","conclusion":"pos < pos' <= pos + list_length_z (a :: c)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"rewrite list_length_z_cons.\nlia."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c) : pos < pos' <= pos + (list_length_z c + 1).","conclusion":"pos < pos' <= pos + (list_length_z c + 1)","hypotheses":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall (pos0 : Z) (c'0 : code),\nfind_label lbl c = Some c'0 ->\nexists pos'0 : Z,\n  label_pos lbl pos0 c = Some pos'0 /\\\n  code_tail (pos'0 - pos0) c c'0 /\\ pos0 < pos'0 <= pos0 + list_length_z c) (pos : Z) (c' : code) (H : find_label lbl c = Some c') (pos' : Z) (A : label_pos lbl (pos + 1) c = Some pos') (B : code_tail (pos' - (pos + 1)) c c') (C : pos + 1 < pos' <= pos + 1 + list_length_z c)","proofString":"lia."},{"statement":"(c : code) : is_tail c c.","conclusion":"is_tail c c","hypotheses":"(c : code)","proofString":"apply is_tail_refl."},{"statement":"(c : code) : forall lbl : label, find_label lbl c = find_label lbl c.","conclusion":"forall lbl : label, find_label lbl c = find_label lbl c","hypotheses":"(c : code)","proofString":"auto."},{"statement":"(c1 c2 c3 : code) (H : tail_nolabel c2 c3) (H0 : tail_nolabel c1 c2) : tail_nolabel c1 c3.","conclusion":"tail_nolabel c1 c3","hypotheses":"(c1 c2 c3 : code) (H : tail_nolabel c2 c3) (H0 : tail_nolabel c1 c2)","proofString":"destruct H; destruct H0; split.\neapply is_tail_trans; eauto.\nintros.\nrewrite H1; auto."},{"statement":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl : label, find_label lbl c3 = find_label lbl c2) (H0 : is_tail c1 c2) (H2 : forall lbl : label, find_label lbl c2 = find_label lbl c1) : is_tail c1 c3.","conclusion":"is_tail c1 c3","hypotheses":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl : label, find_label lbl c3 = find_label lbl c2) (H0 : is_tail c1 c2) (H2 : forall lbl : label, find_label lbl c2 = find_label lbl c1)","proofString":"eapply is_tail_trans; eauto."},{"statement":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl : label, find_label lbl c3 = find_label lbl c2) (H0 : is_tail c1 c2) (H2 : forall lbl : label, find_label lbl c2 = find_label lbl c1) : forall lbl : label, find_label lbl c3 = find_label lbl c1.","conclusion":"forall lbl : label, find_label lbl c3 = find_label lbl c1","hypotheses":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl : label, find_label lbl c3 = find_label lbl c2) (H0 : is_tail c1 c2) (H2 : forall lbl : label, find_label lbl c2 = find_label lbl c1)","proofString":"intros.\nrewrite H1; auto."},{"statement":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl0 : label, find_label lbl0 c3 = find_label lbl0 c2) (H0 : is_tail c1 c2) (H2 : forall lbl0 : label, find_label lbl0 c2 = find_label lbl0 c1) (lbl : label) : find_label lbl c3 = find_label lbl c1.","conclusion":"find_label lbl c3 = find_label lbl c1","hypotheses":"(c1 c2 c3 : code) (H : is_tail c2 c3) (H1 : forall lbl0 : label, find_label lbl0 c3 = find_label lbl0 c2) (H0 : is_tail c1 c2) (H2 : forall lbl0 : label, find_label lbl0 c2 = find_label lbl0 c1) (lbl : label)","proofString":"rewrite H1; auto."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : tail_nolabel k c) : tail_nolabel k (i :: c).","conclusion":"tail_nolabel k (i :: c)","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : tail_nolabel k c)","proofString":"destruct H0.\nsplit.\nconstructor; auto.\nintros.\nsimpl.\nrewrite <- H1.\ndestruct i; reflexivity || contradiction."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k) : tail_nolabel k (i :: c).","conclusion":"tail_nolabel k (i :: c)","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k)","proofString":"split.\nconstructor; auto.\nintros.\nsimpl.\nrewrite <- H1.\ndestruct i; reflexivity || contradiction."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k) : is_tail k (i :: c).","conclusion":"is_tail k (i :: c)","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k)","proofString":"constructor; auto."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k) : forall lbl : label, find_label lbl (i :: c) = find_label lbl k.","conclusion":"forall lbl : label, find_label lbl (i :: c) = find_label lbl k","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl : label, find_label lbl c = find_label lbl k)","proofString":"intros.\nsimpl.\nrewrite <- H1.\ndestruct i; reflexivity || contradiction."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label) : find_label lbl (i :: c) = find_label lbl k.","conclusion":"find_label lbl (i :: c) = find_label lbl k","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label)","proofString":"simpl.\nrewrite <- H1.\ndestruct i; reflexivity || contradiction."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label) : (if is_label lbl i then Some c else find_label lbl c) = find_label lbl k.","conclusion":"(if is_label lbl i then Some c else find_label lbl c) = find_label lbl k","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label)","proofString":"rewrite <- H1.\ndestruct i; reflexivity || contradiction."},{"statement":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label) : (if is_label lbl i then Some c else find_label lbl c) = find_label lbl c.","conclusion":"(if is_label lbl i then Some c else find_label lbl c) = find_label lbl c","hypotheses":"(i : instruction) (c k : code) (H : nolabel i) (H0 : is_tail k c) (H1 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) (lbl : label)","proofString":"destruct i; reflexivity || contradiction."},{"statement":"(lbl : label) (k c : code) (H : tail_nolabel k c) : find_label lbl c = find_label lbl k.","conclusion":"find_label lbl c = find_label lbl k","hypotheses":"(lbl : label) (k c : code) (H : tail_nolabel k c)","proofString":"destruct H.\nauto."},{"statement":"(lbl : label) (k c : code) (H : is_tail k c) (H0 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k) : find_label lbl c = find_label lbl k.","conclusion":"find_label lbl c = find_label lbl k","hypotheses":"(lbl : label) (k c : code) (H : is_tail k c) (H0 : forall lbl0 : label, find_label lbl0 c = find_label lbl0 k)","proofString":"auto."},{"statement":"(k c : code) (H : tail_nolabel k c) : is_tail k c.","conclusion":"is_tail k c","hypotheses":"(k c : code) (H : tail_nolabel k c)","proofString":"destruct H.\nauto."},{"statement":"(k c : code) (H : is_tail k c) (H0 : forall lbl : label, find_label lbl c = find_label lbl k) : is_tail k c.","conclusion":"is_tail k c","hypotheses":"(k c : code) (H : is_tail k c) (H0 : forall lbl : label, find_label lbl c = find_label lbl k)","proofString":"auto."},{"statement":"(c3 : code) (rs3 : regset) (m3 : mem) (i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c3 rs3 m3) : exec_straight (i1 :: c) rs1 m1 c3 rs3 m3.","conclusion":"exec_straight (i1 :: c) rs1 m1 c3 rs3 m3","hypotheses":"(c3 : code) (rs3 : regset) (m3 : mem) (i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c3 rs3 m3)","proofString":"apply exec_straight_step with rs2 m2; auto."},{"statement":"(c3 : code) (rs3 : regset) (m3 : mem) (i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs0 : regset) (m0 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs0 m0) (IHexec_straight : exec_straight c' rs0 m0 c3 rs3 m3 -> exec_straight c rs2 m2 c3 rs3 m3) (H2 : exec_straight c' rs0 m0 c3 rs3 m3) : exec_straight (i :: c) rs1 m1 c3 rs3 m3.","conclusion":"exec_straight (i :: c) rs1 m1 c3 rs3 m3","hypotheses":"(c3 : code) (rs3 : regset) (m3 : mem) (i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs0 : regset) (m0 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs0 m0) (IHexec_straight : exec_straight c' rs0 m0 c3 rs3 m3 -> exec_straight c rs2 m2 c3 rs3 m3) (H2 : exec_straight c' rs0 m0 c3 rs3 m3)","proofString":"apply exec_straight_step with rs2 m2; auto."},{"statement":"(i1 i2 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) : exec_straight (i1 :: i2 :: c) rs1 m1 c rs3 m3.","conclusion":"exec_straight (i1 :: i2 :: c) rs1 m1 c rs3 m3","hypotheses":"(i1 i2 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one)","proofString":"apply exec_straight_step with rs2 m2; auto.\napply exec_straight_one; auto."},{"statement":"(i1 i2 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) : exec_straight (i2 :: c) rs2 m2 c rs3 m3.","conclusion":"exec_straight (i2 :: c) rs2 m2 c rs3 m3","hypotheses":"(i1 i2 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one)","proofString":"apply exec_straight_one; auto."},{"statement":"(i1 i2 i3 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (rs4 : regset) (m4 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : exec_instr ge fn i3 rs3 m3 = Next rs4 m4) (H2 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H3 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) (H4 : rs4 PC = Val.offset_ptr (rs3 PC) Ptrofs.one) : exec_straight (i1 :: i2 :: i3 :: c) rs1 m1 c rs4 m4.","conclusion":"exec_straight (i1 :: i2 :: i3 :: c) rs1 m1 c rs4 m4","hypotheses":"(i1 i2 i3 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (rs4 : regset) (m4 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : exec_instr ge fn i3 rs3 m3 = Next rs4 m4) (H2 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H3 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) (H4 : rs4 PC = Val.offset_ptr (rs3 PC) Ptrofs.one)","proofString":"apply exec_straight_step with rs2 m2; auto.\neapply exec_straight_two; eauto."},{"statement":"(i1 i2 i3 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (rs4 : regset) (m4 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : exec_instr ge fn i3 rs3 m3 = Next rs4 m4) (H2 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H3 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) (H4 : rs4 PC = Val.offset_ptr (rs3 PC) Ptrofs.one) : exec_straight (i2 :: i3 :: c) rs2 m2 c rs4 m4.","conclusion":"exec_straight (i2 :: i3 :: c) rs2 m2 c rs4 m4","hypotheses":"(i1 i2 i3 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (rs3 : regset) (m3 : mem) (rs4 : regset) (m4 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : exec_instr ge fn i2 rs2 m2 = Next rs3 m3) (H1 : exec_instr ge fn i3 rs3 m3 = Next rs4 m4) (H2 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H3 : rs3 PC = Val.offset_ptr (rs2 PC) Ptrofs.one) (H4 : rs4 PC = Val.offset_ptr (rs3 PC) Ptrofs.one)","proofString":"eapply exec_straight_two; eauto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : plus step ge (State rs1 m1) E0 (State rs2 m2).","conclusion":"plus step ge (State rs1 m1) E0 (State rs2 m2)","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"apply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : step ge (State rs1 m1) E0 (State rs2 m2).","conclusion":"step ge (State rs1 m1) E0 (State rs2 m2)","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"econstructor; eauto.\neapply find_instr_tail.\neauto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : find_instr (Ptrofs.unsigned ofs) (fn_code fn) = Some i1.","conclusion":"find_instr (Ptrofs.unsigned ofs) (fn_code fn) = Some i1","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"eapply find_instr_tail.\neauto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : plus step ge (State rs1 m1) E0 (State rs3 m3).","conclusion":"plus step ge (State rs1 m1) E0 (State rs3 m3)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"eapply plus_left'.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\napply IHexec_straight with b (Ptrofs.add ofs Ptrofs.one).\nauto.\nrewrite H0.\nrewrite H3.\nreflexivity.\nauto.\napply code_tail_next_int with i; auto.\ntraceEq."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : find_instr (Ptrofs.unsigned ofs) (fn_code fn) = Some i.","conclusion":"find_instr (Ptrofs.unsigned ofs) (fn_code fn) = Some i","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"eapply find_instr_tail.\neauto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : list_length_z (fn_code fn) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code fn) <= Ptrofs.max_unsigned","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"rewrite H0.\nrewrite H3.\nreflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"rewrite H3.\nreflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"reflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Genv.find_funct_ptr ge b = Some (Internal fn).","conclusion":"Genv.find_funct_ptr ge b = Some (Internal fn)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nplus step ge (State rs2 m2) E0 (State rs3 m3)) (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"apply code_tail_next_int with i; auto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : exists ofs' : ptrofs,\n  rs2 PC = Vptr b ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c.","conclusion":"exists ofs' : ptrofs,\n  rs2 PC = Vptr b ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"exists (Ptrofs.add ofs Ptrofs.one).\nsplit.\nrewrite H0.\nrewrite H2.\nauto.\napply code_tail_next_int with i1; auto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one) /\\\ncode_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c.","conclusion":"rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one) /\\\ncode_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"split.\nrewrite H0.\nrewrite H2.\nauto.\napply code_tail_next_int with i1; auto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"rewrite H0.\nrewrite H2.\nauto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"rewrite H2.\nauto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"auto."},{"statement":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c)) : code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c","hypotheses":"(i1 : instruction) (c : list instruction) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (H : exec_instr ge fn i1 rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H2 : rs1 PC = Vptr b ofs) (H3 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H4 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i1 :: c))","proofString":"apply code_tail_next_int with i1; auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : exists ofs' : ptrofs,\n  rs3 PC = Vptr b ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c'.","conclusion":"exists ofs' : ptrofs,\n  rs3 PC = Vptr b ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c'","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"apply IHexec_straight with (Ptrofs.add ofs Ptrofs.one).\nauto.\nrewrite H0.\nrewrite H3.\nreflexivity.\nauto.\napply code_tail_next_int with i; auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : list_length_z (fn_code fn) <= Ptrofs.max_unsigned.","conclusion":"list_length_z (fn_code fn) <= Ptrofs.max_unsigned","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"rs2 PC = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"rewrite H0.\nrewrite H3.\nreflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (rs1 PC) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"rewrite H3.\nreflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one).","conclusion":"Val.offset_ptr (Vptr b ofs) Ptrofs.one = Vptr b (Ptrofs.add ofs Ptrofs.one)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"reflexivity."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : Genv.find_funct_ptr ge b = Some (Internal fn).","conclusion":"Genv.find_funct_ptr ge b = Some (Internal fn)","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c)) : code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c.","conclusion":"code_tail (Ptrofs.unsigned (Ptrofs.add ofs Ptrofs.one)) (fn_code fn) c","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight c rs2 m2 c' rs3 m3) (IHexec_straight : list_length_z (fn_code fn) <= Ptrofs.max_unsigned ->\nforall (b0 : block) (ofs0 : ptrofs),\nrs2 PC = Vptr b0 ofs0 ->\nGenv.find_funct_ptr ge b0 = Some (Internal fn) ->\ncode_tail (Ptrofs.unsigned ofs0) (fn_code fn) c ->\nexists ofs' : ptrofs,\n  rs3 PC = Vptr b0 ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code fn) c') (H2 : list_length_z (fn_code fn) <= Ptrofs.max_unsigned) (b : block) (ofs : ptrofs) (H3 : rs1 PC = Vptr b ofs) (H4 : Genv.find_funct_ptr ge b = Some (Internal fn)) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code fn) (i :: c))","proofString":"apply code_tail_next_int with i; auto."},{"statement":"(c1 : code) (rs1 : regset) (m1 : mem) (c : code) (rs : regset) (m : mem) (H : exec_straight c1 rs1 m1 c rs m) : exec_straight c1 rs1 m1 c rs m.","conclusion":"exec_straight c1 rs1 m1 c rs m","hypotheses":"(c1 : code) (rs1 : regset) (m1 : mem) (c : code) (rs : regset) (m : mem) (H : exec_straight c1 rs1 m1 c rs m)","proofString":"auto."},{"statement":"(c1 : code) (rs1 : regset) (m1 : mem) (c0 : code) (rs0 : regset) (m0 : mem) (H : exec_straight c1 rs1 m1 c0 rs0 m0) (c2 : code) (rs2 : regset) (m2 : mem) (H0 : exec_straight c0 rs0 m0 c2 rs2 m2) : exec_straight c1 rs1 m1 c2 rs2 m2.","conclusion":"exec_straight c1 rs1 m1 c2 rs2 m2","hypotheses":"(c1 : code) (rs1 : regset) (m1 : mem) (c0 : code) (rs0 : regset) (m0 : mem) (H : exec_straight c1 rs1 m1 c0 rs0 m0) (c2 : code) (rs2 : regset) (m2 : mem) (H0 : exec_straight c0 rs0 m0 c2 rs2 m2)","proofString":"eapply exec_straight_trans; eauto."},{"statement":"(c3 : code) (rs3 : regset) (m3 : mem) (c : code) (rs : regset) (m : mem) (H : exec_straight c rs m c3 rs3 m3) : exec_straight c rs m c3 rs3 m3.","conclusion":"exec_straight c rs m c3 rs3 m3","hypotheses":"(c3 : code) (rs3 : regset) (m3 : mem) (c : code) (rs : regset) (m : mem) (H : exec_straight c rs m c3 rs3 m3)","proofString":"auto."},{"statement":"(c3 : code) (rs3 : regset) (m3 : mem) (c1 : code) (rs1 : regset) (m1 : mem) (c2 : code) (rs2 : regset) (m2 : mem) (H : exec_straight c1 rs1 m1 c2 rs2 m2) (H0 : exec_straight c2 rs2 m2 c3 rs3 m3) : exec_straight c1 rs1 m1 c3 rs3 m3.","conclusion":"exec_straight c1 rs1 m1 c3 rs3 m3","hypotheses":"(c3 : code) (rs3 : regset) (m3 : mem) (c1 : code) (rs1 : regset) (m1 : mem) (c2 : code) (rs2 : regset) (m2 : mem) (H : exec_straight c1 rs1 m1 c2 rs2 m2) (H0 : exec_straight c2 rs2 m2 c3 rs3 m3)","proofString":"eapply exec_straight_trans; eauto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3) : exec_straight (i :: c) rs1 m1 c' rs3 m3.","conclusion":"exec_straight (i :: c) rs1 m1 c' rs3 m3","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3)","proofString":"inv H1.\napply exec_straight_one; auto.\neapply exec_straight_step; eauto."},{"statement":"(i : instruction) (rs1 : regset) (m1 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H0 : rs3 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H : exec_instr ge fn i rs1 m1 = Next rs3 m3) : exec_straight (i :: c') rs1 m1 c' rs3 m3.","conclusion":"exec_straight (i :: c') rs1 m1 c' rs3 m3","hypotheses":"(i : instruction) (rs1 : regset) (m1 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H0 : rs3 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H : exec_instr ge fn i rs1 m1 = Next rs3 m3)","proofString":"apply exec_straight_one; auto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : exec_straight c rs2 m2 c' rs3 m3) : exec_straight (i :: c) rs1 m1 c' rs3 m3.","conclusion":"exec_straight (i :: c) rs1 m1 c' rs3 m3","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H2 : exec_straight c rs2 m2 c' rs3 m3)","proofString":"eapply exec_straight_step; eauto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3) : exec_straight_opt (i :: c) rs1 m1 c' rs3 m3.","conclusion":"exec_straight_opt (i :: c) rs1 m1 c' rs3 m3","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3)","proofString":"apply exec_straight_opt_intro.\neapply exec_straight_opt_step; eauto."},{"statement":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3) : exec_straight (i :: c) rs1 m1 c' rs3 m3.","conclusion":"exec_straight (i :: c) rs1 m1 c' rs3 m3","hypotheses":"(i : instruction) (c : code) (rs1 : regset) (m1 : mem) (rs2 : regset) (m2 : mem) (c' : code) (rs3 : regset) (m3 : mem) (H : exec_instr ge fn i rs1 m1 = Next rs2 m2) (H0 : rs2 PC = Val.offset_ptr (rs1 PC) Ptrofs.one) (H1 : exec_straight_opt c rs2 m2 c' rs3 m3)","proofString":"eapply exec_straight_opt_step; eauto."},{"statement":"Vnullptr <> Vundef.","conclusion":"Vnullptr <> Vundef","hypotheses":"","proofString":"unfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(fb : block) (sp ra : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transl_code_at_pc ge ra fb f c false tf tc) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_sp s <> Vundef) : sp <> Vundef.","conclusion":"sp <> Vundef","hypotheses":"(fb : block) (sp ra : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transl_code_at_pc ge ra fb f c false tf tc) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_sp s <> Vundef)","proofString":"auto."},{"statement":"Vnullptr <> Vundef.","conclusion":"Vnullptr <> Vundef","hypotheses":"","proofString":"unfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(fb : block) (sp ra : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transl_code_at_pc ge ra fb f c false tf tc) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_ra s <> Vundef) : ra <> Vundef.","conclusion":"ra <> Vundef","hypotheses":"(fb : block) (sp ra : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transl_code_at_pc ge ra fb f c false tf tc) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_ra s <> Vundef)","proofString":"inv H0.\ncongruence."},{"statement":"(fb : block) (sp : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_ra s <> Vundef) (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) : Vptr fb ofs <> Vundef.","conclusion":"Vptr fb ofs <> Vundef","hypotheses":"(fb : block) (sp : val) (c : Mach.code) (s : list stackframe) (f : Mach.function) (tf : function) (tc : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : sp <> Vundef) (H2 : match_stack s) (IHmatch_stack : parent_ra s <> Vundef) (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c false = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc)","proofString":"congruence."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H0 : Val.lessdef (parent_sp s) v) : v = parent_sp s.","conclusion":"v = parent_sp s","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H0 : Val.lessdef (parent_sp s) v)","proofString":"inv H0.\nauto.\nexploit parent_sp_def; eauto.\ntauto."},{"statement":"(s : list stackframe) (H : match_stack s) : parent_sp s = parent_sp s.","conclusion":"parent_sp s = parent_sp s","hypotheses":"(s : list stackframe) (H : match_stack s)","proofString":"auto."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_sp s) : v = Vundef.","conclusion":"v = Vundef","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_sp s)","proofString":"exploit parent_sp_def; eauto.\ntauto."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_sp s) : False -> v = Vundef.","conclusion":"False -> v = Vundef","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_sp s)","proofString":"tauto."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H0 : Val.lessdef (parent_ra s) v) : v = parent_ra s.","conclusion":"v = parent_ra s","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H0 : Val.lessdef (parent_ra s) v)","proofString":"inv H0.\nauto.\nexploit parent_ra_def; eauto.\ntauto."},{"statement":"(s : list stackframe) (H : match_stack s) : parent_ra s = parent_ra s.","conclusion":"parent_ra s = parent_ra s","hypotheses":"(s : list stackframe) (H : match_stack s)","proofString":"auto."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_ra s) : v = Vundef.","conclusion":"v = Vundef","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_ra s)","proofString":"exploit parent_ra_def; eauto.\ntauto."},{"statement":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_ra s) : False -> v = Vundef.","conclusion":"False -> v = Vundef","hypotheses":"(s : list stackframe) (v : val) (H : match_stack s) (H2 : Vundef = parent_ra s)","proofString":"tauto."}]}