{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Initializersproof.v","fileSamples":[{"statement":"(e : env) (x : positive) (ty : type) (m : mem) (bx : block) (H : e ! x = Some (bx, ty)) : eval_simple_lvalue e m (Evar x ty) bx Ptrofs.zero Full.","proofString":"apply esl_var_local; auto."},{"statement":"(e : env) (x : positive) (ty : type) (m : mem) (H : e ! x = None) (bx : block) (H0 : Genv.find_symbol ge x = Some bx) : eval_simple_lvalue e m (Evar x ty) bx Ptrofs.zero Full.","proofString":"apply esl_var_global; auto."},{"statement":"(e : env) (ty1 ty : type) (m : mem) (bx : block) (ofsx : ptrofs) : eval_simple_lvalue e m (Ederef (Eval (Vptr bx ofsx) ty1) ty) bx ofsx Full.","proofString":"constructor.\nconstructor."},{"statement":"(e : env) (ty1 ty : type) (m : mem) (bx : block) (ofsx : ptrofs) : eval_simple_rvalue e m (Eval (Vptr bx ofsx) ty1) (Vptr bx ofsx).","proofString":"constructor."},{"statement":"(v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (H1 : True) (H0 : simple r1) (H3 : simple r2) : simple (if b then r1 else r2).","proofString":"destruct b; auto."},{"statement":"(e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (RED : rred ge r m E0 r' m') (SIMP : simple r) : m = m' /\\ compat_eval RV e r r' m.","proofString":"inv RED; simpl in SIMP; try contradiction; split; auto; split; auto; intros vx EV.\ninv EV.\neconstructor.\nconstructor.\nauto.\nauto.\ninv EV.\neconstructor.\nconstructor.\ninv EV.\neconstructor; eauto.\nconstructor.\ninv EV.\neconstructor; eauto.\nconstructor.\nconstructor.\ninv EV.\neconstructor; eauto.\nconstructor.\ninv EV.\neapply esr_seqand_true; eauto.\nconstructor.\ninv EV.\neapply esr_seqand_false; eauto.\nconstructor.\ninv EV.\neapply esr_seqor_true; eauto.\nconstructor.\ninv EV.\neapply esr_seqor_false; eauto.\nconstructor.\ninv EV.\neapply esr_condition; eauto.\nconstructor.\ninv EV.\nconstructor.\ninv EV.\nconstructor.\neconstructor; eauto.\nconstructor.\ninv EV.\neconstructor.\nconstructor.\nauto."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (SIMP : True) (v : val) (H : deref_loc ge ty m' b ofs bf E0 v) (vx : val) (EV : eval_simple_rvalue e m' (Eval v ty) vx) : eval_simple_rvalue e m' (Evalof (Eloc b ofs bf ty) ty) vx.","proofString":"inv EV.\neconstructor.\nconstructor.\nauto.\nauto."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (SIMP : True) (vx : val) (H : deref_loc ge ty m' b ofs bf E0 vx) : eval_simple_rvalue e m' (Evalof (Eloc b ofs bf ty) ty) vx.","proofString":"econstructor.\nconstructor.\nauto.\nauto."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (SIMP : True) (vx : val) (H : deref_loc ge ty m' b ofs bf E0 vx) : ty = typeof (Eloc b ofs bf ty).","proofString":"auto."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (ty1 ty : type) (SIMP : True) (vx : val) (EV : eval_simple_rvalue e m' (Eval (Vptr b ofs) ty) vx) : eval_simple_rvalue e m' (Eaddrof (Eloc b ofs Full ty1) ty) vx.","proofString":"inv EV.\neconstructor.\nconstructor."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (ty1 ty : type) (SIMP : True) : eval_simple_rvalue e m' (Eaddrof (Eloc b ofs Full ty1) ty) (Vptr b ofs).","proofString":"econstructor.\nconstructor."},{"statement":"(e : env) (m' : mem) (b : block) (ofs : ptrofs) (ty1 ty : type) (SIMP : True) : eval_simple_lvalue e m' (Eloc b ofs Full ty1) b ofs Full.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (op : unary_operation) (v1 : val) (ty1 ty : type) (SIMP : True) (v : val) (H : sem_unary_operation op v1 ty1 m' = Some v) (vx : val) (EV : eval_simple_rvalue e m' (Eval v ty) vx) : eval_simple_rvalue e m' (Eunop op (Eval v1 ty1) ty) vx.","proofString":"inv EV.\neconstructor; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (op : unary_operation) (v1 : val) (ty1 ty : type) (SIMP : True) (vx : val) (H : sem_unary_operation op v1 ty1 m' = Some vx) : eval_simple_rvalue e m' (Eunop op (Eval v1 ty1) ty) vx.","proofString":"econstructor; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (op : unary_operation) (v1 : val) (ty1 ty : type) (SIMP : True) (vx : val) (H : sem_unary_operation op v1 ty1 m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (SIMP : True /\\ True) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m' = Some v) (vx : val) (EV : eval_simple_rvalue e m' (Eval v ty) vx) : eval_simple_rvalue e m' (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty) vx.","proofString":"inv EV.\neconstructor; eauto.\nconstructor.\nconstructor."},{"statement":"(e : env) (m' : mem) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (SIMP : True /\\ True) (vx : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m' = Some vx) : eval_simple_rvalue e m' (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty) vx.","proofString":"econstructor; eauto.\nconstructor.\nconstructor."},{"statement":"(e : env) (m' : mem) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (SIMP : True /\\ True) (vx : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (SIMP : True /\\ True) (vx : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m' = Some vx) : eval_simple_rvalue e m' (Eval v2 ty2) v2.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (ty : type) (v1 : val) (ty1 : type) (SIMP : True) (v : val) (H : sem_cast v1 ty1 ty m' = Some v) (vx : val) (EV : eval_simple_rvalue e m' (Eval v ty) vx) : eval_simple_rvalue e m' (Ecast (Eval v1 ty1) ty) vx.","proofString":"inv EV.\neconstructor; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (ty : type) (v1 : val) (ty1 : type) (SIMP : True) (vx : val) (H : sem_cast v1 ty1 ty m' = Some vx) : eval_simple_rvalue e m' (Ecast (Eval v1 ty1) ty) vx.","proofString":"econstructor; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (ty : type) (v1 : val) (ty1 : type) (SIMP : True) (vx : val) (H : sem_cast v1 ty1 ty m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) (vx : val) (EV : eval_simple_rvalue e m' (Eparen r2 type_bool ty) vx) : eval_simple_rvalue e m' (Eseqand (Eval v1 ty1) r2 ty) vx.","proofString":"inv EV.\neapply esr_seqand_true; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) (vx v : val) (H4 : eval_simple_rvalue e m' r2 v) (H5 : sem_cast v (typeof r2) type_bool m' = Some vx) : eval_simple_rvalue e m' (Eseqand (Eval v1 ty1) r2 ty) vx.","proofString":"eapply esr_seqand_true; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) (vx v : val) (H4 : eval_simple_rvalue e m' r2 v) (H5 : sem_cast v (typeof r2) type_bool m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) (vx : val) (EV : eval_simple_rvalue e m' (Eval (Vint Int.zero) ty) vx) : eval_simple_rvalue e m' (Eseqand (Eval v1 ty1) r2 ty) vx.","proofString":"inv EV.\neapply esr_seqand_false; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) : eval_simple_rvalue e m' (Eseqand (Eval v1 ty1) r2 ty) (Vint Int.zero).","proofString":"eapply esr_seqand_false; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) (vx : val) (EV : eval_simple_rvalue e m' (Eval (Vint Int.one) ty) vx) : eval_simple_rvalue e m' (Eseqor (Eval v1 ty1) r2 ty) vx.","proofString":"inv EV.\neapply esr_seqor_true; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) : eval_simple_rvalue e m' (Eseqor (Eval v1 ty1) r2 ty) (Vint Int.one).","proofString":"eapply esr_seqor_true; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some true) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) (vx : val) (EV : eval_simple_rvalue e m' (Eparen r2 type_bool ty) vx) : eval_simple_rvalue e m' (Eseqor (Eval v1 ty1) r2 ty) vx.","proofString":"inv EV.\neapply esr_seqor_false; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) (vx v : val) (H4 : eval_simple_rvalue e m' r2 v) (H5 : sem_cast v (typeof r2) type_bool m' = Some vx) : eval_simple_rvalue e m' (Eseqor (Eval v1 ty1) r2 ty) vx.","proofString":"eapply esr_seqor_false; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (SIMP : True /\\ simple r2) (H : bool_val v1 ty1 m' = Some false) (vx v : val) (H4 : eval_simple_rvalue e m' r2 v) (H5 : sem_cast v (typeof r2) type_bool m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (SIMP : True /\\ simple r1 /\\ simple r2) (b : bool) (H : bool_val v1 ty1 m' = Some b) (vx : val) (EV : eval_simple_rvalue e m' (Eparen (if b then r1 else r2) ty ty) vx) : eval_simple_rvalue e m' (Econdition (Eval v1 ty1) r1 r2 ty) vx.","proofString":"inv EV.\neapply esr_condition; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (SIMP : True /\\ simple r1 /\\ simple r2) (b : bool) (H : bool_val v1 ty1 m' = Some b) (vx v : val) (H4 : eval_simple_rvalue e m' (if b then r1 else r2) v) (H5 : sem_cast v (typeof (if b then r1 else r2)) ty m' = Some vx) : eval_simple_rvalue e m' (Econdition (Eval v1 ty1) r1 r2 ty) vx.","proofString":"eapply esr_condition; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (SIMP : True /\\ simple r1 /\\ simple r2) (b : bool) (H : bool_val v1 ty1 m' = Some b) (vx v : val) (H4 : eval_simple_rvalue e m' (if b then r1 else r2) v) (H5 : sem_cast v (typeof (if b then r1 else r2)) ty m' = Some vx) : eval_simple_rvalue e m' (Eval v1 ty1) v1.","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (ty1 ty : type) (SIMP : True) (vx : val) (EV : eval_simple_rvalue e m' (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) ty) vx) : eval_simple_rvalue e m' (Esizeof ty1 ty) vx.","proofString":"inv EV.\nconstructor."},{"statement":"(e : env) (m' : mem) (ty1 ty : type) (SIMP : True) : eval_simple_rvalue e m' (Esizeof ty1 ty)\n  (Vptrofs (Ptrofs.repr (sizeof ge ty1))).","proofString":"constructor."},{"statement":"(e : env) (m' : mem) (ty1 ty : type) (SIMP : True) (vx : val) (EV : eval_simple_rvalue e m' (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) ty) vx) : eval_simple_rvalue e m' (Ealignof ty1 ty) vx.","proofString":"inv EV.\nconstructor."},{"statement":"(e : env) (m' : mem) (ty1 ty : type) (SIMP : True) : eval_simple_rvalue e m' (Ealignof ty1 ty)\n  (Vptrofs (Ptrofs.repr (alignof ge ty1))).","proofString":"constructor."},{"statement":"(e : env) (r' : expr) (m' : mem) (v : val) (ty1 : type) (SIMP : True /\\ simple r') (vx : val) (EV : eval_simple_rvalue e m' r' vx) : eval_simple_rvalue e m' (Ecomma (Eval v ty1) r' (typeof r')) vx.","proofString":"econstructor; eauto.\nconstructor."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 ty2 ty : type) (SIMP : True) (v : val) (H : sem_cast v1 ty1 ty2 m' = Some v) (vx : val) (EV : eval_simple_rvalue e m' (Eval v ty) vx) : eval_simple_rvalue e m' (Eparen (Eval v1 ty1) ty2 ty) vx.","proofString":"inv EV.\neconstructor.\nconstructor.\nauto."},{"statement":"(e : env) (m' : mem) (v1 : val) (ty1 ty2 ty : type) (SIMP : True) (vx : val) (H : sem_cast v1 ty1 ty2 m' = Some vx) : eval_simple_rvalue e m' (Eparen (Eval v1 ty1) ty2 ty) vx.","proofString":"econstructor.\nconstructor.\nauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (b : block) (ofs : ptrofs) (bf : bitfield) (H0 : eval_simple_lvalue e m (Ederef (C a') ty) b ofs bf) : eval_simple_lvalue e m (Ederef (C a) ty) b ofs bf.","proofString":"inv H0.\nconstructor; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (b : block) (ofs : ptrofs) (H6 : eval_simple_rvalue e m (C a') (Vptr b ofs)) : eval_simple_lvalue e m (Ederef (C a) ty) b ofs Full.","proofString":"constructor; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (f : ident) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (b : block) (ofs : ptrofs) (bf : bitfield) (H0 : eval_simple_lvalue e m (Efield (C a') f ty) b ofs bf) : eval_simple_lvalue e m (Efield (C a) f ty) b ofs bf.","proofString":"inv H0.\neapply esl_field_struct; eauto.\nrewrite TY; eauto.\neapply esl_field_union; eauto.\nrewrite TY; eauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b ofs bf ->\neval_simple_lvalue e m (C a) b ofs bf) (v : val) (H0 : eval_simple_rvalue e m (Evalof (C a') ty) v) : eval_simple_rvalue e m (Evalof (C a) ty) v.","proofString":"inv H0.\neconstructor.\neauto.\nauto.\nauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\neval_simple_lvalue e m (C a') b0 ofs0 bf0 ->\neval_simple_lvalue e m (C a) b0 ofs0 bf0) (v : val) (b : block) (ofs : ptrofs) (bf : bitfield) (H3 : eval_simple_lvalue e m (C a') b ofs bf) (H6 : deref_loc ge (typeof (C a')) m b ofs bf E0 v) : eval_simple_rvalue e m (Evalof (C a) (typeof (C a'))) v.","proofString":"econstructor.\neauto.\nauto.\nauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b0 : block) (ofs0 : ptrofs) (bf0 : bitfield),\neval_simple_lvalue e m (C a') b0 ofs0 bf0 ->\neval_simple_lvalue e m (C a) b0 ofs0 bf0) (v : val) (b : block) (ofs : ptrofs) (bf : bitfield) (H3 : eval_simple_lvalue e m (C a') b ofs bf) (H6 : deref_loc ge (typeof (C a')) m b ofs bf E0 v) : typeof (C a') = typeof (C a).","proofString":"auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b ofs bf ->\neval_simple_lvalue e m (C a) b ofs bf) (v : val) (H0 : eval_simple_rvalue e m (Eaddrof (C a') ty) v) : eval_simple_rvalue e m (Eaddrof (C a) ty) v.","proofString":"inv H0.\neconstructor; eauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b0 : block) (ofs0 : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b0 ofs0 bf ->\neval_simple_lvalue e m (C a) b0 ofs0 bf) (b : block) (ofs : ptrofs) (H4 : eval_simple_lvalue e m (C a') b ofs Full) : eval_simple_rvalue e m (Eaddrof (C a) ty) (Vptr b ofs).","proofString":"econstructor; eauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eunop op (C a') ty) v) : eval_simple_rvalue e m (Eunop op (C a) ty) v.","proofString":"inv H0.\neconstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : sem_unary_operation op v1 (typeof (C a')) m = Some v) : eval_simple_rvalue e m (Eunop op (C a) ty) v.","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : unary_operation) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : sem_unary_operation op v1 (typeof (C a')) m = Some v) : sem_unary_operation op v1 (typeof (C a)) m = Some v.","proofString":"congruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Ebinop op (C a') e2 ty) v) : eval_simple_rvalue e m (Ebinop op (C a) e2 ty) v.","proofString":"inv H0.\neconstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H6 : eval_simple_rvalue e m (C a') v1) (H7 : eval_simple_rvalue e m e2 v2) (H8 : sem_binary_operation ge op v1 (typeof (C a')) v2 (typeof e2) m = Some v) : eval_simple_rvalue e m (Ebinop op (C a) e2 ty) v.","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H6 : eval_simple_rvalue e m (C a') v1) (H7 : eval_simple_rvalue e m e2 v2) (H8 : sem_binary_operation ge op v1 (typeof (C a')) v2 (typeof e2) m = Some v) : sem_binary_operation ge op v1 (typeof (C a)) v2 (typeof e2) m = Some v.","proofString":"congruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Ebinop op e1 (C a') ty) v) : eval_simple_rvalue e m (Ebinop op e1 (C a) ty) v.","proofString":"inv H0.\neconstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H6 : eval_simple_rvalue e m e1 v1) (H7 : eval_simple_rvalue e m (C a') v2) (H8 : sem_binary_operation ge op v1 (typeof e1) v2 (typeof (C a')) m = Some v) : eval_simple_rvalue e m (Ebinop op e1 (C a) ty) v.","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H6 : eval_simple_rvalue e m e1 v1) (H7 : eval_simple_rvalue e m (C a') v2) (H8 : sem_binary_operation ge op v1 (typeof e1) v2 (typeof (C a')) m = Some v) : sem_binary_operation ge op v1 (typeof e1) v2 (typeof (C a)) m = Some v.","proofString":"congruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Ecast (C a') ty) v) : eval_simple_rvalue e m (Ecast (C a) ty) v.","proofString":"inv H0.\neconstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (H3 : eval_simple_rvalue e m (C a') v1) (H5 : sem_cast v1 (typeof (C a')) ty m = Some v) : eval_simple_rvalue e m (Ecast (C a) ty) v.","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (H3 : eval_simple_rvalue e m (C a') v1) (H5 : sem_cast v1 (typeof (C a')) ty m = Some v) : sem_cast v1 (typeof (C a)) ty m = Some v.","proofString":"congruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eseqand (C a') r2 ty) v) : eval_simple_rvalue e m (Eseqand (C a) r2 ty) v.","proofString":"inv H0.\neapply esr_seqand_true; eauto.\nrewrite TY; auto.\neapply esr_seqand_false; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H4 : eval_simple_rvalue e m (C a') v1) (H5 : bool_val v1 (typeof (C a')) m = Some true) (H7 : eval_simple_rvalue e m r2 v2) (H8 : sem_cast v2 (typeof r2) type_bool m = Some v) : eval_simple_rvalue e m (Eseqand (C a) r2 ty) v.","proofString":"eapply esr_seqand_true; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H4 : eval_simple_rvalue e m (C a') v1) (H5 : bool_val v1 (typeof (C a')) m = Some true) (H7 : eval_simple_rvalue e m r2 v2) (H8 : sem_cast v2 (typeof r2) type_bool m = Some v) : bool_val v1 (typeof (C a)) m = Some true.","proofString":"rewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : bool_val v1 (typeof (C a')) m = Some false) : eval_simple_rvalue e m (Eseqand (C a) r2 ty) (Vint Int.zero).","proofString":"eapply esr_seqand_false; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : bool_val v1 (typeof (C a')) m = Some false) : bool_val v1 (typeof (C a)) m = Some false.","proofString":"rewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eseqor (C a') r2 ty) v) : eval_simple_rvalue e m (Eseqor (C a) r2 ty) v.","proofString":"inv H0.\neapply esr_seqor_false; eauto.\nrewrite TY; auto.\neapply esr_seqor_true; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H4 : eval_simple_rvalue e m (C a') v1) (H5 : bool_val v1 (typeof (C a')) m = Some false) (H7 : eval_simple_rvalue e m r2 v2) (H8 : sem_cast v2 (typeof r2) type_bool m = Some v) : eval_simple_rvalue e m (Eseqor (C a) r2 ty) v.","proofString":"eapply esr_seqor_false; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 v2 : val) (H4 : eval_simple_rvalue e m (C a') v1) (H5 : bool_val v1 (typeof (C a')) m = Some false) (H7 : eval_simple_rvalue e m r2 v2) (H8 : sem_cast v2 (typeof r2) type_bool m = Some v) : bool_val v1 (typeof (C a)) m = Some false.","proofString":"rewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : bool_val v1 (typeof (C a')) m = Some true) : eval_simple_rvalue e m (Eseqor (C a) r2 ty) (Vint Int.one).","proofString":"eapply esr_seqor_true; eauto.\nrewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v : val,\neval_simple_rvalue e m (C a') v -> eval_simple_rvalue e m (C a) v) (v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : bool_val v1 (typeof (C a')) m = Some true) : bool_val v1 (typeof (C a)) m = Some true.","proofString":"rewrite TY; auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Econdition (C a') r2 r3 ty) v) : eval_simple_rvalue e m (Econdition (C a) r2 r3 ty) v.","proofString":"inv H0.\neapply esr_condition; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (b : bool) (v' : val) (H5 : eval_simple_rvalue e m (C a') v1) (H7 : bool_val v1 (typeof (C a')) m = Some b) (H8 : eval_simple_rvalue e m (if b then r2 else r3) v') (H9 : sem_cast v' (typeof (if b then r2 else r3)) ty m = Some v) : eval_simple_rvalue e m (Econdition (C a) r2 r3 ty) v.","proofString":"eapply esr_condition; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (r2 r3 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (b : bool) (v' : val) (H5 : eval_simple_rvalue e m (C a') v1) (H7 : bool_val v1 (typeof (C a')) m = Some b) (H8 : eval_simple_rvalue e m (if b then r2 else r3) v') (H9 : sem_cast v' (typeof (if b then r2 else r3)) ty m = Some v) : bool_val v1 (typeof (C a)) m = Some b.","proofString":"congruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b ofs bf ->\neval_simple_lvalue e m (C a) b ofs bf) (v : val) (H0 : eval_simple_rvalue e m (Eassign (C a') e2 ty) v) : eval_simple_rvalue e m (Eassign (C a) e2 ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (e1 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eassign e1 (C a') ty) v) : eval_simple_rvalue e m (Eassign e1 (C a) ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e2 : expr) (tyres ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b ofs bf ->\neval_simple_lvalue e m (C a) b ofs bf) (v : val) (H0 : eval_simple_rvalue e m (Eassignop op (C a') e2 tyres ty) v) : eval_simple_rvalue e m (Eassignop op (C a) e2 tyres ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (op : binary_operation) (e1 : expr) (tyres ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eassignop op e1 (C a') tyres ty) v) : eval_simple_rvalue e m (Eassignop op e1 (C a) tyres ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (id : incr_or_decr) (ty : type) (H : context k LV C) (IHcontext : compat_eval k e a a' m -> compat_eval LV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue e m (C a') b ofs bf ->\neval_simple_lvalue e m (C a) b ofs bf) (v : val) (H0 : eval_simple_rvalue e m (Epostincr id (C a') ty) v) : eval_simple_rvalue e m (Epostincr id (C a) ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (el : exprlist) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Ecall (C a') el ty) v) : eval_simple_rvalue e m (Ecall (C a) el ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) : compat_eval RV e (Ecall e1 (C a) ty) (Ecall e1 (C a') ty) m.","proofString":"red; split; intros.\nauto.\ninv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) : typeof (Ecall e1 (C a) ty) = typeof (Ecall e1 (C a') ty).","proofString":"auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (e1 : expr) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) (v : val) (H0 : eval_simple_rvalue e m (Ecall e1 (C a') ty) v) : eval_simple_rvalue e m (Ecall e1 (C a) ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) : compat_eval RV e (Ebuiltin ef tyargs (C a) ty) (Ebuiltin ef tyargs (C a') ty)\n  m.","proofString":"red; split; intros.\nauto.\ninv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) : typeof (Ebuiltin ef tyargs (C a) ty) = typeof (Ebuiltin ef tyargs (C a') ty).","proofString":"auto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : contextlist k C) (CE : compat_eval k e a a' m) (v : val) (H0 : eval_simple_rvalue e m (Ebuiltin ef tyargs (C a') ty) v) : eval_simple_rvalue e m (Ebuiltin ef tyargs (C a) ty) v.","proofString":"inv H0."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Ecomma (C a') e2 ty) v) : eval_simple_rvalue e m (Ecomma (C a) e2 ty) v.","proofString":"inv H0.\neconstructor; eauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (e2 : expr) (ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v v1 : val) (H5 : eval_simple_rvalue e m (C a') v1) (H6 : eval_simple_rvalue e m e2 v) : eval_simple_rvalue e m (Ecomma (C a) e2 ty) v.","proofString":"econstructor; eauto."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v0 : val,\neval_simple_rvalue e m (C a') v0 -> eval_simple_rvalue e m (C a) v0) (v : val) (H0 : eval_simple_rvalue e m (Eparen (C a') tycast ty) v) : eval_simple_rvalue e m (Eparen (C a) tycast ty) v.","proofString":"inv H0.\neconstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v1 : val,\neval_simple_rvalue e m (C a') v1 -> eval_simple_rvalue e m (C a) v1) (v v0 : val) (H5 : eval_simple_rvalue e m (C a') v0) (H6 : sem_cast v0 (typeof (C a')) tycast m = Some v) : eval_simple_rvalue e m (Eparen (C a) tycast ty) v.","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(e : env) (a a' : expr) (m : mem) (k : kind) (C : expr -> expr) (tycast ty : type) (H : context k RV C) (IHcontext : compat_eval k e a a' m -> compat_eval RV e (C a) (C a') m) (CE : compat_eval k e a a' m) (TY : typeof (C a) = typeof (C a')) (EV : forall v1 : val,\neval_simple_rvalue e m (C a') v1 -> eval_simple_rvalue e m (C a) v1) (v v0 : val) (H5 : eval_simple_rvalue e m (C a') v0) (H6 : sem_cast v0 (typeof (C a')) tycast m = Some v) : sem_cast v0 (typeof (C a)) tycast m = Some v.","proofString":"congruence."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (r' : expr) (m' : mem) (s2 : Csem.state) (H : simple r) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (H1 : estep ge (ExprState f r Kstop e m) nil s2) : exists r1 : expr,\n  s2 = ExprState f r1 Kstop e m /\\ compat_eval RV e r r1 m /\\ simple r1.","proofString":"inv H1.\nassert (S: simple a) by (eapply simple_context_1; eauto).\nexploit lred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto.\nassert (S: simple a) by (eapply simple_context_1; eauto).\nexploit rred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply rred_simple; eauto.\nassert (S: simple a) by (eapply simple_context_1; eauto).\ninv H8; simpl in S; contradiction.\ninv H0.\ndestruct H1; inv H0."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H8 : lred ge e a m a' m'0) (H9 : context LV RV C) : exists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"assert (S: simple a) by (eapply simple_context_1; eauto).\nexploit lred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H8 : lred ge e a m a' m'0) (H9 : context LV RV C) (S : simple a) : exists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"exploit lred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H8 : lred ge e a m a' m'0) (H9 : context LV RV C) (S : simple a) : m = m'0 /\\ compat_eval LV e a a' m ->\nexists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"intros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H8 : lred ge e a m a' m'0) (H9 : context LV RV C) (S : simple a) (A : m = m'0) (B : compat_eval LV e a a' m) : exists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"subst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (H8 : lred ge e a m a' m) (H0 : star step ge (ExprState f (C a') Kstop e m) nil (ExprState f r' Kstop e m')) (H9 : context LV RV C) (S : simple a) (B : compat_eval LV e a a' m) : exists r1 : expr,\n  ExprState f (C a') Kstop e m = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"econstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (H8 : lred ge e a m a' m) (H0 : star step ge (ExprState f (C a') Kstop e m) nil (ExprState f r' Kstop e m')) (H9 : context LV RV C) (S : simple a) (B : compat_eval LV e a a' m) : compat_eval RV e (C a) (C a') m.","proofString":"eapply compat_eval_context; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (H8 : lred ge e a m a' m) (H0 : star step ge (ExprState f (C a') Kstop e m) nil (ExprState f r' Kstop e m')) (H9 : context LV RV C) (S : simple a) (B : compat_eval LV e a a' m) : simple (C a').","proofString":"eapply simple_context_2; eauto.\neapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (H8 : lred ge e a m a' m) (H0 : star step ge (ExprState f (C a') Kstop e m) nil (ExprState f r' Kstop e m')) (H9 : context LV RV C) (S : simple a) (B : compat_eval LV e a a' m) : simple a'.","proofString":"eapply lred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H9 : rred ge a m nil a' m'0) (H10 : context RV RV C) : exists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"assert (S: simple a) by (eapply simple_context_1; eauto).\nexploit rred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply rred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (m'0 : mem) (H0 : star step ge (ExprState f (C a') Kstop e m'0) nil (ExprState f r' Kstop e m')) (H9 : rred ge a m nil a' m'0) (H10 : context RV RV C) (S : simple a) : exists r1 : expr,\n  ExprState f (C a') Kstop e m'0 = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"exploit rred_compat; eauto.\nintros [A B].\nsubst m'0.\neconstructor; split.\neauto.\nsplit.\neapply compat_eval_context; eauto.\neapply simple_context_2; eauto.\neapply rred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (a' : expr) (H9 : rred ge a m nil a' m) (H0 : star step ge (ExprState f (C a') Kstop e m) nil (ExprState f r' Kstop e m')) (H10 : context RV RV C) (S : simple a) (B : compat_eval RV e a a' m) : simple a'.","proofString":"eapply rred_simple; eauto."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (fd : fundef) (vargs : list val) (ty : type) (H0 : star step ge (Callstate fd vargs (Kcall f e C ty Kstop) m) nil\n  (ExprState f r' Kstop e m')) (H8 : callred ge a m fd vargs ty) (H9 : context RV RV C) : exists r1 : expr,\n  Callstate fd vargs (Kcall f e C ty Kstop) m = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"assert (S: simple a) by (eapply simple_context_1; eauto).\ninv H8; simpl in S; contradiction."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (fd : fundef) (vargs : list val) (ty : type) (H0 : star step ge (Callstate fd vargs (Kcall f e C ty Kstop) m) nil\n  (ExprState f r' Kstop e m')) (H8 : callred ge a m fd vargs ty) (H9 : context RV RV C) (S : simple a) : exists r1 : expr,\n  Callstate fd vargs (Kcall f e C ty Kstop) m = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"inv H8; simpl in S; contradiction."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (H0 : star step ge Stuckstate nil (ExprState f r' Kstop e m')) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a m) : exists r1 : expr,\n  Stuckstate = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"inv H0.\ndestruct H1; inv H0."},{"statement":"(f : function) (e : env) (m : mem) (r' : expr) (m' : mem) (C : expr -> expr) (a : expr) (H : simple (C a)) (K : kind) (H8 : context K RV C) (H9 : ~ imm_safe ge e K a m) (t1 : trace) (s2 : Csem.state) (t2 : trace) (H1 : step ge Stuckstate t1 s2) (H2 : star step ge s2 t2 (ExprState f r' Kstop e m')) (H3 : nil = t1 ** t2) : exists r1 : expr,\n  Stuckstate = ExprState f r1 Kstop e m /\\\n  compat_eval RV e (C a) r1 m /\\ simple r1.","proofString":"destruct H1; inv H0."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (r' : expr) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0 (ExprState f r' Kstop e m')) (H0 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"remember (ExprState f r Kstop e m) as S1.\nremember E0 as t.\nremember (ExprState f r' Kstop e m') as S2.\nrevert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0.\ninduction 1; intros; subst.\ninv HeqS2.\nsplit.\nauto.\nred; auto.\ndestruct (app_eq_nil t1 t2); auto.\nsubst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (r' : expr) (m' : mem) (S1 : Csem.state) (HeqS1 : S1 = ExprState f r Kstop e m) (H : star step ge S1 E0 (ExprState f r' Kstop e m')) (H0 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"remember E0 as t.\nremember (ExprState f r' Kstop e m') as S2.\nrevert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0.\ninduction 1; intros; subst.\ninv HeqS2.\nsplit.\nauto.\nred; auto.\ndestruct (app_eq_nil t1 t2); auto.\nsubst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (r' : expr) (m' : mem) (S1 : Csem.state) (HeqS1 : S1 = ExprState f r Kstop e m) (t : trace) (Heqt : t = E0) (H : star step ge S1 t (ExprState f r' Kstop e m')) (H0 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"remember (ExprState f r' Kstop e m') as S2.\nrevert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0.\ninduction 1; intros; subst.\ninv HeqS2.\nsplit.\nauto.\nred; auto.\ndestruct (app_eq_nil t1 t2); auto.\nsubst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (r' : expr) (m' : mem) (S1 : Csem.state) (HeqS1 : S1 = ExprState f r Kstop e m) (t : trace) (Heqt : t = E0) (S2 : Csem.state) (HeqS2 : S2 = ExprState f r' Kstop e m') (H : star step ge S1 t S2) (H0 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"revert S1 t S2 H r m r' m' HeqS1 Heqt HeqS2 H0.\ninduction 1; intros; subst.\ninv HeqS2.\nsplit.\nauto.\nred; auto.\ndestruct (app_eq_nil t1 t2); auto.\nsubst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : E0 = E0) (HeqS2 : ExprState f r Kstop e m = ExprState f r' Kstop e m') (H0 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"inv HeqS2.\nsplit.\nauto.\nred; auto."},{"statement":"(f : function) (e : env) (r' : expr) (m' : mem) (Heqt : E0 = E0) (H0 : simple r') : m' = m' /\\ compat_eval RV e r' r' m'.","proofString":"split.\nauto.\nred; auto."},{"statement":"(f : function) (e : env) (r' : expr) (m' : mem) (Heqt : E0 = E0) (H0 : simple r') : m' = m'.","proofString":"auto."},{"statement":"(f : function) (e : env) (r' : expr) (m' : mem) (Heqt : E0 = E0) (H0 : simple r') : compat_eval RV e r' r' m'.","proofString":"red; auto."},{"statement":"(f : function) (e : env) (t1 : trace) (s2 : Csem.state) (t2 : trace) (r : expr) (m : mem) (H : step ge (ExprState f r Kstop e m) t1 s2) (r' : expr) (m' : mem) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nt2 = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge s2 t2 (ExprState f r' Kstop e m')) (Heqt : t1 ** t2 = E0) (H2 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"destruct (app_eq_nil t1 t2); auto.\nsubst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (e : env) (t1 : trace) (s2 : Csem.state) (t2 : trace) (r : expr) (m : mem) (H : step ge (ExprState f r Kstop e m) t1 s2) (r' : expr) (m' : mem) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nt2 = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge s2 t2 (ExprState f r' Kstop e m')) (Heqt : t1 ** t2 = E0) (H2 : simple r) (H1 : t1 = nil) (H3 : t2 = nil) : m' = m /\\ compat_eval RV e r r' m.","proofString":"subst.\ninv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (e : env) (s2 : Csem.state) (r : expr) (m : mem) (H : step ge (ExprState f r Kstop e m) nil s2) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H2 : simple r) : m' = m /\\ compat_eval RV e r r' m.","proofString":"inv H.\nexploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto.\ninv H1."},{"statement":"(f : function) (e : env) (s2 : Csem.state) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil s2) : m' = m /\\ compat_eval RV e r r' m.","proofString":"exploit compat_eval_steps_aux; eauto.\nintros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (s2 : Csem.state) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil s2) : (exists r1 : expr,\n   s2 = ExprState f r1 Kstop e m /\\ compat_eval RV e r r1 m /\\ simple r1) ->\nm' = m /\\ compat_eval RV e r r' m.","proofString":"intros [r1 [A [B C]]].\nsubst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (s2 : Csem.state) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil s2) (r1 : expr) (A : s2 = ExprState f r1 Kstop e m) (B : compat_eval RV e r r1 m) (C : simple r1) : m' = m /\\ compat_eval RV e r r' m.","proofString":"subst s2.\nexploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (B : compat_eval RV e r r1 m) (C : simple r1) : m' = m /\\ compat_eval RV e r r' m.","proofString":"exploit IHstar; eauto.\nintros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (B : compat_eval RV e r r1 m) (C : simple r1) : m' = m /\\ compat_eval RV e r1 r' m -> m' = m /\\ compat_eval RV e r r' m.","proofString":"intros [D E].\nsplit.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (B : compat_eval RV e r r1 m) (C : simple r1) (D : m' = m) (E : compat_eval RV e r1 r' m) : m' = m /\\ compat_eval RV e r r' m.","proofString":"split.\nauto.\ndestruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (B : compat_eval RV e r r1 m) (C : simple r1) (D : m' = m) (E : compat_eval RV e r1 r' m) : m' = m.","proofString":"auto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (B : compat_eval RV e r r1 m) (C : simple r1) (D : m' = m) (E : compat_eval RV e r1 r' m) : compat_eval RV e r r' m.","proofString":"destruct B; destruct E.\nsplit.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (H : typeof r = typeof r1) (H3 : forall v : val, eval_simple_rvalue e m r1 v -> eval_simple_rvalue e m r v) (C : simple r1) (D : m' = m) (H4 : typeof r1 = typeof r') (H5 : forall v : val, eval_simple_rvalue e m r' v -> eval_simple_rvalue e m r1 v) : compat_eval RV e r r' m.","proofString":"split.\ncongruence.\nauto."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (H : typeof r = typeof r1) (H3 : forall v : val, eval_simple_rvalue e m r1 v -> eval_simple_rvalue e m r v) (C : simple r1) (D : m' = m) (H4 : typeof r1 = typeof r') (H5 : forall v : val, eval_simple_rvalue e m r' v -> eval_simple_rvalue e m r1 v) : typeof r = typeof r'.","proofString":"congruence."},{"statement":"(f : function) (e : env) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (r1 : expr) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\nExprState f r1 Kstop e m = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H0 : star step ge (ExprState f r1 Kstop e m) nil (ExprState f r' Kstop e m')) (H2 : simple r) (H1 : estep ge (ExprState f r Kstop e m) nil (ExprState f r1 Kstop e m)) (H : typeof r = typeof r1) (H3 : forall v : val, eval_simple_rvalue e m r1 v -> eval_simple_rvalue e m r v) (C : simple r1) (D : m' = m) (H4 : typeof r1 = typeof r') (H5 : forall v : val, eval_simple_rvalue e m r' v -> eval_simple_rvalue e m r1 v) : forall v : val, eval_simple_rvalue e m r' v -> eval_simple_rvalue e m r v.","proofString":"auto."},{"statement":"(f : function) (e : env) (s2 : Csem.state) (r : expr) (m : mem) (r' : expr) (m' : mem) (Heqt : nil ** nil = E0) (H0 : star step ge s2 nil (ExprState f r' Kstop e m')) (IHstar : forall (r0 : expr) (m0 : mem) (r'0 : expr) (m'0 : mem),\ns2 = ExprState f r0 Kstop e m0 ->\nnil = E0 ->\nExprState f r' Kstop e m' = ExprState f r'0 Kstop e m'0 ->\nsimple r0 -> m'0 = m0 /\\ compat_eval RV e r0 r'0 m0) (H2 : simple r) (H1 : sstep ge (ExprState f r Kstop e m) nil s2) : m' = m /\\ compat_eval RV e r r' m.","proofString":"inv H1."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (v : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0\n  (ExprState f (Eval v ty) Kstop e m')) (H0 : simple r) : m' = m /\\ ty = typeof r /\\ eval_simple_rvalue e m r v.","proofString":"exploit compat_eval_steps; eauto.\nintros [A [B C]].\nintuition.\napply C.\nconstructor."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (v : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0\n  (ExprState f (Eval v ty) Kstop e m')) (H0 : simple r) : m' = m /\\ compat_eval RV e r (Eval v ty) m ->\nm' = m /\\ ty = typeof r /\\ eval_simple_rvalue e m r v.","proofString":"intros [A [B C]].\nintuition.\napply C.\nconstructor."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (v : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0\n  (ExprState f (Eval v ty) Kstop e m')) (H0 : simple r) (A : m' = m) (B : typeof r = typeof (Eval v ty)) (C : forall v0 : val,\neval_simple_rvalue e m (Eval v ty) v0 -> eval_simple_rvalue e m r v0) : m' = m /\\ ty = typeof r /\\ eval_simple_rvalue e m r v.","proofString":"intuition.\napply C.\nconstructor."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (v : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0\n  (ExprState f (Eval v ty) Kstop e m')) (H0 : simple r) (A : m' = m) (B : typeof r = typeof (Eval v ty)) (C : forall v0 : val,\neval_simple_rvalue e m (Eval v ty) v0 -> eval_simple_rvalue e m r v0) : eval_simple_rvalue e m r v.","proofString":"apply C.\nconstructor."},{"statement":"(f : function) (r : expr) (e : env) (m : mem) (v : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop e m) E0\n  (ExprState f (Eval v ty) Kstop e m')) (H0 : simple r) (A : m' = m) (B : typeof r = typeof (Eval v ty)) (C : forall v0 : val,\neval_simple_rvalue e m (Eval v ty) v0 -> eval_simple_rvalue e m r v0) : eval_simple_rvalue e m (Eval v ty) v.","proofString":"constructor."},{"statement":"(b : block) (ofs : Z) : Mem.valid_pointer Mem.empty b ofs = false.","proofString":"unfold Mem.valid_pointer.\ndestruct (Mem.perm_dec Mem.empty b ofs Cur Nonempty); auto.\neelim Mem.perm_empty; eauto."},{"statement":"(b : block) (ofs : Z) : Mem.weak_valid_pointer Mem.empty b ofs = false.","proofString":"unfold Mem.weak_valid_pointer.\nnow rewrite !mem_empty_not_valid_pointer."},{"statement":"(b : block) (ofs : Z) : Mem.valid_pointer Mem.empty b ofs || Mem.valid_pointer Mem.empty b (ofs - 1) =\nfalse.","proofString":"now rewrite !mem_empty_not_valid_pointer."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (H0 : do_cast v1' ty1 ty2 = OK v2') (H1 : Val.inject inj v1' v1) : Val.inject inj v2' v2.","proofString":"unfold do_cast in H0.\ndestruct (sem_cast v1' ty1 ty2 Mem.empty) as [v2''|] eqn:E; inv H0.\nexploit (sem_cast_inj inj Mem.empty m).\nintros.\nrewrite mem_empty_not_weak_valid_pointer in H2.\ndiscriminate.\neexact E.\neauto.\nintros [v' [A B]].\ncongruence."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (H0 : match sem_cast v1' ty1 ty2 Mem.empty with\n| Some v' => OK v'\n| None => Error (msg \"undefined cast\")\nend = OK v2') (H1 : Val.inject inj v1' v1) : Val.inject inj v2' v2.","proofString":"destruct (sem_cast v1' ty1 ty2 Mem.empty) as [v2''|] eqn:E; inv H0.\nexploit (sem_cast_inj inj Mem.empty m).\nintros.\nrewrite mem_empty_not_weak_valid_pointer in H2.\ndiscriminate.\neexact E.\neauto.\nintros [v' [A B]].\ncongruence."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (E : sem_cast v1' ty1 ty2 Mem.empty = Some v2') (H1 : Val.inject inj v1' v1) : Val.inject inj v2' v2.","proofString":"exploit (sem_cast_inj inj Mem.empty m).\nintros.\nrewrite mem_empty_not_weak_valid_pointer in H2.\ndiscriminate.\neexact E.\neauto.\nintros [v' [A B]].\ncongruence."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (E : sem_cast v1' ty1 ty2 Mem.empty = Some v2') (H1 : Val.inject inj v1' v1) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\ninj b1 = Some (b2, delta) ->\nMem.weak_valid_pointer Mem.empty b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros.\nrewrite mem_empty_not_weak_valid_pointer in H2.\ndiscriminate."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (E : sem_cast v1' ty1 ty2 Mem.empty = Some v2') (H1 : Val.inject inj v1' v1) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : inj b1 = Some (b2, delta)) (H2 : Mem.weak_valid_pointer Mem.empty b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"rewrite mem_empty_not_weak_valid_pointer in H2.\ndiscriminate."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (E : sem_cast v1' ty1 ty2 Mem.empty = Some v2') (H1 : Val.inject inj v1' v1) (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H0 : inj b1 = Some (b2, delta)) (H2 : false = true) : Mem.weak_valid_pointer m b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"discriminate."},{"statement":"(v1 : val) (ty1 ty2 : type) (m : mem) (v2 v1' v2' : val) (H : sem_cast v1 ty1 ty2 m = Some v2) (E : sem_cast v1' ty1 ty2 Mem.empty = Some v2') (H1 : Val.inject inj v1' v1) (v' : val) (A : sem_cast v1 ty1 ty2 m = Some v') (B : Val.inject inj v2' v') : Val.inject inj v2' v2.","proofString":"congruence."},{"statement":"(v : val) (ty : type) (b : bool) (v' : val) (m : mem) (H : bool_val v ty Mem.empty = Some b) (H0 : Val.inject inj v v') : bool_val v' ty m = Some b.","proofString":"eapply bool_val_inj; eauto.\nintros.\nrewrite mem_empty_not_weak_valid_pointer in H2; discriminate."},{"statement":"(v : val) (ty : type) (b : bool) (v' : val) (m : mem) (H : bool_val v ty Mem.empty = Some b) (H0 : Val.inject inj v v') : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\ninj b1 = Some (b2, delta) ->\nMem.weak_valid_pointer Mem.empty b1 (Ptrofs.unsigned ofs) = true ->\nMem.weak_valid_pointer m b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros.\nrewrite mem_empty_not_weak_valid_pointer in H2; discriminate."},{"statement":"(v : val) (ty : type) (b : bool) (v' : val) (m : mem) (H : bool_val v ty Mem.empty = Some b) (H0 : Val.inject inj v v') (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z) (H1 : inj b1 = Some (b2, delta)) (H2 : Mem.weak_valid_pointer Mem.empty b1 (Ptrofs.unsigned ofs) = true) : Mem.weak_valid_pointer m b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"rewrite mem_empty_not_weak_valid_pointer in H2; discriminate."},{"statement":"(v : val) (b : block) (ofs : ptrofs) (delta : Z) (H : Val.inject inj v (Vptr b ofs)) : Val.inject inj\n  (if Archi.ptr64\n   then Val.addl v (Vlong (Int64.repr delta))\n   else Val.add v (Vint (Int.repr delta)))\n  (Vptr b (Ptrofs.add ofs (Ptrofs.repr delta))).","proofString":"inv H.\nrewrite Ptrofs.add_assoc.\nrewrite (Ptrofs.add_commut (Ptrofs.repr delta0)).\nunfold Val.addl, Val.add; destruct Archi.ptr64 eqn:SF;  econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs.\nunfold Val.addl, Val.add; destruct Archi.ptr64; auto."},{"statement":"(b : block) (delta : Z) (b1 : block) (ofs1 : ptrofs) (delta0 : Z) (H3 : inj b1 = Some (b, delta0)) : Val.inject inj\n  (if Archi.ptr64\n   then Val.addl (Vptr b1 ofs1) (Vlong (Int64.repr delta))\n   else Val.add (Vptr b1 ofs1) (Vint (Int.repr delta)))\n  (Vptr b\n     (Ptrofs.add (Ptrofs.add ofs1 (Ptrofs.repr delta0)) (Ptrofs.repr delta))).","proofString":"rewrite Ptrofs.add_assoc.\nrewrite (Ptrofs.add_commut (Ptrofs.repr delta0)).\nunfold Val.addl, Val.add; destruct Archi.ptr64 eqn:SF;  econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs."},{"statement":"(b : block) (delta : Z) (b1 : block) (ofs1 : ptrofs) (delta0 : Z) (H3 : inj b1 = Some (b, delta0)) : Val.inject inj\n  (if Archi.ptr64\n   then Val.addl (Vptr b1 ofs1) (Vlong (Int64.repr delta))\n   else Val.add (Vptr b1 ofs1) (Vint (Int.repr delta)))\n  (Vptr b\n     (Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta0) (Ptrofs.repr delta)))).","proofString":"rewrite (Ptrofs.add_commut (Ptrofs.repr delta0)).\nunfold Val.addl, Val.add; destruct Archi.ptr64 eqn:SF;  econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs."},{"statement":"(b : block) (delta : Z) (b1 : block) (ofs1 : ptrofs) (delta0 : Z) (H3 : inj b1 = Some (b, delta0)) : Val.inject inj\n  (if Archi.ptr64\n   then Val.addl (Vptr b1 ofs1) (Vlong (Int64.repr delta))\n   else Val.add (Vptr b1 ofs1) (Vint (Int.repr delta)))\n  (Vptr b\n     (Ptrofs.add ofs1 (Ptrofs.add (Ptrofs.repr delta) (Ptrofs.repr delta0)))).","proofString":"unfold Val.addl, Val.add; destruct Archi.ptr64 eqn:SF;  econstructor; eauto; rewrite ! Ptrofs.add_assoc; f_equal; f_equal; symmetry; auto with ptrofs."},{"statement":"(b : block) (ofs : ptrofs) (delta : Z) : Val.inject inj\n  (if Archi.ptr64\n   then Val.addl Vundef (Vlong (Int64.repr delta))\n   else Val.add Vundef (Vint (Int.repr delta)))\n  (Vptr b (Ptrofs.add ofs (Ptrofs.repr delta))).","proofString":"unfold Val.addl, Val.add; destruct Archi.ptr64; auto."},{"statement":"(a : expr) (ty : type) (IHa : forall v : val, constval ge a = OK v -> simple a) (vx : val) (CV : match access_mode ty with\n| By_reference | By_copy => constval ge a\n| _ => Error (msg \"dereferencing of an l-value\")\nend = OK vx) : simple a.","proofString":"destruct (access_mode ty); discriminate || eauto."},{"statement":"(a1 a2 a3 : expr) (ty : type) (IHa1 : forall v : val, constval ge a1 = OK v -> simple a1) (IHa2 : forall v : val, constval ge a2 = OK v -> simple a2) (IHa3 : forall v : val, constval ge a3 = OK v -> simple a3) (vx x : val) (EQ : constval ge a1 = OK x) (x0 : val) (EQ1 : constval ge a2 = OK x0) (x1 : val) (EQ0 : constval ge a3 = OK x1) (EQ3 : match bool_val x (typeof a1) Mem.empty with\n| Some true => do_cast x0 (typeof a2) ty\n| Some false => do_cast x1 (typeof a3) ty\n| None => Error (msg \"condition is undefined\")\nend = OK vx) : simple a1 /\\ simple a2 /\\ simple a3.","proofString":"intuition eauto."},{"statement":"(f : function) (r : expr) (m : mem) (v v' : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop empty_env m) E0\n  (ExprState f (Eval v' ty) Kstop empty_env m')) (H0 : constval ge r = OK v) : m' = m /\\ ty = typeof r /\\ Val.inject inj v v'.","proofString":"exploit eval_simple_steps; eauto.\neapply constval_simple; eauto.\nintros [A [B C]].\nintuition.\neapply constval_rvalue; eauto."},{"statement":"(f : function) (r : expr) (m : mem) (v v' : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop empty_env m) E0\n  (ExprState f (Eval v' ty) Kstop empty_env m')) (H0 : constval ge r = OK v) : simple r.","proofString":"eapply constval_simple; eauto."},{"statement":"(f : function) (r : expr) (m : mem) (v v' : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop empty_env m) E0\n  (ExprState f (Eval v' ty) Kstop empty_env m')) (H0 : constval ge r = OK v) : m' = m /\\ ty = typeof r /\\ eval_simple_rvalue empty_env m r v' ->\nm' = m /\\ ty = typeof r /\\ Val.inject inj v v'.","proofString":"intros [A [B C]].\nintuition.\neapply constval_rvalue; eauto."},{"statement":"(f : function) (r : expr) (m : mem) (v v' : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop empty_env m) E0\n  (ExprState f (Eval v' ty) Kstop empty_env m')) (H0 : constval ge r = OK v) (A : m' = m) (B : ty = typeof r) (C : eval_simple_rvalue empty_env m r v') : m' = m /\\ ty = typeof r /\\ Val.inject inj v v'.","proofString":"intuition.\neapply constval_rvalue; eauto."},{"statement":"(f : function) (r : expr) (m : mem) (v v' : val) (ty : type) (m' : mem) (H : star step ge (ExprState f r Kstop empty_env m) E0\n  (ExprState f (Eval v' ty) Kstop empty_env m')) (H0 : constval ge r = OK v) (A : m' = m) (B : ty = typeof r) (C : eval_simple_rvalue empty_env m r v') : Val.inject inj v v'.","proofString":"eapply constval_rvalue; eauto."},{"statement":"(il2 : list init_data) : boidl il2 = boidl il2.","proofString":"auto."},{"statement":"(il2 : list init_data) (il : init_data) (il1 : list init_data) (IHil1 : boidl (il1 ++ il2) = boidl il1 ++ boidl il2) : boid il ++ boidl (il1 ++ il2) = (boid il ++ boidl il1) ++ boidl il2.","proofString":"rewrite app_ass.\nf_equal; auto."},{"statement":"(il2 : list init_data) (il : init_data) (il1 : list init_data) (IHil1 : boidl (il1 ++ il2) = boidl il1 ++ boidl il2) : boid il ++ boidl (il1 ++ il2) = boid il ++ boidl il1 ++ boidl il2.","proofString":"f_equal; auto."},{"statement":"(i : init_data) (il : list init_data) : boidl (rev il ++ i :: nil) = boidl (rev il) ++ boid i.","proofString":"rewrite boidl_app.\nsimpl.\nrewrite app_nil_r.\nauto."},{"statement":"(i : init_data) (il : list init_data) : boidl (rev il) ++ boidl (i :: nil) = boidl (rev il) ++ boid i.","proofString":"simpl.\nrewrite app_nil_r.\nauto."},{"statement":"(i : init_data) (il : list init_data) : boidl (rev il) ++ boid i ++ nil = boidl (rev il) ++ boid i.","proofString":"rewrite app_nil_r.\nauto."},{"statement":"(i : init_data) (il : list init_data) : boidl (rev il) ++ boid i = boidl (rev il) ++ boid i.","proofString":"auto."},{"statement":"(b : byte) : byte_of_int (int_of_byte b) = b.","proofString":"unfold int_of_byte, byte_of_int.\nrewrite Int.unsigned_repr, Byte.repr_unsigned.\nauto.\nassert(Byte.max_unsigned < Int.max_unsigned) by reflexivity.\ngeneralize (Byte.unsigned_range_2 b).\nlia."},{"statement":"(b : byte) : Byte.repr (Int.unsigned (Int.repr (Byte.unsigned b))) = b.","proofString":"rewrite Int.unsigned_repr, Byte.repr_unsigned.\nauto.\nassert(Byte.max_unsigned < Int.max_unsigned) by reflexivity.\ngeneralize (Byte.unsigned_range_2 b).\nlia."},{"statement":"(b : byte) : b = b.","proofString":"auto."},{"statement":"(b : byte) : 0 <= Byte.unsigned b <= Int.max_unsigned.","proofString":"assert(Byte.max_unsigned < Int.max_unsigned) by reflexivity.\ngeneralize (Byte.unsigned_range_2 b).\nlia."},{"statement":"(b : byte) (H : Byte.max_unsigned < Int.max_unsigned) : 0 <= Byte.unsigned b <= Int.max_unsigned.","proofString":"generalize (Byte.unsigned_range_2 b).\nlia."},{"statement":"(b : byte) (H : Byte.max_unsigned < Int.max_unsigned) : 0 <= Byte.unsigned b <= Byte.max_unsigned ->\n0 <= Byte.unsigned b <= Int.max_unsigned.","proofString":"lia."},{"statement":"(n : Z) : inj_bytes (encode_int 1 n) = Byte (Byte.repr n) :: nil.","proofString":"unfold encode_int, bytes_of_int, rev_if_be.\ndestruct Archi.big_endian; auto."},{"statement":"(n : Z) : inj_bytes\n  (if Archi.big_endian then rev (Byte.repr n :: nil) else Byte.repr n :: nil) =\nByte (Byte.repr n) :: nil.","proofString":"destruct Archi.big_endian; auto."},{"statement":"(b : byte) : inj_bytes (encode_int 1 (Int.unsigned (int_of_byte b))) = Byte b :: nil.","proofString":"rewrite inj_bytes_1.\ndo 2 f_equal.\napply byte_of_int_of_byte."},{"statement":"(b : byte) : Byte (Byte.repr (Int.unsigned (int_of_byte b))) :: nil = Byte b :: nil.","proofString":"do 2 f_equal.\napply byte_of_int_of_byte."},{"statement":"(b : byte) : Byte.repr (Int.unsigned (int_of_byte b)) = b.","proofString":"apply byte_of_int_of_byte."},{"statement":"(i : int) (l : list int) (IHl : boidl (map Init_int8 l) = inj_bytes (map byte_of_int l)) : inj_bytes (encode_int 1 (Int.unsigned i)) ++ boidl (map Init_int8 l) =\nByte (byte_of_int i) :: inj_bytes (map byte_of_int l).","proofString":"rewrite inj_bytes_1; simpl.\nf_equal; auto."},{"statement":"(i : int) (l : list int) (IHl : boidl (map Init_int8 l) = inj_bytes (map byte_of_int l)) : Byte (Byte.repr (Int.unsigned i)) :: boidl (map Init_int8 l) =\nByte (byte_of_int i) :: inj_bytes (map byte_of_int l).","proofString":"f_equal; auto."},{"statement":"(b : byte) (l : list byte) (IHl : boidl (map Init_byte l) = inj_bytes l) : inj_bytes (encode_int 1 (Int.unsigned (int_of_byte b))) ++\nboidl (map Init_byte l) = Byte b :: inj_bytes l.","proofString":"rewrite inj_bytes_byte, IHl.\nauto."},{"statement":"(b : byte) (l : list byte) (IHl : boidl (map Init_byte l) = inj_bytes l) : (Byte b :: nil) ++ inj_bytes l = Byte b :: inj_bytes l.","proofString":"auto."},{"statement":"(i : int) (n : nat) (IHn : boidl (repeat (Init_int8 i) n) = repeat (Byte (byte_of_int i)) n) : inj_bytes (encode_int 1 (Int.unsigned i)) ++ boidl (repeat (Init_int8 i) n) =\nByte (byte_of_int i) :: repeat (Byte (byte_of_int i)) n.","proofString":"rewrite inj_bytes_1.\nsimpl; f_equal; auto."},{"statement":"(i : int) (n : nat) (IHn : boidl (repeat (Init_int8 i) n) = repeat (Byte (byte_of_int i)) n) : (Byte (Byte.repr (Int.unsigned i)) :: nil) ++ boidl (repeat (Init_int8 i) n) =\nByte (byte_of_int i) :: repeat (Byte (byte_of_int i)) n.","proofString":"simpl; f_equal; auto."},{"statement":"(il : list init_data) : il = il.","proofString":"auto."},{"statement":"(b : byte) (l : list byte) (IHl : forall il0 : list init_data,\nadd_rev_bytes l il0 = map Init_byte (rev l) ++ il0) (il : list init_data) : add_rev_bytes l (Init_byte b :: il) = map Init_byte (rev l ++ b :: nil) ++ il.","proofString":"rewrite IHl.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nauto."},{"statement":"(b : byte) (l : list byte) (IHl : forall il0 : list init_data,\nadd_rev_bytes l il0 = map Init_byte (rev l) ++ il0) (il : list init_data) : map Init_byte (rev l) ++ Init_byte b :: il =\nmap Init_byte (rev l ++ b :: nil) ++ il.","proofString":"rewrite map_app.\nsimpl.\nrewrite app_ass.\nauto."},{"statement":"(b : byte) (l : list byte) (IHl : forall il0 : list init_data,\nadd_rev_bytes l il0 = map Init_byte (rev l) ++ il0) (il : list init_data) : map Init_byte (rev l) ++ Init_byte b :: il =\n(map Init_byte (rev l) ++ map Init_byte (b :: nil)) ++ il.","proofString":"simpl.\nrewrite app_ass.\nauto."},{"statement":"(b : byte) (l : list byte) (IHl : forall il0 : list init_data,\nadd_rev_bytes l il0 = map Init_byte (rev l) ++ il0) (il : list init_data) : map Init_byte (rev l) ++ Init_byte b :: il =\n(map Init_byte (rev l) ++ Init_byte b :: nil) ++ il.","proofString":"rewrite app_ass.\nauto."},{"statement":"(b : byte) (l : list byte) (IHl : forall il0 : list init_data,\nadd_rev_bytes l il0 = map Init_byte (rev l) ++ il0) (il : list init_data) : map Init_byte (rev l) ++ Init_byte b :: il =\nmap Init_byte (rev l) ++ (Init_byte b :: nil) ++ il.","proofString":"auto."},{"statement":"(l : list byte) (il : list init_data) : rev (add_rev_bytes l il) = rev il ++ map Init_byte l.","proofString":"rewrite add_rev_bytes_spec.\nrewrite rev_app_distr, map_rev, rev_involutive.\nauto."},{"statement":"(l : list byte) (il : list init_data) : rev (map Init_byte (rev l) ++ il) = rev il ++ map Init_byte l.","proofString":"rewrite rev_app_distr, map_rev, rev_involutive.\nauto."},{"statement":"(l : list byte) (il : list init_data) : rev il ++ map Init_byte l = rev il ++ map Init_byte l.","proofString":"auto."},{"statement":"(n : Z) (il : list init_data) (H : 0 <= n) : add_zeros n il = repeat (Init_int8 Int.zero) (Z.to_nat n) ++ il.","proofString":"unfold add_zeros; rewrite iter_nat_of_Z by auto; rewrite Zabs2Nat.abs_nat_nonneg by auto.\ninduction (Z.to_nat n); simpl.\nauto.\nf_equal; auto."},{"statement":"(n : Z) (il : list init_data) (H : 0 <= n) : nat_rect (fun _ : nat => list init_data) il\n  (fun (_ : nat) (l : list init_data) => Init_int8 Int.zero :: l)\n  (Z.to_nat n) = repeat (Init_int8 Int.zero) (Z.to_nat n) ++ il.","proofString":"induction (Z.to_nat n); simpl.\nauto.\nf_equal; auto."},{"statement":"(n : Z) (il : list init_data) (H : 0 <= n) : il = il.","proofString":"auto."},{"statement":"(n : Z) (il : list init_data) (H : 0 <= n) (n0 : nat) (IHn0 : nat_rect (fun _ : nat => list init_data) il\n  (fun (_ : nat) (l : list init_data) => Init_int8 Int.zero :: l) n0 =\nrepeat (Init_int8 Int.zero) n0 ++ il) : Init_int8 Int.zero\n:: nat_rect (fun _ : nat => list init_data) il\n     (fun (_ : nat) (l : list init_data) => Init_int8 Int.zero :: l) n0 =\nInit_int8 Int.zero :: repeat (Init_int8 Int.zero) n0 ++ il.","proofString":"f_equal; auto."},{"statement":"forall (il : list init_data) (accu : list byte) (depth : Z) \n  (bl : list byte) (il' : list init_data),\ndecompose_rec accu il depth = OK (bl, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"induction il as [ | i il ]; intros until il'; intros D; simpl in D.\ndestruct (zle depth 0); inv D.\nexists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto.\ndestruct (zle depth 0).\ninv D.\nexists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto.\ndestruct i; try discriminate.\napply IHil in D; destruct D as (nl & P & Q & R).\nexists (i :: nl); simpl; split.\ncongruence.\nsplit.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (D : (if zle depth 0 then OK (accu, nil) else Error (msg \"decompose: wrong shape\")) =\nOK (bl, il')) : exists nl : list int,\n  nil = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"destruct (zle depth 0); inv D.\nexists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto."},{"statement":"(depth : Z) (bl : list byte) (l : depth <= 0) : exists nl : list int,\n  nil = map Init_int8 nl ++ nil /\\\n  bl = map byte_of_int (rev nl) ++ bl /\\ Datatypes.length nl = Z.to_nat depth.","proofString":"exists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu0 /\\\n  Datatypes.length nl = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (D : (if zle depth 0\n then OK (accu, i :: il)\n else\n  match i with\n  | Init_int8 n =>\n      decompose_rec (Byte.repr (Int.unsigned n) :: accu) il (depth - 1)\n  | _ => Error (msg \"decompose: wrong shape\")\n  end) = OK (bl, il')) : exists nl : list int,\n  i :: il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"destruct (zle depth 0).\ninv D.\nexists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto.\ndestruct i; try discriminate.\napply IHil in D; destruct D as (nl & P & Q & R).\nexists (i :: nl); simpl; split.\ncongruence.\nsplit.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu0 /\\\n  Datatypes.length nl = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (l : depth <= 0) (D : OK (accu, i :: il) = OK (bl, il')) : exists nl : list int,\n  i :: il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"inv D.\nexists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu : list byte) (depth0 : Z) (bl0 : list byte)\n  (il' : list init_data),\ndecompose_rec accu il depth0 = OK (bl0, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl0 = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth0) (depth : Z) (bl : list byte) (l : depth <= 0) : exists nl : list int,\n  i :: il = map Init_int8 nl ++ i :: il /\\\n  bl = map byte_of_int (rev nl) ++ bl /\\ Datatypes.length nl = Z.to_nat depth.","proofString":"exists (@nil int); simpl.\nrewrite Z_to_nat_neg by auto.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu : list byte) (depth0 : Z) (bl0 : list byte)\n  (il' : list init_data),\ndecompose_rec accu il depth0 = OK (bl0, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl0 = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth0) (depth : Z) (bl : list byte) (l : depth <= 0) : i :: il = i :: il /\\ bl = bl /\\ 0%nat = Z.to_nat depth.","proofString":"rewrite Z_to_nat_neg by auto.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu : list byte) (depth0 : Z) (bl0 : list byte)\n  (il' : list init_data),\ndecompose_rec accu il depth0 = OK (bl0, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl0 = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth0) (depth : Z) (bl : list byte) (l : depth <= 0) : i :: il = i :: il /\\ bl = bl /\\ 0%nat = 0%nat.","proofString":"auto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu0 /\\\n  Datatypes.length nl = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (D : match i with\n| Init_int8 n =>\n    decompose_rec (Byte.repr (Int.unsigned n) :: accu) il (depth - 1)\n| _ => Error (msg \"decompose: wrong shape\")\nend = OK (bl, il')) : exists nl : list int,\n  i :: il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"destruct i; try discriminate.\napply IHil in D; destruct D as (nl & P & Q & R).\nexists (i :: nl); simpl; split.\ncongruence.\nsplit.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu0 /\\\n  Datatypes.length nl = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (D : decompose_rec (Byte.repr (Int.unsigned i) :: accu) il (depth - 1) =\nOK (bl, il')) : exists nl : list int,\n  Init_int8 i :: il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth.","proofString":"apply IHil in D; destruct D as (nl & P & Q & R).\nexists (i :: nl); simpl; split.\ncongruence.\nsplit.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : exists nl0 : list int,\n  Init_int8 i :: il = map Init_int8 nl0 ++ il' /\\\n  bl = map byte_of_int (rev nl0) ++ accu /\\\n  Datatypes.length nl0 = Z.to_nat depth.","proofString":"exists (i :: nl); simpl; split.\ncongruence.\nsplit.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : Init_int8 i :: il = Init_int8 i :: map Init_int8 nl ++ il'.","proofString":"congruence."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : bl = map byte_of_int (rev nl ++ i :: nil) ++ accu /\\\nS (Datatypes.length nl) = Z.to_nat depth.","proofString":"split.\nrewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q.\nrewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : bl = map byte_of_int (rev nl ++ i :: nil) ++ accu.","proofString":"rewrite map_app.\nsimpl.\nrewrite app_ass.\nexact Q."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : bl = (map byte_of_int (rev nl) ++ map byte_of_int (i :: nil)) ++ accu.","proofString":"simpl.\nrewrite app_ass.\nexact Q."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : bl = (map byte_of_int (rev nl) ++ byte_of_int i :: nil) ++ accu.","proofString":"rewrite app_ass.\nexact Q."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : bl = map byte_of_int (rev nl) ++ (byte_of_int i :: nil) ++ accu.","proofString":"exact Q."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : S (Datatypes.length nl) = Z.to_nat depth.","proofString":"rewrite R, <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(i : int) (il : list init_data) (IHil : forall (accu0 : list byte) (depth0 : Z) (bl0 : list byte)\n  (il'0 : list init_data),\ndecompose_rec accu0 il depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu0 /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (accu : list byte) (depth : Z) (bl : list byte) (il' : list init_data) (g : depth > 0) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ Byte.repr (Int.unsigned i) :: accu) (R : Datatypes.length nl = Z.to_nat (depth - 1)) : Z.to_nat (Z.succ (depth - 1)) = Z.to_nat depth.","proofString":"f_equal; lia."},{"statement":"(REC : forall (il : list init_data) (accu : list byte) (depth : Z) \n  (bl : list byte) (il' : list init_data),\ndecompose_rec accu il depth = OK (bl, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth) : forall (il : list init_data) (depth : Z) (bl : list byte)\n  (il' : list init_data),\ndecompose il depth = OK (bl, il') ->\nexists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat depth.","proofString":"intros.\napply REC in H.\ndestruct H as (nl & P & Q & R).\nrewrite app_nil_r in Q.\nexists nl; auto."},{"statement":"(REC : forall (il0 : list init_data) (accu : list byte) (depth0 : Z)\n  (bl0 : list byte) (il'0 : list init_data),\ndecompose_rec accu il0 depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il0 = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth0) (il : list init_data) (depth : Z) (bl : list byte) (il' : list init_data) (H : decompose il depth = OK (bl, il')) : exists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat depth.","proofString":"apply REC in H.\ndestruct H as (nl & P & Q & R).\nrewrite app_nil_r in Q.\nexists nl; auto."},{"statement":"(REC : forall (il0 : list init_data) (accu : list byte) (depth0 : Z)\n  (bl0 : list byte) (il'0 : list init_data),\ndecompose_rec accu il0 depth0 = OK (bl0, il'0) ->\nexists nl : list int,\n  il0 = map Init_int8 nl ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl) ++ accu /\\\n  Datatypes.length nl = Z.to_nat depth0) (il : list init_data) (depth : Z) (bl : list byte) (il' : list init_data) (H : exists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) ++ nil /\\\n  Datatypes.length nl = Z.to_nat depth) : exists nl : list int,\n  il = map Init_int8 nl ++ il' /\\\n  bl = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat depth.","proofString":"destruct H as (nl & P & Q & R).\nrewrite app_nil_r in Q.\nexists nl; auto."},{"statement":"(REC : forall (il0 : list init_data) (accu : list byte) (depth0 : Z)\n  (bl0 : list byte) (il'0 : list init_data),\ndecompose_rec accu il0 depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il0 = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (il : list init_data) (depth : Z) (bl : list byte) (il' : list init_data) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl) ++ nil) (R : Datatypes.length nl = Z.to_nat depth) : exists nl0 : list int,\n  il = map Init_int8 nl0 ++ il' /\\\n  bl = map byte_of_int (rev nl0) /\\ Datatypes.length nl0 = Z.to_nat depth.","proofString":"rewrite app_nil_r in Q.\nexists nl; auto."},{"statement":"(REC : forall (il0 : list init_data) (accu : list byte) (depth0 : Z)\n  (bl0 : list byte) (il'0 : list init_data),\ndecompose_rec accu il0 depth0 = OK (bl0, il'0) ->\nexists nl0 : list int,\n  il0 = map Init_int8 nl0 ++ il'0 /\\\n  bl0 = map byte_of_int (rev nl0) ++ accu /\\\n  Datatypes.length nl0 = Z.to_nat depth0) (il : list init_data) (depth : Z) (bl : list byte) (il' : list init_data) (nl : list int) (P : il = map Init_int8 nl ++ il') (Q : bl = map byte_of_int (rev nl)) (R : Datatypes.length nl = Z.to_nat depth) : exists nl0 : list int,\n  il = map Init_int8 nl0 ++ il' /\\\n  bl = map byte_of_int (rev nl0) /\\ Datatypes.length nl0 = Z.to_nat depth.","proofString":"exists nl; auto."},{"statement":"(A : Type) (a : A) (n : nat) (IHn : rev (repeat a n) = repeat a n) : rev (repeat a n) ++ a :: nil = a :: repeat a n.","proofString":"rewrite IHn.\nchange (a :: nil) with (repeat a 1%nat).\nrewrite list_repeat_app.\nrewrite Nat.add_comm.\nauto."},{"statement":"(A : Type) (a : A) (n : nat) (IHn : rev (repeat a n) = repeat a n) : repeat a n ++ a :: nil = a :: repeat a n.","proofString":"change (a :: nil) with (repeat a 1%nat).\nrewrite list_repeat_app.\nrewrite Nat.add_comm.\nauto."},{"statement":"(A : Type) (a : A) (n : nat) (IHn : rev (repeat a n) = repeat a n) : repeat a n ++ repeat a 1 = a :: repeat a n.","proofString":"rewrite list_repeat_app.\nrewrite Nat.add_comm.\nauto."},{"statement":"(A : Type) (a : A) (n : nat) (IHn : rev (repeat a n) = repeat a n) : repeat a (n + 1) = a :: repeat a n.","proofString":"rewrite Nat.add_comm.\nauto."},{"statement":"(A : Type) (a : A) (n : nat) (IHn : rev (repeat a n) = repeat a n) : repeat a (1 + n) = a :: repeat a n.","proofString":"auto."},{"statement":"(depth : Z) (il' : list init_data) (AT : (if zle depth 0 then OK nil else Error (msg \"normalize: empty list\")) =\nOK il') : boidl (rev il') = nil.","proofString":"destruct (zle depth 0); inv AT.\nauto."},{"statement":"(depth : Z) (l : depth <= 0) : boidl (rev nil) = nil.","proofString":"auto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> boidl (rev il'0) = boidl (rev il)) (depth : Z) (il' : list init_data) (AT : (if zle depth 0\n then OK (i :: il)\n else\n  match i with\n  | Init_int8 n =>\n      do il'0 <- normalize il (depth - 1); OK (Init_int8 n :: il'0)\n  | Init_int16 n =>\n      do il'0 <- normalize il (depth - 2);\n      OK (add_rev_bytes (encode_int 2 (Int.unsigned n)) il'0)\n  | Init_int32 n =>\n      do il'0 <- normalize il (depth - 4);\n      OK (add_rev_bytes (encode_int 4 (Int.unsigned n)) il'0)\n  | Init_int64 n =>\n      do il'0 <- normalize il (depth - 8);\n      OK (add_rev_bytes (encode_int 8 (Int64.unsigned n)) il'0)\n  | Init_float32 f =>\n      do il'0 <- normalize il (depth - 4);\n      OK\n        (add_rev_bytes (encode_int 4 (Int.unsigned (Float32.to_bits f))) il'0)\n  | Init_float64 f =>\n      do il'0 <- normalize il (depth - 8);\n      OK\n        (add_rev_bytes (encode_int 8 (Int64.unsigned (Float.to_bits f))) il'0)\n  | Init_space n =>\n      if zle (Z.max 0 n) depth\n      then\n       do il'0 <- normalize il (depth - Z.max 0 n);\n       OK (add_zeros (Z.max 0 n) il'0)\n      else OK (add_zeros depth (Init_space (Z.max 0 n - depth) :: il))\n  | Init_addrof _ _ => Error (msg \"normalize: Init_addrof\")\n  end) = OK il') : boidl (rev il') = boidl (rev il ++ i :: nil).","proofString":"destruct (zle depth 0).\ninv AT.\nauto.\ndestruct i;  try (monadInv AT; simpl;       rewrite ? add_rev_bytes_spec', ? boidl_rev_cons, ? boidl_app, ? boidl_init_bytes;       erewrite IHil by eauto; reflexivity).\nset (n := Z.max 0 z) in *.\ndestruct (zle n depth); monadInv AT.\nrewrite add_zeros_spec, rev_app_distr, ! boidl_app by lia.\nerewrite IHil by eauto.\nf_equal.\nrewrite list_rev_repeat.\nsimpl.\nrewrite app_nil_r, boidl_ints8.\nf_equal.\nunfold n.\napply Z.max_case_strong; intros; auto.\nrewrite ! Z_to_nat_neg by lia.\nauto.\nrewrite add_zeros_spec, rev_app_distr, !boidl_app by lia.\nsimpl.\nrewrite boidl_rev_cons, list_rev_repeat.\nsimpl.\nrewrite app_ass, app_nil_r, !boidl_ints8.\nf_equal.\nrewrite list_repeat_app.\nf_equal.\nrewrite <- Z2Nat.inj_add by lia.\nunfold n.\napply Z.max_case_strong; intros; f_equal; lia."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> boidl (rev il'0) = boidl (rev il)) (depth : Z) (il' : list init_data) (l : depth <= 0) (AT : OK (i :: il) = OK il') : boidl (rev il') = boidl (rev il ++ i :: nil).","proofString":"inv AT.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> boidl (rev il') = boidl (rev il)) (depth : Z) (l : depth <= 0) : boidl (rev (i :: il)) = boidl (rev il ++ i :: nil).","proofString":"auto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> boidl (rev il'0) = boidl (rev il)) (depth : Z) (il' : list init_data) (g : depth > 0) (AT : match i with\n| Init_int8 n =>\n    do il'0 <- normalize il (depth - 1); OK (Init_int8 n :: il'0)\n| Init_int16 n =>\n    do il'0 <- normalize il (depth - 2);\n    OK (add_rev_bytes (encode_int 2 (Int.unsigned n)) il'0)\n| Init_int32 n =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned n)) il'0)\n| Init_int64 n =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned n)) il'0)\n| Init_float32 f =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned (Float32.to_bits f))) il'0)\n| Init_float64 f =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned (Float.to_bits f))) il'0)\n| Init_space n =>\n    if zle (Z.max 0 n) depth\n    then\n     do il'0 <- normalize il (depth - Z.max 0 n);\n     OK (add_zeros (Z.max 0 n) il'0)\n    else OK (add_zeros depth (Init_space (Z.max 0 n - depth) :: il))\n| Init_addrof _ _ => Error (msg \"normalize: Init_addrof\")\nend = OK il') : boidl (rev il') = boidl (rev il ++ i :: nil).","proofString":"destruct i;  try (monadInv AT; simpl;       rewrite ? add_rev_bytes_spec', ? boidl_rev_cons, ? boidl_app, ? boidl_init_bytes;       erewrite IHil by eauto; reflexivity).\nset (n := Z.max 0 z) in *.\ndestruct (zle n depth); monadInv AT.\nrewrite add_zeros_spec, rev_app_distr, ! boidl_app by lia.\nerewrite IHil by eauto.\nf_equal.\nrewrite list_rev_repeat.\nsimpl.\nrewrite app_nil_r, boidl_ints8.\nf_equal.\nunfold n.\napply Z.max_case_strong; intros; auto.\nrewrite ! Z_to_nat_neg by lia.\nauto.\nrewrite add_zeros_spec, rev_app_distr, !boidl_app by lia.\nsimpl.\nrewrite boidl_rev_cons, list_rev_repeat.\nsimpl.\nrewrite app_ass, app_nil_r, !boidl_ints8.\nf_equal.\nrewrite list_repeat_app.\nf_equal.\nrewrite <- Z2Nat.inj_add by lia.\nunfold n.\napply Z.max_case_strong; intros; f_equal; lia."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> boidl (rev il'0) = boidl (rev il)) (depth : Z) (il' : list init_data) (g : depth > 0) (AT : (if zle (Z.max 0 z) depth\n then\n  do il'0 <- normalize il (depth - Z.max 0 z);\n  OK (add_zeros (Z.max 0 z) il'0)\n else OK (add_zeros depth (Init_space (Z.max 0 z - depth) :: il))) = \nOK il') : boidl (rev il') = boidl (rev il ++ Init_space z :: nil).","proofString":"set (n := Z.max 0 z) in *.\ndestruct (zle n depth); monadInv AT.\nrewrite add_zeros_spec, rev_app_distr, ! boidl_app by lia.\nerewrite IHil by eauto.\nf_equal.\nrewrite list_rev_repeat.\nsimpl.\nrewrite app_nil_r, boidl_ints8.\nf_equal.\nunfold n.\napply Z.max_case_strong; intros; auto.\nrewrite ! Z_to_nat_neg by lia.\nauto.\nrewrite add_zeros_spec, rev_app_distr, !boidl_app by lia.\nsimpl.\nrewrite boidl_rev_cons, list_rev_repeat.\nsimpl.\nrewrite app_ass, app_nil_r, !boidl_ints8.\nf_equal.\nrewrite list_repeat_app.\nf_equal.\nrewrite <- Z2Nat.inj_add by lia.\nunfold n.\napply Z.max_case_strong; intros; f_equal; lia."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> boidl (rev il') = boidl (rev il)) (depth : Z) (g : depth > 0) (n : Z) (l : n <= depth) (x : list init_data) (EQ : normalize il (depth - n) = OK x) : Z.to_nat (Z.max 0 z) = Z.to_nat z.","proofString":"apply Z.max_case_strong; intros; auto.\nrewrite ! Z_to_nat_neg by lia.\nauto."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> boidl (rev il') = boidl (rev il)) (depth : Z) (g : depth > 0) (n : Z) (l : n <= depth) (x : list init_data) (EQ : normalize il (depth - n) = OK x) (H : z <= 0) : Z.to_nat 0 = Z.to_nat z.","proofString":"rewrite ! Z_to_nat_neg by lia.\nauto."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> boidl (rev il') = boidl (rev il)) (depth : Z) (g : depth > 0) (n : Z) (l : n <= depth) (x : list init_data) (EQ : normalize il (depth - n) = OK x) (H : z <= 0) : 0%nat = 0%nat.","proofString":"auto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H : (do il0 <- normalize il (depth + sz);\n do (bytes0, il1)<- decompose il0 depth;\n do (bytes3, il2)<- decompose il1 sz; OK (bytes0, bytes3, il2)) =\nOK (bytes1, bytes2, il')) : boidl (rev il) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"monadInv H.\napply normalize_boidl in EQ.\nrewrite <- EQ.\napply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (EQ1 : decompose x depth = OK (bytes1, x1)) (EQ0 : decompose x1 sz = OK (bytes2, il')) : boidl (rev il) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"apply normalize_boidl in EQ.\nrewrite <- EQ.\napply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (EQ1 : decompose x depth = OK (bytes1, x1)) (EQ0 : decompose x1 sz = OK (bytes2, il')) : boidl (rev il) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"rewrite <- EQ.\napply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (EQ1 : decompose x depth = OK (bytes1, x1)) (EQ0 : decompose x1 sz = OK (bytes2, il')) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"apply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (EQ1 : exists nl : list int,\n  x = map Init_int8 nl ++ x1 /\\\n  bytes1 = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat depth) (EQ0 : decompose x1 sz = OK (bytes2, il')) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"destruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (EQ0 : decompose x1 sz = OK (bytes2, il')) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"apply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (EQ0 : exists nl : list int,\n  x1 = map Init_int8 nl ++ il' /\\\n  bytes2 = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat sz) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"destruct EQ0 as (nl2 & A2 & B2 & C2).\nsplit.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"split.\nrewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto.\nrewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : boidl (rev x) = boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1.","proofString":"rewrite A1, A2, !rev_app_distr, !boidl_app, app_ass.\nrewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : boidl (rev il') ++\nboidl (rev (map Init_int8 nl2)) ++ boidl (rev (map Init_int8 nl1)) =\nboidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1.","proofString":"rewrite <- !map_rev, !boidl_init_ints8.\nrewrite <- B1, <- B2.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : boidl (rev il') ++\ninj_bytes (map byte_of_int (rev nl2)) ++\ninj_bytes (map byte_of_int (rev nl1)) =\nboidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1.","proofString":"rewrite <- B1, <- B2.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : boidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1 =\nboidl (rev il') ++ inj_bytes bytes2 ++ inj_bytes bytes1.","proofString":"auto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : Datatypes.length bytes1 = Z.to_nat depth /\\\nDatatypes.length bytes2 = Z.to_nat sz.","proofString":"rewrite B1, B2, !map_length, !rev_length.\nauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' x : list init_data) (EQ : boidl (rev x) = boidl (rev il)) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : Datatypes.length nl1 = Z.to_nat depth /\\ Datatypes.length nl2 = Z.to_nat sz.","proofString":"auto."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (H : Some m = Some m') (H0 : False) : Mem.loadbytes m' b p (init_data_size (Init_space z)) =\nSome (boid (Init_space z)).","proofString":"contradiction."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match Genv.find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : True) : Mem.loadbytes m' b p (init_data_size (Init_addrof i i0)) =\nSome (boid (Init_addrof i i0)).","proofString":"rewrite Genv.init_data_size_addrof.\nsimpl.\ndestruct (Genv.find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match Genv.find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : True) : Mem.loadbytes m' b p (size_chunk Mptr) = Some (boid (Init_addrof i i0)).","proofString":"simpl.\ndestruct (Genv.find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match Genv.find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : True) : Mem.loadbytes m' b p (size_chunk Mptr) =\nSome\n  match Genv.find_symbol ge i with\n  | Some b0 => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b0 i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"destruct (Genv.find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (b' : block) (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : True) : Mem.loadbytes m' b p (size_chunk Mptr) =\nSome (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"rewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (b' : block) (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : True) : Some (encode_val Mptr (Vptr b' i0)) =\nSome (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"unfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(l2 : list init_data) (pos : Z) : idlvalid pos l2 <-> True /\\ idlvalid (pos + 0) l2.","proofString":"rewrite Z.add_0_r; tauto."},{"statement":"(l2 : list init_data) (d : init_data) (l1 : list init_data) (IHl1 : forall pos0 : Z,\nidlvalid pos0 (l1 ++ l2) <->\nidlvalid pos0 l1 /\\ idlvalid (pos0 + init_data_list_size l1) l2) (pos : Z) : (Genv.init_data_alignment d | pos) /\\\nidvalid d /\\ idlvalid (pos + init_data_size d) (l1 ++ l2) <->\n((Genv.init_data_alignment d | pos) /\\\n idvalid d /\\ idlvalid (pos + init_data_size d) l1) /\\\nidlvalid (pos + (init_data_size d + init_data_list_size l1)) l2.","proofString":"rewrite IHl1.\nrewrite Z.add_assoc.\ntauto."},{"statement":"(l2 : list init_data) (d : init_data) (l1 : list init_data) (IHl1 : forall pos0 : Z,\nidlvalid pos0 (l1 ++ l2) <->\nidlvalid pos0 l1 /\\ idlvalid (pos0 + init_data_list_size l1) l2) (pos : Z) : (Genv.init_data_alignment d | pos) /\\\nidvalid d /\\\nidlvalid (pos + init_data_size d) l1 /\\\nidlvalid (pos + init_data_size d + init_data_list_size l1) l2 <->\n((Genv.init_data_alignment d | pos) /\\\n idvalid d /\\ idlvalid (pos + init_data_size d) l1) /\\\nidlvalid (pos + (init_data_size d + init_data_list_size l1)) l2.","proofString":"rewrite Z.add_assoc.\ntauto."},{"statement":"(l2 : list init_data) (d : init_data) (l1 : list init_data) (IHl1 : forall pos0 : Z,\nidlvalid pos0 (l1 ++ l2) <->\nidlvalid pos0 l1 /\\ idlvalid (pos0 + init_data_list_size l1) l2) (pos : Z) : (Genv.init_data_alignment d | pos) /\\\nidvalid d /\\\nidlvalid (pos + init_data_size d) l1 /\\\nidlvalid (pos + init_data_size d + init_data_list_size l1) l2 <->\n((Genv.init_data_alignment d | pos) /\\\n idvalid d /\\ idlvalid (pos + init_data_size d) l1) /\\\nidlvalid (pos + init_data_size d + init_data_list_size l1) l2.","proofString":"tauto."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) : idlvalid 0 (rev (add_rev_bytes bl il)).","proofString":"rewrite add_rev_bytes_spec, rev_app_distr, idlvalid_app.\nsplit; auto.\ngeneralize (rev bl) (0 + init_data_list_size (rev il)).\ninduction l; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) : idlvalid 0 (rev il) /\\\nidlvalid (0 + init_data_list_size (rev il)) (rev (map Init_byte (rev bl))).","proofString":"split; auto.\ngeneralize (rev bl) (0 + init_data_list_size (rev il)).\ninduction l; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) : idlvalid (0 + init_data_list_size (rev il)) (rev (map Init_byte (rev bl))).","proofString":"generalize (rev bl) (0 + init_data_list_size (rev il)).\ninduction l; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) : forall (l : list byte) (z : Z), idlvalid z (rev (map Init_byte l)).","proofString":"induction l; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) (z : Z) : True.","proofString":"auto."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) (a : byte) (l : list byte) (IHl : forall z0 : Z, idlvalid z0 (rev (map Init_byte l))) (z : Z) : idlvalid z (rev (map Init_byte l) ++ Init_byte a :: nil).","proofString":"rewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) (a : byte) (l : list byte) (IHl : forall z0 : Z, idlvalid z0 (rev (map Init_byte l))) (z : Z) : idlvalid (z + init_data_list_size (rev (map Init_byte l)))\n  (Init_byte a :: nil).","proofString":"simpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (bl : list byte) (H : idlvalid 0 (rev il)) (a : byte) (l : list byte) (IHl : forall z0 : Z, idlvalid z0 (rev (map Init_byte l))) (z : Z) : (1 | z + init_data_list_size (rev (map Init_byte l))) /\\ True /\\ True.","proofString":"auto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) : idlvalid 0 (rev (add_zeros n il)).","proofString":"rewrite add_zeros_spec, rev_app_distr, idlvalid_app by auto.\nsplit; auto.\ngeneralize (Z.to_nat n) (0 + init_data_list_size (rev il)).\ninduction n0; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) : idlvalid 0 (rev il) /\\\nidlvalid (0 + init_data_list_size (rev il))\n  (rev (repeat (Init_int8 Int.zero) (Z.to_nat n))).","proofString":"split; auto.\ngeneralize (Z.to_nat n) (0 + init_data_list_size (rev il)).\ninduction n0; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) : idlvalid (0 + init_data_list_size (rev il))\n  (rev (repeat (Init_int8 Int.zero) (Z.to_nat n))).","proofString":"generalize (Z.to_nat n) (0 + init_data_list_size (rev il)).\ninduction n0; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) : forall (n0 : nat) (z : Z), idlvalid z (rev (repeat (Init_int8 Int.zero) n0)).","proofString":"induction n0; simpl; intros.\nauto.\nrewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) (z : Z) : True.","proofString":"auto."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) (n0 : nat) (IHn0 : forall z0 : Z, idlvalid z0 (rev (repeat (Init_int8 Int.zero) n0))) (z : Z) : idlvalid z\n  (rev (repeat (Init_int8 Int.zero) n0) ++ Init_int8 Int.zero :: nil).","proofString":"rewrite idlvalid_app; split; auto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) (n0 : nat) (IHn0 : forall z0 : Z, idlvalid z0 (rev (repeat (Init_int8 Int.zero) n0))) (z : Z) : idlvalid (z + init_data_list_size (rev (repeat (Init_int8 Int.zero) n0)))\n  (Init_int8 Int.zero :: nil).","proofString":"simpl.\nauto using Z.divide_1_l."},{"statement":"(il : list init_data) (n : Z) (H : 0 <= n) (H0 : idlvalid 0 (rev il)) (n0 : nat) (IHn0 : forall z0 : Z, idlvalid z0 (rev (repeat (Init_int8 Int.zero) n0))) (z : Z) : (1 | z + init_data_list_size (rev (repeat (Init_int8 Int.zero) n0))) /\\\nTrue /\\ True.","proofString":"auto using Z.divide_1_l."},{"statement":"(depth : Z) (il' : list init_data) (H : (if zle depth 0 then OK nil else Error (msg \"normalize: empty list\")) =\nOK il') (H0 : True) : idlvalid 0 (rev il').","proofString":"destruct (zle depth 0); inv H.\nsimpl.\ntauto."},{"statement":"(depth : Z) (l : depth <= 0) (H0 : True) : idlvalid 0 (rev nil).","proofString":"simpl.\ntauto."},{"statement":"(depth : Z) (l : depth <= 0) (H0 : True) : True.","proofString":"tauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (H : (if zle depth 0\n then OK (i :: il)\n else\n  match i with\n  | Init_int8 n =>\n      do il'0 <- normalize il (depth - 1); OK (Init_int8 n :: il'0)\n  | Init_int16 n =>\n      do il'0 <- normalize il (depth - 2);\n      OK (add_rev_bytes (encode_int 2 (Int.unsigned n)) il'0)\n  | Init_int32 n =>\n      do il'0 <- normalize il (depth - 4);\n      OK (add_rev_bytes (encode_int 4 (Int.unsigned n)) il'0)\n  | Init_int64 n =>\n      do il'0 <- normalize il (depth - 8);\n      OK (add_rev_bytes (encode_int 8 (Int64.unsigned n)) il'0)\n  | Init_float32 f =>\n      do il'0 <- normalize il (depth - 4);\n      OK\n        (add_rev_bytes (encode_int 4 (Int.unsigned (Float32.to_bits f))) il'0)\n  | Init_float64 f =>\n      do il'0 <- normalize il (depth - 8);\n      OK\n        (add_rev_bytes (encode_int 8 (Int64.unsigned (Float.to_bits f))) il'0)\n  | Init_space n =>\n      if zle (Z.max 0 n) depth\n      then\n       do il'0 <- normalize il (depth - Z.max 0 n);\n       OK (add_zeros (Z.max 0 n) il'0)\n      else OK (add_zeros depth (Init_space (Z.max 0 n - depth) :: il))\n  | Init_addrof _ _ => Error (msg \"normalize: Init_addrof\")\n  end) = OK il') (H0 : idlvalid 0 (rev il ++ i :: nil)) : idlvalid 0 (rev il').","proofString":"destruct (zle depth 0).\ninv H.\nauto.\nrewrite idlvalid_app in H0; destruct H0.\ndestruct i; try (monadInv H; apply add_rev_bytes_valid; eapply IHil; eauto).\nmonadInv H.\nsimpl.\nrewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l.\ndestruct (zle (Z.max 0 z)); monadInv H.\napply add_zeros_valid.\nlia.\neauto.\napply add_zeros_valid.\nlia.\nsimpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (l : depth <= 0) (H : OK (i :: il) = OK il') (H0 : idlvalid 0 (rev il ++ i :: nil)) : idlvalid 0 (rev il').","proofString":"inv H.\nauto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (l : depth <= 0) (H0 : idlvalid 0 (rev il ++ i :: nil)) : idlvalid 0 (rev (i :: il)).","proofString":"auto."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (g : depth > 0) (H : match i with\n| Init_int8 n =>\n    do il'0 <- normalize il (depth - 1); OK (Init_int8 n :: il'0)\n| Init_int16 n =>\n    do il'0 <- normalize il (depth - 2);\n    OK (add_rev_bytes (encode_int 2 (Int.unsigned n)) il'0)\n| Init_int32 n =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned n)) il'0)\n| Init_int64 n =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned n)) il'0)\n| Init_float32 f =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned (Float32.to_bits f))) il'0)\n| Init_float64 f =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned (Float.to_bits f))) il'0)\n| Init_space n =>\n    if zle (Z.max 0 n) depth\n    then\n     do il'0 <- normalize il (depth - Z.max 0 n);\n     OK (add_zeros (Z.max 0 n) il'0)\n    else OK (add_zeros depth (Init_space (Z.max 0 n - depth) :: il))\n| Init_addrof _ _ => Error (msg \"normalize: Init_addrof\")\nend = OK il') (H0 : idlvalid 0 (rev il ++ i :: nil)) : idlvalid 0 (rev il').","proofString":"rewrite idlvalid_app in H0; destruct H0.\ndestruct i; try (monadInv H; apply add_rev_bytes_valid; eapply IHil; eauto).\nmonadInv H.\nsimpl.\nrewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l.\ndestruct (zle (Z.max 0 z)); monadInv H.\napply add_zeros_valid.\nlia.\neauto.\napply add_zeros_valid.\nlia.\nsimpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : init_data) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (g : depth > 0) (H : match i with\n| Init_int8 n =>\n    do il'0 <- normalize il (depth - 1); OK (Init_int8 n :: il'0)\n| Init_int16 n =>\n    do il'0 <- normalize il (depth - 2);\n    OK (add_rev_bytes (encode_int 2 (Int.unsigned n)) il'0)\n| Init_int32 n =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned n)) il'0)\n| Init_int64 n =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned n)) il'0)\n| Init_float32 f =>\n    do il'0 <- normalize il (depth - 4);\n    OK (add_rev_bytes (encode_int 4 (Int.unsigned (Float32.to_bits f))) il'0)\n| Init_float64 f =>\n    do il'0 <- normalize il (depth - 8);\n    OK (add_rev_bytes (encode_int 8 (Int64.unsigned (Float.to_bits f))) il'0)\n| Init_space n =>\n    if zle (Z.max 0 n) depth\n    then\n     do il'0 <- normalize il (depth - Z.max 0 n);\n     OK (add_zeros (Z.max 0 n) il'0)\n    else OK (add_zeros depth (Init_space (Z.max 0 n - depth) :: il))\n| Init_addrof _ _ => Error (msg \"normalize: Init_addrof\")\nend = OK il') (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (i :: nil)) : idlvalid 0 (rev il').","proofString":"destruct i; try (monadInv H; apply add_rev_bytes_valid; eapply IHil; eauto).\nmonadInv H.\nsimpl.\nrewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l.\ndestruct (zle (Z.max 0 z)); monadInv H.\napply add_zeros_valid.\nlia.\neauto.\napply add_zeros_valid.\nlia.\nsimpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : int) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (g : depth > 0) (H : (do il'0 <- normalize il (depth - 1); OK (Init_int8 i :: il'0)) = OK il') (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_int8 i :: nil)) : idlvalid 0 (rev il').","proofString":"monadInv H.\nsimpl.\nrewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : int) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_int8 i :: nil)) (x : list init_data) (EQ : normalize il (depth - 1) = OK x) : idlvalid 0 (rev (Init_int8 i :: x)).","proofString":"simpl.\nrewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : int) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_int8 i :: nil)) (x : list init_data) (EQ : normalize il (depth - 1) = OK x) : idlvalid 0 (rev x ++ Init_int8 i :: nil).","proofString":"rewrite idlvalid_app; split.\neauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(i : int) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_int8 i :: nil)) (x : list init_data) (EQ : normalize il (depth - 1) = OK x) : idlvalid 0 (rev x).","proofString":"eauto."},{"statement":"(i : int) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_int8 i :: nil)) (x : list init_data) (EQ : normalize il (depth - 1) = OK x) : idlvalid (0 + init_data_list_size (rev x)) (Init_int8 i :: nil).","proofString":"simpl; auto using Z.divide_1_l."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il'0 : list init_data),\nnormalize il depth0 = OK il'0 -> idlvalid 0 (rev il) -> idlvalid 0 (rev il'0)) (depth : Z) (il' : list init_data) (g : depth > 0) (H : (if zle (Z.max 0 z) depth\n then\n  do il'0 <- normalize il (depth - Z.max 0 z);\n  OK (add_zeros (Z.max 0 z) il'0)\n else OK (add_zeros depth (Init_space (Z.max 0 z - depth) :: il))) = \nOK il') (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid 0 (rev il').","proofString":"destruct (zle (Z.max 0 z)); monadInv H.\napply add_zeros_valid.\nlia.\neauto.\napply add_zeros_valid.\nlia.\nsimpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (l : Z.max 0 z <= depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) (x : list init_data) (EQ : normalize il (depth - Z.max 0 z) = OK x) : idlvalid 0 (rev (add_zeros (Z.max 0 z) x)).","proofString":"apply add_zeros_valid.\nlia.\neauto."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (l : Z.max 0 z <= depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) (x : list init_data) (EQ : normalize il (depth - Z.max 0 z) = OK x) : 0 <= Z.max 0 z.","proofString":"lia."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (l : Z.max 0 z <= depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) (x : list init_data) (EQ : normalize il (depth - Z.max 0 z) = OK x) : idlvalid 0 (rev x).","proofString":"eauto."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid 0 (rev (add_zeros depth (Init_space (Z.max 0 z - depth) :: il))).","proofString":"apply add_zeros_valid.\nlia.\nsimpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : 0 <= depth.","proofString":"lia."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid 0 (rev (Init_space (Z.max 0 z - depth) :: il)).","proofString":"simpl.\nrewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid 0 (rev il ++ Init_space (Z.max 0 z - depth) :: nil).","proofString":"rewrite idlvalid_app; split.\nauto.\nsimpl; auto using Z.divide_1_l."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid 0 (rev il).","proofString":"auto."},{"statement":"(z : Z) (il : list init_data) (IHil : forall (depth0 : Z) (il' : list init_data),\nnormalize il depth0 = OK il' -> idlvalid 0 (rev il) -> idlvalid 0 (rev il')) (depth : Z) (g : depth > 0) (g0 : Z.max 0 z > depth) (H0 : idlvalid 0 (rev il)) (H1 : idlvalid (0 + init_data_list_size (rev il)) (Init_space z :: nil)) : idlvalid (0 + init_data_list_size (rev il))\n  (Init_space (Z.max 0 z - depth) :: nil).","proofString":"simpl; auto using Z.divide_1_l."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H : (do il0 <- normalize il (depth + sz);\n do (bytes0, il1)<- decompose il0 depth;\n do (bytes3, il2)<- decompose il1 sz; OK (bytes0, bytes3, il2)) =\nOK (bytes1, bytes2, il')) (H0 : idlvalid 0 (rev il)) : idlvalid 0 (rev il').","proofString":"monadInv H.\napply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nexploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (EQ1 : decompose x depth = OK (bytes1, x1)) (EQ0 : decompose x1 sz = OK (bytes2, il')) : idlvalid 0 (rev il').","proofString":"apply decompose_spec in EQ1.\ndestruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nexploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (EQ1 : exists nl : list int,\n  x = map Init_int8 nl ++ x1 /\\\n  bytes1 = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat depth) (EQ0 : decompose x1 sz = OK (bytes2, il')) : idlvalid 0 (rev il').","proofString":"destruct EQ1 as (nl1 & A1 & B1 & C1).\napply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nexploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (EQ0 : decompose x1 sz = OK (bytes2, il')) : idlvalid 0 (rev il').","proofString":"apply decompose_spec in EQ0.\ndestruct EQ0 as (nl2 & A2 & B2 & C2).\nexploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (EQ0 : exists nl : list int,\n  x1 = map Init_int8 nl ++ il' /\\\n  bytes2 = map byte_of_int (rev nl) /\\ Datatypes.length nl = Z.to_nat sz) : idlvalid 0 (rev il').","proofString":"destruct EQ0 as (nl2 & A2 & B2 & C2).\nexploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : idlvalid 0 (rev il').","proofString":"exploit normalize_valid; eauto.\nrewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : idlvalid 0 (rev x) -> idlvalid 0 (rev il').","proofString":"rewrite A1, A2, !rev_app_distr, !idlvalid_app.\ntauto."},{"statement":"(il : list init_data) (depth sz : Z) (bytes1 bytes2 : list byte) (il' : list init_data) (H0 : idlvalid 0 (rev il)) (x : list init_data) (EQ : normalize il (depth + sz) = OK x) (x1 : list init_data) (nl1 : list int) (A1 : x = map Init_int8 nl1 ++ x1) (B1 : bytes1 = map byte_of_int (rev nl1)) (C1 : Datatypes.length nl1 = Z.to_nat depth) (nl2 : list int) (A2 : x1 = map Init_int8 nl2 ++ il') (B2 : bytes2 = map byte_of_int (rev nl2)) (C2 : Datatypes.length nl2 = Z.to_nat sz) : (idlvalid 0 (rev il') /\\\n idlvalid (0 + init_data_list_size (rev il')) (rev (map Init_int8 nl2))) /\\\nidlvalid (0 + init_data_list_size (rev il' ++ rev (map Init_int8 nl2)))\n  (rev (map Init_int8 nl1)) -> idlvalid 0 (rev il').","proofString":"tauto."},{"statement":"(i : init_data) : init_data_size i = Z.of_nat (Datatypes.length (boid i)).","proofString":"destruct i; simpl; rewrite ?length_inj_bytes, ?encode_int_length; auto.\nrewrite repeat_length.\nrewrite Z_to_nat_max; auto.\ndestruct (Genv.find_symbol ge i), Archi.ptr64; reflexivity."},{"statement":"(z : Z) : Z.max z 0 =\nZ.of_nat (Datatypes.length (repeat (Byte Byte.zero) (Z.to_nat z))).","proofString":"rewrite repeat_length.\nrewrite Z_to_nat_max; auto."},{"statement":"(z : Z) : Z.max z 0 = Z.of_nat (Z.to_nat z).","proofString":"rewrite Z_to_nat_max; auto."},{"statement":"(i : ident) (i0 : ptrofs) : (if Archi.ptr64 then 8 else 4) =\nZ.of_nat\n  (Datatypes.length\n     match Genv.find_symbol ge i with\n     | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b i0)\n     | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n     end).","proofString":"destruct (Genv.find_symbol ge i), Archi.ptr64; reflexivity."},{"statement":"0 = 0.","proofString":"auto."},{"statement":"(i : init_data) (il : list init_data) (IHil : init_data_list_size il = Z.of_nat (Datatypes.length (boidl il))) : init_data_size i + init_data_list_size il =\nZ.of_nat (Datatypes.length (boid i ++ boidl il)).","proofString":"rewrite app_length, init_data_size_boid.\nlia."},{"statement":"(i : init_data) (il : list init_data) (IHil : init_data_list_size il = Z.of_nat (Datatypes.length (boidl il))) : Z.of_nat (Datatypes.length (boid i)) + init_data_list_size il =\nZ.of_nat (Datatypes.length (boid i) + Datatypes.length (boidl il)).","proofString":"lia."},{"statement":"(l2 : list init_data) : init_data_list_size l2 = init_data_list_size l2.","proofString":"auto."},{"statement":"(i : init_data) (l1 : list init_data) (IHl1 : forall l0 : list init_data,\ninit_data_list_size (l1 ++ l0) =\ninit_data_list_size l1 + init_data_list_size l0) (l2 : list init_data) : init_data_size i + init_data_list_size (l1 ++ l2) =\ninit_data_size i + init_data_list_size l1 + init_data_list_size l2.","proofString":"rewrite IHl1; lia."},{"statement":"(m : mem) (b : block) (from1 from2 to1 to2 : Z) (H : reads_as_zeros m b from1 to1) (H0 : from1 <= from2) (H1 : to2 <= to1) (i : Z) (H2 : from2 <= i < to2) : Mem.loadbytes m b i 1 = Some (Byte Byte.zero :: nil).","proofString":"apply H; lia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (from to : Z) (m' : mem) (H : reads_as_zeros m b from to) (H0 : Mem.unchanged_on P m m') (H1 : forall i0 : Z, from <= i0 < to -> P b i0) (i : Z) (H2 : from <= i < to) : Mem.loadbytes m' b i 1 = Some (Byte Byte.zero :: nil).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros; apply H1.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (from to : Z) (m' : mem) (H : reads_as_zeros m b from to) (H0 : Mem.unchanged_on P m m') (H1 : forall i0 : Z, from <= i0 < to -> P b i0) (i : Z) (H2 : from <= i < to) : forall i0 : Z, i <= i0 < i + 1 -> P b i0.","proofString":"intros; apply H1.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (from to : Z) (m' : mem) (H : reads_as_zeros m b from to) (H0 : Mem.unchanged_on P m m') (H1 : forall i1 : Z, from <= i1 < to -> P b i1) (i : Z) (H2 : from <= i < to) (i0 : Z) (H3 : i <= i0 < i + 1) : from <= i0 < to.","proofString":"lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) : forall len pos : Z,\nfrom <= pos ->\npos + len <= to ->\n0 <= len ->\nMem.loadbytes m b pos len = Some (repeat (Byte Byte.zero) (Z.to_nat len)).","proofString":"induction len using (well_founded_induction (Zwf_well_founded 0)).\nintros.\ndestruct (zeq len 0).\nsubst len.\nrewrite Mem.loadbytes_empty by lia.\nauto.\nreplace (Z.to_nat len) with (S (Z.to_nat (len - 1))).\nchange (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1))))    with ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).\nreplace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia.\nrewrite <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos : Z,\nfrom <= pos ->\npos + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) : forall pos : Z,\nfrom <= pos ->\npos + len <= to ->\n0 <= len ->\nMem.loadbytes m b pos len = Some (repeat (Byte Byte.zero) (Z.to_nat len)).","proofString":"intros.\ndestruct (zeq len 0).\nsubst len.\nrewrite Mem.loadbytes_empty by lia.\nauto.\nreplace (Z.to_nat len) with (S (Z.to_nat (len - 1))).\nchange (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1))))    with ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).\nreplace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia.\nrewrite <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) : Mem.loadbytes m b pos len = Some (repeat (Byte Byte.zero) (Z.to_nat len)).","proofString":"destruct (zeq len 0).\nsubst len.\nrewrite Mem.loadbytes_empty by lia.\nauto.\nreplace (Z.to_nat len) with (S (Z.to_nat (len - 1))).\nchange (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1))))    with ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).\nreplace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia.\nrewrite <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (e : len = 0) : Mem.loadbytes m b pos len = Some (repeat (Byte Byte.zero) (Z.to_nat len)).","proofString":"subst len.\nrewrite Mem.loadbytes_empty by lia.\nauto."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (H : forall y : Z,\nZwf 0 y 0 ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H2 : 0 <= 0) (H1 : pos + 0 <= to) : Mem.loadbytes m b pos 0 = Some (repeat (Byte Byte.zero) (Z.to_nat 0)).","proofString":"rewrite Mem.loadbytes_empty by lia.\nauto."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (H : forall y : Z,\nZwf 0 y 0 ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H2 : 0 <= 0) (H1 : pos + 0 <= to) : Some nil = Some (repeat (Byte Byte.zero) (Z.to_nat 0)).","proofString":"auto."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b pos len = Some (repeat (Byte Byte.zero) (Z.to_nat len)).","proofString":"replace (Z.to_nat len) with (S (Z.to_nat (len - 1))).\nchange (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1))))    with ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).\nreplace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia.\nrewrite <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b pos len =\nSome (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1)))).","proofString":"change (repeat (Byte Byte.zero) (S (Z.to_nat (len - 1))))    with ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).\nreplace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b pos len =\nSome\n  ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).","proofString":"replace len with (1 + (len - 1)) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b pos (1 + (len - 1)) =\nSome\n  ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) (Z.to_nat (len - 1))).","proofString":"apply Mem.loadbytes_concat; try lia.\napply RZ.\nlia.\napply H; unfold Zwf; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b pos 1 = Some (Byte Byte.zero :: nil).","proofString":"apply RZ.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : from <= pos < to.","proofString":"lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Mem.loadbytes m b (pos + 1) (len - 1) =\nSome (repeat (Byte Byte.zero) (Z.to_nat (len - 1))).","proofString":"apply H; unfold Zwf; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : S (Z.to_nat (len - 1)) = Z.to_nat len.","proofString":"rewrite <- Z2Nat.inj_succ by lia.\nf_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (RZ : reads_as_zeros m b from to) (len : Z) (H : forall y : Z,\nZwf 0 y len ->\nforall pos0 : Z,\nfrom <= pos0 ->\npos0 + y <= to ->\n0 <= y ->\nMem.loadbytes m b pos0 y = Some (repeat (Byte Byte.zero) (Z.to_nat y))) (pos : Z) (H0 : from <= pos) (H1 : pos + len <= to) (H2 : 0 <= len) (n : len <> 0) : Z.to_nat (Z.succ (len - 1)) = Z.to_nat len.","proofString":"f_equal; lia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : reads_as_zeros m b from to) : Genv.readbytes_as_zero m b from (to - from).","proofString":"red; intros.\nset (len := Z.of_nat n).\nreplace n with (Z.to_nat len) by apply Nat2Z.id.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : reads_as_zeros m b from to) (p : Z) (n : nat) (H0 : from <= p) (H1 : p + Z.of_nat n <= from + (to - from)) : Mem.loadbytes m b p (Z.of_nat n) = Some (repeat (Byte Byte.zero) n).","proofString":"set (len := Z.of_nat n).\nreplace n with (Z.to_nat len) by apply Nat2Z.id.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : Genv.readbytes_as_zero m b from (to - from)) : reads_as_zeros m b from to.","proofString":"red; intros.\nred in H.\napply (H i 1%nat).\nlia.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : Genv.readbytes_as_zero m b from (to - from)) (i : Z) (H0 : from <= i < to) : Mem.loadbytes m b i 1 = Some (Byte Byte.zero :: nil).","proofString":"red in H.\napply (H i 1%nat).\nlia.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : forall (p : Z) (n : nat),\nfrom <= p ->\np + Z.of_nat n <= from + (to - from) ->\nMem.loadbytes m b p (Z.of_nat n) = Some (repeat (Byte Byte.zero) n)) (i : Z) (H0 : from <= i < to) : Mem.loadbytes m b i 1 = Some (Byte Byte.zero :: nil).","proofString":"apply (H i 1%nat).\nlia.\nlia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : forall (p : Z) (n : nat),\nfrom <= p ->\np + Z.of_nat n <= from + (to - from) ->\nMem.loadbytes m b p (Z.of_nat n) = Some (repeat (Byte Byte.zero) n)) (i : Z) (H0 : from <= i < to) : from <= i.","proofString":"lia."},{"statement":"(m : mem) (b : block) (from to : Z) (H : forall (p : Z) (n : nat),\nfrom <= p ->\np + Z.of_nat n <= from + (to - from) ->\nMem.loadbytes m b p (Z.of_nat n) = Some (repeat (Byte Byte.zero) n)) (i : Z) (H0 : from <= i < to) : i + Z.of_nat 1 <= from + (to - from).","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (H : match_state s m b) : init_data_list_size (rev (init s)) = curr s.","proofString":"rewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by (eapply match_contents; eauto).\napply Z2Nat.id.\neapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (H : match_state s m b) : Z.of_nat (Datatypes.length (boidl (rev (init s)))) = curr s.","proofString":"erewrite Mem.loadbytes_length by (eapply match_contents; eauto).\napply Z2Nat.id.\neapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (H : match_state s m b) : Z.of_nat (Z.to_nat (curr s)) = curr s.","proofString":"apply Z2Nat.id.\neapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (H : match_state s m b) : 0 <= curr s.","proofString":"eapply match_range; eauto."},{"statement":"(s : state) (pos : Z) : curr s <=\ncurr\n  (if zle pos (curr s)\n   then s\n   else\n    {|\n      init := Init_space (pos - curr s) :: init s;\n      curr := pos;\n      total_size := total_size s\n    |}) /\\\npos <=\ncurr\n  (if zle pos (curr s)\n   then s\n   else\n    {|\n      init := Init_space (pos - curr s) :: init s;\n      curr := pos;\n      total_size := total_size s\n    |}).","proofString":"destruct (zle pos (curr s)); simpl; lia."},{"statement":"(s : state) (pos : Z) : total_size\n  (if zle pos (curr s)\n   then s\n   else\n    {|\n      init := Init_space (pos - curr s) :: init s;\n      curr := pos;\n      total_size := total_size s\n    |}) = total_size s.","proofString":"destruct (zle pos (curr s)); auto."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (H : match_state s m b) (H0 : pos <= total_size s) : match_state (pad_to s pos) m b.","proofString":"unfold pad_to.\ndestruct (zle pos (curr s)); auto.\ndestruct H; constructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons.\nsimpl.\nreplace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia.\nrewrite idlvalid_app.\nsplit; auto.\nsimpl.\nintuition auto using Z.divide_1_l.\neapply reads_as_zeros_mono; eauto; lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (H : match_state s m b) (H0 : pos <= total_size s) : match_state\n  (if zle pos (curr s)\n   then s\n   else\n    {|\n      init := Init_space (pos - curr s) :: init s;\n      curr := pos;\n      total_size := total_size s\n    |}) m b.","proofString":"destruct (zle pos (curr s)); auto.\ndestruct H; constructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons.\nsimpl.\nreplace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia.\nrewrite idlvalid_app.\nsplit; auto.\nsimpl.\nintuition auto using Z.divide_1_l.\neapply reads_as_zeros_mono; eauto; lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (H : match_state s m b) (H0 : pos <= total_size s) (g : pos > curr s) : match_state\n  {|\n    init := Init_space (pos - curr s) :: init s;\n    curr := pos;\n    total_size := total_size s\n  |} m b.","proofString":"destruct H; constructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons.\nsimpl.\nreplace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia.\nrewrite idlvalid_app.\nsplit; auto.\nsimpl.\nintuition auto using Z.divide_1_l.\neapply reads_as_zeros_mono; eauto; lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : 0 <= pos <= total_size s.","proofString":"lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b 0 pos =\nSome (boidl (rev (init s) ++ Init_space (pos - curr s) :: nil)).","proofString":"rewrite boidl_rev_cons.\nsimpl.\nreplace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b 0 pos =\nSome (boidl (rev (init s)) ++ boid (Init_space (pos - curr s))).","proofString":"simpl.\nreplace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b 0 pos =\nSome\n  (boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).","proofString":"replace pos with (s.(curr) + (pos - s.(curr))) at 1 by lia.\napply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b 0 (curr s + (pos - curr s)) =\nSome\n  (boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).","proofString":"apply Mem.loadbytes_concat; try lia.\nauto.\neapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s))).","proofString":"auto."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : Mem.loadbytes m b (0 + curr s) (pos - curr s) =\nSome (repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).","proofString":"eapply reads_as_zeros_loadbytes; eauto.\nlia.\nlia.\nlia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : curr s <= 0 + curr s.","proofString":"lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : 0 + curr s + (pos - curr s) <= total_size s.","proofString":"lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : 0 <= pos - curr s.","proofString":"lia."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : idlvalid 0 (rev (init s) ++ Init_space (pos - curr s) :: nil).","proofString":"rewrite idlvalid_app.\nsplit; auto.\nsimpl.\nintuition auto using Z.divide_1_l."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : idlvalid 0 (rev (init s)) /\\\nidlvalid (0 + init_data_list_size (rev (init s)))\n  (Init_space (pos - curr s) :: nil).","proofString":"split; auto.\nsimpl.\nintuition auto using Z.divide_1_l."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : idlvalid (0 + init_data_list_size (rev (init s)))\n  (Init_space (pos - curr s) :: nil).","proofString":"simpl.\nintuition auto using Z.divide_1_l."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : (1 | init_data_list_size (rev (init s))) /\\ True /\\ True.","proofString":"intuition auto using Z.divide_1_l."},{"statement":"(pos : Z) (s : state) (m : mem) (b : block) (match_range0 : 0 <= curr s <= total_size s) (match_contents0 : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s)))) (match_valid0 : idlvalid 0 (rev (init s))) (match_uninitialized0 : reads_as_zeros m b (curr s) (total_size s)) (H0 : pos <= total_size s) (g : pos > curr s) : reads_as_zeros m b pos (total_size s).","proofString":"eapply reads_as_zeros_mono; eauto; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (H0 : trisection (init s) (curr s - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) (curr s - (pos + sz)) = Some (inj_bytes bytes1).","proofString":"apply trisection_boidl in H0.\ndestruct H0 as (A & B & C).\nset (depth := curr s - (pos + sz)) in *.\npose proof (match_contents _ _ _ H) as D.\nreplace (curr s) with ((pos + sz) + depth) in D by lia.\nexploit Mem.loadbytes_split.\neexact D.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes0 & bytes1' & LB0 & LB1 & E1).\nexploit Mem.loadbytes_split.\neexact LB0.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (H0 : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1 /\\\nDatatypes.length bytes1 = Z.to_nat (curr s - (pos + sz)) /\\\nDatatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) (curr s - (pos + sz)) = Some (inj_bytes bytes1).","proofString":"destruct H0 as (A & B & C).\nset (depth := curr s - (pos + sz)) in *.\npose proof (match_contents _ _ _ H) as D.\nreplace (curr s) with ((pos + sz) + depth) in D by lia.\nexploit Mem.loadbytes_split.\neexact D.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes0 & bytes1' & LB0 & LB1 & E1).\nexploit Mem.loadbytes_split.\neexact LB0.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (B : Datatypes.length bytes1 = Z.to_nat (curr s - (pos + sz))) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) (curr s - (pos + sz)) = Some (inj_bytes bytes1).","proofString":"set (depth := curr s - (pos + sz)) in *.\npose proof (match_contents _ _ _ H) as D.\nreplace (curr s) with ((pos + sz) + depth) in D by lia.\nexploit Mem.loadbytes_split.\neexact D.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes0 & bytes1' & LB0 & LB1 & E1).\nexploit Mem.loadbytes_split.\neexact LB0.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) : (exists bytes3 bytes4 : list memval,\n   Mem.loadbytes m b 0 (pos + sz) = Some bytes3 /\\\n   Mem.loadbytes m b (pos + sz) depth = Some bytes4 /\\\n   boidl (rev (init s)) = bytes3 ++ bytes4) ->\nMem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"intros (bytes0 & bytes1' & LB0 & LB1 & E1).\nexploit Mem.loadbytes_split.\neexact LB0.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : boidl (rev (init s)) = bytes0 ++ bytes1') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"exploit Mem.loadbytes_split.\neexact LB0.\nlia.\nlia.\nrewrite Z.add_0_l.\nintros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : boidl (rev (init s)) = bytes0 ++ bytes1') : (exists bytes3 bytes4 : list memval,\n   Mem.loadbytes m b 0 pos = Some bytes3 /\\\n   Mem.loadbytes m b pos sz = Some bytes4 /\\ bytes0 = bytes3 ++ bytes4) ->\nMem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"intros (bytes3 & bytes2' & LB3 & LB2 & E2).\nrewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : boidl (rev (init s)) = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"rewrite A in E1.\nrewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"rewrite <- app_ass in E1.\nexploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"exploit list_append_injective_r.\neexact E1.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E3 & E4).\nrewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') : Datatypes.length bytes1 = Datatypes.length bytes1'.","proofString":"erewrite Mem.loadbytes_length; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') (E3 : boidl (rev il) ++ inj_bytes bytes2 = bytes0) (E4 : inj_bytes bytes1 = bytes1') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"rewrite E2 in E3.\nexploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') (E3 : boidl (rev il) ++ inj_bytes bytes2 = bytes3 ++ bytes2') (E4 : inj_bytes bytes1 = bytes1') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"exploit list_append_injective_r.\neexact E3.\nunfold inj_bytes; rewrite map_length.\nerewrite Mem.loadbytes_length; eauto.\nintros (E5 & E6).\nintuition congruence."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') (E3 : boidl (rev il) ++ inj_bytes bytes2 = bytes3 ++ bytes2') (E4 : inj_bytes bytes1 = bytes1') : Datatypes.length bytes2 = Datatypes.length bytes2'.","proofString":"erewrite Mem.loadbytes_length; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos sz : Z) (bytes1 bytes2 : list byte) (il : list init_data) (H : match_state s m b) (A : boidl (rev (init s)) = boidl (rev il) ++ inj_bytes bytes2 ++ inj_bytes bytes1) (depth : Z) (B : Datatypes.length bytes1 = Z.to_nat depth) (C : Datatypes.length bytes2 = Z.to_nat sz) (H1 : 0 <= pos) (H2 : pos + sz <= curr s) (H3 : 0 <= sz) (D : Mem.loadbytes m b 0 (pos + sz + depth) = Some (boidl (rev (init s)))) (bytes0 bytes1' : list memval) (LB0 : Mem.loadbytes m b 0 (pos + sz) = Some bytes0) (LB1 : Mem.loadbytes m b (pos + sz) depth = Some bytes1') (E1 : (boidl (rev il) ++ inj_bytes bytes2) ++ inj_bytes bytes1 = bytes0 ++ bytes1') (bytes3 bytes2' : list memval) (LB3 : Mem.loadbytes m b 0 pos = Some bytes3) (LB2 : Mem.loadbytes m b pos sz = Some bytes2') (E2 : bytes0 = bytes3 ++ bytes2') (E3 : boidl (rev il) ++ inj_bytes bytes2 = bytes3 ++ bytes2') (E4 : inj_bytes bytes1 = bytes1') (E5 : boidl (rev il) = bytes3) (E6 : inj_bytes bytes2 = bytes2') : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) depth = Some (inj_bytes bytes1).","proofString":"intuition congruence."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) : Int.zero_ext (n * 8) (Int.repr (decode_int bytes)) =\nInt.repr (decode_int bytes).","proofString":"assert (0 <= decode_int bytes < two_p (n * 8)).\nrewrite H0.\nreplace (length bytes) with (length (rev_if_be bytes)).\napply int_of_bytes_range.\napply rev_if_be_length.\nassert (two_p (n * 8) <= Int.modulus).\napply (two_p_monotone (n * 8) 32); lia.\nunfold Int.zero_ext.\nrewrite Int.unsigned_repr by (unfold Int.max_unsigned; lia).\nrewrite Zbits.Zzero_ext_mod by lia.\nrewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) : 0 <= decode_int bytes < two_p (n * 8).","proofString":"rewrite H0.\nreplace (length bytes) with (length (rev_if_be bytes)).\napply int_of_bytes_range.\napply rev_if_be_length."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) : 0 <= decode_int bytes < two_p (Z.of_nat (Datatypes.length bytes) * 8).","proofString":"replace (length bytes) with (length (rev_if_be bytes)).\napply int_of_bytes_range.\napply rev_if_be_length."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) : 0 <= decode_int bytes <\ntwo_p (Z.of_nat (Datatypes.length (rev_if_be bytes)) * 8).","proofString":"apply int_of_bytes_range."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) : Datatypes.length (rev_if_be bytes) = Datatypes.length bytes.","proofString":"apply rev_if_be_length."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) : Int.zero_ext (n * 8) (Int.repr (decode_int bytes)) =\nInt.repr (decode_int bytes).","proofString":"assert (two_p (n * 8) <= Int.modulus).\napply (two_p_monotone (n * 8) 32); lia.\nunfold Int.zero_ext.\nrewrite Int.unsigned_repr by (unfold Int.max_unsigned; lia).\nrewrite Zbits.Zzero_ext_mod by lia.\nrewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) : two_p (n * 8) <= Int.modulus.","proofString":"apply (two_p_monotone (n * 8) 32); lia."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) (H2 : two_p (n * 8) <= Int.modulus) : Int.zero_ext (n * 8) (Int.repr (decode_int bytes)) =\nInt.repr (decode_int bytes).","proofString":"unfold Int.zero_ext.\nrewrite Int.unsigned_repr by (unfold Int.max_unsigned; lia).\nrewrite Zbits.Zzero_ext_mod by lia.\nrewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) (H2 : two_p (n * 8) <= Int.modulus) : Int.repr\n  (Zbits.Zzero_ext (n * 8) (Int.unsigned (Int.repr (decode_int bytes)))) =\nInt.repr (decode_int bytes).","proofString":"rewrite Int.unsigned_repr by (unfold Int.max_unsigned; lia).\nrewrite Zbits.Zzero_ext_mod by lia.\nrewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) (H2 : two_p (n * 8) <= Int.modulus) : Int.repr (Zbits.Zzero_ext (n * 8) (decode_int bytes)) =\nInt.repr (decode_int bytes).","proofString":"rewrite Zbits.Zzero_ext_mod by lia.\nrewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) (H2 : two_p (n * 8) <= Int.modulus) : Int.repr (decode_int bytes mod two_p (n * 8)) = Int.repr (decode_int bytes).","proofString":"rewrite Zmod_small by auto.\nauto."},{"statement":"(n : Z) (bytes : list byte) (H : 0 <= n <= 4) (H0 : n = Z.of_nat (Datatypes.length bytes)) (H1 : 0 <= decode_int bytes < two_p (n * 8)) (H2 : two_p (n * 8) <= Int.modulus) : Int.repr (decode_int bytes) = Int.repr (decode_int bytes).","proofString":"auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (RI : load_int s pos isz = OK i) (LD : Mem.load (chunk_for_carrier isz) m b pos = Some v) : v = Vint i.","proofString":"exploit Mem.load_valid_access.\neauto.\nintros [PERM ALIGN].\nunfold load_int in RI.\nset (chunk := chunk_for_carrier isz) in *.\nset (sz := size_chunk chunk) in *.\nassert (sz > 0) by (apply size_chunk_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nmonadInv RI.\nInvBooleans.\ndestruct x as [[bytes1 bytes2] il].\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nassert (LEN: Z.of_nat (length bytes2) = sz).\napply Mem.loadbytes_length in L2.\nunfold inj_bytes in L2.\nrewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia.\nexploit Mem.loadbytes_load.\neexact L2.\nexact ALIGN.\nrewrite LD.\nunfold decode_val.\nrewrite proj_inj_bytes.\nintros E; inv E; inv EQ0.\nunfold chunk, chunk_for_carrier; destruct isz; f_equal.\napply (decode_int_zero_ext 1).\nlia.\nauto.\napply (decode_int_zero_ext 2).\nlia.\nauto.\napply (decode_int_zero_ext 1).\nlia.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (RI : load_int s pos isz = OK i) (LD : Mem.load (chunk_for_carrier isz) m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + size_chunk (chunk_for_carrier isz)) Cur\n  Readable) (ALIGN : (align_chunk (chunk_for_carrier isz) | pos)) : v = Vint i.","proofString":"unfold load_int in RI.\nset (chunk := chunk_for_carrier isz) in *.\nset (sz := size_chunk chunk) in *.\nassert (sz > 0) by (apply size_chunk_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nmonadInv RI.\nInvBooleans.\ndestruct x as [[bytes1 bytes2] il].\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nassert (LEN: Z.of_nat (length bytes2) = sz).\napply Mem.loadbytes_length in L2.\nunfold inj_bytes in L2.\nrewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia.\nexploit Mem.loadbytes_load.\neexact L2.\nexact ALIGN.\nrewrite LD.\nunfold decode_val.\nrewrite proj_inj_bytes.\nintros E; inv E; inv EQ0.\nunfold chunk, chunk_for_carrier; destruct isz; f_equal.\napply (decode_int_zero_ext 1).\nlia.\nauto.\napply (decode_int_zero_ext 2).\nlia.\nauto.\napply (decode_int_zero_ext 1).\nlia.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (RI : (assertion zle 0 pos &&\n           zle (pos + size_chunk (chunk_for_carrier isz)) (total_size s);\n do x3 <-\n trisection (init (pad_to s (pos + size_chunk (chunk_for_carrier isz))))\n   (curr (pad_to s (pos + size_chunk (chunk_for_carrier isz))) -\n    (pos + size_chunk (chunk_for_carrier isz)))\n   (size_chunk (chunk_for_carrier isz));\n let '(_, bytes2, _) := x3 in OK (Int.repr (decode_int bytes2))) = \nOK i) (LD : Mem.load (chunk_for_carrier isz) m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + size_chunk (chunk_for_carrier isz)) Cur\n  Readable) (ALIGN : (align_chunk (chunk_for_carrier isz) | pos)) : v = Vint i.","proofString":"set (chunk := chunk_for_carrier isz) in *.\nset (sz := size_chunk chunk) in *.\nassert (sz > 0) by (apply size_chunk_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nmonadInv RI.\nInvBooleans.\ndestruct x as [[bytes1 bytes2] il].\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nassert (LEN: Z.of_nat (length bytes2) = sz).\napply Mem.loadbytes_length in L2.\nunfold inj_bytes in L2.\nrewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia.\nexploit Mem.loadbytes_load.\neexact L2.\nexact ALIGN.\nrewrite LD.\nunfold decode_val.\nrewrite proj_inj_bytes.\nintros E; inv E; inv EQ0.\nunfold chunk, chunk_for_carrier; destruct isz; f_equal.\napply (decode_int_zero_ext 1).\nlia.\nauto.\napply (decode_int_zero_ext 2).\nlia.\nauto.\napply (decode_int_zero_ext 1).\nlia.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) : 0 <= sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Z.of_nat (Datatypes.length bytes2) = sz.","proofString":"apply Mem.loadbytes_length in L2.\nunfold inj_bytes in L2.\nrewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Datatypes.length (inj_bytes bytes2) = Z.to_nat sz) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Z.of_nat (Datatypes.length bytes2) = sz.","proofString":"unfold inj_bytes in L2.\nrewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Datatypes.length (map Byte bytes2) = Z.to_nat sz) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Z.of_nat (Datatypes.length bytes2) = sz.","proofString":"rewrite map_length in L2.\nrewrite L2.\napply Z2Nat.id; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Datatypes.length bytes2 = Z.to_nat sz) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Z.of_nat (Datatypes.length bytes2) = sz.","proofString":"rewrite L2.\napply Z2Nat.id; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (i : int) (v : val) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (LD : Mem.load chunk m b pos = Some v) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (EQ0 : OK (Int.repr (decode_int bytes2)) = OK i) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Datatypes.length bytes2 = Z.to_nat sz) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Z.of_nat (Z.to_nat sz) = sz.","proofString":"apply Z2Nat.id; lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (bytes2 : list byte) (LD : Mem.load chunk m b pos =\nSome\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint32 => Vint (Int.repr (decode_int bytes2))\n  | Mint64 => Vlong (Int64.repr (decode_int bytes2))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bytes2)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bytes2)))\n  | _ => Vundef\n  end) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (LEN : Z.of_nat (Datatypes.length bytes2) = sz) : 0 <= 1 <= 4.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (bytes2 : list byte) (LD : Mem.load chunk m b pos =\nSome\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint32 => Vint (Int.repr (decode_int bytes2))\n  | Mint64 => Vlong (Int64.repr (decode_int bytes2))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bytes2)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bytes2)))\n  | _ => Vundef\n  end) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (LEN : Z.of_nat (Datatypes.length bytes2) = sz) : 0 <= 2 <= 4.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (MS : match_state s m b) (chunk : memory_chunk) (sz : Z) (s1 : state) (bytes2 : list byte) (LD : Mem.load chunk m b pos =\nSome\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bytes2)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bytes2)))\n  | Mint32 => Vint (Int.repr (decode_int bytes2))\n  | Mint64 => Vlong (Int64.repr (decode_int bytes2))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bytes2)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bytes2)))\n  | _ => Vundef\n  end) (PERM : Mem.range_perm m b pos (pos + sz) Cur Readable) (ALIGN : (align_chunk chunk | pos)) (H : sz > 0) (H0 : pos + sz <= curr s1) (bytes1 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= total_size s) (H1 : 0 <= pos) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (LEN : Z.of_nat (Datatypes.length bytes2) = sz) : 0 <= 1 <= 4.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b ofs1 len = Some (l1 ++ l2 ++ l3).","proofString":"rewrite H7, <- Z.add_assoc.\napply Mem.loadbytes_concat.\nauto.\napply Mem.loadbytes_concat.\nrewrite <- H2; auto.\nrewrite <- H2, <- H3; auto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b ofs1 (len1 + (len2 + len3)) = Some (l1 ++ l2 ++ l3).","proofString":"apply Mem.loadbytes_concat.\nauto.\napply Mem.loadbytes_concat.\nrewrite <- H2; auto.\nrewrite <- H2, <- H3; auto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b ofs1 len1 = Some l1.","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b (ofs1 + len1) (len2 + len3) = Some (l2 ++ l3).","proofString":"apply Mem.loadbytes_concat.\nrewrite <- H2; auto.\nrewrite <- H2, <- H3; auto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b (ofs1 + len1) len2 = Some l2.","proofString":"rewrite <- H2; auto."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : Mem.loadbytes m b (ofs1 + len1 + len2) len3 = Some l3.","proofString":"rewrite <- H2, <- H3; auto."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : len2 >= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : len3 >= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : len1 >= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (ofs1 len1 : Z) (l1 : list memval) (ofs2 len2 : Z) (l2 : list memval) (ofs3 len3 : Z) (l3 : list memval) (len : Z) (H : Mem.loadbytes m b ofs1 len1 = Some l1) (H0 : Mem.loadbytes m b ofs2 len2 = Some l2) (H1 : Mem.loadbytes m b ofs3 len3 = Some l3) (H2 : ofs2 = ofs1 + len1) (H3 : ofs3 = ofs2 + len2) (H4 : 0 <= len1) (H5 : 0 <= len2) (H6 : 0 <= len3) (H7 : len = len1 + len2 + len3) : len2 + len3 >= 0.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos i = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) : match_state s' m' b.","proofString":"exploit Genv.store_init_data_aligned; eauto.\nintros ALIGN.\nassert (VALID: idvalid i).\ndestruct i; simpl; auto.\nsimpl in SI.\ndestruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto.\nunfold store_data in ST.\nset (sz := init_data_size i) in *.\nassert (sz >= 0) by (apply init_data_size_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nmonadInv ST.\nInvBooleans.\nassert (U: Mem.unchanged_on (fun b i => ~(pos <= i < pos + sz)) m m').\neapply Genv.store_init_data_unchanged.\neauto.\ntauto.\nexploit store_init_data_loadbytes; eauto.\nfold sz.\nintros D.\ndestruct (zle (curr s) pos).\ninv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia.\nmonadInv ST.\ndestruct x as [[bytes1 bytes2] il].\ninv EQ0.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos i = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) : (Genv.init_data_alignment i | pos) -> match_state s' m' b.","proofString":"intros ALIGN.\nassert (VALID: idvalid i).\ndestruct i; simpl; auto.\nsimpl in SI.\ndestruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto.\nunfold store_data in ST.\nset (sz := init_data_size i) in *.\nassert (sz >= 0) by (apply init_data_size_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nmonadInv ST.\nInvBooleans.\nassert (U: Mem.unchanged_on (fun b i => ~(pos <= i < pos + sz)) m m').\neapply Genv.store_init_data_unchanged.\neauto.\ntauto.\nexploit store_init_data_loadbytes; eauto.\nfold sz.\nintros D.\ndestruct (zle (curr s) pos).\ninv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia.\nmonadInv ST.\ndestruct x as [[bytes1 bytes2] il].\ninv EQ0.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos i = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) : match_state s' m' b.","proofString":"assert (VALID: idvalid i).\ndestruct i; simpl; auto.\nsimpl in SI.\ndestruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto.\nunfold store_data in ST.\nset (sz := init_data_size i) in *.\nassert (sz >= 0) by (apply init_data_size_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nmonadInv ST.\nInvBooleans.\nassert (U: Mem.unchanged_on (fun b i => ~(pos <= i < pos + sz)) m m').\neapply Genv.store_init_data_unchanged.\neauto.\ntauto.\nexploit store_init_data_loadbytes; eauto.\nfold sz.\nintros D.\ndestruct (zle (curr s) pos).\ninv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia.\nmonadInv ST.\ndestruct x as [[bytes1 bytes2] il].\ninv EQ0.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos i = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) : idvalid i.","proofString":"destruct i; simpl; auto.\nsimpl in SI.\ndestruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : ident) (i0 : ptrofs) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos (Init_addrof i i0) = OK s') (SI : Genv.store_init_data ge m b pos (Init_addrof i i0) = Some m') (NOSPACE : True) (ALIGN : (Genv.init_data_alignment (Init_addrof i i0) | pos)) : exists b0 : block, Genv.find_symbol ge i = Some b0.","proofString":"simpl in SI.\ndestruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : ident) (i0 : ptrofs) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos (Init_addrof i i0) = OK s') (SI : match Genv.find_symbol ge i with\n| Some b' => Mem.store Mptr m b pos (Vptr b' i0)\n| None => None\nend = Some m') (NOSPACE : True) (ALIGN : (Genv.init_data_alignment (Init_addrof i i0) | pos)) : exists b0 : block, Genv.find_symbol ge i = Some b0.","proofString":"destruct (Genv.find_symbol ge i); try discriminate.\nexists b0; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : ident) (i0 : ptrofs) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos (Init_addrof i i0) = OK s') (b0 : block) (SI : Mem.store Mptr m b pos (Vptr b0 i0) = Some m') (NOSPACE : True) (ALIGN : (Genv.init_data_alignment (Init_addrof i i0) | pos)) : exists b1 : block, Some b0 = Some b1.","proofString":"exists b0; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : store_data s pos i = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) : match_state s' m' b.","proofString":"unfold store_data in ST.\nset (sz := init_data_size i) in *.\nassert (sz >= 0) by (apply init_data_size_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nmonadInv ST.\nInvBooleans.\nassert (U: Mem.unchanged_on (fun b i => ~(pos <= i < pos + sz)) m m').\neapply Genv.store_init_data_unchanged.\neauto.\ntauto.\nexploit store_init_data_loadbytes; eauto.\nfold sz.\nintros D.\ndestruct (zle (curr s) pos).\ninv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia.\nmonadInv ST.\ndestruct x as [[bytes1 bytes2] il].\ninv EQ0.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (ST : (assertion zle 0 pos && zle (pos + init_data_size i) (total_size s);\n if zle (curr s) pos\n then\n  OK\n    {|\n      init :=\n        i\n        :: (if zlt (curr s) pos\n            then Init_space (pos - curr s) :: init s\n            else init s);\n      curr := pos + init_data_size i;\n      total_size := total_size s\n    |}\n else\n  do x3 <-\n  trisection (init (pad_to s (pos + init_data_size i)))\n    (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n    (init_data_size i);\n  let\n  '(bytes1, _, il2) := x3 in\n   OK\n     {|\n       init := add_rev_bytes bytes1 (i :: il2);\n       curr := curr (pad_to s (pos + init_data_size i));\n       total_size := total_size (pad_to s (pos + init_data_size i))\n     |}) = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) : match_state s' m' b.","proofString":"set (sz := init_data_size i) in *.\nassert (sz >= 0) by (apply init_data_size_pos).\nset (s1 := pad_to s (pos + sz)) in *.\nmonadInv ST.\nInvBooleans.\nassert (U: Mem.unchanged_on (fun b i => ~(pos <= i < pos + sz)) m m').\neapply Genv.store_init_data_unchanged.\neauto.\ntauto.\nexploit store_init_data_loadbytes; eauto.\nfold sz.\nintros D.\ndestruct (zle (curr s) pos).\ninv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia.\nmonadInv ST.\ndestruct x as [[bytes1 bytes2] il].\ninv EQ0.\nassert (pos + sz <= curr s1) by (apply curr_pad_to).\nassert (MS': match_state s1 m b) by (apply pad_to_correct; auto).\nexploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (s' : state) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (ST : OK\n  {|\n    init :=\n      i\n      :: (if zlt (curr s) pos\n          then Init_space (pos - curr s) :: init s\n          else init s);\n    curr := pos + sz;\n    total_size := total_size s\n  |} = OK s') (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) : match_state s' m' b.","proofString":"inv ST.\nset (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) : match_state\n  {|\n    init :=\n      i\n      :: (if zlt (curr s) pos\n          then Init_space (pos - curr s) :: init s\n          else init s);\n    curr := pos + sz;\n    total_size := total_size s\n  |} m' b.","proofString":"set (il := if zlt (curr s) pos then Init_space (pos - curr s) :: init s else init s).\nassert (IL: boidl (rev il) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).\nunfold il; destruct (zlt (curr s) pos).\nsimpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto.\nrewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto.\nconstructor; simpl; intros.\nlia.\nrewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto.\nrewrite idlvalid_app; split.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l.\neapply match_valid; eauto.\nsimpl.\nreplace (init_data_list_size (rev il)) with pos.\ntauto.\nunfold il; destruct (zlt (curr s) pos).\nsimpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia.\nerewrite match_size by eauto.\nlia.\neapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) : boidl (rev (Init_space (pos - curr s) :: init s)) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)).","proofString":"simpl rev.\nrewrite boidl_rev_cons.\nsimpl.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) : boidl (rev (init s) ++ Init_space (pos - curr s) :: nil) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)).","proofString":"rewrite boidl_rev_cons.\nsimpl.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) : boidl (rev (init s)) ++ boid (Init_space (pos - curr s)) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)).","proofString":"simpl.\nauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) : boidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)).","proofString":"auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) : boidl (rev (init s)) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)).","proofString":"rewrite Z_to_nat_neg by lia.\nsimpl.\nrewrite app_nil_r; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) : boidl (rev (init s)) = boidl (rev (init s)) ++ repeat (Byte Byte.zero) 0.","proofString":"simpl.\nrewrite app_nil_r; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) : boidl (rev (init s)) = boidl (rev (init s)) ++ nil.","proofString":"rewrite app_nil_r; auto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : 0 <= pos + sz <= total_size s.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m' b 0 (pos + sz) = Some (boidl (rev il ++ i :: nil)).","proofString":"rewrite boidl_rev_cons, IL, app_ass.\napply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m' b 0 (pos + sz) =\nSome\n  (boidl (rev (init s)) ++\n   repeat (Byte Byte.zero) (Z.to_nat (pos - curr s)) ++ boid i).","proofString":"apply loadbytes_concat_3 with (len1 := curr s) (ofs2 := curr s) (len2 := pos - curr s) (ofs3 := pos) (len3 := sz); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia.\nexact D.\neapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m' b 0 (curr s) = Some (boidl (rev (init s))).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply match_contents; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : forall i0 : Z,\n0 <= i0 < 0 + curr s ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : 0 <= i0 < 0 + curr s) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : 0 <= i0 < 0 + curr s) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m b 0 (curr s) = Some (boidl (rev (init s))).","proofString":"eapply match_contents; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m' b (curr s) (pos - curr s) =\nSome (repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\neapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : forall i0 : Z,\ncurr s <= i0 < curr s + (pos - curr s) ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : curr s <= i0 < curr s + (pos - curr s)) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : curr s <= i0 < curr s + (pos - curr s)) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m b (curr s) (pos - curr s) =\nSome (repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))).","proofString":"eapply reads_as_zeros_loadbytes.\neapply match_uninitialized; eauto.\nlia.\nlia.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : 0 <= pos - curr s.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : Mem.loadbytes m' b pos sz = Some (boid i).","proofString":"exact D."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : 0 <= curr s.","proofString":"eapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : idlvalid 0 (rev (Init_space (pos - curr s) :: init s)).","proofString":"simpl; rewrite idlvalid_app; split.\neapply match_valid; eauto.\nsimpl.\nauto using Z.divide_1_l."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : idlvalid 0 (rev (init s)).","proofString":"eapply match_valid; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : idlvalid (0 + init_data_list_size (rev (init s)))\n  (Init_space (pos - curr s) :: nil).","proofString":"simpl.\nauto using Z.divide_1_l."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : (1 | init_data_list_size (rev (init s))) /\\ True /\\ True.","proofString":"auto using Z.divide_1_l."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : idlvalid 0 (rev (init s)).","proofString":"eapply match_valid; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : (Genv.init_data_alignment i | pos) /\\ idvalid i /\\ True.","proofString":"tauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : pos = init_data_list_size (rev (Init_space (pos - curr s) :: init s)).","proofString":"simpl; rewrite init_data_list_size_app; simpl.\nerewrite match_size by eauto.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : pos = init_data_list_size (rev (init s)) + (Z.max (pos - curr s) 0 + 0).","proofString":"erewrite match_size by eauto.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (l0 : curr s < pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : pos = curr s + (Z.max (pos - curr s) 0 + 0).","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : pos = init_data_list_size (rev (init s)).","proofString":"erewrite match_size by eauto.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (g : curr s >= pos) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : pos = curr s.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : reads_as_zeros m' b (pos + sz) (total_size s).","proofString":"eapply reads_as_zeros_unchanged; eauto.\neapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : reads_as_zeros m b (pos + sz) (total_size s).","proofString":"eapply reads_as_zeros_mono.\neapply match_uninitialized; eauto.\nlia.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) : forall i0 : Z,\npos + sz <= i0 < total_size s ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : pos + sz <= i0 < total_size s) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (l : curr s <= pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (il : list init_data) (IL : boidl (rev il) =\nboidl (rev (init s)) ++ repeat (Byte Byte.zero) (Z.to_nat (pos - curr s))) (i0 : Z) (H2 : pos + sz <= i0 < total_size s) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) : match_state\n  {|\n    init := add_rev_bytes bytes1 (i :: il);\n    curr := curr s1;\n    total_size := total_size s1\n  |} m' b.","proofString":"exploit trisection_correct; eauto.\nlia.\nintros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) : 0 <= sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) : Mem.loadbytes m b 0 pos = Some (boidl (rev il)) /\\\nMem.loadbytes m b pos sz = Some (inj_bytes bytes2) /\\\nMem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1) ->\nmatch_state\n  {|\n    init := add_rev_bytes bytes1 (i :: il);\n    curr := curr s1;\n    total_size := total_size s1\n  |} m' b.","proofString":"intros (L1 & L2 & L3).\nconstructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : match_state\n  {|\n    init := add_rev_bytes bytes1 (i :: il);\n    curr := curr s1;\n    total_size := total_size s1\n  |} m' b.","proofString":"constructor; simpl; intros.\neapply match_range; eauto.\nrewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\napply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto.\neapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : 0 <= curr s1 <= total_size s1.","proofString":"eapply match_range; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev (add_rev_bytes bytes1 (i :: il)))).","proofString":"rewrite add_rev_bytes_spec, rev_app_distr; simpl; rewrite app_ass; simpl.\nrewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev il ++ i :: rev (map Init_byte (rev bytes1)))).","proofString":"rewrite <- map_rev, rev_involutive.\nrewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev il ++ i :: map Init_byte bytes1)).","proofString":"rewrite boidl_app.\nsimpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev il) ++ boidl (i :: map Init_byte bytes1)).","proofString":"simpl.\nrewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev il) ++ boid i ++ boidl (map Init_byte bytes1)).","proofString":"rewrite boidl_init_bytes.\napply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 (curr s1) =\nSome (boidl (rev il) ++ boid i ++ inj_bytes bytes1).","proofString":"apply loadbytes_concat_3 with (len1 := pos) (ofs2 := pos) (len2 := sz) (ofs3 := pos + sz)                                  (len3 := curr s1 - (pos + sz)); try lia.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia.\nexact D.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b 0 pos = Some (boidl (rev il)).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : forall i0 : Z,\n0 <= i0 < 0 + pos ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : 0 <= i0 < 0 + pos) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : 0 <= i0 < 0 + pos) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b pos sz = Some (boid i).","proofString":"exact D."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : Mem.loadbytes m' b (pos + sz) (curr s1 - (pos + sz)) =\nSome (inj_bytes bytes1).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : forall i0 : Z,\npos + sz <= i0 < pos + sz + (curr s1 - (pos + sz)) ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : pos + sz <= i0 < pos + sz + (curr s1 - (pos + sz))) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : pos + sz <= i0 < pos + sz + (curr s1 - (pos + sz))) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid 0 (rev (add_rev_bytes bytes1 (i :: il))).","proofString":"apply add_rev_bytes_valid.\nsimpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid 0 (rev (i :: il)).","proofString":"simpl; rewrite idlvalid_app; split.\neapply trisection_valid; eauto.\neapply match_valid; eauto.\nrewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid 0 (rev il).","proofString":"eapply trisection_valid; eauto.\neapply match_valid; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid 0 (rev (init s1)).","proofString":"eapply match_valid; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid (0 + init_data_list_size (rev il)) (i :: nil).","proofString":"rewrite init_data_list_size_boidl.\nerewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid (0 + Z.of_nat (Datatypes.length (boidl (rev il)))) (i :: nil).","proofString":"erewrite Mem.loadbytes_length by eauto.\nrewrite Z2Nat.id by lia.\nsimpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid (0 + Z.of_nat (Z.to_nat pos)) (i :: nil).","proofString":"rewrite Z2Nat.id by lia.\nsimpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : idlvalid (0 + pos) (i :: nil).","proofString":"simpl.\ntauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : (Genv.init_data_alignment i | pos) /\\ idvalid i /\\ True.","proofString":"tauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : reads_as_zeros m' b (curr s1) (total_size s1).","proofString":"eapply reads_as_zeros_unchanged; eauto.\neapply match_uninitialized; eauto.\nintros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : reads_as_zeros m b (curr s1) (total_size s1).","proofString":"eapply match_uninitialized; eauto."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i0 : Z) => ~ pos <= i0 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) : forall i0 : Z,\ncurr s1 <= i0 < total_size s1 ->\n(fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"intros.\nsimpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : curr s1 <= i0 < total_size s1) : (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) b i0.","proofString":"simpl.\nlia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (i : init_data) (m' : mem) (MS : match_state s m b) (sz : Z) (s1 : state) (g : curr s > pos) (SI : Genv.store_init_data ge m b pos i = Some m') (NOSPACE : match i with\n| Init_space _ => False\n| _ => True\nend) (ALIGN : (Genv.init_data_alignment i | pos)) (VALID : idvalid i) (H : sz >= 0) (H1 : pos + sz <= total_size s) (H0 : 0 <= pos) (U : Mem.unchanged_on (fun (_ : block) (i1 : Z) => ~ pos <= i1 < pos + sz) m m') (D : Mem.loadbytes m' b pos sz = Some (boid i)) (bytes1 bytes2 : list byte) (il : list init_data) (EQ : trisection (init s1) (curr s1 - (pos + sz)) sz = OK (bytes1, bytes2, il)) (H2 : pos + sz <= curr s1) (MS' : match_state s1 m b) (L1 : Mem.loadbytes m b 0 pos = Some (boidl (rev il))) (L2 : Mem.loadbytes m b pos sz = Some (inj_bytes bytes2)) (L3 : Mem.loadbytes m b (pos + sz) (curr s1 - (pos + sz)) = Some (inj_bytes bytes1)) (i0 : Z) (H3 : curr s1 <= i0 < total_size s1) : ~ pos <= i0 < pos + sz.","proofString":"lia."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (n : int) (s' : state) (m' : mem) (H : match_state s m b) (H0 : store_int s pos isz n = OK s') (H1 : Mem.store (chunk_for_carrier isz) m b pos (Vint n) = Some m') : match_state s' m' b.","proofString":"eapply store_data_correct; eauto.\ndestruct isz; exact H1.\ndestruct isz; exact I."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (n : int) (s' : state) (m' : mem) (H : match_state s m b) (H0 : store_int s pos isz n = OK s') (H1 : Mem.store (chunk_for_carrier isz) m b pos (Vint n) = Some m') : Genv.store_init_data ge m b pos (init_data_for_carrier isz n) = Some m'.","proofString":"destruct isz; exact H1."},{"statement":"(s : state) (m : mem) (b : block) (pos : Z) (isz : intsize) (n : int) (s' : state) (m' : mem) (H : match_state s m b) (H0 : store_int s pos isz n = OK s') (H1 : Mem.store (chunk_for_carrier isz) m b pos (Vint n) = Some m') : match init_data_for_carrier isz n with\n| Init_space _ => False\n| _ => True\nend.","proofString":"destruct isz; exact I."},{"statement":"(s : state) (pos : Z) (i : init_data) (s' : state) (H : (assertion zle 0 pos && zle (pos + init_data_size i) (total_size s);\n if zle (curr s) pos\n then\n  OK\n    {|\n      init :=\n        i\n        :: (if zlt (curr s) pos\n            then Init_space (pos - curr s) :: init s\n            else init s);\n      curr := pos + init_data_size i;\n      total_size := total_size s\n    |}\n else\n  do x3 <-\n  trisection (init (pad_to s (pos + init_data_size i)))\n    (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n    (init_data_size i);\n  let\n  '(bytes1, _, il2) := x3 in\n   OK\n     {|\n       init := add_rev_bytes bytes1 (i :: il2);\n       curr := curr (pad_to s (pos + init_data_size i));\n       total_size := total_size (pad_to s (pos + init_data_size i))\n     |}) = OK s') : total_size s' = total_size s.","proofString":"monadInv H.\ndestruct (zle (curr s) pos); monadInv H.\nauto.\ndestruct x as [[bytes1 bytes2] il2].\ninv EQ0.\nsimpl.\napply total_size_pad_to."},{"statement":"(s : state) (pos : Z) (i : init_data) (s' : state) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (H : (if zle (curr s) pos\n then\n  OK\n    {|\n      init :=\n        i\n        :: (if zlt (curr s) pos\n            then Init_space (pos - curr s) :: init s\n            else init s);\n      curr := pos + init_data_size i;\n      total_size := total_size s\n    |}\n else\n  do x3 <-\n  trisection (init (pad_to s (pos + init_data_size i)))\n    (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n    (init_data_size i);\n  let\n  '(bytes1, _, il2) := x3 in\n   OK\n     {|\n       init := add_rev_bytes bytes1 (i :: il2);\n       curr := curr (pad_to s (pos + init_data_size i));\n       total_size := total_size (pad_to s (pos + init_data_size i))\n     |}) = OK s') : total_size s' = total_size s.","proofString":"destruct (zle (curr s) pos); monadInv H.\nauto.\ndestruct x as [[bytes1 bytes2] il2].\ninv EQ0.\nsimpl.\napply total_size_pad_to."},{"statement":"(s : state) (pos : Z) (i : init_data) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (l : curr s <= pos) : total_size\n  {|\n    init :=\n      i\n      :: (if zlt (curr s) pos\n          then Init_space (pos - curr s) :: init s\n          else init s);\n    curr := pos + init_data_size i;\n    total_size := total_size s\n  |} = total_size s.","proofString":"auto."},{"statement":"(s : state) (pos : Z) (i : init_data) (s' : state) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (g : curr s > pos) (x : list byte * list byte * list init_data) (EQ : trisection (init (pad_to s (pos + init_data_size i)))\n  (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n  (init_data_size i) = OK x) (EQ0 : (let\n '(bytes1, _, il2) := x in\n  OK\n    {|\n      init := add_rev_bytes bytes1 (i :: il2);\n      curr := curr (pad_to s (pos + init_data_size i));\n      total_size := total_size (pad_to s (pos + init_data_size i))\n    |}) = OK s') : total_size s' = total_size s.","proofString":"destruct x as [[bytes1 bytes2] il2].\ninv EQ0.\nsimpl.\napply total_size_pad_to."},{"statement":"(s : state) (pos : Z) (i : init_data) (s' : state) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (g : curr s > pos) (bytes1 bytes2 : list byte) (il2 : list init_data) (EQ : trisection (init (pad_to s (pos + init_data_size i)))\n  (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n  (init_data_size i) = OK (bytes1, bytes2, il2)) (EQ0 : OK\n  {|\n    init := add_rev_bytes bytes1 (i :: il2);\n    curr := curr (pad_to s (pos + init_data_size i));\n    total_size := total_size (pad_to s (pos + init_data_size i))\n  |} = OK s') : total_size s' = total_size s.","proofString":"inv EQ0.\nsimpl.\napply total_size_pad_to."},{"statement":"(s : state) (pos : Z) (i : init_data) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (g : curr s > pos) (bytes1 bytes2 : list byte) (il2 : list init_data) (EQ : trisection (init (pad_to s (pos + init_data_size i)))\n  (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n  (init_data_size i) = OK (bytes1, bytes2, il2)) : total_size\n  {|\n    init := add_rev_bytes bytes1 (i :: il2);\n    curr := curr (pad_to s (pos + init_data_size i));\n    total_size := total_size (pad_to s (pos + init_data_size i))\n  |} = total_size s.","proofString":"simpl.\napply total_size_pad_to."},{"statement":"(s : state) (pos : Z) (i : init_data) (Heqb : zle 0 pos && zle (pos + init_data_size i) (total_size s) = true) (g : curr s > pos) (bytes1 bytes2 : list byte) (il2 : list init_data) (EQ : trisection (init (pad_to s (pos + init_data_size i)))\n  (curr (pad_to s (pos + init_data_size i)) - (pos + init_data_size i))\n  (init_data_size i) = OK (bytes1, bytes2, il2)) : total_size (pad_to s (pos + init_data_size i)) = total_size s.","proofString":"apply total_size_pad_to."},{"statement":"(ce : composite_env) (s : state) (ty : type) (sz : intsize) (p w : Z) (i : initializer) (pos : Z) (s' : state) (H : match i with\n| Init_single a =>\n    do v <- constval_cast ce a ty;\n    match v with\n    | Vundef => Error (msg \"undefined operation in bitfield initializer\")\n    | Vint n =>\n        do c <- load_int s pos sz;\n        store_int s pos sz (Int.bitfield_insert (first_bit sz p w) w c n)\n    | _ => Error (msg \"type mismatch in bitfield initializer\")\n    end\n| _ => Error (msg \"bitfield initialized by composite initializer\")\nend = OK s') : total_size s' = total_size s.","proofString":"destruct i; monadInv H.\ndestruct x; monadInv EQ0.\neapply total_size_store_data.\neexact EQ2."},{"statement":"(ce : composite_env) (s : state) (ty : type) (sz : intsize) (p w : Z) (a : expr) (pos : Z) (s' : state) (x : val) (EQ : constval_cast ce a ty = OK x) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in bitfield initializer\")\n| Vint n =>\n    do c <- load_int s pos sz;\n    store_int s pos sz (Int.bitfield_insert (first_bit sz p w) w c n)\n| _ => Error (msg \"type mismatch in bitfield initializer\")\nend = OK s') : total_size s' = total_size s.","proofString":"destruct x; monadInv EQ0.\neapply total_size_store_data.\neexact EQ2."},{"statement":"(ce : composite_env) (s : state) (ty : type) (sz : intsize) (p w : Z) (a : expr) (pos : Z) (s' : state) (i : int) (EQ : constval_cast ce a ty = OK (Vint i)) (x : int) (EQ1 : load_int s pos sz = OK x) (EQ2 : store_int s pos sz (Int.bitfield_insert (first_bit sz p w) w x i) = OK s') : total_size s' = total_size s.","proofString":"eapply total_size_store_data.\neexact EQ2."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (ty1 : type) (m' : mem) (v : val) (b : block) (ofs : Z) (m'' : mem) (TR : transl_init_single ge ty a = OK data) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"monadInv TR.\nmonadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (ty1 : type) (m' : mem) (v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (x : val) (EQ : constval_cast ge a ty = OK x) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"monadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (ty1 : type) (m' : mem) (v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"exploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (ty1 : type) (m' : mem) (v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) : m' = m /\\ ty1 = typeof a /\\ Val.inject inj x0 v1 ->\nGenv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"intros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (ty1 : type) (m' : mem) (v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (A : m' = m) (B : ty1 = typeof a) (C : Val.inject inj x0 v1) : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"subst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (ASG : exec_assign m b ofs Full ty v m'') (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"exploit sem_cast_match; eauto.\nintros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (ASG : exec_assign m b ofs Full ty v m'') (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) : Val.inject inj x v ->\nGenv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"intros D.\ninv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (ASG : exec_assign m b ofs Full ty v m'') (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) (D : Val.inject inj x v) : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"inv ASG.\nrename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) (D : Val.inject inj x v) (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs v = Some m'') : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"rename H into A.\nunfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) (D : Val.inject inj x v) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs v = Some m'') : Genv.store_init_data ge m b ofs data = Some m'' /\\\nmatch data with\n| Init_space _ => False\n| _ => True\nend.","proofString":"unfold Genv.store_init_data.\ninv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (x : val) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in initializer\")\n| Vint n =>\n    match ty with\n    | Tint I16 _ _ => OK (Init_int16 n)\n    | Tint I32 _ _ => OK (Init_int32 n)\n    | Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 n)\n    | Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vlong n =>\n    match ty with\n    | Tlong _ _ => OK (Init_int64 n)\n    | Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 n)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vfloat f0 =>\n    match ty with\n    | Tfloat F64 _ => OK (Init_float64 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vsingle f0 =>\n    match ty with\n    | Tfloat F32 _ => OK (Init_float32 f0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\n| Vptr id ofs0 =>\n    match ty with\n    | Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof id ofs0)\n    | Tpointer _ _ => OK (Init_addrof id ofs0)\n    | _ => Error (msg \"type mismatch in initializer\")\n    end\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK x) (C : Val.inject inj x0 v1) (D : Val.inject inj x v) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs v = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"inv D.\nremember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\nremember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\ndestruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto.\nunfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto.\ndiscriminate."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) ty m = Some (Vint i)) (EQ0 : match ty with\n| Tint I16 _ _ => OK (Init_int16 i)\n| Tint I32 _ _ => OK (Init_int32 i)\n| Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 i)\n| Tpointer _ _ => assertion negb Archi.ptr64; OK (Init_int32 i)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"remember Archi.ptr64 as ptr64.\ndestruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) ty m = Some (Vint i)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : match ty with\n| Tint I16 _ _ => OK (Init_int16 i)\n| Tint I32 _ _ => OK (Init_int32 i)\n| Tint I8 _ _ | Tint IBool _ _ => OK (Init_int8 i)\n| Tpointer _ _ => assertion negb ptr64; OK (Init_int32 i)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct ty; try discriminate EQ0.\ndestruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto.\ndestruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(i0 : intsize) (s : signedness) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint i0 s a0) m = Some (Vint i)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : match i0 with\n| I16 => OK (Init_int16 i)\n| I32 => OK (Init_int32 i)\n| _ => OK (Init_int8 i)\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint i0 s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint i0 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct i0; inv EQ0.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto.\ndestruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto.\nsimpl in A; inv A.\nauto.\nsimpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I8 s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I8 s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I8 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"destruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_8; auto.\nauto."},{"statement":"(a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I8 Signed a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I8 Signed a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint8signed m b ofs (Vint i) = Some m'') : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"rewrite <- Mem.store_signed_unsigned_8; auto."},{"statement":"(a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I8 Unsigned a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I8 Unsigned a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'') : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I16 s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I16 s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I16 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : Mem.store Mint16unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"destruct s; simpl in A; inv A.\nrewrite <- Mem.store_signed_unsigned_16; auto.\nauto."},{"statement":"(a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I16 Signed a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I16 Signed a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint16signed m b ofs (Vint i) = Some m'') : Mem.store Mint16unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"rewrite <- Mem.store_signed_unsigned_16; auto."},{"statement":"(a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I16 Unsigned a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I16 Unsigned a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint16unsigned m b ofs (Vint i) = Some m'') : Mem.store Mint16unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I32 s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I32 s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I32 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : Mem.store Mint32 m b ofs (Vint i) = Some m'' /\\ True.","proofString":"simpl in A; inv A.\nauto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint I32 s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I32 s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint32 m b ofs (Vint i) = Some m'') : Mem.store Mint32 m b ofs (Vint i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint IBool s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint IBool s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint IBool s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"simpl in A; inv A.\nrewrite <- Mem.store_bool_unsigned_8; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tint IBool s a0) m = Some (Vint i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint IBool s a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mbool m b ofs (Vint i) = Some m'') : Mem.store Mint8unsigned m b ofs (Vint i) = Some m'' /\\ True.","proofString":"rewrite <- Mem.store_bool_unsigned_8; auto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m = Some (Vint i)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : (assertion negb ptr64; OK (Init_int32 i)) = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tpointer ty a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct ptr64; inv EQ0.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m = Some (Vint i)) (Heqptr64 : false = Archi.ptr64) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tpointer ty a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vint i) = Some m'') : Mem.store Mint32 m b ofs (Vint i) = Some m'' /\\ True.","proofString":"simpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m = Some (Vint i)) (Heqptr64 : false = Archi.ptr64) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vint i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint32 m b ofs (Vint i) = Some m'') : Mem.store Mint32 m b ofs (Vint i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) ty m = Some (Vlong i)) (EQ0 : match ty with\n| Tlong _ _ => OK (Init_int64 i)\n| Tpointer _ _ => assertion Archi.ptr64; OK (Init_int64 i)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vlong i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vlong i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"remember Archi.ptr64 as ptr64.\ndestruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) ty m = Some (Vlong i)) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : match ty with\n| Tlong _ _ => OK (Init_int64 i)\n| Tpointer _ _ => assertion ptr64; OK (Init_int64 i)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vlong i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vlong i) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct ty; monadInv EQ0.\nsimpl in A; inv A.\nauto.\nsimpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m = Some (Vlong i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vlong i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tlong s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vlong i) = Some m'') : Mem.store Mint64 m b ofs (Vlong i) = Some m'' /\\ True.","proofString":"simpl in A; inv A.\nauto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m = Some (Vlong i)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vlong i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint64 m b ofs (Vlong i) = Some m'') : Mem.store Mint64 m b ofs (Vlong i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m = Some (Vlong i)) (Heqptr64 : true = Archi.ptr64) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vlong i)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tpointer ty a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vlong i) = Some m'') : Mem.store Mint64 m b ofs (Vlong i) = Some m'' /\\ True.","proofString":"simpl in A; unfold Mptr in A; rewrite <- Heqptr64 in A; inv A.\nauto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (i : int64) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m = Some (Vlong i)) (Heqptr64 : true = Archi.ptr64) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vlong i)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mint64 m b ofs (Vlong i) = Some m'') : Mem.store Mint64 m b ofs (Vlong i) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (f0 : float) (CAST : sem_cast v1 (typeof a) ty m = Some (Vfloat f0)) (EQ0 : match ty with\n| Tfloat F64 _ => OK (Init_float64 f0)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vfloat f0)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vfloat f0) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto."},{"statement":"(f1 : floatsize) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (f0 : float) (CAST : sem_cast v1 (typeof a) (Tfloat f1 a0) m = Some (Vfloat f0)) (EQ0 : match f1 with\n| F32 => Error (msg \"type mismatch in initializer\")\n| F64 => OK (Init_float64 f0)\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tfloat f1 a0) = OK (Vfloat f0)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tfloat f1 a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vfloat f0) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct f1; inv EQ0; simpl in A; inv A; auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (f0 : float32) (CAST : sem_cast v1 (typeof a) ty m = Some (Vsingle f0)) (EQ0 : match ty with\n| Tfloat F32 _ => OK (Init_float32 f0)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vsingle f0)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vsingle f0) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct ty; try discriminate.\ndestruct f1; inv EQ0; simpl in A; inv A; auto."},{"statement":"(f1 : floatsize) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (f0 : float32) (CAST : sem_cast v1 (typeof a) (Tfloat f1 a0) m = Some (Vsingle f0)) (EQ0 : match f1 with\n| F32 => OK (Init_float32 f0)\n| F64 => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tfloat f1 a0) = OK (Vsingle f0)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tfloat f1 a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vsingle f0) = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct f1; inv EQ0; simpl in A; inv A; auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : inj b1 = Some (b2, delta)) : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"unfold inj in H.\nassert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"assert (X: data = Init_addrof b1 ofs1 /\\ chunk = Mptr).\nremember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto.\ndestruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : data = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"remember Archi.ptr64 as ptr64.\ndestruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : data = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"destruct ty; inversion EQ0.\ndestruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\nmonadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto.\ninv A; auto."},{"statement":"(i : intsize) (s : signedness) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tint i s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : match i with\n| I32 => assertion negb ptr64; OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint i s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint i s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (H2 : match i with\n| I32 => assertion negb ptr64; OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) : data = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"destruct i; monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tint I32 s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : false = Archi.ptr64) (EQ0 : (assertion negb false; OK (Init_addrof b1 ofs1)) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I32 s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I32 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (Heqb1 : true = true) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"unfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tint I32 s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : false = Archi.ptr64) (EQ0 : (assertion negb false; OK (Init_addrof b1 ofs1)) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I32 s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I32 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (Heqb1 : true = true) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\\nchunk = (if Archi.ptr64 then Mint64 else Mint32).","proofString":"rewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tint I32 s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : false = Archi.ptr64) (EQ0 : (assertion negb false; OK (Init_addrof b1 ofs1)) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tint I32 s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tint I32 s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (Heqb1 : true = true) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\ chunk = Mint32.","proofString":"inv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : (assertion ptr64; OK (Init_addrof b1 ofs1)) = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tlong s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (H2 : (assertion ptr64; OK (Init_addrof b1 ofs1)) = OK data) : data = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"monadInv H2.\nunfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : true = Archi.ptr64) (EQ0 : OK (Init_addrof b1 ofs1) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tlong s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"unfold Mptr.\nrewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : true = Archi.ptr64) (EQ0 : OK (Init_addrof b1 ofs1) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tlong s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\\nchunk = (if Archi.ptr64 then Mint64 else Mint32).","proofString":"rewrite <- Heqptr64.\ninv A; auto."},{"statement":"(s : signedness) (a0 : attr) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tlong s a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (Heqptr64 : true = Archi.ptr64) (EQ0 : OK (Init_addrof b1 ofs1) = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tlong s a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tlong s a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\ chunk = Mint64.","proofString":"inv A; auto."},{"statement":"(ty : type) (a0 : attr) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) (Tpointer ty a0) m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (EQ0 : OK (Init_addrof b1 ofs1) = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) (Tpointer ty a0) = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode (Tpointer ty a0) = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (H2 : Init_addrof b1 ofs1 = data) : Init_addrof b1 ofs1 = Init_addrof b1 ofs1 /\\ chunk = Mptr.","proofString":"inv A; auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) (X : data = Init_addrof b1 ofs1 /\\ chunk = Mptr) : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"destruct X; subst.\ndestruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto."},{"statement":"(ty : type) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (delta : Z) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mptr m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr delta))) =\nSome m'') (A : access_mode ty = By_value Mptr) (H : match Genv.find_symbol ge b1 with\n| Some b' => Some (b', 0)\n| None => None\nend = Some (b2, delta)) : match Genv.find_symbol ge b1 with\n| Some b' => Mem.store Mptr m b ofs (Vptr b' ofs1)\n| None => None\nend = Some m'' /\\ True.","proofString":"destruct (Genv.find_symbol ge b1); inv H.\nrewrite Ptrofs.add_zero in H0.\nauto."},{"statement":"(ty : type) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr 0)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mptr m b ofs (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr 0))) = Some m'') (A : access_mode ty = By_value Mptr) : Mem.store Mptr m b ofs (Vptr b2 ofs1) = Some m'' /\\ True.","proofString":"rewrite Ptrofs.add_zero in H0.\nauto."},{"statement":"(ty : type) (a : expr) (f : function) (m : mem) (v1 : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (ofs1 : ptrofs) (b2 : block) (CAST : sem_cast v1 (typeof a) ty m =\nSome (Vptr b2 (Ptrofs.add ofs1 (Ptrofs.repr 0)))) (b1 : block) (EQ0 : match ty with\n| Tint I32 _ _ => assertion negb Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tlong _ _ => assertion Archi.ptr64; OK (Init_addrof b1 ofs1)\n| Tpointer _ _ => OK (Init_addrof b1 ofs1)\n| _ => Error (msg \"type mismatch in initializer\")\nend = OK (Init_addrof b1 ofs1)) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK (Vptr b1 ofs1)) (C : Val.inject inj x0 v1) (H0 : Mem.store Mptr m b ofs (Vptr b2 ofs1) = Some m'') (A : access_mode ty = By_value Mptr) : Mem.store Mptr m b ofs (Vptr b2 ofs1) = Some m'' /\\ True.","proofString":"auto."},{"statement":"(ty : type) (a : expr) (data : init_data) (f : function) (m : mem) (v1 v : val) (b : block) (ofs : Z) (m'' : mem) (STEPS : star step ge (ExprState f a Kstop empty_env m) E0\n  (ExprState f (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (EQ0 : Error (msg \"undefined operation in initializer\") = OK data) (x0 : val) (EQ1 : constval ge a = OK x0) (EQ2 : do_cast x0 (typeof a) ty = OK Vundef) (C : Val.inject inj x0 v1) (chunk : memory_chunk) (A : access_mode ty = By_value chunk) (H0 : Mem.store chunk m b ofs v = Some m'') : match data with\n| Init_int8 n => Mem.store Mint8unsigned m b ofs (Vint n)\n| Init_int16 n => Mem.store Mint16unsigned m b ofs (Vint n)\n| Init_int32 n => Mem.store Mint32 m b ofs (Vint n)\n| Init_int64 n => Mem.store Mint64 m b ofs (Vlong n)\n| Init_float32 n => Mem.store Mfloat32 m b ofs (Vsingle n)\n| Init_float64 n => Mem.store Mfloat64 m b ofs (Vfloat n)\n| Init_space _ => Some m\n| Init_addrof symb ofs0 =>\n    match Genv.find_symbol ge symb with\n    | Some b' => Mem.store Mptr m b ofs (Vptr b' ofs0)\n    | None => None\n    end\nend = Some m'' /\\ match data with\n                  | Init_space _ => False\n                  | _ => True\n                  end.","proofString":"discriminate."},{"statement":"forall (m : mem) (b : block) (ofs : Z) (bf : bitfield) \n  (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) \n  (v : val) (m'' : mem),\nstar step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m') ->\nsem_cast v1 ty1 ty m' = Some v ->\nexec_assign m' b ofs bf ty v m'' ->\nforall s s' : state,\nmatch_state s m b ->\nmatch bf with\n| Full => transl_init_rec ge s ty (Init_single a) ofs\n| Bits sz _ p w => transl_init_bitfield ge s ty sz p w (Init_single a) ofs\nend = OK s' -> match_state s' m'' b.","proofString":"intros until m''; intros STEP CAST ASG s s' MS TR.\ndestruct bf; monadInv TR.\nexploit transl_init_single_sound; eauto.\nintros [P Q].\neapply store_data_correct; eauto.\ndestruct x; monadInv EQ0.\nmonadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (bf : bitfield) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs bf ty v m'') (s s' : state) (MS : match_state s m b) (TR : match bf with\n| Full => transl_init_rec ge s ty (Init_single a) ofs\n| Bits sz _ p w => transl_init_bitfield ge s ty sz p w (Init_single a) ofs\nend = OK s') : match_state s' m'' b.","proofString":"destruct bf; monadInv TR.\nexploit transl_init_single_sound; eauto.\nintros [P Q].\neapply store_data_correct; eauto.\ndestruct x; monadInv EQ0.\nmonadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (s s' : state) (MS : match_state s m b) (x : init_data) (EQ : transl_init_single ge ty a = OK x) (EQ0 : store_data s ofs x = OK s') : match_state s' m'' b.","proofString":"exploit transl_init_single_sound; eauto.\nintros [P Q].\neapply store_data_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (s s' : state) (MS : match_state s m b) (x : init_data) (EQ : transl_init_single ge ty a = OK x) (EQ0 : store_data s ofs x = OK s') : Genv.store_init_data ge m b ofs x = Some m'' /\\\nmatch x with\n| Init_space _ => False\n| _ => True\nend -> match_state s' m'' b.","proofString":"intros [P Q].\neapply store_data_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs Full ty v m'') (s s' : state) (MS : match_state s m b) (x : init_data) (EQ : transl_init_single ge ty a = OK x) (EQ0 : store_data s ofs x = OK s') (P : Genv.store_init_data ge m b ofs x = Some m'') (Q : match x with\n| Init_space _ => False\n| _ => True\nend) : match_state s' m'' b.","proofString":"eapply store_data_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs (Bits sz sg pos width) ty v m'') (s s' : state) (MS : match_state s m b) (x : val) (EQ : constval_cast ge a ty = OK x) (EQ0 : match x with\n| Vundef => Error (msg \"undefined operation in bitfield initializer\")\n| Vint n =>\n    do c <- load_int s ofs sz;\n    store_int s ofs sz\n      (Int.bitfield_insert (first_bit sz pos width) width c n)\n| _ => Error (msg \"type mismatch in bitfield initializer\")\nend = OK s') : match_state s' m'' b.","proofString":"destruct x; monadInv EQ0.\nmonadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs (Bits sz sg pos width) ty v m'') (s s' : state) (MS : match_state s m b) (i : int) (EQ : constval_cast ge a ty = OK (Vint i)) (x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') : match_state s' m'' b.","proofString":"monadInv EQ.\nexploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs (Bits sz sg pos width) ty v m'') (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) : match_state s' m'' b.","proofString":"exploit constval_steps; eauto.\nintros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs (Bits sz sg pos width) ty v m'') (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) : m' = m /\\ ty1 = typeof a /\\ Val.inject inj x0 v1 -> match_state s' m'' b.","proofString":"intros [A [B C]].\nsubst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 : val) (ty1 : type) (m' : mem) (v : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 ty1) Kstop empty_env m')) (CAST : sem_cast v1 ty1 ty m' = Some v) (ASG : exec_assign m' b ofs (Bits sz sg pos width) ty v m'') (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) (A : m' = m) (B : ty1 = typeof a) (C : Val.inject inj x0 v1) : match_state s' m'' b.","proofString":"subst m' ty1.\nexploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 v : val) (m'' : mem) (ASG : exec_assign m b ofs (Bits sz sg pos width) ty v m'') (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) (C : Val.inject inj x0 v1) : match_state s' m'' b.","proofString":"exploit sem_cast_match; eauto.\nintros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 v : val) (m'' : mem) (ASG : exec_assign m b ofs (Bits sz sg pos width) ty v m'') (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) (C : Val.inject inj x0 v1) : Val.inject inj (Vint i) v -> match_state s' m'' b.","proofString":"intros D.\ninv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (ty : type) (a : expr) (v1 v : val) (m'' : mem) (ASG : exec_assign m b ofs (Bits sz sg pos width) ty v m'') (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (CAST : sem_cast v1 (typeof a) ty m = Some v) (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a) ty = OK (Vint i)) (C : Val.inject inj x0 v1) (D : Val.inject inj (Vint i) v) : match_state s' m'' b.","proofString":"inv ASG.\ninv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (a : expr) (v1 : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (attr : Ctypes.attr) (n : int) (CAST : sem_cast v1 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) m =\nSome (Vint n)) (s s' : state) (MS : match_state s m b) (i x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x i) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) =\nOK (Vint i)) (C : Val.inject inj x0 v1) (D : Val.inject inj (Vint i) (Vint n)) (ty0 : type) (c : int) (H3 : type_is_volatile ty0 = false) (H4 : 0 <= pos) (H5 : 0 < width) (H9 : pos + width <= bitsize_intsize sz) (H14 : Mem.load (chunk_for_carrier sz) m b ofs = Some (Vint c)) (H15 : Mem.store (chunk_for_carrier sz) m b ofs\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m'') : match_state s' m'' b.","proofString":"inv D.\nset (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (a : expr) (v1 : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (attr : Ctypes.attr) (n : int) (CAST : sem_cast v1 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) m =\nSome (Vint n)) (s s' : state) (MS : match_state s m b) (x : int) (EQ1 : load_int s ofs sz = OK x) (EQ2 : store_int s ofs sz (Int.bitfield_insert (first_bit sz pos width) width x n) =\nOK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) =\nOK (Vint n)) (C : Val.inject inj x0 v1) (ty0 : type) (c : int) (H3 : type_is_volatile ty0 = false) (H4 : 0 <= pos) (H5 : 0 < width) (H9 : pos + width <= bitsize_intsize sz) (H14 : Mem.load (chunk_for_carrier sz) m b ofs = Some (Vint c)) (H15 : Mem.store (chunk_for_carrier sz) m b ofs\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m'') : match_state s' m'' b.","proofString":"set (f := first_bit sz pos width) in *.\nassert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (a : expr) (v1 : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (attr : Ctypes.attr) (n : int) (CAST : sem_cast v1 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) m =\nSome (Vint n)) (s s' : state) (MS : match_state s m b) (x : int) (EQ1 : load_int s ofs sz = OK x) (f : Z) (EQ2 : store_int s ofs sz (Int.bitfield_insert f width x n) = OK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) =\nOK (Vint n)) (C : Val.inject inj x0 v1) (ty0 : type) (c : int) (H3 : type_is_volatile ty0 = false) (H4 : 0 <= pos) (H5 : 0 < width) (H9 : pos + width <= bitsize_intsize sz) (H14 : Mem.load (chunk_for_carrier sz) m b ofs = Some (Vint c)) (H15 : Mem.store (chunk_for_carrier sz) m b ofs\n  (Vint (Int.bitfield_insert f width c n)) = Some m'') : match_state s' m'' b.","proofString":"assert (E: Vint c = Vint x) by (eapply load_int_correct; eauto).\ninv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (a : expr) (v1 : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (attr : Ctypes.attr) (n : int) (CAST : sem_cast v1 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) m =\nSome (Vint n)) (s s' : state) (MS : match_state s m b) (x : int) (EQ1 : load_int s ofs sz = OK x) (f : Z) (EQ2 : store_int s ofs sz (Int.bitfield_insert f width x n) = OK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) =\nOK (Vint n)) (C : Val.inject inj x0 v1) (ty0 : type) (c : int) (H3 : type_is_volatile ty0 = false) (H4 : 0 <= pos) (H5 : 0 < width) (H9 : pos + width <= bitsize_intsize sz) (H14 : Mem.load (chunk_for_carrier sz) m b ofs = Some (Vint c)) (H15 : Mem.store (chunk_for_carrier sz) m b ofs\n  (Vint (Int.bitfield_insert f width c n)) = Some m'') (E : Vint c = Vint x) : match_state s' m'' b.","proofString":"inv E.\neapply store_int_correct; eauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (sz : intsize) (sg : signedness) (pos width : Z) (a : expr) (v1 : val) (m'' : mem) (STEP : star step ge (ExprState dummy_function a Kstop empty_env m) E0\n  (ExprState dummy_function (Eval v1 (typeof a)) Kstop empty_env m)) (attr : Ctypes.attr) (n : int) (CAST : sem_cast v1 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) m =\nSome (Vint n)) (s s' : state) (MS : match_state s m b) (x : int) (EQ1 : load_int s ofs sz = OK x) (f : Z) (EQ2 : store_int s ofs sz (Int.bitfield_insert f width x n) = OK s') (x0 : val) (EQ0 : constval ge a = OK x0) (EQ3 : do_cast x0 (typeof a)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr) =\nOK (Vint n)) (C : Val.inject inj x0 v1) (ty0 : type) (H3 : type_is_volatile ty0 = false) (H4 : 0 <= pos) (H5 : 0 < width) (H9 : pos + width <= bitsize_intsize sz) (H15 : Mem.store (chunk_for_carrier sz) m b ofs\n  (Vint (Int.bitfield_insert f width x n)) = Some m'') (H14 : Mem.load (chunk_for_carrier sz) m b ofs = Some (Vint x)) : match_state s' m'' b.","proofString":"eapply store_int_correct; eauto."},{"statement":"forall (m : mem) (b : block) (ofs : Z) (ty : type) \n  (sz : Z) (a : attr) (il : initializer_list) (m' : mem),\nexec_init_array m b ofs ty sz il m' ->\n(forall s s' : state,\n match_state s m b ->\n transl_init_array ge s ty il ofs = OK s' -> match_state s' m' b) ->\nforall s s' : state,\nmatch_state s m b ->\ntransl_init_rec ge s (Tarray ty sz a) (Init_array il) ofs = OK s' ->\nmatch_state s' m' b.","proofString":"intros.\nmonadInv H2.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (a : attr) (il : initializer_list) (m' : mem) (H : exec_init_array m b ofs ty sz il m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\ntransl_init_array ge s0 ty il ofs = OK s'0 -> match_state s'0 m' b) (s s' : state) (H1 : match_state s m b) (H2 : transl_init_rec ge s (Tarray ty sz a) (Init_array il) ofs = OK s') : match_state s' m' b.","proofString":"monadInv H2.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (a : attr) (il : initializer_list) (m' : mem) (H : exec_init_array m b ofs ty sz il m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\ntransl_init_array ge s0 ty il ofs = OK s'0 -> match_state s'0 m' b) (s s' : state) (H1 : match_state s m b) (l : length_initializer_list il <= Z.max 0 sz) (H2 : transl_init_array ge s ty il ofs = OK s') : match_state s' m' b.","proofString":"eauto."},{"statement":"forall (m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z),\nsz >= 0 ->\nforall s s' : state,\nmatch_state s m b ->\ntransl_init_array ge s ty Init_nil ofs = OK s' -> match_state s' m b.","proofString":"intros.\nmonadInv H1.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (H : sz >= 0) (s s' : state) (H0 : match_state s m b) (H1 : transl_init_array ge s ty Init_nil ofs = OK s') : match_state s' m b.","proofString":"monadInv H1.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (H : sz >= 0) (s' : state) (H0 : match_state s' m b) : match_state s' m b.","proofString":"auto."},{"statement":"forall (m : mem) (b : block) (ofs : Z) (ty : type) \n  (sz : Z) (i1 : initializer) (il : initializer_list) \n  (m' m'' : mem),\nexec_init m b ofs Full ty i1 m' ->\n(forall s s' : state,\n match_state s m b ->\n transl_init_rec ge s ty i1 ofs = OK s' -> match_state s' m' b) ->\nexec_init_array m' b (ofs + sizeof ge ty) ty (sz - 1) il m'' ->\n(forall s s' : state,\n match_state s m' b ->\n transl_init_array ge s ty il (ofs + sizeof ge ty) = OK s' ->\n match_state s' m'' b) ->\nforall s s' : state,\nmatch_state s m b ->\ntransl_init_array ge s ty (Init_cons i1 il) ofs = OK s' ->\nmatch_state s' m'' b.","proofString":"intros.\nmonadInv H4.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b ofs Full ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\ntransl_init_rec ge s0 ty i1 ofs = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_array m' b (ofs + sizeof ge ty) ty (sz - 1) il m'') (H2 : forall s0 s'0 : state,\nmatch_state s0 m' b ->\ntransl_init_array ge s0 ty il (ofs + sizeof ge ty) = OK s'0 ->\nmatch_state s'0 m'' b) (s s' : state) (H3 : match_state s m b) (H4 : transl_init_array ge s ty (Init_cons i1 il) ofs = OK s') : match_state s' m'' b.","proofString":"monadInv H4.\neauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (ty : type) (sz : Z) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b ofs Full ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\ntransl_init_rec ge s0 ty i1 ofs = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_array m' b (ofs + sizeof ge ty) ty (sz - 1) il m'') (H2 : forall s0 s'0 : state,\nmatch_state s0 m' b ->\ntransl_init_array ge s0 ty il (ofs + sizeof ge ty) = OK s'0 ->\nmatch_state s'0 m'' b) (s s' : state) (H3 : match_state s m b) (x : state) (EQ : transl_init_rec ge s ty i1 ofs = OK x) (EQ0 : transl_init_array ge x ty il (ofs + sizeof ge ty) = OK s') : match_state s' m'' b.","proofString":"eauto."},{"statement":"forall (m : mem) (b : block) (ofs : Z) (s s' : state) \n  (ms : members) (pos : Z),\nmatch_state s m b ->\ninitialized_fields_of_struct ms pos = OK nil ->\ntransl_init_struct ge s ms Init_nil ofs pos = OK s' -> match_state s' m b.","proofString":"intros.\nmonadInv H1.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (s s' : state) (ms : members) (pos : Z) (H : match_state s m b) (H0 : initialized_fields_of_struct ms pos = OK nil) (H1 : transl_init_struct ge s ms Init_nil ofs pos = OK s') : match_state s' m b.","proofString":"monadInv H1.\nauto."},{"statement":"(m : mem) (b : block) (ofs : Z) (s' : state) (ms : members) (pos : Z) (H : match_state s' m b) (H0 : initialized_fields_of_struct ms pos = OK nil) : match_state s' m b.","proofString":"auto."},{"statement":"forall (m : mem) (b : block) (ofs pos : Z) (bf : bitfield) \n  (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer)\n  (il : initializer_list) (m' m'' : mem),\nexec_init m b (ofs + pos) bf ty i1 m' ->\n(forall s s' : state,\n match_state s m b ->\n match bf with\n | Full => transl_init_rec ge s ty i1 (ofs + pos)\n | Bits sz _ p w => transl_init_bitfield ge s ty sz p w i1 (ofs + pos)\n end = OK s' -> match_state s' m' b) ->\nexec_init_struct m' b ofs l il m'' ->\n(forall (s s' : state) (ms : members) (pos0 : Z),\n match_state s m' b ->\n initialized_fields_of_struct ms pos0 = OK l ->\n transl_init_struct ge s ms il ofs pos0 = OK s' -> match_state s' m'' b) ->\nforall (s s' : state) (ms : members) (pos0 : Z),\nmatch_state s m b ->\ninitialized_fields_of_struct ms pos0 = OK ((pos, bf, ty) :: l) ->\ntransl_init_struct ge s ms (Init_cons i1 il) ofs pos0 = OK s' ->\nmatch_state s' m'' b.","proofString":"intros.\nsimpl in H5.\nrevert H4 H5.\ngeneralize pos0.\ninduction ms as [ | m1 ms].\ndiscriminate.\nsimpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : members) (pos0 : Z) (H3 : match_state s m b) (H4 : initialized_fields_of_struct ms pos0 = OK ((pos, bf, ty) :: l)) (H5 : transl_init_struct ge s ms (Init_cons i1 il) ofs pos0 = OK s') : match_state s' m'' b.","proofString":"simpl in H5.\nrevert H4 H5.\ngeneralize pos0.\ninduction ms as [ | m1 ms].\ndiscriminate.\nsimpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : members) (pos0 : Z) (H3 : match_state s m b) (H4 : initialized_fields_of_struct ms pos0 = OK ((pos, bf, ty) :: l)) (H5 : (fix init (ms0 : members) (pos1 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos1 m0)\n       else\n        do (delta, layout)<- layout_field ge pos1 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos1 m0)\n   end) ms pos0 = OK s') : match_state s' m'' b.","proofString":"revert H4 H5.\ngeneralize pos0.\ninduction ms as [ | m1 ms].\ndiscriminate.\nsimpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : members) (pos0 : Z) (H3 : match_state s m b) : initialized_fields_of_struct ms pos0 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos1 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos1 m0)\n       else\n        do (delta, layout)<- layout_field ge pos1 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos1 m0)\n   end) ms pos0 = OK s' -> match_state s' m'' b.","proofString":"generalize pos0.\ninduction ms as [ | m1 ms].\ndiscriminate.\nsimpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : members) (pos0 : Z) (H3 : match_state s m b) : forall pos1 : Z,\ninitialized_fields_of_struct ms pos1 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms pos1 = OK s' -> match_state s' m'' b.","proofString":"induction ms as [ | m1 ms].\ndiscriminate.\nsimpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms pos1 = OK l ->\ntransl_init_struct ge s0 ms il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (pos0 : Z) (H3 : match_state s m b) : forall pos1 : Z,\ninitialized_fields_of_struct nil pos1 = OK ((pos, bf, ty) :: l) ->\nError (msg \"too many elements in struct initializer\") = OK s' ->\nmatch_state s' m'' b.","proofString":"discriminate."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (IHms : forall pos1 : Z,\ninitialized_fields_of_struct ms pos1 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms pos1 = OK s' -> match_state s' m'' b) : forall pos1 : Z,\ninitialized_fields_of_struct (m1 :: ms) pos1 = OK ((pos, bf, ty) :: l) ->\n(if member_not_initialized m1\n then\n  (fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n     match ms0 with\n     | nil => Error (msg \"too many elements in struct initializer\")\n     | m0 :: ms' =>\n         if member_not_initialized m0\n         then init ms' (next_field ge pos2 m0)\n         else\n          do (delta, layout)<- layout_field ge pos2 m0;\n          do s1 <-\n          match layout with\n          | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n          | Bits sz _ p w =>\n              transl_init_bitfield ge s (type_member m0) sz p w i1\n                (ofs + delta)\n          end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n     end) ms (next_field ge pos1 m1)\n else\n  do (delta, layout)<- layout_field ge pos1 m1;\n  do s1 <-\n  match layout with\n  | Full => transl_init_rec ge s (type_member m1) i1 (ofs + delta)\n  | Bits sz _ p w =>\n      transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + delta)\n  end; transl_init_struct ge s1 ms il ofs (next_field ge pos1 m1)) = \nOK s' -> match_state s' m'' b.","proofString":"simpl.\ndestruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (IHms : forall pos1 : Z,\ninitialized_fields_of_struct ms pos1 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms pos1 = OK s' -> match_state s' m'' b) : forall pos1 : Z,\n(if member_not_initialized m1\n then initialized_fields_of_struct ms (next_field ge pos1 m1)\n else\n  do ofs_bf <- layout_field ge pos1 m1;\n  do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n  OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l) ->\n(if member_not_initialized m1\n then\n  (fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n     match ms0 with\n     | nil => Error (msg \"too many elements in struct initializer\")\n     | m0 :: ms' =>\n         if member_not_initialized m0\n         then init ms' (next_field ge pos2 m0)\n         else\n          do (delta, layout)<- layout_field ge pos2 m0;\n          do s1 <-\n          match layout with\n          | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n          | Bits sz _ p w =>\n              transl_init_bitfield ge s (type_member m0) sz p w i1\n                (ofs + delta)\n          end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n     end) ms (next_field ge pos1 m1)\n else\n  do (delta, layout)<- layout_field ge pos1 m1;\n  do s1 <-\n  match layout with\n  | Full => transl_init_rec ge s (type_member m1) i1 (ofs + delta)\n  | Bits sz _ p w =>\n      transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + delta)\n  end; transl_init_struct ge s1 ms il ofs (next_field ge pos1 m1)) = \nOK s' -> match_state s' m'' b.","proofString":"destruct (member_not_initialized m1).\nintros; eapply IHms; eauto.\nclear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (IHms : forall pos1 : Z,\ninitialized_fields_of_struct ms pos1 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms pos1 = OK s' -> match_state s' m'' b) : forall pos1 : Z,\ninitialized_fields_of_struct ms (next_field ge pos1 m1) =\nOK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms (next_field ge pos1 m1) = OK s' -> match_state s' m'' b.","proofString":"intros; eapply IHms; eauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (IHms : forall pos1 : Z,\ninitialized_fields_of_struct ms pos1 = OK ((pos, bf, ty) :: l) ->\n(fix init (ms0 : members) (pos2 : Z) {struct ms0} : res state :=\n   match ms0 with\n   | nil => Error (msg \"too many elements in struct initializer\")\n   | m0 :: ms' =>\n       if member_not_initialized m0\n       then init ms' (next_field ge pos2 m0)\n       else\n        do (delta, layout)<- layout_field ge pos2 m0;\n        do s1 <-\n        match layout with\n        | Full => transl_init_rec ge s (type_member m0) i1 (ofs + delta)\n        | Bits sz _ p w =>\n            transl_init_bitfield ge s (type_member m0) sz p w i1\n              (ofs + delta)\n        end; transl_init_struct ge s1 ms' il ofs (next_field ge pos2 m0)\n   end) ms pos1 = OK s' -> match_state s' m'' b) : forall pos1 : Z,\n(do ofs_bf <- layout_field ge pos1 m1;\n do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l) ->\n(do (delta, layout)<- layout_field ge pos1 m1;\n do s1 <-\n match layout with\n | Full => transl_init_rec ge s (type_member m1) i1 (ofs + delta)\n | Bits sz _ p w =>\n     transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + delta)\n end; transl_init_struct ge s1 ms il ofs (next_field ge pos1 m1)) = \nOK s' -> match_state s' m'' b.","proofString":"clear IHms.\nintros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos1 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos1 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos1 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) : forall pos1 : Z,\n(do ofs_bf <- layout_field ge pos1 m1;\n do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l) ->\n(do (delta, layout)<- layout_field ge pos1 m1;\n do s1 <-\n match layout with\n | Full => transl_init_rec ge s (type_member m1) i1 (ofs + delta)\n | Bits sz _ p w =>\n     transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + delta)\n end; transl_init_struct ge s1 ms il ofs (next_field ge pos1 m1)) = \nOK s' -> match_state s' m'' b.","proofString":"intros.\nmonadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos2 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos2 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos2 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (pos1 : Z) (H4 : (do ofs_bf <- layout_field ge pos1 m1;\n do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l)) (H5 : (do (delta, layout)<- layout_field ge pos1 m1;\n do s1 <-\n match layout with\n | Full => transl_init_rec ge s (type_member m1) i1 (ofs + delta)\n | Bits sz _ p w =>\n     transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + delta)\n end; transl_init_struct ge s1 ms il ofs (next_field ge pos1 m1)) = \nOK s') : match_state s' m'' b.","proofString":"monadInv H5.\nrewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos2 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos2 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos2 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (pos1 : Z) (H4 : (do ofs_bf <- layout_field ge pos1 m1;\n do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l)) (x : Z) (x0 : bitfield) (EQ : layout_field ge pos1 m1 = OK (x, x0)) (x1 : state) (EQ1 : match x0 with\n| Full => transl_init_rec ge s (type_member m1) i1 (ofs + x)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + x)\nend = OK x1) (EQ2 : transl_init_struct ge x1 ms il ofs (next_field ge pos1 m1) = OK s') : match_state s' m'' b.","proofString":"rewrite EQ in H4.\nmonadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (ty : type) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (H : exec_init m b (ofs + pos) bf ty i1 m') (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 ty i1 (ofs + pos)\n| Bits sz _ p w => transl_init_bitfield ge s0 ty sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos2 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos2 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos2 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (m1 : member) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (pos1 x : Z) (x0 : bitfield) (H4 : (do ofs_bf <- OK (x, x0);\n do l0 <- initialized_fields_of_struct ms (next_field ge pos1 m1);\n OK ((ofs_bf, type_member m1) :: l0)) = OK ((pos, bf, ty) :: l)) (EQ : layout_field ge pos1 m1 = OK (x, x0)) (x1 : state) (EQ1 : match x0 with\n| Full => transl_init_rec ge s (type_member m1) i1 (ofs + x)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + x)\nend = OK x1) (EQ2 : transl_init_struct ge x1 ms il ofs (next_field ge pos1 m1) = OK s') : match_state s' m'' b.","proofString":"monadInv H4.\ninv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (m1 : member) (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 (type_member m1) i1 (ofs + pos)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s0 (type_member m1) sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H : exec_init m b (ofs + pos) bf (type_member m1) i1 m') (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos2 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos2 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos2 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (pos1 x : Z) (x0 : bitfield) (EQ : layout_field ge pos1 m1 = OK (x, x0)) (x1 : state) (EQ1 : match x0 with\n| Full => transl_init_rec ge s (type_member m1) i1 (ofs + x)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + x)\nend = OK x1) (EQ2 : transl_init_struct ge x1 ms il ofs (next_field ge pos1 m1) = OK s') (EQ0 : OK (x, x0) = OK (pos, bf)) (EQ4 : initialized_fields_of_struct ms (next_field ge pos1 m1) = OK l) : match_state s' m'' b.","proofString":"inv EQ0.\neauto."},{"statement":"(m : mem) (b : block) (ofs pos : Z) (bf : bitfield) (l : list (Z * bitfield * type)) (i1 : initializer) (il : initializer_list) (m' m'' : mem) (m1 : member) (H0 : forall s0 s'0 : state,\nmatch_state s0 m b ->\nmatch bf with\n| Full => transl_init_rec ge s0 (type_member m1) i1 (ofs + pos)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s0 (type_member m1) sz p w i1 (ofs + pos)\nend = OK s'0 -> match_state s'0 m' b) (H : exec_init m b (ofs + pos) bf (type_member m1) i1 m') (H1 : exec_init_struct m' b ofs l il m'') (H2 : forall (s0 s'0 : state) (ms0 : members) (pos2 : Z),\nmatch_state s0 m' b ->\ninitialized_fields_of_struct ms0 pos2 = OK l ->\ntransl_init_struct ge s0 ms0 il ofs pos2 = OK s'0 -> match_state s'0 m'' b) (s s' : state) (ms : list member) (pos0 : Z) (H3 : match_state s m b) (pos1 : Z) (EQ : layout_field ge pos1 m1 = OK (pos, bf)) (x1 : state) (EQ1 : match bf with\n| Full => transl_init_rec ge s (type_member m1) i1 (ofs + pos)\n| Bits sz _ p w =>\n    transl_init_bitfield ge s (type_member m1) sz p w i1 (ofs + pos)\nend = OK x1) (EQ2 : transl_init_struct ge x1 ms il ofs (next_field ge pos1 m1) = OK s') (EQ4 : initialized_fields_of_struct ms (next_field ge pos1 m1) = OK l) : match_state s' m'' b.","proofString":"eauto."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) : sz >= 0 -> 0 <= 0 <= sz.","proofString":"lia."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) : Mem.loadbytes m b 0 0 = Some nil.","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) : 0 <= 0.","proofString":"lia."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) : True.","proofString":"auto."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) : reads_as_zeros m b 0 sz.","proofString":"assumption."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) (H2 : match_state ge s0 m b) : match_state ge x m1 b.","proofString":"eapply (proj1 (transl_init_rec_sound ge)); eauto."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) (H2 : match_state ge s0 m b) (H3 : match_state ge x m1 b) : total_size x = total_size s0.","proofString":"eapply total_size_transl_init_rec; eauto."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) (H2 : match_state ge s0 m b) (H3 : match_state ge x m1 b) (H4 : total_size x = sz) : exists m2 : mem,\n  Genv.store_init_data_list ge m b 0 data = Some m2 /\\\n  Mem.loadbytes m2 b 0 (init_data_list_size data) = Mem.loadbytes m1 b 0 sz.","proofString":"rewrite <- H4.\neapply init_data_list_of_state_correct; eauto; rewrite H4; auto."},{"statement":"(p : Ctypes.program function) (m : mem) (b : block) (ty : type) (i : initializer) (m1 : mem) (data : list init_data) (ge : genv) (sz : Z) (H : Mem.range_perm m b 0 sz Cur Writable) (H0 : reads_as_zeros m b 0 sz) (H1 : exec_init ge m b 0 Full ty i m1) (x : state) (s0 : state) (EQ : transl_init_rec ge s0 ty i 0 = OK x) (EQ0 : init_data_list_of_state x = OK data) (H2 : match_state ge s0 m b) (H3 : match_state ge x m1 b) (H4 : total_size x = sz) : exists m2 : mem,\n  Genv.store_init_data_list ge m b 0 data = Some m2 /\\\n  Mem.loadbytes m2 b 0 (init_data_list_size data) =\n  Mem.loadbytes m1 b 0 (total_size x).","proofString":"eapply init_data_list_of_state_correct; eauto; rewrite H4; auto."}]}