{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/MenhirLib/Interpreter_complete.v","fileSamples":[{"statement":"(t : TerminalSet.elt) (word2 : list symbol) : TerminalSet.In t (first_word_set word2) <->\nTerminalSet.In t TerminalSet.empty \\/\nTerminalSet.In t (first_word_set word2) /\\ true = true.","proofString":"split; [tauto|].\nmove=>[/TerminalSet.empty_1 ?|[? _]]//."},{"statement":"(t : TerminalSet.elt) (word2 : list symbol) : TerminalSet.In t TerminalSet.empty \\/\nTerminalSet.In t (first_word_set word2) /\\ true = true ->\nTerminalSet.In t (first_word_set word2).","proofString":"move=>[/TerminalSet.empty_1 ?|[? _]]//."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (if nullable_symb s\n   then\n    TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))\n   else first_symb_set s) <->\nTerminalSet.In t\n  (if nullable_symb s\n   then TerminalSet.union (first_symb_set s) (first_word_set word1)\n   else first_symb_set s) \\/\nTerminalSet.In t (first_word_set word2) /\\\nnullable_word (rev word1 ++ [s]) = true.","proofString":"rewrite /nullable_word forallb_app /=.\ndestruct nullable_symb=>/=.\nrewrite Bool.andb_true_r.\nsplit.\nmove=>/TerminalSet.union_1.\nrewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3.\ndestruct IH.\nmove=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3.\nrewrite Bool.andb_false_r.\nby intuition."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (if nullable_symb s\n   then\n    TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))\n   else first_symb_set s) <->\nTerminalSet.In t\n  (if nullable_symb s\n   then TerminalSet.union (first_symb_set s) (first_word_set word1)\n   else first_symb_set s) \\/\nTerminalSet.In t (first_word_set word2) /\\\n(forallb nullable_symb (rev word1) && (nullable_symb s && true))%bool = true.","proofString":"destruct nullable_symb=>/=.\nrewrite Bool.andb_true_r.\nsplit.\nmove=>/TerminalSet.union_1.\nrewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3.\ndestruct IH.\nmove=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3.\nrewrite Bool.andb_false_r.\nby intuition."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))) <->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\n(forallb nullable_symb (rev word1) && true)%bool = true.","proofString":"rewrite Bool.andb_true_r.\nsplit.\nmove=>/TerminalSet.union_1.\nrewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3.\ndestruct IH.\nmove=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))) <->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true.","proofString":"split.\nmove=>/TerminalSet.union_1.\nrewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3.\ndestruct IH.\nmove=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))) ->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true.","proofString":"move=>/TerminalSet.union_1.\nrewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t (first_symb_set s) \\/\nTerminalSet.In t (first_word_set (word1 ++ word2)) ->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true.","proofString":"rewrite IH.\nmove=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t (first_symb_set s) \\/\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true ->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true.","proofString":"move=>[?|[?|[??]]]; auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true ->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))).","proofString":"destruct IH.\nmove=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (H : TerminalSet.In t (first_word_set (word1 ++ word2)) ->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) (H0 : TerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true ->\nTerminalSet.In t (first_word_set (word1 ++ word2))) : TerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set word1)) \\/\nTerminalSet.In t (first_word_set word2) /\\\nforallb nullable_symb (rev word1) = true ->\nTerminalSet.In t\n  (TerminalSet.union (first_symb_set s) (first_word_set (word1 ++ word2))).","proofString":"move=>[/TerminalSet.union_1 [?|?]|[??]];        auto using TerminalSet.union_2, TerminalSet.union_3."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t (first_symb_set s) <->\nTerminalSet.In t (first_symb_set s) \\/\nTerminalSet.In t (first_word_set word2) /\\\n(forallb nullable_symb (rev word1) && false)%bool = true.","proofString":"rewrite Bool.andb_false_r.\nby intuition."},{"statement":"(t : TerminalSet.elt) (s : symbol) (word1 word2 : list symbol) (IH : TerminalSet.In t (first_word_set (word1 ++ word2)) <->\nTerminalSet.In t (first_word_set word1) \\/\nTerminalSet.In t (first_word_set word2) /\\ nullable_word (rev word1) = true) : TerminalSet.In t (first_symb_set s) <->\nTerminalSet.In t (first_symb_set s) \\/\nTerminalSet.In t (first_word_set word2) /\\ false = true.","proofString":"by intuition."},{"statement":"(A : Type) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (stk0 : stack) (action : arrows_right A (map symbol_semantic_type symbs)) : forall stk : stack,\nptl_stack_compat stk0 ptl stk ->\npop_spec symbs stk action stk0 (ptl_sem ptl action).","proofString":"induction ptl=>stk /= Hstk.\nsubst.\nconstructor.\ndestruct stk as [|[st sem] stk]=>//.\ndestruct Hstk as [Hstk [??]].\nsubst.\nsimpl.\nconstructor.\neauto."},{"statement":"(A : Type) (stk0 : stack) (action : arrows_right A (map symbol_semantic_type [])) (stk : stack) (Hstk : stk0 = stk) : pop_spec [] stk action stk0 action.","proofString":"subst.\nconstructor."},{"statement":"(A : Type) (action : arrows_right A (map symbol_semantic_type [])) (stk : stack) : pop_spec [] stk action stk action.","proofString":"constructor."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (stk0 : stack) (action : arrows_right A (map symbol_semantic_type (head_symbolt :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (stk : stack) (Hstk : match stk with\n| [] => False\n| existT _ x sem :: stk1 =>\n    ptl_stack_compat stk0 ptl stk1 /\\\n    (exists e : head_symbolt = last_symb_of_non_init_state x,\n       sem =\n       eq_rect head_symbolt symbol_semantic_type (pt_sem p)\n         (last_symb_of_non_init_state x) e)\nend) : pop_spec (head_symbolt :: head_symbolsq) stk action stk0\n  (ptl_sem ptl (action (pt_sem p))).","proofString":"destruct stk as [|[st sem] stk]=>//.\ndestruct Hstk as [Hstk [??]].\nsubst.\nsimpl.\nconstructor.\neauto."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (stk0 : stack) (action : arrows_right A (map symbol_semantic_type (head_symbolt :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hstk : ptl_stack_compat stk0 ptl stk /\\\n(exists e : head_symbolt = last_symb_of_non_init_state st,\n   sem =\n   eq_rect head_symbolt symbol_semantic_type (pt_sem p)\n     (last_symb_of_non_init_state st) e)) : pop_spec (head_symbolt :: head_symbolsq)\n  (existT noninitstate_type st sem :: stk) action stk0\n  (ptl_sem ptl (action (pt_sem p))).","proofString":"destruct Hstk as [Hstk [??]].\nsubst.\nsimpl.\nconstructor.\neauto."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (stk0 : stack) (action : arrows_right A (map symbol_semantic_type (head_symbolt :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hstk : ptl_stack_compat stk0 ptl stk) (x : head_symbolt = last_symb_of_non_init_state st) (H : sem =\neq_rect head_symbolt symbol_semantic_type (pt_sem p)\n  (last_symb_of_non_init_state st) x) : pop_spec (head_symbolt :: head_symbolsq)\n  (existT noninitstate_type st sem :: stk) action stk0\n  (ptl_sem ptl (action (pt_sem p))).","proofString":"subst.\nsimpl.\nconstructor.\neauto."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (p : parse_tree (last_symb_of_non_init_state st) wordt) (stk0 : stack) (action : arrows_right A\n  (map symbol_semantic_type (last_symb_of_non_init_state st :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (stk : list {x : noninitstate & noninitstate_type x}) (Hstk : ptl_stack_compat stk0 ptl stk) : pop_spec (last_symb_of_non_init_state st :: head_symbolsq)\n  (existT noninitstate_type st\n     (eq_rect (last_symb_of_non_init_state st) symbol_semantic_type\n        (pt_sem p) (last_symb_of_non_init_state st) eq_refl) :: stk) action\n  stk0 (ptl_sem ptl (action (pt_sem p))).","proofString":"simpl.\nconstructor.\neauto."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (p : parse_tree (last_symb_of_non_init_state st) wordt) (stk0 : stack) (action : arrows_right A\n  (map symbol_semantic_type (last_symb_of_non_init_state st :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (stk : list {x : noninitstate & noninitstate_type x}) (Hstk : ptl_stack_compat stk0 ptl stk) : pop_spec (last_symb_of_non_init_state st :: head_symbolsq)\n  (existT noninitstate_type st (pt_sem p) :: stk) action stk0\n  (ptl_sem ptl (action (pt_sem p))).","proofString":"constructor.\neauto."},{"statement":"(A : Type) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (p : parse_tree (last_symb_of_non_init_state st) wordt) (stk0 : stack) (action : arrows_right A\n  (map symbol_semantic_type (last_symb_of_non_init_state st :: head_symbolsq))) (IHptl : forall (action0 : arrows_right A (map symbol_semantic_type head_symbolsq))\n  (stk1 : stack),\nptl_stack_compat stk0 ptl stk1 ->\npop_spec head_symbolsq stk1 action0 stk0 (ptl_sem ptl action0)) (stk : list {x : noninitstate & noninitstate_type x}) (Hstk : ptl_stack_compat stk0 ptl stk) : pop_spec head_symbolsq stk (action (pt_sem p)) stk0\n  (ptl_sem ptl (action (pt_sem p))).","proofString":"eauto."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (head_symbolt : symbol) (pt : parse_tree head_symbolt []) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ [])) (IH : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (first_word_set (ptlz_future ptlz)) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\nnullable_word (ptlz_future ptlz) = true) : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (if nullable_symb head_symbolt\n   then\n    TerminalSet.union (first_symb_set head_symbolt)\n      (first_word_set (ptlz_future ptlz))\n   else first_symb_set head_symbolt) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\n(nullable_symb head_symbolt && nullable_word (ptlz_future ptlz))%bool = true.","proofString":"rewrite (nullable_correct _ _ eq_refl pt).\ndestruct IH as [|[??]]; [left|right]=>/=; auto using TerminalSet.union_3."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (head_symbolt : symbol) (pt : parse_tree head_symbolt []) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ [])) (IH : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (first_word_set (ptlz_future ptlz)) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\nnullable_word (ptlz_future ptlz) = true) : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (TerminalSet.union (first_symb_set head_symbolt)\n     (first_word_set (ptlz_future ptlz))) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\n(true && nullable_word (ptlz_future ptlz))%bool = true.","proofString":"destruct IH as [|[??]]; [left|right]=>/=; auto using TerminalSet.union_3."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (head_symbolt : symbol) (tok : token) (l : list token) (pt : parse_tree head_symbolt (tok :: l)) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ tok :: l)) (IH : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (first_word_set (ptlz_future ptlz)) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\nnullable_word (ptlz_future ptlz) = true) : TerminalSet.In (token_term tok)\n  (if nullable_symb head_symbolt\n   then\n    TerminalSet.union (first_symb_set head_symbolt)\n      (first_word_set (ptlz_future ptlz))\n   else first_symb_set head_symbolt) \\/\ntoken_term tok = ptlz_lookahead ptlz /\\\n(nullable_symb head_symbolt && nullable_word (ptlz_future ptlz))%bool = true.","proofString":"left.\ndestruct nullable_symb; eauto using TerminalSet.union_2, first_correct."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (head_symbolt : symbol) (tok : token) (l : list token) (pt : parse_tree head_symbolt (tok :: l)) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ tok :: l)) (IH : TerminalSet.In (token_term (buf_head (ptlz_buffer ptlz)))\n  (first_word_set (ptlz_future ptlz)) \\/\ntoken_term (buf_head (ptlz_buffer ptlz)) = ptlz_lookahead ptlz /\\\nnullable_word (ptlz_future ptlz) = true) : TerminalSet.In (token_term tok)\n  (if nullable_symb head_symbolt\n   then\n    TerminalSet.union (first_symb_set head_symbolt)\n      (first_word_set (ptlz_future ptlz))\n   else first_symb_set head_symbolt).","proofString":"destruct nullable_symb; eauto using TerminalSet.union_2, first_correct."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) : ptlz_sem ptlz\n  (fun (A : Type)\n     (f : symbol_semantic_type head_symbolt ->\n          arrows_right A (map symbol_semantic_type head_symbolsq)) =>\n   ptl_sem ptl (f (pt_sem p))) =\nptd_sem (build_pt_dot_from_pt p (Cons_ptl_ptz ptl ptlz)).","proofString":"by rewrite -sem_build_from_pt."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' => ptz_sem ptz (ptl_sem ptl (prod_action prod)) = ptd_sem ptd'\n| None => True\nend.","proofString":"change (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -sem_build_from_ptl."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' => ptz_sem ptz (pt_sem (Non_terminal_pt prod ptl)) = ptd_sem ptd'\n| None => True\nend.","proofString":"generalize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -sem_build_from_ptl."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd' => ptz_sem ptz (pt_sem p) = ptd_sem ptd'\n| None => True\nend.","proofString":"clear ptl.\ndestruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -sem_build_from_ptl."},{"statement":"(prod : production) (word : list token) (ptz : pt_zipper (NT (prod_lhs prod)) word) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd' => ptz_sem ptz (pt_sem p) = ptd_sem ptd'\n| None => True\nend.","proofString":"destruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -sem_build_from_ptl."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) (pt : parse_tree head_symbolt wordt) : ptz_sem (Cons_ptl_ptz ptl ptlz) (pt_sem pt) =\nptd_sem (build_pt_dot_from_ptl (Cons_ptl ptl pt) ptlz).","proofString":"by rewrite -sem_build_from_ptl."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) : ptlz_sem ptlz\n  (fun (A : Type)\n     (f : symbol_semantic_type (T (token_term tok)) ->\n          arrows_right A (map symbol_semantic_type symbs)) =>\n   ptl_sem ptl (f (token_sem tok))) =\nptd_sem (build_pt_dot_from_ptl (Cons_ptl ptl (Terminal_pt tok)) ptlz).","proofString":"by rewrite -sem_build_from_ptl."},{"statement":"(log_n_steps : nat) : forall ptd : pt_dot,\nmatch next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend.","proofString":"induction log_n_steps as [|log_n_steps IH]; [by apply sem_next_ptd|]=>/= ptd.\nassert (IH1 := IH ptd).\ndestruct next_ptd_iter as [ptd'|]=>//.\nspecialize (IH ptd').\ndestruct next_ptd_iter=>//.\ncongruence."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_sem ptd0 = ptd_sem ptd'\n| None => True\nend) (ptd : pt_dot) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend.","proofString":"assert (IH1 := IH ptd).\ndestruct next_ptd_iter as [ptd'|]=>//.\nspecialize (IH ptd').\ndestruct next_ptd_iter=>//.\ncongruence."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_sem ptd0 = ptd_sem ptd'\n| None => True\nend) (ptd : pt_dot) (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend.","proofString":"destruct next_ptd_iter as [ptd'|]=>//.\nspecialize (IH ptd').\ndestruct next_ptd_iter=>//.\ncongruence."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd'0 => ptd_sem ptd0 = ptd_sem ptd'0\n| None => True\nend) (ptd ptd' : pt_dot) (IH1 : ptd_sem ptd = ptd_sem ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 => ptd_sem ptd = ptd_sem ptd'0\n| None => True\nend.","proofString":"specialize (IH ptd').\ndestruct next_ptd_iter=>//.\ncongruence."},{"statement":"(log_n_steps : nat) (ptd' : pt_dot) (IH : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 => ptd_sem ptd' = ptd_sem ptd'0\n| None => True\nend) (ptd : pt_dot) (IH1 : ptd_sem ptd = ptd_sem ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 => ptd_sem ptd = ptd_sem ptd'0\n| None => True\nend.","proofString":"destruct next_ptd_iter=>//.\ncongruence."},{"statement":"(log_n_steps : nat) (ptd' p : pt_dot) (IH : ptd_sem ptd' = ptd_sem p) (ptd : pt_dot) (IH1 : ptd_sem ptd = ptd_sem ptd') : ptd_sem ptd = ptd_sem p.","proofString":"congruence."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (pt : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) : (wordt ++ ptlz_buffer ptlz)%buf =\nptd_buffer (build_pt_dot_from_pt pt (Cons_ptl_ptz ptl ptlz)).","proofString":"by rewrite -ptd_buffer_build_from_pt."},{"statement":"(symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper symbs word) (stk stk0 : stack) (Hstk0 : ptlz_stack_compat stk0 ptlz) (Hstk : ptl_stack_compat stk0 ptl stk) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod ptlz)\n  (ptlz_future ptlz) (ptlz_lookahead ptlz)) : ptd_stack_compat (build_pt_dot_from_ptl ptl ptlz) stk.","proofString":"destruct ptlz=>/=.\neauto.\napply ptd_stack_compat_build_from_pt=>/=.\neauto."},{"statement":"(p : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev p) word) (p0 : pt_zipper (NT (prod_lhs p)) word) (stk stk0 : stack) (Hstk0 : ptlz_stack_compat stk0 (Non_terminal_pt_ptlz p0)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hfut : state_has_future (state_of_stack init stk)\n  (ptlz_prod (Non_terminal_pt_ptlz p0))\n  (ptlz_future (Non_terminal_pt_ptlz p0))\n  (ptlz_lookahead (Non_terminal_pt_ptlz p0))) : exists stk1 : stack,\n  state_has_future (state_of_stack init stk) p []\n    (token_term (buf_head (ptz_buffer p0))) /\\\n  ptl_stack_compat stk1 ptl stk /\\ ptz_stack_compat stk1 p0.","proofString":"eauto."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) (stk stk0 : stack) (Hstk0 : ptlz_stack_compat stk0 (Cons_ptl_ptlz p ptlz)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod (Cons_ptl_ptlz p ptlz))\n  (ptlz_future (Cons_ptl_ptlz p ptlz))\n  (ptlz_lookahead (Cons_ptl_ptlz p ptlz))) : ptd_stack_compat (build_pt_dot_from_pt p (Cons_ptl_ptz ptl ptlz)) stk.","proofString":"apply ptd_stack_compat_build_from_pt=>/=.\neauto."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) (stk stk0 : stack) (Hstk0 : ptlz_stack_compat stk0 (Cons_ptl_ptlz p ptlz)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod (Cons_ptl_ptlz p ptlz))\n  (ptlz_future (Cons_ptl_ptlz p ptlz))\n  (ptlz_lookahead (Cons_ptl_ptlz p ptlz))) : exists stk1 : stack,\n  state_has_future (state_of_stack init stk) (ptlz_prod ptlz)\n    (head_symbolt :: ptlz_future ptlz) (ptlz_lookahead ptlz) /\\\n  ptl_stack_compat stk1 ptl stk /\\ ptlz_stack_compat stk1 ptlz.","proofString":"eauto."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptz_stack_compat stk0 ptz) : match next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"apply pop_stack_compat_pop_spec with (action := prod_action prod) in Hstk.\nrewrite <-pop_spec_ok with (Hp := reduce_step_subproof init stk prod Hval Hi) in Hstk.\nunfold reduce_step.\nmatch goal with  | |- context [pop_state_valid init ?A stk ?B ?C ?D ?E ?F] =>    generalize (pop_state_valid init A stk B C D E F)  end.\nrewrite Hstk /=.\nintros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop_spec (prod_rhs_rev prod) stk (prod_action prod) stk0\n  (ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) : match next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"rewrite <-pop_spec_ok with (Hp := reduce_step_subproof init stk prod Hval Hi) in Hstk.\nunfold reduce_step.\nmatch goal with  | |- context [pop_state_valid init ?A stk ?B ?C ?D ?E ?F] =>    generalize (pop_state_valid init A stk B C D E F)  end.\nrewrite Hstk /=.\nintros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) : match next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) Hval Hi =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"unfold reduce_step.\nmatch goal with  | |- context [pop_state_valid init ?A stk ?B ?C ?D ?E ?F] =>    generalize (pop_state_valid init A stk B C D E F)  end.\nrewrite Hstk /=.\nintros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) : match next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd =>\n    exists stk' : stack,\n      (let\n       '(stk'0, sem) as ss :=\n        pop (prod_rhs_rev prod) stk\n          (reduce_step_subproof init stk prod Hval Hi) \n          (prod_action prod)\n        return\n          (thunkP\n             (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n                (prod_rhs_rev prod)\n                (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n           step_result init) in\n        fun\n          Hval' : thunkP\n                    (ValidSafe.state_valid_after_pop\n                       (state_of_stack init (fst (stk'0, sem)))\n                       (prod_rhs_rev prod)\n                       (ValidSafe.head_states_of_state\n                          (state_of_stack init stk))) =>\n        match\n          goto_table (state_of_stack init stk'0) (prod_lhs prod) as goto\n          return\n            (thunkP\n               (goto = None ->\n                match state_of_stack init stk'0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) -> step_result init)\n        with\n        | Some s =>\n            let\n              (state_new, e) as s0\n               return\n                 (thunkP\n                    (Some s0 = None ->\n                     match state_of_stack init stk'0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) -> step_result init) := s in\n            fun\n              _ : thunkP\n                    (Some\n                       (exist\n                          (fun s0 : noninitstate =>\n                           NT (prod_lhs prod) =\n                           last_symb_of_non_init_state s0) state_new e) =\n                     None ->\n                     match state_of_stack init stk'0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                    (last_symb_of_non_init_state state_new) e) :: stk'0)\n              (ptz_buffer ptz)\n        | None =>\n            fun\n              Hval0 : thunkP\n                        (None = None ->\n                         match state_of_stack init stk'0 with\n                         | Init i => prod_lhs prod = start_nt i\n                         | Ninit _ => False\n                         end) =>\n            Accept_sr\n              (cast symbol_semantic_type\n                 (reduce_step_subproof0 init prod stk'0 Hval0) sem)\n              (ptz_buffer ptz)\n        end\n          (fun _ : True =>\n           reduce_step_subproof1 init stk prod Hval stk'0 Hval'))\n        (fun _ : True =>\n         pop_state_valid init (prod_rhs_rev prod) stk\n           (reduce_step_subproof init stk prod Hval Hi)\n           (symbol_semantic_type (NT (prod_lhs prod))) \n           (prod_action prod)\n           (ValidSafe.head_states_of_state (state_of_stack init stk))\n           (reduce_step_subproof2 init stk Hi)) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    (let\n     '(stk', sem) as ss :=\n      pop (prod_rhs_rev prod) stk\n        (reduce_step_subproof init stk prod Hval Hi) \n        (prod_action prod)\n      return\n        (thunkP\n           (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n              (prod_rhs_rev prod)\n              (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n         step_result init) in\n      fun\n        Hval' : thunkP\n                  (ValidSafe.state_valid_after_pop\n                     (state_of_stack init (fst (stk', sem)))\n                     (prod_rhs_rev prod)\n                     (ValidSafe.head_states_of_state\n                        (state_of_stack init stk))) =>\n      match\n        goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk' with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk' with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk' with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                  (last_symb_of_non_init_state state_new) e) :: stk')\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval0 : thunkP\n                      (None = None ->\n                       match state_of_stack init stk' with\n                       | Init i => prod_lhs prod = start_nt i\n                       | Ninit _ => False\n                       end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk' Hval0) sem)\n            (ptz_buffer ptz)\n      end\n        (fun _ : True => reduce_step_subproof1 init stk prod Hval stk' Hval'))\n      (fun _ : True =>\n       pop_state_valid init (prod_rhs_rev prod) stk\n         (reduce_step_subproof init stk prod Hval Hi)\n         (symbol_semantic_type (NT (prod_lhs prod))) \n         (prod_action prod)\n         (ValidSafe.head_states_of_state (state_of_stack init stk))\n         (reduce_step_subproof2 init stk Hi)) =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"match goal with  | |- context [pop_state_valid init ?A stk ?B ?C ?D ?E ?F] =>    generalize (pop_state_valid init A stk B C D E F)  end.\nrewrite Hstk /=.\nintros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) : forall\n  s : let stk' :=\n        fst\n          (pop (prod_rhs_rev prod) stk\n             (reduce_step_subproof init stk prod Hval Hi) \n             (prod_action prod)) in\n      ValidSafe.state_valid_after_pop (state_of_stack init stk')\n        (prod_rhs_rev prod)\n        (ValidSafe.head_states_of_state (state_of_stack init stk)),\nmatch next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd =>\n    exists stk' : stack,\n      (let\n       '(stk'0, sem) as ss :=\n        pop (prod_rhs_rev prod) stk\n          (reduce_step_subproof init stk prod Hval Hi) \n          (prod_action prod)\n        return\n          (thunkP\n             (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n                (prod_rhs_rev prod)\n                (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n           step_result init) in\n        fun\n          Hval' : thunkP\n                    (ValidSafe.state_valid_after_pop\n                       (state_of_stack init (fst (stk'0, sem)))\n                       (prod_rhs_rev prod)\n                       (ValidSafe.head_states_of_state\n                          (state_of_stack init stk))) =>\n        match\n          goto_table (state_of_stack init stk'0) (prod_lhs prod) as goto\n          return\n            (thunkP\n               (goto = None ->\n                match state_of_stack init stk'0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) -> step_result init)\n        with\n        | Some s0 =>\n            let\n              (state_new, e) as s1\n               return\n                 (thunkP\n                    (Some s1 = None ->\n                     match state_of_stack init stk'0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) -> step_result init) := s0 in\n            fun\n              _ : thunkP\n                    (Some\n                       (exist\n                          (fun s1 : noninitstate =>\n                           NT (prod_lhs prod) =\n                           last_symb_of_non_init_state s1) state_new e) =\n                     None ->\n                     match state_of_stack init stk'0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                    (last_symb_of_non_init_state state_new) e) :: stk'0)\n              (ptz_buffer ptz)\n        | None =>\n            fun\n              Hval0 : thunkP\n                        (None = None ->\n                         match state_of_stack init stk'0 with\n                         | Init i => prod_lhs prod = start_nt i\n                         | Ninit _ => False\n                         end) =>\n            Accept_sr\n              (cast symbol_semantic_type\n                 (reduce_step_subproof0 init prod stk'0 Hval0) sem)\n              (ptz_buffer ptz)\n        end\n          (fun _ : True =>\n           reduce_step_subproof1 init stk prod Hval stk'0 Hval'))\n        (fun _ : True => s) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    (let\n     '(stk', sem) as ss :=\n      pop (prod_rhs_rev prod) stk\n        (reduce_step_subproof init stk prod Hval Hi) \n        (prod_action prod)\n      return\n        (thunkP\n           (ValidSafe.state_valid_after_pop (state_of_stack init (fst ss))\n              (prod_rhs_rev prod)\n              (ValidSafe.head_states_of_state (state_of_stack init stk))) ->\n         step_result init) in\n      fun\n        Hval' : thunkP\n                  (ValidSafe.state_valid_after_pop\n                     (state_of_stack init (fst (stk', sem)))\n                     (prod_rhs_rev prod)\n                     (ValidSafe.head_states_of_state\n                        (state_of_stack init stk))) =>\n      match\n        goto_table (state_of_stack init stk') (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk' with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s0 =>\n          let\n            (state_new, e) as s1\n             return\n               (thunkP\n                  (Some s1 = None ->\n                   match state_of_stack init stk' with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s0 in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s1 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                        state_new e) = None ->\n                   match state_of_stack init stk' with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n                  (last_symb_of_non_init_state state_new) e) :: stk')\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval0 : thunkP\n                      (None = None ->\n                       match state_of_stack init stk' with\n                       | Init i => prod_lhs prod = start_nt i\n                       | Ninit _ => False\n                       end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk' Hval0) sem)\n            (ptz_buffer ptz)\n      end\n        (fun _ : True => reduce_step_subproof1 init stk prod Hval stk' Hval'))\n      (fun _ : True => s) =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"rewrite Hstk /=.\nintros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) : forall\n  s : ValidSafe.state_valid_after_pop (state_of_stack init stk0)\n        (prod_rhs_rev prod)\n        (ValidSafe.head_states_of_state (state_of_stack init stk)),\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s0 =>\n          let\n            (state_new, e) as s1\n             return\n               (thunkP\n                  (Some s1 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s0 in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s1 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval0 : thunkP\n                      (None = None ->\n                       match state_of_stack init stk0 with\n                       | Init i => prod_lhs prod = start_nt i\n                       | Ninit _ => False\n                       end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval0)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end\n        (fun _ : True =>\n         reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => s)) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s0 =>\n        let\n          (state_new, e) as s1\n           return\n             (thunkP\n                (Some s1 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s0 in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s1 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval0 : thunkP\n                    (None = None ->\n                     match state_of_stack init stk0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval0)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end\n      (fun _ : True =>\n       reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => s)) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"intros Hv.\ngeneralize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) (Hv : ValidSafe.state_valid_after_pop (state_of_stack init stk0)\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval0 : thunkP\n                      (None = None ->\n                       match state_of_stack init stk0 with\n                       | Init i => prod_lhs prod = start_nt i\n                       | Ninit _ => False\n                       end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval0)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end\n        (fun _ : True =>\n         reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval0 : thunkP\n                    (None = None ->\n                     match state_of_stack init stk0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval0)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end\n      (fun _ : True =>\n       reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"generalize (reduce_step_subproof1 init stk prod Hval stk0 (fun _ : True => Hv)).\nclear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hval : thunkP (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : pop (prod_rhs_rev prod) stk (reduce_step_subproof init stk prod Hval Hi)\n  (prod_action prod) = (stk0, ptl_sem ptl (prod_action prod))) (Hstk0 : ptz_stack_compat stk0 ptz) (Hv : ValidSafe.state_valid_after_pop (state_of_stack init stk0)\n  (prod_rhs_rev prod)\n  (ValidSafe.head_states_of_state (state_of_stack init stk))) : forall\n  y : goto_table (state_of_stack init stk0) (prod_lhs prod) = None ->\n      match state_of_stack init stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval0 : thunkP\n                      (None = None ->\n                       match state_of_stack init stk0 with\n                       | Init i => prod_lhs prod = start_nt i\n                       | Ninit _ => False\n                       end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval0)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval0 : thunkP\n                    (None = None ->\n                     match state_of_stack init stk0 with\n                     | Init i => prod_lhs prod = start_nt i\n                     | Ninit _ => False\n                     end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval0)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end (fun _ : True => y) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"clear Hval Hstk Hi Hv stk.\nassert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) : forall\n  y : goto_table (state_of_stack init stk0) (prod_lhs prod) = None ->\n      match state_of_stack init stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval : thunkP\n                     (None = None ->\n                      match state_of_stack init stk0 with\n                      | Init i => prod_lhs prod = start_nt i\n                      | Ninit _ => False\n                      end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval : thunkP\n                   (None = None ->\n                    match state_of_stack init stk0 with\n                    | Init i => prod_lhs prod = start_nt i\n                    | Ninit _ => False\n                    end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end (fun _ : True => y) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"assert (Hgoto := fun fut prod' =>    non_terminal_goto (state_of_stack init stk0) prod' (NT (prod_lhs prod)::fut)).\nsimpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nmatch NT (prod_lhs prod) :: fut with\n| NT nt :: q =>\n    match goto_table (state_of_stack init stk0) nt with\n    | Some (exist _ s2 _) => state_has_future s2 prod' q lookahead\n    | None => False\n    end\n| _ => True\nend) : forall\n  y : goto_table (state_of_stack init stk0) (prod_lhs prod) = None ->\n      match state_of_stack init stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval : thunkP\n                     (None = None ->\n                      match state_of_stack init stk0 with\n                      | Init i => prod_lhs prod = start_nt i\n                      | Ninit _ => False\n                      end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval : thunkP\n                   (None = None ->\n                    match state_of_stack init stk0 with\n                    | Init i => prod_lhs prod = start_nt i\n                    | Ninit _ => False\n                    end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end (fun _ : True => y) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"simpl in Hgoto.\ndestruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nmatch goto_table (state_of_stack init stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) => state_has_future s2 prod' fut lookahead\n| None => False\nend) : forall\n  y : goto_table (state_of_stack init stk0) (prod_lhs prod) = None ->\n      match state_of_stack init stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      match\n        goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n        return\n          (thunkP\n             (goto = None ->\n              match state_of_stack init stk0 with\n              | Init i => prod_lhs prod = start_nt i\n              | Ninit _ => False\n              end) -> step_result init)\n      with\n      | Some s =>\n          let\n            (state_new, e) as s0\n             return\n               (thunkP\n                  (Some s0 = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) -> step_result init) := s in\n          fun\n            _ : thunkP\n                  (Some\n                     (exist\n                        (fun s0 : noninitstate =>\n                         NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                        state_new e) = None ->\n                   match state_of_stack init stk0 with\n                   | Init i => prod_lhs prod = start_nt i\n                   | Ninit _ => False\n                   end) =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                  (ptl_sem ptl (prod_action prod))\n                  (last_symb_of_non_init_state state_new) e) :: stk0)\n            (ptz_buffer ptz)\n      | None =>\n          fun\n            Hval : thunkP\n                     (None = None ->\n                      match state_of_stack init stk0 with\n                      | Init i => prod_lhs prod = start_nt i\n                      | Ninit _ => False\n                      end) =>\n          Accept_sr\n            (cast symbol_semantic_type\n               (reduce_step_subproof0 init prod stk0 Hval)\n               (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    match\n      goto_table (state_of_stack init stk0) (prod_lhs prod) as goto\n      return\n        (thunkP\n           (goto = None ->\n            match state_of_stack init stk0 with\n            | Init i => prod_lhs prod = start_nt i\n            | Ninit _ => False\n            end) -> step_result init)\n    with\n    | Some s =>\n        let\n          (state_new, e) as s0\n           return\n             (thunkP\n                (Some s0 = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) -> step_result init) := s in\n        fun\n          _ : thunkP\n                (Some\n                   (exist\n                      (fun s0 : noninitstate =>\n                       NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                      state_new e) = None ->\n                 match state_of_stack init stk0 with\n                 | Init i => prod_lhs prod = start_nt i\n                 | Ninit _ => False\n                 end) =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (NT (prod_lhs prod)) symbol_semantic_type\n                (ptl_sem ptl (prod_action prod))\n                (last_symb_of_non_init_state state_new) e) :: stk0)\n          (ptz_buffer ptz)\n    | None =>\n        fun\n          Hval : thunkP\n                   (None = None ->\n                    match state_of_stack init stk0 with\n                    | Init i => prod_lhs prod = start_nt i\n                    | Ninit _ => False\n                    end) =>\n        Accept_sr\n          (cast symbol_semantic_type\n             (reduce_step_subproof0 init prod stk0 Hval)\n             (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz)\n    end (fun _ : True => y) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"destruct goto_table as [[st Hst]|] eqn:Hgoto'.\nintros _.\nassert (match ptz with Top_ptz => False | _ => True end).\nrevert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg.\nclear Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ? ? ptlz]=>// pt.\nsubst=>/=.\neexists _.\nsplit.\nf_equal.\napply ptd_buffer_build_from_ptl.\ndestruct Hstk0 as (stk0' & Hfut & Hstk0' & Hstk0).\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl.\nintros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (st : noninitstate) (Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st) (Hgoto' : goto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) st Hst)) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) : match ptz with\n| Top_ptz => False\n| Cons_ptl_ptz _ _ => True\nend.","proofString":"revert ptz Hst Hstk0 Hgoto'.\ngeneralize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) : forall (ptz : pt_zipper (NT (prod_lhs prod)) word)\n  (Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st),\nptz_stack_compat stk0 ptz ->\ngoto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) st Hst) ->\nmatch ptz with\n| Top_ptz => False\n| Cons_ptl_ptz _ _ => True\nend.","proofString":"generalize (eq_refl (NT (prod_lhs prod))).\ngeneralize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) : NT (prod_lhs prod) = NT (prod_lhs prod) ->\nforall (ptz : pt_zipper (NT (prod_lhs prod)) word)\n  (Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st),\nptz_stack_compat stk0 ptz ->\ngoto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) st Hst) ->\nmatch ptz with\n| Top_ptz => False\n| Cons_ptl_ptz _ _ => True\nend.","proofString":"generalize (NT (prod_lhs prod)) at 1 3 5.\nintros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) : forall s : symbol,\ns = NT (prod_lhs prod) ->\nforall (ptz : pt_zipper s word)\n  (Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st),\nptz_stack_compat stk0 ptz ->\ngoto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s0 : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s0) st Hst) ->\nmatch ptz with\n| Top_ptz => False\n| Cons_ptl_ptz _ _ => True\nend.","proofString":"intros nt Hnt ptz.\ndestruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (nt : symbol) (Hnt : nt = NT (prod_lhs prod)) (ptz : pt_zipper nt word) : forall Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st,\nptz_stack_compat stk0 ptz ->\ngoto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) st Hst) ->\nmatch ptz with\n| Top_ptz => False\n| Cons_ptl_ptz _ _ => True\nend.","proofString":"destruct ptz=>//.\ninjection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (ptl : parse_tree_list (prod_rhs_rev prod) full_word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (Hnt : NT (start_nt init) = NT (prod_lhs prod)) : forall Hst : NT (prod_lhs prod) = last_symb_of_non_init_state st,\nptz_stack_compat stk0 Top_ptz ->\ngoto_table (state_of_stack init stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) st Hst) -> False.","proofString":"injection Hnt=> <- /= Hst -> /= Hg.\nassert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (ptl : parse_tree_list (prod_rhs_rev prod) full_word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (Hnt : NT (start_nt init) = NT (prod_lhs prod)) (Hst : NT (start_nt init) = last_symb_of_non_init_state st) (Hg : goto_table init (start_nt init) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (start_nt init) = last_symb_of_non_init_state s) st Hst)) : False.","proofString":"assert (Hsg := start_goto init).\nby rewrite Hg in Hsg."},{"statement":"(prod : production) (ptl : parse_tree_list (prod_rhs_rev prod) full_word) (stk0 : stack) (st : noninitstate) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (Hnt : NT (start_nt init) = NT (prod_lhs prod)) (Hst : NT (start_nt init) = last_symb_of_non_init_state st) (Hg : goto_table init (start_nt init) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (start_nt init) = last_symb_of_non_init_state s) st Hst)) (Hsg : match goto_table init (start_nt init) with\n| Some _ => False\n| None => True\nend) : False.","proofString":"by rewrite Hg in Hsg."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (ptlz : ptl_zipper (last_symb_of_non_init_state st :: head_symbolsq) (wordq ++ wordt)) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 (Cons_ptl_ptz ptl ptlz)) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod'\n  (last_symb_of_non_init_state st :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (H : True) (pt : parse_tree (last_symb_of_non_init_state st) wordt) : ptlz_buffer ptlz = ptd_buffer (build_pt_dot_from_ptl (Cons_ptl ptl pt) ptlz).","proofString":"apply ptd_buffer_build_from_ptl."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (ptlz : ptl_zipper (last_symb_of_non_init_state st :: head_symbolsq) (wordq ++ wordt)) (stk0 stk0' : stack) (Hfut : state_has_future (state_of_stack init stk0) (ptlz_prod ptlz)\n  (last_symb_of_non_init_state st :: ptlz_future ptlz) \n  (ptlz_lookahead ptlz)) (Hstk0' : ptl_stack_compat stk0' ptl stk0) (Hstk0 : ptlz_stack_compat stk0' ptlz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod'\n  (last_symb_of_non_init_state st :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (H : True) (pt : parse_tree (last_symb_of_non_init_state st) wordt) : ptd_stack_compat (build_pt_dot_from_ptl (Cons_ptl ptl pt) ptlz)\n  (existT noninitstate_type st (pt_sem pt) :: stk0).","proofString":"apply (ptd_stack_compat_build_from_ptl _ _ _ stk0'); auto; [].\nsplit=>//.\nby exists eq_refl."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (ptlz : ptl_zipper (last_symb_of_non_init_state st :: head_symbolsq) (wordq ++ wordt)) (stk0 stk0' : stack) (Hfut : state_has_future (state_of_stack init stk0) (ptlz_prod ptlz)\n  (last_symb_of_non_init_state st :: ptlz_future ptlz) \n  (ptlz_lookahead ptlz)) (Hstk0' : ptl_stack_compat stk0' ptl stk0) (Hstk0 : ptlz_stack_compat stk0' ptlz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod'\n  (last_symb_of_non_init_state st :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (H : True) (pt : parse_tree (last_symb_of_non_init_state st) wordt) : ptl_stack_compat stk0' (Cons_ptl ptl pt)\n  (existT noninitstate_type st (pt_sem pt) :: stk0).","proofString":"split=>//.\nby exists eq_refl."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (wordt : list token) (st : noninitstate) (ptlz : ptl_zipper (last_symb_of_non_init_state st :: head_symbolsq) (wordq ++ wordt)) (stk0 stk0' : stack) (Hfut : state_has_future (state_of_stack init stk0) (ptlz_prod ptlz)\n  (last_symb_of_non_init_state st :: ptlz_future ptlz) \n  (ptlz_lookahead ptlz)) (Hstk0' : ptl_stack_compat stk0' ptl stk0) (Hstk0 : ptlz_stack_compat stk0' ptlz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod'\n  (last_symb_of_non_init_state st :: fut) lookahead ->\nstate_has_future st prod' fut lookahead) (H : True) (pt : parse_tree (last_symb_of_non_init_state st) wordt) : exists e : last_symb_of_non_init_state st = last_symb_of_non_init_state st,\n  pt_sem pt =\n  eq_rect (last_symb_of_non_init_state st) symbol_semantic_type \n    (pt_sem pt) (last_symb_of_non_init_state st) e.","proofString":"by exists eq_refl."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto' : goto_table (state_of_stack init stk0) (prod_lhs prod) = None) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) : forall\n  y : None = None ->\n      match state_of_stack init stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk0 (fun _ : True => y))\n           (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr\n      (cast symbol_semantic_type\n         (reduce_step_subproof0 init prod stk0 (fun _ : True => y))\n         (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"intros Hv.\ngeneralize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto' : goto_table (state_of_stack init stk0) (prod_lhs prod) = None) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) (Hv : None = None ->\nmatch state_of_stack init stk0 with\n| Init i => prod_lhs prod = start_nt i\n| Ninit _ => False\nend) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr\n        (cast symbol_semantic_type\n           (reduce_step_subproof0 init prod stk0 (fun _ : True => Hv))\n           (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr\n      (cast symbol_semantic_type\n         (reduce_step_subproof0 init prod stk0 (fun _ : True => Hv))\n         (ptl_sem ptl (prod_action prod))) (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"generalize (reduce_step_subproof0 _ prod _ (fun _ => Hv)).\nintros EQnt.\nclear Hv Hgoto'.\nchange (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) (EQnt : thunkP (NT (prod_lhs prod) = NT (start_nt init))) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr\n        (cast symbol_semantic_type EQnt (ptl_sem ptl (prod_action prod)))\n        (ptz_buffer ptz) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr\n      (cast symbol_semantic_type EQnt (ptl_sem ptl (prod_action prod)))\n      (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"change (ptl_sem ptl (prod_action prod))      with (pt_sem (Non_terminal_pt prod ptl)).\ngeneralize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) (EQnt : thunkP (NT (prod_lhs prod) = NT (start_nt init))) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr\n        (cast symbol_semantic_type EQnt (pt_sem (Non_terminal_pt prod ptl)))\n        (ptz_buffer ptz) = Progress_sr stk' (ptd_buffer ptd) /\\\n      ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr\n      (cast symbol_semantic_type EQnt (pt_sem (Non_terminal_pt prod ptl)))\n      (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (pt_sem (Non_terminal_pt prod ptl))) buffer_end\nend.","proofString":"generalize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) (EQnt : thunkP (NT (prod_lhs prod) = NT (start_nt init))) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr (cast symbol_semantic_type EQnt (pt_sem p)) (ptz_buffer ptz) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr (cast symbol_semantic_type EQnt (pt_sem p)) (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (pt_sem p)) buffer_end\nend.","proofString":"clear ptl.\ndestruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (word : list token) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (prod_lhs prod) :: fut) lookahead -> False) (EQnt : thunkP (NT (prod_lhs prod) = NT (start_nt init))) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd =>\n    exists stk' : stack,\n      Accept_sr (cast symbol_semantic_type EQnt (pt_sem p)) (ptz_buffer ptz) =\n      Progress_sr stk' (ptd_buffer ptd) /\\ ptd_stack_compat ptd stk'\n| None =>\n    Accept_sr (cast symbol_semantic_type EQnt (pt_sem p)) (ptz_buffer ptz) =\n    Accept_sr (ptz_sem ptz (pt_sem p)) buffer_end\nend.","proofString":"destruct ptz.\nintros pt.\nf_equal.\nby rewrite cast_eq.\nedestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(prod : production) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 Top_ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (start_nt init) :: fut) lookahead -> False) (EQnt : thunkP (NT (start_nt init) = NT (start_nt init))) : forall p : parse_tree (NT (start_nt init)) full_word,\nAccept_sr (cast symbol_semantic_type EQnt (pt_sem p)) (ptz_buffer Top_ptz) =\nAccept_sr (ptz_sem Top_ptz (pt_sem p)) buffer_end.","proofString":"intros pt.\nf_equal.\nby rewrite cast_eq."},{"statement":"(prod : production) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 Top_ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (start_nt init) :: fut) lookahead -> False) (EQnt : thunkP (NT (start_nt init) = NT (start_nt init))) (pt : parse_tree (NT (start_nt init)) full_word) : Accept_sr (cast symbol_semantic_type EQnt (pt_sem pt)) (ptz_buffer Top_ptz) =\nAccept_sr (ptz_sem Top_ptz (pt_sem pt)) buffer_end.","proofString":"f_equal.\nby rewrite cast_eq."},{"statement":"(prod : production) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 Top_ptz) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (NT (start_nt init) :: fut) lookahead -> False) (EQnt : thunkP (NT (start_nt init) = NT (start_nt init))) (pt : parse_tree (NT (start_nt init)) full_word) : cast symbol_semantic_type EQnt (pt_sem pt) = ptz_sem Top_ptz (pt_sem pt).","proofString":"by rewrite cast_eq."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (p : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p0 : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) (stk0 : stack) (Hstk0 : ptz_stack_compat stk0 (Cons_ptl_ptz p p0)) (Hgoto : forall (fut : list symbol) (prod' : production) (lookahead : terminal),\nstate_has_future (state_of_stack init stk0) prod' \n  (head_symbolt :: fut) lookahead -> False) (EQnt : thunkP (head_symbolt = NT (start_nt init))) : forall p1 : parse_tree head_symbolt wordt,\nexists stk' : stack,\n  Accept_sr (cast symbol_semantic_type EQnt (pt_sem p1))\n    (ptz_buffer (Cons_ptl_ptz p p0)) =\n  Progress_sr stk' (ptd_buffer (build_pt_dot_from_ptl (Cons_ptl p p1) p0)) /\\\n  ptd_stack_compat (build_pt_dot_from_ptl (Cons_ptl p p1) p0) stk'.","proofString":"edestruct Hgoto.\neapply ptz_stack_compat_cons_state_has_future, Hstk0."},{"statement":"(ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) : match next_ptd ptd with\n| Some ptd' =>\n    exists stk' : stack,\n      step safe init stk (ptd_buffer ptd) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    step safe init stk (ptd_buffer ptd) Hi =\n    Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"unfold step.\ngeneralize (reduce_ok safe (state_of_stack init stk)).\ndestruct ptd as [prod word ptl ptz|tok symbs word ptl ptlz].\nassert (Hfut : state_has_future (state_of_stack init stk) prod []                                    (token_term (buf_head (ptz_buffer ptz)))).\ndestruct Hstk as (? & ? & ?)=>//.\nassert (Hact := end_reduce _ _ _ _ Hfut).\ndestruct action_table as [?|awt]=>Hval /=.\nsubst.\nby apply reduce_step_next_ptd.\nset (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd.\ndestruct Hstk as (stk0 & Hfut & Hstk & Hstk0).\nassert (Hact := terminal_shift _ _ _ _ Hfut).\nsimpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) : match next_ptd ptd with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          => reduce_step init stk prod (ptd_buffer ptd) Hv Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer ptd))) as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect (T (token_term (buf_head (ptd_buffer ptd))))\n                      symbol_semantic_type\n                      (token_sem (buf_head (ptd_buffer ptd)))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer ptd))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer ptd) Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer ptd))\n          end (fun _ : True => Hv I (token_term (buf_head (ptd_buffer ptd))))\n      end (fun _ : True => reduce_ok safe (state_of_stack init stk)) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        => reduce_step init stk prod (ptd_buffer ptd) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer ptd))) as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect (T (token_term (buf_head (ptd_buffer ptd))))\n                    symbol_semantic_type\n                    (token_sem (buf_head (ptd_buffer ptd)))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer ptd))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer ptd) Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer ptd))\n        end (fun _ : True => Hv I (token_term (buf_head (ptd_buffer ptd))))\n    end (fun _ : True => reduce_ok safe (state_of_stack init stk)) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"generalize (reduce_ok safe (state_of_stack init stk)).\ndestruct ptd as [prod word ptl ptz|tok symbs word ptl ptlz].\nassert (Hfut : state_has_future (state_of_stack init stk) prod []                                    (token_term (buf_head (ptz_buffer ptz)))).\ndestruct Hstk as (? & ? & ?)=>//.\nassert (Hact := end_reduce _ _ _ _ Hfut).\ndestruct action_table as [?|awt]=>Hval /=.\nsubst.\nby apply reduce_step_next_ptd.\nset (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd.\ndestruct Hstk as (stk0 & Hfut & Hstk & Hstk0).\nassert (Hact := terminal_shift _ _ _ _ Hfut).\nsimpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd ptd with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          => reduce_step init stk prod (ptd_buffer ptd) Hv Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer ptd))) as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect (T (token_term (buf_head (ptd_buffer ptd))))\n                      symbol_semantic_type\n                      (token_sem (buf_head (ptd_buffer ptd)))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer ptd))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer ptd) Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer ptd))\n          end (fun _ : True => Hv I (token_term (buf_head (ptd_buffer ptd))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        => reduce_step init stk prod (ptd_buffer ptd) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer ptd))) as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect (T (token_term (buf_head (ptd_buffer ptd))))\n                    symbol_semantic_type\n                    (token_sem (buf_head (ptd_buffer ptd)))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer ptd))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer ptd) Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer ptd))\n        end (fun _ : True => Hv I (token_term (buf_head (ptd_buffer ptd))))\n    end (fun _ : True => y) = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"destruct ptd as [prod word ptl ptz|tok symbs word ptl ptlz].\nassert (Hfut : state_has_future (state_of_stack init stk) prod []                                    (token_term (buf_head (ptz_buffer ptz)))).\ndestruct Hstk as (? & ? & ?)=>//.\nassert (Hact := end_reduce _ _ _ _ Hfut).\ndestruct action_table as [?|awt]=>Hval /=.\nsubst.\nby apply reduce_step_next_ptd.\nset (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd.\ndestruct Hstk as (stk0 & Hfut & Hstk & Hstk0).\nassert (Hact := terminal_shift _ _ _ _ Hfut).\nsimpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod0 =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod0\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod0 =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk)\n                      prod0) =>\n          reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))) as\n            a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n                      symbol_semantic_type\n                      (token_sem (buf_head (ptd_buffer (Reduce_ptd ptl ptz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Reduce_ptd ptl ptz)))\n          | Reduce_act prod0 =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod0) =>\n              reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))\n          end\n            (fun _ : True =>\n             Hv I (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod0 =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod0\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod0 =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod0)\n        => reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))) as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n                    symbol_semantic_type\n                    (token_sem (buf_head (ptd_buffer (Reduce_ptd ptl ptz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Reduce_ptd ptl ptz)))\n        | Reduce_act prod0 =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod0) =>\n            reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv0\n              Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"assert (Hfut : state_has_future (state_of_stack init stk) prod []                                    (token_term (buf_head (ptz_buffer ptz)))).\ndestruct Hstk as (? & ? & ?)=>//.\nassert (Hact := end_reduce _ _ _ _ Hfut).\ndestruct action_table as [?|awt]=>Hval /=.\nsubst.\nby apply reduce_step_next_ptd.\nset (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) : state_has_future (state_of_stack init stk) prod []\n  (token_term (buf_head (ptz_buffer ptz))).","proofString":"destruct Hstk as (? & ? & ?)=>//."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (Hfut : state_has_future (state_of_stack init stk) prod []\n  (token_term (buf_head (ptz_buffer ptz)))) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Reduce_ptd ptl ptz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod0 =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod0\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod0 =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk)\n                      prod0) =>\n          reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))) as\n            a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n                      symbol_semantic_type\n                      (token_sem (buf_head (ptd_buffer (Reduce_ptd ptl ptz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Reduce_ptd ptl ptz)))\n          | Reduce_act prod0 =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod0) =>\n              reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))\n          end\n            (fun _ : True =>\n             Hv I (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod0 =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod0\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod0 =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod0)\n        => reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))) as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n                    symbol_semantic_type\n                    (token_sem (buf_head (ptd_buffer (Reduce_ptd ptl ptz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Reduce_ptd ptl ptz)))\n        | Reduce_act prod0 =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod0) =>\n            reduce_step init stk prod0 (ptd_buffer (Reduce_ptd ptl ptz)) Hv0\n              Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Reduce_ptd ptl ptz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Reduce_ptd ptl ptz)) buffer_end\nend.","proofString":"assert (Hact := end_reduce _ _ _ _ Hfut).\ndestruct action_table as [?|awt]=>Hval /=.\nsubst.\nby apply reduce_step_next_ptd.\nset (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (Hfut : state_has_future (state_of_stack init stk) prod []\n  (token_term (buf_head (ptz_buffer ptz)))) (p : production) (Hact : p = prod) (Hval : ValidSafe.valid_for_reduce (state_of_stack init stk) p) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      reduce_step init stk p (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    reduce_step init stk p (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"subst.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (Hfut : state_has_future (state_of_stack init stk) prod []\n  (token_term (buf_head (ptz_buffer ptz)))) (Hval : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"by apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (Hfut : state_has_future (state_of_stack init stk) prod []\n  (token_term (buf_head (ptz_buffer ptz)))) (awt : forall term : terminal, lookahead_action term) (Hact : match awt (token_term (buf_head (ptz_buffer ptz))) with\n| Reduce_act p => p = prod\n| _ => False\nend) (Hval : forall t : terminal,\nmatch awt t with\n| Reduce_act p => ValidSafe.valid_for_reduce (state_of_stack init stk) p\n| _ => True\nend) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        awt (token_term (buf_head (ptz_buffer ptz))) as a\n        return\n          (thunkP\n             match a with\n             | Reduce_act p =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) p\n             | _ => True\n             end -> step_result init)\n      with\n      | Shift_act state_new e =>\n          fun _ : thunkP True =>\n          Progress_sr\n            (existT noninitstate_type state_new\n               (eq_rect (T (token_term (buf_head (ptz_buffer ptz))))\n                  symbol_semantic_type\n                  (token_sem (buf_head (ptz_buffer ptz)))\n                  (last_symb_of_non_init_state state_new) e) :: stk)\n            (buf_tail (ptz_buffer ptz))\n      | Reduce_act prod0 =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk)\n                      prod0) =>\n          reduce_step init stk prod0 (ptz_buffer ptz) Hv Hi\n      | Fail_act =>\n          fun _ : thunkP True =>\n          Fail_sr_full (state_of_stack init stk) (buf_head (ptz_buffer ptz))\n      end (fun _ : True => Hval (token_term (buf_head (ptz_buffer ptz)))) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    match\n      awt (token_term (buf_head (ptz_buffer ptz))) as a\n      return\n        (thunkP\n           match a with\n           | Reduce_act p =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) p\n           | _ => True\n           end -> step_result init)\n    with\n    | Shift_act state_new e =>\n        fun _ : thunkP True =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (T (token_term (buf_head (ptz_buffer ptz))))\n                symbol_semantic_type (token_sem (buf_head (ptz_buffer ptz)))\n                (last_symb_of_non_init_state state_new) e) :: stk)\n          (buf_tail (ptz_buffer ptz))\n    | Reduce_act prod0 =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod0)\n        => reduce_step init stk prod0 (ptz_buffer ptz) Hv Hi\n    | Fail_act =>\n        fun _ : thunkP True =>\n        Fail_sr_full (state_of_stack init stk) (buf_head (ptz_buffer ptz))\n    end (fun _ : True => Hval (token_term (buf_head (ptz_buffer ptz)))) =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"set (term := token_term (buf_head (ptz_buffer ptz))) in *.\ngeneralize (Hval term).\nclear Hval.\ndestruct (awt term)=>//.\nsubst.\nintros Hval.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (term : terminal) (Hfut : state_has_future (state_of_stack init stk) prod [] term) (awt : forall term0 : terminal, lookahead_action term0) (p : production) (Hact : p = prod) : forall y : ValidSafe.valid_for_reduce (state_of_stack init stk) p,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      reduce_step init stk p (ptz_buffer ptz) (fun _ : True => y) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    reduce_step init stk p (ptz_buffer ptz) (fun _ : True => y) Hi =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"subst.\nintros Hval.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (term : terminal) (Hfut : state_has_future (state_of_stack init stk) prod [] term) (awt : forall term0 : terminal, lookahead_action term0) : forall y : ValidSafe.valid_for_reduce (state_of_stack init stk) prod,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => y) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => y) Hi =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"intros Hval.\nby apply reduce_step_next_ptd."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Reduce_ptd ptl ptz) stk) (term : terminal) (Hfut : state_has_future (state_of_stack init stk) prod [] term) (awt : forall term0 : terminal, lookahead_action term0) (Hval : ValidSafe.valid_for_reduce (state_of_stack init stk) prod) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    reduce_step init stk prod (ptz_buffer ptz) (fun _ : True => Hval) Hi =\n    Accept_sr (ptz_sem ptz (ptl_sem ptl (prod_action prod))) buffer_end\nend.","proofString":"by apply reduce_step_next_ptd."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat (Shift_ptd tok ptl ptlz) stk) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Shift_ptd tok ptl ptlz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          =>\n          reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv\n            Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n            as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                      symbol_semantic_type\n                      (token_sem\n                         (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          end\n            (fun _ : True =>\n             Hv I\n               (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        =>\n        reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n          as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                    symbol_semantic_type\n                    (token_sem\n                       (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n              Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Shift_ptd tok ptl ptlz)) buffer_end\nend.","proofString":"destruct Hstk as (stk0 & Hfut & Hstk & Hstk0).\nassert (Hact := terminal_shift _ _ _ _ Hfut).\nsimpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod ptlz)\n  (T (token_term tok) :: ptlz_future ptlz) (ptlz_lookahead ptlz)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptlz_stack_compat stk0 ptlz) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Shift_ptd tok ptl ptlz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          =>\n          reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv\n            Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n            as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                      symbol_semantic_type\n                      (token_sem\n                         (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          end\n            (fun _ : True =>\n             Hv I\n               (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        =>\n        reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n          as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                    symbol_semantic_type\n                    (token_sem\n                       (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n              Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Shift_ptd tok ptl ptlz)) buffer_end\nend.","proofString":"assert (Hact := terminal_shift _ _ _ _ Hfut).\nsimpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod ptlz)\n  (T (token_term tok) :: ptlz_future ptlz) (ptlz_lookahead ptlz)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptlz_stack_compat stk0 ptlz) (Hact : match T (token_term tok) :: ptlz_future ptlz with\n| T t :: q =>\n    match action_table (state_of_stack init stk) with\n    | Default_reduce_act _ => False\n    | Lookahead_act awp =>\n        match awp t with\n        | Shift_act s2 _ =>\n            state_has_future s2 (ptlz_prod ptlz) q (ptlz_lookahead ptlz)\n        | _ => False\n        end\n    end\n| _ => True\nend) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Shift_ptd tok ptl ptlz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          =>\n          reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv\n            Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n            as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                      symbol_semantic_type\n                      (token_sem\n                         (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          end\n            (fun _ : True =>\n             Hv I\n               (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        =>\n        reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n          as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                    symbol_semantic_type\n                    (token_sem\n                       (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n              Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Shift_ptd tok ptl ptlz)) buffer_end\nend.","proofString":"simpl in Hact.\nclear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hfut : state_has_future (state_of_stack init stk) (ptlz_prod ptlz)\n  (T (token_term tok) :: ptlz_future ptlz) (ptlz_lookahead ptlz)) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptlz_stack_compat stk0 ptlz) (Hact : match action_table (state_of_stack init stk) with\n| Default_reduce_act _ => False\n| Lookahead_act awp =>\n    match awp (token_term tok) with\n    | Shift_act s2 _ =>\n        state_has_future s2 (ptlz_prod ptlz) (ptlz_future ptlz)\n          (ptlz_lookahead ptlz)\n    | _ => False\n    end\nend) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Shift_ptd tok ptl ptlz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          =>\n          reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv\n            Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n            as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                      symbol_semantic_type\n                      (token_sem\n                         (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          end\n            (fun _ : True =>\n             Hv I\n               (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        =>\n        reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n          as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                    symbol_semantic_type\n                    (token_sem\n                       (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n              Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Shift_ptd tok ptl ptlz)) buffer_end\nend.","proofString":"clear Hfut.\ndestruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptlz_stack_compat stk0 ptlz) (Hact : match action_table (state_of_stack init stk) with\n| Default_reduce_act _ => False\n| Lookahead_act awp =>\n    match awp (token_term tok) with\n    | Shift_act s2 _ =>\n        state_has_future s2 (ptlz_prod ptlz) (ptlz_future ptlz)\n          (ptlz_lookahead ptlz)\n    | _ => False\n    end\nend) : forall\n  y : match action_table (state_of_stack init stk) with\n      | Default_reduce_act p =>\n          ValidSafe.valid_for_reduce (state_of_stack init stk) p\n      | Lookahead_act awp =>\n          forall t : terminal,\n          match awp t with\n          | Reduce_act p =>\n              ValidSafe.valid_for_reduce (state_of_stack init stk) p\n          | _ => True\n          end\n      end,\nmatch next_ptd (Shift_ptd tok ptl ptlz) with\n| Some ptd' =>\n    exists stk' : stack,\n      match\n        action_table (state_of_stack init stk) as a\n        return\n          (thunkP\n             match a with\n             | Default_reduce_act prod =>\n                 ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n             | Lookahead_act awt =>\n                 forall t : terminal,\n                 match awt t with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end\n             end -> step_result init)\n      with\n      | Default_reduce_act prod =>\n          fun\n            Hv : thunkP\n                   (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n          =>\n          reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv\n            Hi\n      | Lookahead_act awt =>\n          fun\n            Hv : thunkP\n                   (forall t : terminal,\n                    match awt t with\n                    | Reduce_act p =>\n                        ValidSafe.valid_for_reduce \n                          (state_of_stack init stk) p\n                    | _ => True\n                    end) =>\n          match\n            awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n            as a\n            return\n              (thunkP\n                 match a with\n                 | Reduce_act p =>\n                     ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                 | _ => True\n                 end -> step_result init)\n          with\n          | Shift_act state_new e =>\n              fun _ : thunkP True =>\n              Progress_sr\n                (existT noninitstate_type state_new\n                   (eq_rect\n                      (T\n                         (token_term\n                            (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                      symbol_semantic_type\n                      (token_sem\n                         (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                      (last_symb_of_non_init_state state_new) e) :: stk)\n                (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          | Reduce_act prod =>\n              fun\n                Hv0 : thunkP\n                        (ValidSafe.valid_for_reduce \n                           (state_of_stack init stk) prod) =>\n              reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n                Hv0 Hi\n          | Fail_act =>\n              fun _ : thunkP True =>\n              Fail_sr_full (state_of_stack init stk)\n                (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n          end\n            (fun _ : True =>\n             Hv I\n               (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n      end (fun _ : True => y) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    match\n      action_table (state_of_stack init stk) as a\n      return\n        (thunkP\n           match a with\n           | Default_reduce_act prod =>\n               ValidSafe.valid_for_reduce (state_of_stack init stk) prod\n           | Lookahead_act awt =>\n               forall t : terminal,\n               match awt t with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end\n           end -> step_result init)\n    with\n    | Default_reduce_act prod =>\n        fun\n          Hv : thunkP\n                 (ValidSafe.valid_for_reduce (state_of_stack init stk) prod)\n        =>\n        reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz)) Hv Hi\n    | Lookahead_act awt =>\n        fun\n          Hv : thunkP\n                 (forall t : terminal,\n                  match awt t with\n                  | Reduce_act p =>\n                      ValidSafe.valid_for_reduce (state_of_stack init stk) p\n                  | _ => True\n                  end) =>\n        match\n          awt (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n          as a\n          return\n            (thunkP\n               match a with\n               | Reduce_act p =>\n                   ValidSafe.valid_for_reduce (state_of_stack init stk) p\n               | _ => True\n               end -> step_result init)\n        with\n        | Shift_act state_new e =>\n            fun _ : thunkP True =>\n            Progress_sr\n              (existT noninitstate_type state_new\n                 (eq_rect\n                    (T\n                       (token_term\n                          (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n                    symbol_semantic_type\n                    (token_sem\n                       (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz))))\n                    (last_symb_of_non_init_state state_new) e) :: stk)\n              (buf_tail (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        | Reduce_act prod =>\n            fun\n              Hv0 : thunkP\n                      (ValidSafe.valid_for_reduce \n                         (state_of_stack init stk) prod) =>\n            reduce_step init stk prod (ptd_buffer (Shift_ptd tok ptl ptlz))\n              Hv0 Hi\n        | Fail_act =>\n            fun _ : thunkP True =>\n            Fail_sr_full (state_of_stack init stk)\n              (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))\n        end\n          (fun _ : True =>\n           Hv I (token_term (buf_head (ptd_buffer (Shift_ptd tok ptl ptlz)))))\n    end (fun _ : True => y) =\n    Accept_sr (ptd_sem (Shift_ptd tok ptl ptlz)) buffer_end\nend.","proofString":"destruct action_table as [?|awt]=>//= /(_ (token_term tok)).\ndestruct awt as [st' EQ| |]=>// _.\neexists.\nsplit.\nf_equal.\nrewrite -ptd_buffer_build_from_ptl //.\napply (ptd_stack_compat_build_from_ptl _ _ _ stk0); simpl; eauto."},{"statement":"(tok : token) (symbs : list symbol) (word : list token) (ptl : parse_tree_list symbs word) (ptlz : ptl_zipper (T (token_term tok) :: symbs) (word ++ [tok])) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (stk0 : stack) (Hstk : ptl_stack_compat stk0 ptl stk) (Hstk0 : ptlz_stack_compat stk0 ptlz) (awt : forall term : terminal, lookahead_action term) (st' : noninitstate) (EQ : T (token_term tok) = last_symb_of_non_init_state st') (Hact : state_has_future st' (ptlz_prod ptlz) (ptlz_future ptlz)\n  (ptlz_lookahead ptlz)) : ptlz_buffer ptlz =\nptd_buffer (build_pt_dot_from_ptl (Cons_ptl ptl (Terminal_pt tok)) ptlz).","proofString":"rewrite -ptd_buffer_build_from_ptl //."},{"statement":"(log_n_steps : nat) : forall (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)),\nptd_stack_compat ptd stk ->\nmatch next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"induction log_n_steps as [|log_n_steps IH]; [by apply step_next_ptd|].\nmove => /= ptd stk Hi Hstk.\nassert (IH1 := IH ptd stk Hi Hstk).\nassert (EQsem := sem_next_ptd_iter ptd log_n_steps).\ndestruct parse_fix as [sr Hi'].\nsimpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)),\nptd_stack_compat ptd stk ->\nmatch next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend) : forall (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)),\nptd_stack_compat ptd stk ->\nmatch next_ptd_iter ptd (S log_n_steps) with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk (ptd_buffer ptd) (S log_n_steps) Hi) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk (ptd_buffer ptd) (S log_n_steps) Hi) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"move => /= ptd stk Hi Hstk.\nassert (IH1 := IH ptd stk Hi Hstk).\nassert (EQsem := sem_next_ptd_iter ptd log_n_steps).\ndestruct parse_fix as [sr Hi'].\nsimpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (let (x, Hi') :=\n           parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n         match\n           x as x0\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (let (x, Hi') :=\n         parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n       match\n         x as x0\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x0 = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"assert (IH1 := IH ptd stk Hi Hstk).\nassert (EQsem := sem_next_ptd_iter ptd log_n_steps).\ndestruct parse_fix as [sr Hi'].\nsimpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (let (x, Hi') :=\n           parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n         match\n           x as x0\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (let (x, Hi') :=\n         parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n       match\n         x as x0\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x0 = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"assert (EQsem := sem_next_ptd_iter ptd log_n_steps).\ndestruct parse_fix as [sr Hi'].\nsimpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi) =\n    Accept_sr (ptd_sem ptd) buffer_end\nend) (EQsem : match next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (let (x, Hi') :=\n           parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n         match\n           x as x0\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (let (x, Hi') :=\n         parse_fix safe init stk (ptd_buffer ptd) log_n_steps Hi in\n       match\n         x as x0\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x0 = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"destruct parse_fix as [sr Hi'].\nsimpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (sr : step_result init) (Hi' : forall (stk' : stack) (buffer' : buffer),\nsr = Progress_sr stk' buffer' -> stack_invariant init stk') (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (exist\n           (fun sr0 : step_result init =>\n            forall (stk'0 : stack) (buffer' : buffer),\n            sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) sr\n           Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (exist\n         (fun sr0 : step_result init =>\n          forall (stk' : stack) (buffer' : buffer),\n          sr0 = Progress_sr stk' buffer' -> stack_invariant init stk') sr Hi') =\n    Accept_sr (ptd_sem ptd) buffer_end\nend) (EQsem : match next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (match\n           sr as x\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr0 : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (match\n         sr as x\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr0 : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"simpl in IH1.\ndestruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (sr : step_result init) (Hi' : forall (stk' : stack) (buffer' : buffer),\nsr = Progress_sr stk' buffer' -> stack_invariant init stk') (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      sr = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None => sr = Accept_sr (ptd_sem ptd) buffer_end\nend) (EQsem : match next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_sem ptd = ptd_sem ptd'\n| None => True\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (match\n           sr as x\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr0 : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (match\n         sr as x\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr0 : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"destruct next_ptd_iter as [ptd'|].\nrewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH.\nby subst."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd'0 =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd'0) /\\ ptd_stack_compat ptd'0 stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (sr : step_result init) (Hi' : forall (stk' : stack) (buffer' : buffer),\nsr = Progress_sr stk' buffer' -> stack_invariant init stk') (ptd' : pt_dot) (IH1 : exists stk' : stack,\n  sr = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk') (EQsem : ptd_sem ptd = ptd_sem ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 =>\n    exists stk' : stack,\n      proj1_sig\n        (match\n           sr as x\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr0 : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd'0) /\\\n      ptd_stack_compat ptd'0 stk'\n| None =>\n    proj1_sig\n      (match\n         sr as x\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr0 : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd) buffer_end\nend.","proofString":"rewrite EQsem.\ndestruct IH1 as (stk' & -> & Hstk').\nby apply IH."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd'0 =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd'0) /\\ ptd_stack_compat ptd'0 stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (sr : step_result init) (Hi' : forall (stk' : stack) (buffer' : buffer),\nsr = Progress_sr stk' buffer' -> stack_invariant init stk') (ptd' : pt_dot) (IH1 : exists stk' : stack,\n  sr = Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk') (EQsem : ptd_sem ptd = ptd_sem ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 =>\n    exists stk' : stack,\n      proj1_sig\n        (match\n           sr as x\n           return\n             ((forall (stk'0 : stack) (buffer' : buffer),\n               x = Progress_sr stk'0 buffer' -> stack_invariant init stk'0) ->\n              {sr0 : step_result init\n              | forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0})\n         with\n         | Fail_sr_full s t =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Fail_sr_full s t = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Fail_sr_full s t) Hi'0\n         | Accept_sr s b =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Accept_sr s b = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             exist\n               (fun sr0 : step_result init =>\n                forall (stk'0 : stack) (buffer' : buffer),\n                sr0 = Progress_sr stk'0 buffer' -> stack_invariant init stk'0)\n               (Accept_sr s b) Hi'0\n         | Progress_sr stk0 buffer0 =>\n             fun\n               Hi'0 : forall (stk'0 : stack) (buffer' : buffer),\n                      Progress_sr stk0 buffer0 = Progress_sr stk'0 buffer' ->\n                      stack_invariant init stk'0 =>\n             parse_fix safe init stk0 buffer0 log_n_steps\n               (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n         end Hi') = Progress_sr stk' (ptd_buffer ptd'0) /\\\n      ptd_stack_compat ptd'0 stk'\n| None =>\n    proj1_sig\n      (match\n         sr as x\n         return\n           ((forall (stk' : stack) (buffer' : buffer),\n             x = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n            {sr0 : step_result init\n            | forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk'})\n       with\n       | Fail_sr_full s t =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Fail_sr_full s t = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Fail_sr_full s t) Hi'0\n       | Accept_sr s b =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Accept_sr s b = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           exist\n             (fun sr0 : step_result init =>\n              forall (stk' : stack) (buffer' : buffer),\n              sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n             (Accept_sr s b) Hi'0\n       | Progress_sr stk0 buffer0 =>\n           fun\n             Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                    Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                    stack_invariant init stk' =>\n           parse_fix safe init stk0 buffer0 log_n_steps\n             (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n       end Hi') = Accept_sr (ptd_sem ptd') buffer_end\nend.","proofString":"destruct IH1 as (stk' & -> & Hstk').\nby apply IH."},{"statement":"(log_n_steps : nat) (IH : forall (ptd0 : pt_dot) (stk0 : stack)\n  (Hi0 : thunkP (stack_invariant init stk0)),\nptd_stack_compat ptd0 stk0 ->\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n      Progress_sr stk' (ptd_buffer ptd') /\\ ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig (parse_fix safe init stk0 (ptd_buffer ptd0) log_n_steps Hi0) =\n    Accept_sr (ptd_sem ptd0) buffer_end\nend) (ptd : pt_dot) (stk : stack) (Hi : thunkP (stack_invariant init stk)) (Hstk : ptd_stack_compat ptd stk) (sr : step_result init) (Hi' : forall (stk' : stack) (buffer' : buffer),\nsr = Progress_sr stk' buffer' -> stack_invariant init stk') (IH1 : sr = Accept_sr (ptd_sem ptd) buffer_end) (EQsem : True) : proj1_sig\n  (match\n     sr as x\n     return\n       ((forall (stk' : stack) (buffer' : buffer),\n         x = Progress_sr stk' buffer' -> stack_invariant init stk') ->\n        {sr0 : step_result init\n        | forall (stk' : stack) (buffer' : buffer),\n          sr0 = Progress_sr stk' buffer' -> stack_invariant init stk'})\n   with\n   | Fail_sr_full s t =>\n       fun\n         Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                Fail_sr_full s t = Progress_sr stk' buffer' ->\n                stack_invariant init stk' =>\n       exist\n         (fun sr0 : step_result init =>\n          forall (stk' : stack) (buffer' : buffer),\n          sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n         (Fail_sr_full s t) Hi'0\n   | Accept_sr s b =>\n       fun\n         Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                Accept_sr s b = Progress_sr stk' buffer' ->\n                stack_invariant init stk' =>\n       exist\n         (fun sr0 : step_result init =>\n          forall (stk' : stack) (buffer' : buffer),\n          sr0 = Progress_sr stk' buffer' -> stack_invariant init stk')\n         (Accept_sr s b) Hi'0\n   | Progress_sr stk0 buffer0 =>\n       fun\n         Hi'0 : forall (stk' : stack) (buffer' : buffer),\n                Progress_sr stk0 buffer0 = Progress_sr stk' buffer' ->\n                stack_invariant init stk' =>\n       parse_fix safe init stk0 buffer0 log_n_steps\n         (fun _ : True => Hi'0 stk0 buffer0 eq_refl)\n   end Hi') = Accept_sr (ptd_sem ptd) buffer_end.","proofString":"by subst."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) : ptlz_cost (Cons_ptl_ptlz p ptlz) =\nptd_cost (build_pt_dot_from_ptl ptl (Cons_ptl_ptlz p ptlz)).","proofString":"apply eq_add_S.\nrewrite -ptd_cost_build_from_pt /=.\nring."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) : S (ptlz_cost (Cons_ptl_ptlz p ptlz)) =\nS (ptd_cost (build_pt_dot_from_ptl ptl (Cons_ptl_ptlz p ptlz))).","proofString":"rewrite -ptd_cost_build_from_pt /=.\nring."},{"statement":"(head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (p : parse_tree head_symbolt wordt) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) : S (pt_size p + ptlz_cost ptlz) = pt_size p + S (ptlz_cost ptlz).","proofString":"ring."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) : match\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end (Non_terminal_pt prod ptl)\nwith\n| Some ptd' => ptz_cost ptz = S (ptd_cost ptd')\n| None => ptz_cost ptz = 0\nend.","proofString":"generalize (Non_terminal_pt prod ptl).\nclear ptl.\ndestruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -ptd_cost_build_from_ptl."},{"statement":"(prod : production) (word : list token) (ptl : parse_tree_list (prod_rhs_rev prod) word) (ptz : pt_zipper (NT (prod_lhs prod)) word) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd' => ptz_cost ptz = S (ptd_cost ptd')\n| None => ptz_cost ptz = 0\nend.","proofString":"clear ptl.\ndestruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -ptd_cost_build_from_ptl."},{"statement":"(prod : production) (word : list token) (ptz : pt_zipper (NT (prod_lhs prod)) word) : forall p : parse_tree (NT (prod_lhs prod)) word,\nmatch\n  match\n    ptz in (pt_zipper symb word0)\n    return (parse_tree symb word0 -> option pt_dot)\n  with\n  | Top_ptz => fun _ : parse_tree (NT (start_nt init)) full_word => None\n  | @Cons_ptl_ptz head_symbolsq wordq ptl' head_symbolt wordt ptlz =>\n      fun pt : parse_tree head_symbolt wordt =>\n      Some (build_pt_dot_from_ptl (Cons_ptl ptl' pt) ptlz)\n  end p\nwith\n| Some ptd' => ptz_cost ptz = S (ptd_cost ptd')\n| None => ptz_cost ptz = 0\nend.","proofString":"destruct ptz as [|?? ptl ?? ptlz]=>// pt.\nby rewrite -ptd_cost_build_from_ptl."},{"statement":"(prod : production) (head_symbolsq : list symbol) (wordq : list token) (ptl : parse_tree_list head_symbolsq wordq) (head_symbolt : symbol) (wordt : list token) (ptlz : ptl_zipper (head_symbolt :: head_symbolsq) (wordq ++ wordt)) (pt : parse_tree head_symbolt wordt) : ptz_cost (Cons_ptl_ptz ptl ptlz) =\nS (ptd_cost (build_pt_dot_from_ptl (Cons_ptl ptl pt) ptlz)).","proofString":"by rewrite -ptd_cost_build_from_ptl."},{"statement":"(tok : token) (symbq : list symbol) (wordq : list token) (ptl : parse_tree_list symbq wordq) (ptlz : ptl_zipper (T (token_term tok) :: symbq) (wordq ++ [tok])) : S (ptlz_cost ptlz) =\nS (ptd_cost (build_pt_dot_from_ptl (Cons_ptl ptl (Terminal_pt tok)) ptlz)).","proofString":"by rewrite -ptd_cost_build_from_ptl."},{"statement":"(log_n_steps : nat) : forall ptd : pt_dot,\nmatch next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd < 2 ^ log_n_steps\nend.","proofString":"induction log_n_steps as [|log_n_steps IH]=>ptd /=.\nassert (Hptd := next_ptd_cost ptd).\ndestruct next_ptd=>//.\nby rewrite Hptd.\nrewrite Nat.add_0_r.\nassert (IH1 := IH ptd).\ndestruct next_ptd_iter as [ptd'|].\nspecialize (IH ptd').\ndestruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l.\nby apply Nat.lt_le_trans with (1 := IH1), Nat.le_add_r."},{"statement":"(ptd : pt_dot) : match next_ptd ptd with\n| Some ptd' => ptd_cost ptd = S (ptd_cost ptd')\n| None => ptd_cost ptd < 1\nend.","proofString":"assert (Hptd := next_ptd_cost ptd).\ndestruct next_ptd=>//.\nby rewrite Hptd."},{"statement":"(ptd : pt_dot) (Hptd : match next_ptd ptd with\n| Some ptd' => ptd_cost ptd = S (ptd_cost ptd')\n| None => ptd_cost ptd = 0\nend) : match next_ptd ptd with\n| Some ptd' => ptd_cost ptd = S (ptd_cost ptd')\n| None => ptd_cost ptd < 1\nend.","proofString":"destruct next_ptd=>//.\nby rewrite Hptd."},{"statement":"(ptd : pt_dot) (Hptd : ptd_cost ptd = 0) : ptd_cost ptd < 1.","proofString":"by rewrite Hptd."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_cost ptd0 = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd0 < 2 ^ log_n_steps\nend) (ptd : pt_dot) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    ptd_cost ptd = 2 ^ log_n_steps + (2 ^ log_n_steps + 0) + ptd_cost ptd'\n| None => ptd_cost ptd < 2 ^ log_n_steps + (2 ^ log_n_steps + 0)\nend.","proofString":"rewrite Nat.add_0_r.\nassert (IH1 := IH ptd).\ndestruct next_ptd_iter as [ptd'|].\nspecialize (IH ptd').\ndestruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l.\nby apply Nat.lt_le_trans with (1 := IH1), Nat.le_add_r."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_cost ptd0 = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd0 < 2 ^ log_n_steps\nend) (ptd : pt_dot) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    ptd_cost ptd = 2 ^ log_n_steps + 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps\nend.","proofString":"assert (IH1 := IH ptd).\ndestruct next_ptd_iter as [ptd'|].\nspecialize (IH ptd').\ndestruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l.\nby apply Nat.lt_le_trans with (1 := IH1), Nat.le_add_r."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_cost ptd0 = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd0 < 2 ^ log_n_steps\nend) (ptd : pt_dot) (IH1 : match next_ptd_iter ptd log_n_steps with\n| Some ptd' => ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd < 2 ^ log_n_steps\nend) : match\n  match next_ptd_iter ptd log_n_steps with\n  | Some ptd0 => next_ptd_iter ptd0 log_n_steps\n  | None => None\n  end\nwith\n| Some ptd' =>\n    ptd_cost ptd = 2 ^ log_n_steps + 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps\nend.","proofString":"destruct next_ptd_iter as [ptd'|].\nspecialize (IH ptd').\ndestruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l.\nby apply Nat.lt_le_trans with (1 := IH1), Nat.le_add_r."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd'0 => ptd_cost ptd0 = 2 ^ log_n_steps + ptd_cost ptd'0\n| None => ptd_cost ptd0 < 2 ^ log_n_steps\nend) (ptd ptd' : pt_dot) (IH1 : ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 =>\n    ptd_cost ptd = 2 ^ log_n_steps + 2 ^ log_n_steps + ptd_cost ptd'0\n| None => ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps\nend.","proofString":"specialize (IH ptd').\ndestruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l."},{"statement":"(log_n_steps : nat) (ptd' : pt_dot) (IH : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 => ptd_cost ptd' = 2 ^ log_n_steps + ptd_cost ptd'0\n| None => ptd_cost ptd' < 2 ^ log_n_steps\nend) (ptd : pt_dot) (IH1 : ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd') : match next_ptd_iter ptd' log_n_steps with\n| Some ptd'0 =>\n    ptd_cost ptd = 2 ^ log_n_steps + 2 ^ log_n_steps + ptd_cost ptd'0\n| None => ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps\nend.","proofString":"destruct next_ptd_iter as [ptd''|].\nby rewrite IH1 IH -!Nat.add_assoc.\nrewrite IH1.\nby apply Nat.add_lt_mono_l."},{"statement":"(log_n_steps : nat) (ptd' ptd'' : pt_dot) (IH : ptd_cost ptd' = 2 ^ log_n_steps + ptd_cost ptd'') (ptd : pt_dot) (IH1 : ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd') : ptd_cost ptd = 2 ^ log_n_steps + 2 ^ log_n_steps + ptd_cost ptd''.","proofString":"by rewrite IH1 IH -!Nat.add_assoc."},{"statement":"(log_n_steps : nat) (ptd' : pt_dot) (IH : ptd_cost ptd' < 2 ^ log_n_steps) (ptd : pt_dot) (IH1 : ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd') : ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps.","proofString":"rewrite IH1.\nby apply Nat.add_lt_mono_l."},{"statement":"(log_n_steps : nat) (ptd' : pt_dot) (IH : ptd_cost ptd' < 2 ^ log_n_steps) (ptd : pt_dot) (IH1 : ptd_cost ptd = 2 ^ log_n_steps + ptd_cost ptd') : 2 ^ log_n_steps + ptd_cost ptd' < 2 ^ log_n_steps + 2 ^ log_n_steps.","proofString":"by apply Nat.add_lt_mono_l."},{"statement":"(log_n_steps : nat) (IH : forall ptd0 : pt_dot,\nmatch next_ptd_iter ptd0 log_n_steps with\n| Some ptd' => ptd_cost ptd0 = 2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost ptd0 < 2 ^ log_n_steps\nend) (ptd : pt_dot) (IH1 : ptd_cost ptd < 2 ^ log_n_steps) : ptd_cost ptd < 2 ^ log_n_steps + 2 ^ log_n_steps.","proofString":"by apply Nat.lt_le_trans with (1 := IH1), Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) : match parse safe init (full_word ++ buffer_end) log_n_steps with\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"unfold parse.\nassert (Hparse := parse_fix_next_ptd_iter _ _ log_n_steps (parse_subproof init) Hstk).\nrewrite -ptd_buffer_build_from_pt -sem_build_from_pt /= in Hparse.\nassert (Hcost := next_ptd_iter_cost (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps).\ndestruct next_ptd_iter.\ndestruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r.\nrewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"assert (Hparse := parse_fix_next_ptd_iter _ _ log_n_steps (parse_subproof init) Hstk).\nrewrite -ptd_buffer_build_from_pt -sem_build_from_pt /= in Hparse.\nassert (Hcost := next_ptd_iter_cost (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps).\ndestruct next_ptd_iter.\ndestruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r.\nrewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : match next_ptd_iter (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (parse_fix safe init []\n           (ptd_buffer (build_pt_dot_from_pt full_pt Top_ptz)) log_n_steps\n           (parse_subproof init)) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (parse_fix safe init []\n         (ptd_buffer (build_pt_dot_from_pt full_pt Top_ptz)) log_n_steps\n         (parse_subproof init)) =\n    Accept_sr (ptd_sem (build_pt_dot_from_pt full_pt Top_ptz)) buffer_end\nend) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"rewrite -ptd_buffer_build_from_pt -sem_build_from_pt /= in Hparse.\nassert (Hcost := next_ptd_iter_cost (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps).\ndestruct next_ptd_iter.\ndestruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r.\nrewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : match next_ptd_iter (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n           (parse_subproof init)) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end\nend) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"assert (Hcost := next_ptd_iter_cost (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps).\ndestruct next_ptd_iter.\ndestruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r.\nrewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : match next_ptd_iter (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps with\n| Some ptd' =>\n    exists stk' : stack,\n      proj1_sig\n        (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n           (parse_subproof init)) = Progress_sr stk' (ptd_buffer ptd') /\\\n      ptd_stack_compat ptd' stk'\n| None =>\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end\nend) (Hcost : match next_ptd_iter (build_pt_dot_from_pt full_pt Top_ptz) log_n_steps with\n| Some ptd' =>\n    ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) =\n    2 ^ log_n_steps + ptd_cost ptd'\n| None => ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) < 2 ^ log_n_steps\nend) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"destruct next_ptd_iter.\ndestruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r.\nrewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (p : pt_dot) (Hparse : exists stk' : stack,\n  proj1_sig\n    (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n       (parse_subproof init)) = Progress_sr stk' (ptd_buffer p) /\\\n  ptd_stack_compat p stk') (Hcost : ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) =\n2 ^ log_n_steps + ptd_cost p) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"destruct Hparse as (? & -> & ?).\napply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (p : pt_dot) (x : stack) (H : ptd_stack_compat p x) (Hcost : ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) =\n2 ^ log_n_steps + ptd_cost p) : 2 ^ log_n_steps < pt_size full_pt.","proofString":"apply (f_equal S) in Hcost.\nrewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (p : pt_dot) (x : stack) (H : ptd_stack_compat p x) (Hcost : S (ptd_cost (build_pt_dot_from_pt full_pt Top_ptz)) =\nS (2 ^ log_n_steps + ptd_cost p)) : 2 ^ log_n_steps < pt_size full_pt.","proofString":"rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost.\nrewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (p : pt_dot) (x : stack) (H : ptd_stack_compat p x) (Hcost : pt_size full_pt = S (2 ^ log_n_steps + ptd_cost p)) : 2 ^ log_n_steps < pt_size full_pt.","proofString":"rewrite Hcost.\napply Nat.lt_succ_r, Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (p : pt_dot) (x : stack) (H : ptd_stack_compat p x) (Hcost : pt_size full_pt = S (2 ^ log_n_steps + ptd_cost p)) : 2 ^ log_n_steps < S (2 ^ log_n_steps + ptd_cost p).","proofString":"apply Nat.lt_succ_r, Nat.le_add_r."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : proj1_sig\n  (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n     (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end) (Hcost : ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) < 2 ^ log_n_steps) : match\n  match\n    proj1_sig\n      (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n         (parse_subproof init))\n  with\n  | Fail_sr_full st tok => Fail_pr_full st tok\n  | Accept_sr sem buffer' => Parsed_pr sem buffer'\n  | Progress_sr _ _ => Timeout_pr\n  end\nwith\n| Fail_pr_full _ _ => False\n| Timeout_pr => 2 ^ log_n_steps < pt_size full_pt\n| Parsed_pr sem buff =>\n    sem = pt_sem full_pt /\\\n    buff = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps\nend.","proofString":"rewrite Hparse.\nsplit; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : proj1_sig\n  (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n     (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end) (Hcost : ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) < 2 ^ log_n_steps) : pt_sem full_pt = pt_sem full_pt /\\\nbuffer_end = buffer_end /\\ pt_size full_pt <= 2 ^ log_n_steps.","proofString":"split; [|split]=>//.\napply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : proj1_sig\n  (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n     (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end) (Hcost : ptd_cost (build_pt_dot_from_pt full_pt Top_ptz) < 2 ^ log_n_steps) : pt_size full_pt <= 2 ^ log_n_steps.","proofString":"apply Nat.le_succ_l in Hcost.\nby rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."},{"statement":"(log_n_steps : nat) (Hstk : ptd_stack_compat (build_pt_dot_from_pt full_pt Top_ptz) []) (Hparse : proj1_sig\n  (parse_fix safe init [] (full_word ++ buffer_end) log_n_steps\n     (parse_subproof init)) = Accept_sr (pt_sem full_pt) buffer_end) (Hcost : S (ptd_cost (build_pt_dot_from_pt full_pt Top_ptz)) <= 2 ^ log_n_steps) : pt_size full_pt <= 2 ^ log_n_steps.","proofString":"by rewrite -ptd_cost_build_from_pt Nat.add_0_r in Hcost."}]}