{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/HbFsupp.v","fileSamples":[{"statement":"sc_per_loc G.","proofString":"apply coherence_sc_per_loc, IMMCON."},{"statement":"(SCPL : sc_per_loc G) : fsupp (co G)＊.","proofString":"rewrite rt_of_trans; [| apply co_trans; auto].\napply fsupp_cr.\napply FAIR."},{"statement":"(SCPL : sc_per_loc G) : fsupp (co G)^?.","proofString":"apply fsupp_cr.\napply FAIR."},{"statement":"(SCPL : sc_per_loc G) : fsupp (co G).","proofString":"apply FAIR."},{"statement":"(SCPL : sc_per_loc G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb G ∩ same_loc (lab G))^?).","proofString":"rewrite inclusion_inter_l1.\nrewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_eqv, fsupp_sb."},{"statement":"(SCPL : sc_per_loc G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb G)^?).","proofString":"rewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_eqv, fsupp_sb."},{"statement":"(SCPL : sc_per_loc G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb G)).","proofString":"relsf.\napply fsupp_union; auto using fsupp_eqv, fsupp_sb."},{"statement":"(SCPL : sc_per_loc G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G).","proofString":"apply fsupp_union; auto using fsupp_eqv, fsupp_sb."},{"statement":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb G)).","proofString":"relsf.\napply fsupp_union; auto using fsupp_sb, fsupp_eqv."},{"statement":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G).","proofString":"apply fsupp_union; auto using fsupp_sb, fsupp_eqv."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗fun a : actid => is_f (lab G) a⦘ ⨾ sb G)^? ⨾ rs G\n⊆ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb G)^?)\n  ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rs G.","proofString":"rewrite no_sb_to_init at 1.\nbasic_solver 10."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (⦗fun a : actid => is_f (lab G) a⦘ ⨾ sb G ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n  ⨾ rs G\n⊆ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb G)^?)\n  ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ rs G.","proofString":"basic_solver 10."},{"statement":"fsupp (⦗fun x : actid => ~ is_init x⦘ ⨾ (sb G)^?).","proofString":"rewrite crE.\nrelsf.\napply fsupp_union; auto using fsupp_sb, fsupp_eqv."},{"statement":"fsupp (⦗fun x : actid => ~ is_init x⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ sb G)).","proofString":"relsf.\napply fsupp_union; auto using fsupp_sb, fsupp_eqv."},{"statement":"fsupp\n  (⦗fun x : actid => ~ is_init x⦘ ∪ ⦗fun x : actid => ~ is_init x⦘ ⨾ sb G).","proofString":"apply fsupp_union; auto using fsupp_sb, fsupp_eqv."},{"statement":"fsupp (⦗acts_set G \\₁ (fun a : actid => is_init a)⦘ ⨾ (sb G ∪ sw G))⁺.","proofString":"arewrite (acts_set G \\₁ is_init ⊆₁ set_compl is_init); [basic_solver| ].\nrewrite seq_union_r.\neapply fsupp_ct with (s := acts_set G \\₁ is_init), fsupp_union; ins; eauto.\nrewrite 2!inclusion_seq_eqv_l.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10.\nrewrite (dom_l (@wf_sbE G)), (dom_l (wf_swE WF)); basic_solver 10.\nrewrite <- inclusion_union_r1.\neapply (@has_finite_antichains_sb G); eauto.\napply WF.\napply fsupp_sb; auto.\neapply fsupp_mori; [| apply fsupp_sw].\nred.\nbasic_solver 10."},{"statement":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (sb G ∪ sw G))⁺.","proofString":"rewrite seq_union_r.\neapply fsupp_ct with (s := acts_set G \\₁ is_init), fsupp_union; ins; eauto.\nrewrite 2!inclusion_seq_eqv_l.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10.\nrewrite (dom_l (@wf_sbE G)), (dom_l (wf_swE WF)); basic_solver 10.\nrewrite <- inclusion_union_r1.\neapply (@has_finite_antichains_sb G); eauto.\napply WF.\napply fsupp_sb; auto.\neapply fsupp_mori; [| apply fsupp_sw].\nred.\nbasic_solver 10."},{"statement":"fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G)⁺.","proofString":"eapply fsupp_ct with (s := acts_set G \\₁ is_init), fsupp_union; ins; eauto.\nrewrite 2!inclusion_seq_eqv_l.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10.\nrewrite (dom_l (@wf_sbE G)), (dom_l (wf_swE WF)); basic_solver 10.\nrewrite <- inclusion_union_r1.\neapply (@has_finite_antichains_sb G); eauto.\napply WF.\napply fsupp_sb; auto.\neapply fsupp_mori; [| apply fsupp_sw].\nred.\nbasic_solver 10."},{"statement":"acyclic\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G).","proofString":"rewrite 2!inclusion_seq_eqv_l.\ncdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10."},{"statement":"acyclic (sb G ∪ sw G).","proofString":"cdes IMMCON.\nred in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10."},{"statement":"(Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : coherence G) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : acyclic (sb G ∪ sw G).","proofString":"red in Cint.\ngeneralize Cint.\nunfold acyclic, hb.\nbasic_solver 10."},{"statement":"(Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : irreflexive (hb G ⨾ (eco G)^?)) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : acyclic (sb G ∪ sw G).","proofString":"generalize Cint.\nunfold acyclic, hb.\nbasic_solver 10."},{"statement":"(Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : irreflexive (hb G ⨾ (eco G)^?)) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : irreflexive (hb G ⨾ (eco G)^?) -> acyclic (sb G ∪ sw G).","proofString":"unfold acyclic, hb.\nbasic_solver 10."},{"statement":"(Wf_sc : wf_sc G sc) (Csc : coh_sc G sc) (Comp : complete G) (Cint : irreflexive (hb G ⨾ (eco G)^?)) (Cext : acyc_ext G sc) (Cat : rmw_atomicity G) : irreflexive ((sb G ∪ sw G)⁺ ⨾ (eco G)^?) -> irreflexive (sb G ∪ sw G)⁺.","proofString":"basic_solver 10."},{"statement":"doma\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G)\n  (acts_set G \\₁ (fun a : actid => is_init a)).","proofString":"rewrite (dom_l (@wf_sbE G)), (dom_l (wf_swE WF)); basic_solver 10."},{"statement":"has_finite_antichains (acts_set G \\₁ (fun a : actid => is_init a))\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G).","proofString":"rewrite <- inclusion_union_r1.\neapply (@has_finite_antichains_sb G); eauto.\napply WF."},{"statement":"has_finite_antichains (acts_set G \\₁ (fun a : actid => is_init a))\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G).","proofString":"eapply (@has_finite_antichains_sb G); eauto.\napply WF."},{"statement":"forall e : actid, acts_set G e -> threads_set G (tid e).","proofString":"apply WF."},{"statement":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb G).","proofString":"apply fsupp_sb; auto."},{"statement":"fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G).","proofString":"eapply fsupp_mori; [| apply fsupp_sw].\nred.\nbasic_solver 10."},{"statement":"Basics.flip inclusion (sw G)\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G).","proofString":"red.\nbasic_solver 10."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sw G ⊆ sw G.","proofString":"basic_solver 10."}]}