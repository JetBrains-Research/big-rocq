[{"statement":"Lemma sc_rf_in_sw :\n    ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ sw.","proof":"arewrite (Sc ⊆₁ Rel) at 1 by mode_solver.\narewrite (Sc ⊆₁ Acq)      by mode_solver.\nunfold imm_s_hb.sw, imm_s_hb.release, imm_s_hb.rs.\nrewrite !seqA.\nhahn_frame.\nrewrite (dom_l (wf_rfD WF)) at 1.\nbasic_solver 40.\n"},{"statement":"Lemma sc_rf_in_pscb :\n    ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ psc_base G.","proof":"arewrite (rf ⊆ rf ∩ same_loc).\n{\napply inclusion_inter_r; try basic_solver.\napply (wf_rfl WF).\n}\nrewrite <- seq_eqvK, !seqA.\narewrite (⦗Sc⦘ ⨾ rf ∩ same_loc ⨾ ⦗Sc⦘ ⊆ hb ∩ same_loc).\n{\napply inclusion_inter_r.\n{\nrewrite inclusion_inter_l1.\nrewrite sc_rf_in_sw.\napply sw_in_hb.\n}\nbasic_solver.\n}\nunfold psc_base.\nhahn_frame.\narewrite (hb ∩ same_loc ⊆ scb G).\nbasic_solver 10.\n"},{"statement":"Lemma co_sc_in_hb sc\n      (IPC : imm_s.imm_psc_consistent G sc) :\n  ⦗Sc⦘ ⨾ co ⨾ ⦗Sc⦘ ⊆ hb.","proof":"rewrite fsupp_imm_t with (r:=⦗Sc⦘ ⨾ co ⨾ ⦗Sc⦘).\n4: {\ngeneralize (co_trans WF).\nbasic_solver.\n}\n3: {\ngeneralize (co_irr WF).\nbasic_solver.\n}\n2: {\narewrite (⦗Sc⦘ ⨾ co ⨾ ⦗Sc⦘ ⊆ co) by basic_solver.\n}\nassert (sc_per_loc G) as SPL.\n{\napply coherence_sc_per_loc.\napply IPC.\n}\nassert (W ∩₁ Sc ⊆₁ codom_rel rmw) as WSCRMW.\n{\nrewrite WSCFACQRMW.\nbasic_solver.\n}\napply inclusion_t_ind, hb_trans; auto.\narewrite (immediate (⦗Sc⦘ ⨾ co ⨾ ⦗Sc⦘) ⊆ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⨾ sb).\n2: {\nsin_rewrite sc_rf_in_sw.\nrewrite sw_in_hb, sb_in_hb.\napply rewrite_trans, hb_trans.\n}\nrewrite (dom_r (wf_coD WF)).\nrewrite !seqA.\nrewrite <- id_inter.\nrewrite WSCFACQRMW.\nintros w1 w2 [co_rmw_w1_w2 imm_w1_w2].\napply seq_eqv_l in co_rmw_w1_w2.\ndestruct co_rmw_w1_w2 as [SCW1 co_rmw_w1_w2].\napply seq_eqv_r in co_rmw_w1_w2.\ndestruct co_rmw_w1_w2 as [co_rmw_w1_w2 tmp].\ndestruct tmp as [f2 tmp].\nrewrite <- seqA2 in tmp.\ndestruct tmp as [r2 [SB_f2_r2 rw_r2_w2]].\napply seq_eqv_l.\nsplit; auto.\nassert (Sc r2) as SCR2.\n{\napply RMWSC in rw_r2_w2.\ngeneralize rw_r2_w2.\nbasic_solver.\n}\nassert (E r2) as ER2.\n{\napply (dom_l (wf_rmwE WF)) in rw_r2_w2.\ngeneralize rw_r2_w2.\nbasic_solver.\n}\nassert (R r2) as EW.\n{\napply (dom_l (wf_rmwD WF)) in rw_r2_w2.\ngeneralize rw_r2_w2.\ntype_solver.\n}\nexists r2.\nsplit.\n2: {\napply seq_eqv_l.\nsplit; auto.\napply rmw_in_sb; auto.\n}\nassert (exists w', rf w' r2) as [w' RF].\n{\napply IPC.\nsplit; auto.\n}\ndestruct (classic (w1 = w')) as [|NEQ]; desf.\nassert (E w') as EW'.\n{\napply (wf_rfE WF) in RF.\ngeneralize RF.\nbasic_solver.\n}\nassert (W w') as WW'.\n{\napply (wf_rfD WF) in RF.\ngeneralize RF.\nbasic_solver.\n}\nset (GG := WW').\napply is_w_loc in GG.\ndesf.\nassert (loc r2 = Some l) as LOCR2.\n{\nrewrite <- GG.\nsymmetry.\napply wf_rfl; auto.\n}\nassert (same_loc_w1_w': same_loc w1 w').\n{\nred.\nrewrite GG.\nrewrite <- LOCR2.\napply (wf_col WF) in co_rmw_w1_w2.\nred in co_rmw_w1_w2.\napply (wf_rmwl WF) in rw_r2_w2.\nred in rw_r2_w2.\nsymmetry in rw_r2_w2.\napply (same_loc_trans co_rmw_w1_w2 rw_r2_w2).\n}\nassert (E w1) as EW1.\n{\napply (dom_l (wf_coE WF)) in co_rmw_w1_w2.\ngeneralize co_rmw_w1_w2.\nbasic_solver.\n}\nassert (W w1) as WW1.\n{\napply (dom_l (wf_coD WF)) in co_rmw_w1_w2.\ngeneralize co_rmw_w1_w2.\nbasic_solver.\n}\ndestruct (classic (is_init w')) as [INIT|NINIT].\n{\nassert (co w' w1) as CO.\n{\napply co_from_init; auto.\nunfolder.\nsplits; eauto; desf.\n}\nexfalso.\neapply atomicity_alt; eauto.\n{\napply IPC.\n}\nsplit; eauto.\ndo 2 (eexists; split; eauto).\n}\nassert (Sc w') as SCW'.\n{\nspecialize (LSM l).\ndestruct LSM as [CC|CC].\n2: {\napply CC.\nsplit; auto.\n}\nexfalso.\nassert (~ is_init r2) as NINITR2.\n{\neapply read_or_fence_is_not_init; eauto.\n}\nassert ((Loc_ l \\₁ is_init) r2) as DD by (by split).\napply CC in DD.\nclear -SCR2 DD.\nmode_solver.\n}\nassert (codom_rel rmw w') as RMWW'.\n{\napply WSCRMW.\nby split.\n}\neapply wf_co_total in NEQ; eauto.\n2,3: split; [split|]; auto.\ncdes IPC.\ncdes IC.\nexfalso.\ndestruct NEQ as [NEQ|NEQ].\n2: {\neapply atomicity_alt; eauto.\nsplit; eauto.\ndo 2 (eexists; split; eauto).\n}\napply imm_w1_w2 with (c:=w').\n{\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; auto.\napply WSCFACQRMW.\nby split.\n}\napply seq_eqv_l.\nsplit; auto.\napply seq_eqv_r.\nsplit; auto.\n2: {\neexists.\nrewrite <- seqA2.\neexists.\nsplit; eauto.\n}\napply rf_rmw_in_co; auto.\neexists.\neauto.\n"},{"statement":"Lemma ohb_in_hb sc (IPC : imm_s.imm_psc_consistent G sc) :\n  ohb ⊆ hb.","proof":"unfold OCaml.hb.\nrewrite !seq_union_l, !seq_union_r.\nrewrite co_sc_in_hb; eauto.\nsin_rewrite sc_rf_in_sw.\nrewrite sb_in_hb, sw_in_hb, !unionK.\nunfold imm_s_hb.hb.\nby rewrite ct_of_ct.\n"},{"statement":"Lemma imm_to_ocaml_coherent sc (IPC : imm_s.imm_psc_consistent G sc) :\n  irreflexive (ohb ⨾ (co ∪ fr)).","proof":"rewrite ohb_in_hb; eauto.\narewrite (co ∪ fr ⊆ eco^?).\n{\nrewrite co_in_eco, fr_in_eco.\nbasic_solver.\n}\napply IPC.\n"},{"statement":"Lemma trans_co_fr : transitive (co ∪ fr).","proof":"apply transitiveI.\nrewrite seq_union_r.\ndo 2 rewrite seq_union_l.\nrewrite co_co, fr_co, fr_fr, co_fr; auto.\nbasic_solver.\n"},{"statement":"Lemma sc_scb_pscb : (⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘ ⊆ psc_base G).","proof":"unfold psc_base.\nbasic_solver 10.\n"},{"statement":"Lemma wr_mode: Eninit ∩₁ (W ∪₁ R) ⊆₁ Sc ∪₁ ORlx.","proof":"unfolder.\nins.\ndesc.\nassert (exists l, Loc_ l x) as [l LX].\n{\nunfold Events.loc.\nunfold is_f, is_r, is_w in *.\ndestruct (lab x) eqn:AA; simpls; desf.\nall: eauto.\n}\ndestruct (LSM l) as [LL|LL]; [right|left].\nall: eapply LL; split; auto.\n"},{"statement":"Lemma sl_mode r (SL: r ⊆ same_loc):\n  ⦗Eninit \\₁ F⦘ ⨾ r ⨾ ⦗Eninit \\₁ F⦘ ⊆ ⦗Sc⦘ ⨾ r ⨾ ⦗Sc⦘ ∪ ⦗ORlx⦘ ⨾ r ⨾ ⦗ORlx⦘.","proof":"red.\nintros x y HH.\napply seq_eqv_lr in HH.\ndestruct HH as [[[EX NIX] NFX] [HH [[EY NIY] NFY]]].\nassert (exists l, Loc_ l x) as [l LX].\n{\nunfold Events.loc.\nunfold is_f in *.\ndestruct (lab x) eqn:AA; simpls.\nall: eauto.\n}\nassert (Loc_ l y) as LY.\n{\nrewrite <- LX.\nsymmetry.\nby apply SL.\n}\ndestruct (LSM l) as [LL|LL]; [right|left].\nall: apply seq_eqv_lr; splits; auto.\nall: eapply LL; split; auto.\n"},{"statement":"Lemma sc_ninit : Sc ⊆₁ set_compl is_init.","proof":"rewrite (init_pln WF).\nmode_solver.\n"},{"statement":"Lemma sc_rf_l : ⦗Sc⦘ ⨾ rf ⊆ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘.","proof":"rewrite (wf_rfD WF) at 1.\nrewrite (wf_rfE WF) at 1.\nrewrite !seqA.\narewrite (⦗Sc⦘ ⨾ ⦗W⦘ ⨾ ⦗E⦘ ⊆ ⦗Eninit \\₁ F⦘ ⨾ ⦗Sc⦘).\n{\narewrite (Sc ⊆₁ Sc ∩₁ set_compl is_init).\n{\ngeneralize sc_ninit.\nbasic_solver.\n}\ntype_solver.\n}\nrewrite <- id_inter.\narewrite (E ∩₁ R ⊆₁ Eninit \\₁ F).\n{\nrewrite init_w; eauto.\ntype_solver.\n}\nseq_rewrite seq_eqvC.\nrewrite !seqA.\nsin_rewrite sl_mode; [| by apply (wf_rfl WF) ].\nmode_solver.\n"},{"statement":"Lemma sc_rf_r : ⦗set_compl is_init⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘.","proof":"rewrite WF.(wf_rfD) at 1.\nrewrite WF.(wf_rfE) at 1.\nrewrite !seqA.\narewrite (⦗set_compl is_init⦘ ⨾ ⦗W⦘ ⨾ ⦗E⦘ ⊆ ⦗Eninit \\₁ F⦘) by type_solver.\narewrite (⦗E⦘ ⨾ ⦗R⦘ ⊆ ⦗Eninit \\₁ F⦘).\n{\nrewrite init_w; eauto.\ntype_solver.\n}\nsin_rewrite sl_mode; [| apply (wf_rfl WF) ].\nmode_solver.\n"},{"statement":"Lemma dom_crt: forall (A : Type) (dom : A -> Prop) r,\n    ⦗dom⦘ ⨾ (r ⨾ ⦗dom⦘)＊ ⊆ ⦗dom⦘ ⨾ (r ⨾ ⦗dom⦘)＊ ⨾ ⦗dom⦘.","proof":"intros A dom r.\nrewrite rtE at 1.\nrewrite seq_union_r.\nunionL; [basic_solver| ].\nhahn_frame.\nrewrite ct_end at 1.\nrewrite <- seq_eqvK at 2.\nhahn_frame_r.\nrewrite <- ct_end.\nbasic_solver.\n"},{"statement":"Lemma sb_w_sync : \n    ⦗E \\₁ F⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ sb ⨾ (⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗ORlx⦘ ∪ ⦗F ∩₁ Acq⦘ ⨾ sb ⨾ ⦗Sc⦘) ⨾ ⦗W⦘ ∪ rmw ⨾ ⦗W⦘.","proof":"rewrite (dom_r (wf_sbE G)) at 1.\nrewrite inclusion_union_minus with (r:=sb) (r':=rmw) at 1.\nrewrite !seq_union_l, !seq_union_r.\napply union_mori; [|basic_solver].\nrewrite no_sb_to_init at 1.\nrewrite seq_eqv_minus_lr.\nrewrite !seqA.\narewrite (⦗set_compl is_init⦘ ⨾ ⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗W ∩₁ Sc ∪₁ W ∩₁ ORlx⦘).\n{\nunfolder.\nins.\ndesf.\nsplits; auto.\ndestruct wr_mode with (x:=y); auto.\nbasic_solver.\n}\nrewrite id_union.\nrewrite !seq_union_r.\nunionL.\n2: {\nunionR left.\nrewrite <- (seq_eqvK (W ∩₁ ORlx)).\nrewrite WRLXF at 1.\nunfolder.\nintros e w H'.\ndestruct H' as [H'' [H' [[f' [f U]] T']]].\ndesf.\nassert (~is_init f) as NINITf.\n{\ngeneralize (@read_or_fence_is_not_init G WF f).\ntype_solver.\n}\nexists f.\nsplits; auto.\nassert (e <> f) as NEQfe.\n{\nred.\ntype_solver.\n}\npose (sb_semi_total_r WF NINITf NEQfe H' U0 ) as SB.\ndestruct SB; auto.\nexfalso.\nspecialize (U1 e).\nauto.\n}\nunionR right.\nrewrite <- (seq_eqvK (W ∩₁ Sc)) at 1.\nrewrite WSCFACQRMW at 1.\nunfolder.\nintros e w [H' [w' [[f' [f U]] V]]].\ndestruct U as [N [r' Z]].\ndesf.\nexists f.\nassert (immediate sb r' w) as [SBr'w IMMr'w].\n{\napply (wf_rmwi WF) in Z0.\nauto.\n}\nsplits; auto.\n2: {\napply (rmw_in_sb WF) in Z0.\napply (sb_trans Z Z0).\n}\nassert (e <> f) as NEQfe.\n{\nred.\ntype_solver.\n}\nassert (sb e r') as SBer'.\n{\nassert (e <> r') as NEQer'.\n{\nred.\ntype_solver.\n}\nassert (~is_init r') as NINITr'.\n{\napply ((wf_rmwD WF)), seq_eqv_l in Z0.\ndesf.\ngeneralize (@read_or_fence_is_not_init G WF r').\ntype_solver 10.\n}\npose (sb_semi_total_r WF NINITr' NEQer' w') as SB.\ndestruct SB; auto.\nexfalso.\nspecialize (IMMr'w e).\nauto.\n}\nassert (~is_init f) as NINITf.\n{\ngeneralize (@read_or_fence_is_not_init G WF f).\ntype_solver.\n}\npose (sb_semi_total_r WF NINITf NEQfe SBer' Z) as SB.\ndestruct SB; auto.\nexfalso.\nspecialize (Z1 e).\nauto.\n"},{"statement":"Lemma sb_r_sc_sync :\n  ⦗E \\₁ F⦘ ⨾  sb ⨾ ⦗R⦘ ⨾ ⦗Sc⦘ ⊆ sb ⨾ ⦗F ∩₁ Acq⦘ ⨾ sb ⨾ ⦗R⦘ ⨾ ⦗Sc⦘.","proof":"rewrite <- id_inter.\nrewrite <- (seq_eqvK (R ∩₁ Sc)).\nrewrite RSCF at 1.\nunfolder.\nintros e r [A [C [[f' [f U]] V]]].\ndesf.\nexists f.\nsplits; auto.\nassert (e <> f) as NEQfe.\n{\nred.\ntype_solver.\n}\nassert (~is_init f) as NINITf.\n{\ngeneralize (@read_or_fence_is_not_init G WF f).\ntype_solver.\n}\npose (sb_semi_total_r WF NINITf NEQfe C U0) as SB.\ndestruct SB; auto.\nexfalso.\nspecialize (U1 e).\nauto.\n"},{"statement":"Lemma sb_rf_sc_sc : (* TODO *)\n  sb ⨾ rf ⨾ ⦗Sc⦘ ⊆ sb ⨾ ⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘.","proof":"rewrite no_sb_to_init at 1.\nrewrite !seqA.\nby sin_rewrite sc_rf_r.\n"},{"statement":"Lemma rmw_rf_hbl :\n  rmw ⨾ rf ⊆ ⦗Sc⦘ ⨾ hb ∩ same_loc ⨾ ⦗Sc⦘.","proof":"rewrite RMWSC, !seqA, sc_rf_l.\nhahn_frame.\napply inclusion_inter_r.\n2: {\nrewrite (wf_rmwl WF), (wf_rfl WF), inclusion_seq_eqv_l.\nrewrite rewrite_trans by apply same_loc_trans.\nbasic_solver.\n}\nrewrite (rmw_in_sb WF), sc_rf_l, sc_rf_in_sw.\nunfold imm_s_hb.hb.\nrewrite ct_begin, <- inclusion_t_rt, ct_begin.\nbasic_solver 10.\n"},{"statement":"Lemma f_hb :\n  ((⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗ORlx⦘ ⨾ rf ∪ sb ⨾ ⦗Sc⦘ ⨾ rf)\n     ⨾ (rmw ⨾ rf)＊ ⨾ sb ⨾ ⦗F ∩₁ Acq⦘) ⊆ hb.","proof":"rewrite (dom_l (wf_rfD WF)) at 1.\nrewrite seq_union_l, !seqA.\nseq_rewrite <- rt_seq_swap.\nrewrite !seqA.\nassert (⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw)＊ ⊆ release) as REL.\n{\nunfold imm_s_hb.release, imm_s_hb.rs.\narewrite (⦗W⦘ ⨾ (rf ⨾ rmw)＊ ⊆ ⦗W⦘ ⨾ (sb ∩ same_loc)^? ⨾ ⦗W⦘ ⨾ (rf ⨾ rmw)＊).\n{\nbasic_solver 10.\n}\narewrite (⦗F ∩₁ Acqrel⦘ ⨾ sb ⊆ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?); [|done].\nmode_solver 10.\n}\nrewrite inclusion_seq_eqv_l with (dom:=ORlx).\nsin_rewrite REL.\nunionL.\n{\nrewrite <- sw_in_hb.\nunfold imm_s_hb.sw.\nhahn_frame.\nrewrite id_inter.\nsin_rewrite (r_step (sb ⨾ ⦗F⦘)).\nbasic_solver 10.\n}\narewrite (⦗Sc⦘ ⨾ (rf ⨾ rmw)＊ ⊆ ⦗Sc⦘ ⨾ (rf ⨾ rmw)＊ ⨾ ⦗Sc⦘).\n{\nrewrite RMWSC.\ndo 2 rewrite <- seqA.\nsin_rewrite dom_crt.\nbasic_solver.\n}\nsin_rewrite sc_rf_l.\narewrite (sb ⊆ hb).\nsin_rewrite sc_rf_in_sw.\nsin_rewrite sw_in_hb.\narewrite (⦗Sc⦘ ⨾ (rf ⨾ rmw)＊ ⊆ hb＊).\n{\nrewrite rtE, seq_union_r.\nunionL; [basic_solver| ].\nrewrite ct_rotl.\nrewrite rmw_rf_hbl.\nsin_rewrite sc_rf_l.\nsin_rewrite (rmw_in_sb WF).\nsin_rewrite sb_in_hb.\nsin_rewrite sc_rf_in_sw.\nsin_rewrite sw_in_hb.\nrewrite inclusion_seq_eqv_l,  inclusion_seq_eqv_r.\narewrite (hb ∩ same_loc ⊆ hb).\nseq_rewrite <- ct_begin.\nrewrite ct_unit.\nbasic_solver.\n}\nrewrite inclusion_seq_eqv_r.\nseq_rewrite <- ct_begin.\ndo 2 sin_rewrite ct_unit.\napply ct_of_trans, hb_trans.\n"},{"statement":"Lemma rf_scb : (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ ⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘).","proof":"rewrite <- seq_eqvK at 1.\nrewrite <- seq_eqvK at 3.\nrewrite !seqA.\nhahn_frame.\nunfold scb.\narewrite (⦗Sc⦘ ⨾ rf ⨾ ⦗Sc⦘ ⊆ hb ∩ same_loc).\n{\napply inclusion_inter_r.\n{\nrewrite <- sw_in_hb.\napply sc_rf_in_sw.\n}\nrewrite inclusion_seq_eqv_l, inclusion_seq_eqv_r.\napply (wf_rfl WF).\n}\nbasic_solver 10.\n"},{"statement":"Lemma sbnl_hb_scb: ((sb \\ same_loc) ⨾ hb＊ ⨾ (sb \\ same_loc) ⊆ scb G).","proof":"unfold scb.\nrewrite rtE.\nrepeat case_union _ _.\nunionL.\n{\nseq_rewrite seq_id_r.\ndo 2 arewrite (sb \\ same_loc ⊆ sb).\nrewrite rewrite_trans; [| apply sb_trans].\nbasic_solver 10.\n}\nrewrite ct_of_trans; [| apply hb_trans].\nbasic_solver 20.\n"},{"statement":"Lemma wr_fb_nl: (⦗W ∪₁ R⦘ ⨾ sb ⨾ ⦗F⦘ ⊆ sb \\ same_loc).","proof":"unfold Events.same_loc, Events.loc, is_w, is_f, is_r.\nunfolder.\nins.\ndesf.\n"},{"statement":"Lemma scb_chain :\n  (⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⨾ (sb ⨾ ⦗F ∩₁ Acq⦘ ⨾ (⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗ORlx⦘ ⨾ rf ∪ sb ⨾ ⦗Sc⦘ ⨾ rf) ⨾ (rmw ⨾ rf)＊)⁺ ⨾ sb ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘) ⊆ (⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)⁺.","proof":"rewrite <- seqA with (r1:=sb).\nrewrite ct_rotl.\nrewrite !seqA.\nrewrite <- !seqA with (r3:=(⦗F ∩₁ Acq⦘)).\nsin_rewrite dom_crt.\nrewrite !seqA.\nsin_rewrite f_hb.\nassert (⦗W ∪₁ R⦘ ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⨾ hb＊ ⨾ ⦗F ∩₁ Acq⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ scb G) as SCB'.\n{\nrewrite rtE.\nrepeat case_union _ _.\nunionL.\n{\nrepeat rewrite inclusion_seq_eqv_l.\nhahn_frame.\nrewrite inclusion_seq_eqv_r, rewrite_trans; [| apply sb_trans].\nunfold scb.\nbasic_solver 10.\n}\narewrite (F ∩₁ Acq ⊆₁ F) by basic_solver.\nsin_rewrite wr_fb_nl.\narewrite (W ⊆₁ W ∪₁ R).\nsin_rewrite fb_wr_nl.\nhahn_frame.\nrewrite ct_of_trans; [| apply hb_trans].\narewrite (hb ⊆ hb＊).\napply sbnl_hb_scb.\n}\nrepeat case_union _ _.\nunionL.\n2: {\nrewrite (dom_l (wf_rfD WF)) at 1.\nseq_rewrite (seq_eqvC Sc W).\nrewrite !seqA.\nsin_rewrite sc_rf_l.\nrewrite <- seqA with (r2:=⦗W⦘).\nsin_rewrite SCB'.\nrewrite <- seq_eqvK at 2.\nrewrite !seqA.\nrewrite <- ct_ct.\nrewrite ct_begin at 1.\nhahn_frame.\nsin_rewrite rf_scb.\nrewrite <- seq_eqvK at 2.\nrewrite !seqA.\nrewrite rt_ct, ct_begin.\nhahn_frame.\nrewrite rmw_rf_hbl.\narewrite (hb ∩ same_loc ⊆ scb G).\nrewrite <- !seqA with (r3:=(⦗Sc⦘)).\nsin_rewrite dom_crt.\nrewrite !seqA.\nrewrite (inclusion_seq_eqv_l).\nrewrite <- rt_rt at 2.\nhahn_frame_l.\nrewrite inclusion_seq_eqv_l with (dom:=(W ∪₁ R)).\narewrite (sb ⊆ scb G).\nrewrite <- inclusion_t_rt.\nrewrite ct_begin.\nhahn_frame.\n}\nrewrite !seqA.\narewrite (sb ⨾ ⦗ORlx⦘ ⨾ rf ⊆ sb ⨾ ⦗ORlx⦘ ⨾ rf ⨾ ⦗ORlx⦘).\n{\nrewrite ((wf_rfE WF)), ((wf_rfD WF)) at 1.\nrewrite no_sb_to_init, (no_rf_to_init WF) at 1.\nhahn_frame_l.\narewrite (⦗fun x : actid => ~ is_init x⦘ ⨾ ⦗ORlx⦘ ⨾ ⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗ORlx⦘ ⨾ ⦗E \\₁ (fun a : actid => is_init a) \\₁ F⦘) by mode_solver.\narewrite (⦗fun x : actid => ~ is_init x⦘ ⨾ ⦗R⦘ ⨾ ⦗E⦘ ⊆ ⦗E \\₁ (fun a : actid => is_init a) \\₁ F⦘) by mode_solver.\nrewrite (sl_mode (wf_rfl WF)).\nrewrite seq_union_r.\nunionL; [mode_solver| ].\nbasic_solver.\n}\narewrite (⦗ORlx⦘ ⨾ (rmw ⨾ rf)＊ ⊆ ⦗ORlx⦘).\n{\nrewrite rtE, seq_union_r.\nunionL; [basic_solver| ].\nrewrite ct_begin, RMWSC, !seqA.\nmode_solver.\n}\narewrite (rf ⨾ ⦗ORlx⦘ ⨾ sb ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘ ⊆ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⨾ sb ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘).\n{\nrewrite (dom_r ((wf_rfD WF))), (dom_r ((wf_rfE WF))) at 1.\nrewrite !seqA.\narewrite (⦗E⦘ ⨾ ⦗R⦘ ⊆ ⦗E \\₁ F⦘) by type_solver.\nhahn_frame_l.\nseq_rewrite (@seq_eqvC _ _ ORlx).\nrewrite seqA.\nrewrite id_union at 1.\ncase_union _ _.\ndo 3 rewrite seq_union_r at 1.\nunionL.\n{\nhahn_frame_r.\nrewrite sb_w_sync, seq_union_r.\nunionL.\n2: {\nrewrite RMWSC, seqA.\nmode_solver.\n}\nrewrite inclusion_seq_eqv_l.\narewrite (W ⊆₁ W ∪₁ R) at 1.\nhahn_frame.\nmode_solver.\n}\nrewrite sb_r_sc_sync.\narewrite (R ⊆₁ W ∪₁ R) at 1.\nhahn_frame.\nbasic_solver.\n}\npose f_hb.\nrewrite seq_union_l,  <- inclusion_union_r1 in i.\nrewrite rtE, <- inclusion_union_r1, seq_id_l, !seqA in i.\nrewrite <- seq_eqvK with (dom:=(F ∩₁ Acq)) at 3.\nrewrite seqA.\nsin_rewrite i.\nsin_rewrite (@inclusion_seq_eqv_l actid hb (F ∩₁ Acq)).\nseq_rewrite <- ct_end.\nrewrite ct_of_trans by apply hb_trans.\narewrite (F ∩₁ Acq ⊆₁ F) by mode_solver.\nsin_rewrite wr_fb_nl.\nsin_rewrite fb_wr_nl.\npose sbnl_hb_scb.\nrewrite rtE, <- inclusion_union_r2, ct_of_trans in i0; [| apply hb_trans].\nsin_rewrite i0.\nrewrite ct_begin.\nhahn_frame.\n"},{"statement":"Lemma rmw_rf_ct_sb_scb :\n  (rmw ⨾ rf)⁺ ⨾ sb ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘ ⊆ (⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)⁺.","proof":"rewrite rmw_rf_hbl.\narewrite (hb ∩ same_loc ⊆ scb G).\narewrite ((⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)⁺ ⊆ (⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)⁺ ⨾ ⦗Sc⦘).\n{\nrewrite ct_end.\nrewrite <- seq_eqvK at 4.\nbasic_solver.\n}\narewrite (⦗Sc⦘ ⨾ sb ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘ ⊆ (⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)).\n{\narewrite (⦗W ∪₁ R⦘ ⨾ ⦗Sc⦘ ⊆ ⦗Sc⦘).\nunfold scb.\nbasic_solver 10.\n}\nrewrite ct_unit.\nbasic_solver.\n"},{"statement":"Lemma sc_sb_rf_ct_sb_pscb :\n  (⦗Sc ∩₁ (W ∪₁ R)⦘ ⨾ (sb ⨾ rf)＊ ⨾ sb ⨾ ⦗(W ∪₁ R) ∩₁ Sc⦘ ⊆ (psc_base G)⁺).","proof":"rewrite <- sc_scb_pscb.\nrewrite rtE.\ndo 2 case_union _ _.\nunionL.\n{\narewrite (sb ⊆ scb G).\nrewrite <- ct_step.\nbasic_solver.\n}\nrewrite !id_inter, !seqA.\narewrite (⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⨾ (sb ⨾ rf)⁺ ⊆ ⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⨾ (⦗E \\₁ F⦘ ⨾ sb ⨾ rf)⁺).\n{\nrewrite ct_rotl at 1.\narewrite (rf ≡ rf ⨾ ⦗R⦘) at 1 by eapply (dom_r (wf_rfD WF)).\narewrite (rf ⨾ ⦗R⦘ ⊆ rf ⨾ ⦗E \\₁ F⦘).\n{\nrewrite (dom_r (wf_rfE WF)) at 1.\nrewrite seqA.\nhahn_frame.\ntype_solver.\n}\narewrite (⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⨾ sb ⊆ ⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⨾ ⦗E \\₁ F⦘ ⨾ sb).\n{\nrewrite <- (seq_eqvK (W ∪₁ R)) at 1.\nrewrite <- (seq_eqvK (Sc)) at 1.\nrewrite !seqA.\nseq_rewrite (seq_eqvC (Sc) (W ∪₁ R)).\narewrite (sb ≡ ⦗E⦘ ⨾ sb) by eapply (dom_l (wf_sbE G)).\narewrite (⦗W ∪₁ R⦘ ⨾ ⦗E⦘ ⊆ ⦗E \\₁ F⦘) by mode_solver.\nhahn_frame.\nbasic_solver.\n}\nrewrite <- seq_eqvK at 1.\nrewrite seqA at 1.\nrewrite <- (seqA _ sb _).\nrewrite <- ct_rotl.\nseq_rewrite seq_eqvK.\nbasic_solver 10.\n}\nrewrite (dom_l (wf_rfD WF)) at 1.\nsin_rewrite sb_w_sync.\nrewrite <- seq_eqvK with (dom:=F ∩₁ Acqrel).\ncase_union _ _.\nseq_rewrite ct_unionE.\ncase_union ((rmw ⨾ ⦗W⦘) ⨾ rf)⁺ _.\ndo 2 rewrite seq_union_r.\nunionL.\n{\nrewrite inclusion_seq_eqv_r.\nsin_rewrite rmw_rf_ct_sb_scb.\nbasic_solver.\n}\nrewrite !seqA.\narewrite (⦗W ∪₁ R⦘ ⨾ (rmw ⨾ ⦗W⦘ ⨾ rf)＊ ⊆ ⦗W ∪₁ R⦘ ⨾ (rmw ⨾ rf)＊ ⨾ ⦗W ∪₁ R⦘).\n{\nrewrite inclusion_seq_eqv_l with (dom:=W).\nrewrite (dom_r (wf_rfD WF)) at 1.\narewrite (R ⊆₁ W ∪₁ R) at 2.\nrewrite <- seqA.\nrewrite dom_crt.\nrewrite !seqA.\nhahn_frame.\nrewrite inclusion_seq_eqv_r.\nbasic_solver.\n}\nrewrite rmw_rf_hbl at 1.\narewrite (hb ∩ same_loc ⊆ scb G).\nseq_rewrite (@seq_eqvC _ Sc _).\nrewrite seqA.\nrewrite <- seqA with (r3:=⦗Sc⦘).\nsin_rewrite dom_crt.\nrewrite !seqA.\nrewrite <- rt_ct with (r:=(⦗Sc⦘ ⨾ scb G ⨾ ⦗Sc⦘)).\ndo 2 rewrite inclusion_seq_eqv_l at 1.\nhahn_frame_l.\npose scb_chain.\nrewrite <- !seqA with (r3:=rf) in i.\nrewrite <- seq_union_l in i.\narewrite (Acqrel ⊆₁ Acq) at 1 by mode_solver.\nrewrite <- seq_union_r.\ndo 2 sin_rewrite (@inclusion_seq_eqv_r actid _ W).\nrewrite !seqA.\nrewrite !seqA in i.\nauto.\n"},{"statement":"Lemma sc_sb_rf_ct_pscb :\n  (⦗Sc ∩₁ (W ∪₁ R)⦘ ⨾ (sb ⨾ rf)⁺ ⨾ ⦗Sc⦘ ⊆ (psc_base G)⁺).","proof":"rewrite ct_end, !seqA.\nsin_rewrite sb_rf_sc_sc; auto.\nrewrite (dom_l (wf_rfD WF)) at 2.\nrewrite <- seq_eqvK with (dom:=Sc) at 1.\nrewrite !seqA.\nseq_rewrite (seq_eqvC Sc W).\nrewrite !seqA.\nsin_rewrite (sc_rf_in_pscb); auto.\nrewrite ct_end.\nhahn_frame.\narewrite (⦗Sc⦘ ⨾ ⦗W⦘ ⊆ ⦗(W ∪₁ R) ∩₁ Sc⦘) by mode_solver.\nrewrite sc_sb_rf_ct_sb_pscb.\nbasic_solver.\n"},{"statement":"Lemma acyclic_sb_rf sc (IPC: imm_psc_consistent G sc):\n  acyclic (sb ∪ rf).","proof":"cdes IPC.\ncdes IC.\nrewrite rfi_union_rfe, <- unionA.\narewrite (rfi ⊆ sb).\nrewrite unionK.\napply acyclic_union.\n{\nrewrite sb_in_hb.\ncdes Cint.\nred.\nrewrite ct_of_trans; [| apply hb_trans].\narewrite (hb ⊆ hb ⨾ eco^?); [basic_solver|auto].\n}\nrewrite acyclic_rotl, rtE, seq_union_l, seq_id_l.\nrewrite ct_of_trans by apply sb_trans.\nred in Cext.\ncdes Cext.\napply acyclic_union.\n{\napply acyclic_disj.\nrewrite (wf_rfeD WF).\nmode_solver.\n}\nrewrite seqA, <- ct_begin.\narewrite (rfe⁺ ≡ rfe).\n{\nrewrite ct_begin, rtE, seq_union_r.\nrewrite ct_begin.\nrewrite (wf_rfeD WF) at 2.\nrewrite (wf_rfeD WF) at 3.\ntype_solver.\n}\nrewrite (wf_rfeD WF), (dom_r (wf_rfeE WF)), seqA.\narewrite (⦗E⦘ ⨾ ⦗R⦘ ⊆ ⦗E \\₁ F⦘) by type_solver.\narewrite (rfe ⊆ ar sc).\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl, !seqA.\nsin_rewrite sb_w_sync.\nseq_rewrite seq_union_r.\narewrite (F ∩₁ Acqrel ⊆₁ F ∩₁ Acq/Rel) by mode_solver.\narewrite (F ∩₁ Acq ⊆₁ F ∩₁ Acq/Rel) by mode_solver.\nrewrite <- seq_eqvK with (dom:=(F ∩₁ Acq/Rel)), !seqA.\nrepeat arewrite (sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ⊆ imm_bob.bob G).\nrepeat arewrite (⦗F ∩₁ Acq/Rel⦘ ⨾ sb ⊆ imm_bob.bob G).\nrewrite RMWSC, (wf_rmwD WF).\nrewrite !seqA.\narewrite (⦗Sc⦘ ⨾ ⦗R⦘ ⊆ ⦗R ∩₁ Acq⦘) by mode_solver.\nrewrite (rmw_in_sb WF).\narewrite (⦗R ∩₁ Acq⦘ ⨾ sb ⊆ imm_bob.bob G).\nrewrite bob_in_ar.\nrepeat rewrite inclusion_seq_eqv_r.\ndo 2 rewrite seq_union_l.\nrewrite !seqA, unionK.\narewrite (ar sc ⨾ ar sc ⨾ ar sc ⊆ (ar sc)⁺).\n{\ndo 2 rewrite <- ct_ct at 1.\nrewrite <- !ct_step.\nbasic_solver 10.\n}\narewrite (ar sc ⨾ ar sc ⊆ (ar sc)⁺).\n{\nrewrite <- ct_ct at 1.\nrewrite <- ct_step.\nbasic_solver 10.\n}\nrewrite unionK.\nred in Cext.\nred.\nrewrite ct_of_ct.\nauto.\n"},{"statement":"Lemma imm_to_ocaml_causal sc\n      (IPC : imm_s.imm_psc_consistent G sc) :\n  acyclic (sb ∪ rfe ∪ ⦗Sc⦘ ⨾ (coe ∪ fre G) ⨾ ⦗Sc⦘).","proof":"arewrite (rfe ⊆ rf).\narewrite (coe ⊆ co).\narewrite (fre G ⊆ fr).\nassert (⦗Sc⦘ ⨾ (co ∪ fr) ⨾ ⦗Sc⦘ ⊆ psc_base G) as CO_FR_PSCB.\n{\nunfold psc_base.\nhahn_frame.\narewrite (co ∪ fr ⊆ scb G).\nbasic_solver 10.\n}\napply acyclic_union1.\n{\napply (@acyclic_sb_rf _ IPC).\n}\n{\nrewrite CO_FR_PSCB.\ncdes IPC.\narewrite (psc_base G ⊆ psc_f G ∪ psc_base G).\nauto.\n}\nrewrite inclusion_ct_seq_eqv_l, inclusion_ct_seq_eqv_r.\nrewrite <- seq_eqvK.\nrewrite <- !seqA, acyclic_rotl, !seqA.\nseq_rewrite (@ct_of_trans _ (co ∪ fr)); [| apply trans_co_fr].\narewrite (co ∪ fr ⊆ ⦗W ∪₁ R⦘ ⨾ (co ∪ fr) ⨾ ⦗W ∪₁ R⦘).\n{\nrewrite (wf_coD WF), (wf_frD WF).\nbasic_solver.\n}\nseq_rewrite (@seq_eqvC _ _ (W ∪₁ R)).\nrewrite seqA.\nrewrite seq_eqvC.\nrewrite <- !seqA, acyclic_rotl, !seqA.\nsin_rewrite CO_FR_PSCB.\narewrite (⦗(W ∪₁ R)⦘ ⨾ ⦗Sc⦘ ⨾ (sb ∪ rf)⁺ ⨾ ⦗Sc⦘ ⨾ ⦗W ∪₁ R⦘ ⊆ (psc_base G)＊).\n{\nrewrite ct_unionE.\nassert (rf⁺ ≡ rf) as RF1.\n{\nrewrite ct_begin.\nrewrite rtE.\nrewrite seq_union_r.\nrewrite ct_begin.\nseq_rewrite (rf_rf WF).\nbasic_solver.\n}\nseq_rewrite RF1.\narewrite (rf＊ ≡ rf^?).\n{\nrewrite rtE.\nrewrite RF1.\nbasic_solver.\n}\nrewrite <- !seqA.\nrewrite seqA with (r3:=⦗Sc⦘).\nrewrite seqA with (r1:=⦗(W ∪₁ R)⦘).\ncase_union _ _.\nrewrite seq_union_r.\nrewrite seq_union_r, seq_union_l.\nunionL.\n{\nrewrite sc_rf_in_pscb.\nrewrite <- inclusion_t_rt, <- ct_step.\nbasic_solver.\n}\nrewrite cr_seq.\ncase_union _ _.\nrewrite seq_union_r.\narewrite ((sb ⨾ rf^?)⁺ ⊆ (sb ⨾ rf)＊ ⨾ sb^?).\n{\nrewrite crE, seq_union_r, seq_id_r.\nrewrite unionC.\nrewrite path_absorb_rt.\n3: by apply sb_trans.\n2: left; generalize (@sb_trans G); basic_solver.\nrewrite crE, seq_union_r, seq_id_r.\napply union_mori; eauto with hahn.\n}\nrewrite seq_union_l.\nassert (⦗Sc ∩₁ (W ∪₁ R)⦘ ⨾ (sb ⨾ rf)＊ ⨾ sb^? ⨾ ⦗(W ∪₁ R) ∩₁ Sc⦘ ⊆ (psc_base G)＊) as SB_RF'.\n{\nrewrite cr_seq, !seq_union_r.\nunionL.\n{\ngeneralize sc_sb_rf_ct_pscb.\nbasic_solver 10.\n}\nrewrite sc_sb_rf_ct_sb_pscb.\nbasic_solver 10.\n}\nrewrite seq_union_r.\nunionL.\n1, 2: rewrite !seqA, <- seqA, <- !id_inter.\n1, 2: rewrite set_interC with (s:=Sc), set_interC with (s':=Sc) at 1.\n{\napply SB_RF'.\n}\narewrite (⦗Sc ∩₁ (W ∪₁ R)⦘ ⊆ ⦗Sc⦘) by mode_solver.\narewrite (rf ≡ rf ⨾ ⦗R⦘) at 1 by eapply dom_r; apply (wf_rfD WF).\narewrite (⦗R⦘ ⊆ ⦗W ∪₁R⦘) by mode_solver.\nsin_rewrite sc_rf_l.\nrewrite <- seq_eqvK at 2.\nrewrite !seqA.\nsin_rewrite sc_rf_in_pscb.\nseq_rewrite <- id_inter.\nsin_rewrite SB_RF'.\nrewrite <- ct_begin.\nbasic_solver.\n}\nrewrite <- ct_end.\ncdes IPC.\narewrite ((psc_base G)⁺ ⊆ (psc_base G ∪ psc_f G)⁺).\nred.\nred in Cpsc.\nrewrite ct_of_ct.\nrewrite unionC.\nauto.\n"},{"statement":"Lemma imm_to_ocaml_consistent sc\n      (IPC : imm_s.imm_psc_consistent G sc) :\n  ocaml_consistent G.","proof":"cdes IPC.\ncdes IC.\nassert (irreflexive (ohb ⨾ (co ∪ fr))) as HH.\n{\neapply imm_to_ocaml_coherent; eauto.\n}\nred.\nsplits; auto.\n1,2: eapply irreflexive_mori; eauto.\n1,2: red; basic_solver 10.\napply (imm_to_ocaml_causal IPC).\n"}]