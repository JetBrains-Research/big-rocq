{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/travorder/TraversalOrder.v","fileSamples":[{"statement":"(y : actid) : exists x : trav_label, y = event x.","proofString":"exists (mkTL ta_cover y); ins."},{"statement":"(y : actid) : set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_cover) x).","proofString":"exists [mkTL ta_cover y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_cover) x) : mkTL ta_cover y = x \\/ False.","proofString":"desf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : (action ↓₁ eq ta_cover) x) : mkTL ta_cover (event x) = x \\/ False.","proofString":"red in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : ta_cover = action x) : mkTL ta_cover (event x) = x \\/ False.","proofString":"destruct x as [[]]; ins; auto."},{"statement":"(y : actid) : set_finite (fun x : trav_label => y = event x /\\ (action ↓₁ eq ta_issue) x).","proofString":"exists [mkTL ta_issue y].\nins.\ndesf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(y : actid) (x : trav_label) (IN : y = event x /\\ (action ↓₁ eq ta_issue) x) : mkTL ta_issue y = x \\/ False.","proofString":"desf.\nred in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : (action ↓₁ eq ta_issue) x) : mkTL ta_issue (event x) = x \\/ False.","proofString":"red in IN0.\ndestruct x as [[]]; ins; auto."},{"statement":"(x : trav_label) (IN0 : ta_issue = action x) : mkTL ta_issue (event x) = x \\/ False.","proofString":"destruct x as [[]]; ins; auto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) : forall x : actid,\n(exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y)) ->\nexists y : trav_label, B y /\\ event y = x.","proofString":"ins.\ndesf.\nexists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (H : exists y : actid, r x y /\\ (exists y0 : trav_label, A y0 /\\ event y0 = y)) : exists y : trav_label, B y /\\ event y = x.","proofString":"desf.\nexists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : exists y : trav_label, B y /\\ event y = x.","proofString":"exists (mkTL b x); ins.\nsplit; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : B (mkTL b x) /\\ x = x.","proofString":"split; auto.\napply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : B (mkTL b x).","proofString":"apply AA.\nunfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) (mkTL b x).","proofString":"unfolder.\ndo 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (AA : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B) (x : actid) (y0 : trav_label) (H : r x (event y0)) (H0 : A y0) : exists y z : trav_label,\n  (mkTL b x = z /\\ b = action (mkTL b x)) /\\\n  (exists z0 : trav_label, r (event z) (event z0) /\\ z0 = y /\\ A z0).","proofString":"do 2 eexists; ins; eauto.\nsplits; eauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B ->\ndom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B.","proofString":"ins.\nunfolder.\nins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) : dom_rel (⦗action ↓₁ eq b⦘ ⨾ event ↓ r ⨾ ⦗A⦘) ⊆₁ B.","proofString":"unfolder.\nins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) : forall x : trav_label,\n(exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y) -> B x.","proofString":"ins.\ndesf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(b : trav_action) (A B : trav_label -> Prop) (r : relation actid) (UU : B ⊆₁ action ↓₁ eq b) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (x : trav_label) (H0 : exists y : trav_label, b = action x /\\ r (event x) (event y) /\\ A y) : B x.","proofString":"desf.\ndestruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (x : trav_label) (UU : B ⊆₁ action ↓₁ eq (action x)) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (y : trav_label) (H1 : r (event x) (event y)) (H2 : A y) : B x.","proofString":"destruct x as [a1 e1], y as [a2 e2].\nins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq (action (a1, e1))) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r (event (a1, e1)) (event (a2, e2))) (H2 : A (a2, e2)) : B (a1, e1).","proofString":"ins.\nspecialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) ⊆₁ event ↑₁ B) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : B (a1, e1).","proofString":"specialize (H e1).\nspecialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : B (a1, e1).","proofString":"specialize_full H.\neexists.\napply seq_eqv_r.\nsplit; vauto.\nred in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (H : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1 -> (event ↑₁ B) e1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) : dom_rel (r ⨾ ⦗event ↑₁ A⦘) e1.","proofString":"eexists.\napply seq_eqv_r.\nsplit; vauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : (event ↑₁ B) e1) : B (a1, e1).","proofString":"red in H.\ndesc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : exists y : trav_label, B y /\\ event y = e1) : B (a1, e1).","proofString":"desc.\nspecialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (UU : B ⊆₁ action ↓₁ eq a1) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (y : trav_label) (H : B y) (H0 : event y = e1) : B (a1, e1).","proofString":"specialize (UU _ H).\ndestruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (y : trav_label) (UU : (action ↓₁ eq a1) y) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B y) (H0 : event y = e1) : B (a1, e1).","proofString":"destruct y as [a3 e3].\nred in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : (action ↓₁ eq a1) (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1) : B (a1, e1).","proofString":"red in UU.\nins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = action (a3, e3)) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : event (a3, e3) = e1) : B (a1, e1).","proofString":"ins.\nsubst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (a1 : trav_action) (e1 : actid) (a3 : trav_action) (e3 : actid) (UU : a1 = a3) (a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e3)) (H0 : e3 = e1) : B (a1, e1).","proofString":"subst.\nauto."},{"statement":"(A B : trav_label -> Prop) (r : relation actid) (e1 : actid) (a3 a2 : trav_action) (e2 : actid) (H1 : r e1 e2) (H2 : A (a2, e2)) (H : B (a3, e1)) : B (a3, e1).","proofString":"auto."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘) ⊆₁ T.","proofString":"transitivity (T ∩₁ action ↓₁ eq a1); [| basic_solver].\napply dom_rel_collect_event2; [basic_solver| ].\ngeneralize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (⦗action ↓₁ eq a1⦘ ⨾ event ↓ r ⨾ ⦗action ↓₁ eq a2 ∩₁ T⦘)\n⊆₁ T ∩₁ action ↓₁ eq a1.","proofString":"apply dom_rel_collect_event2; [basic_solver| ].\ngeneralize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1).","proofString":"generalize DOM.\nbasic_solver 10."},{"statement":"(T : trav_label -> Prop) (a1 a2 : trav_action) (r : relation actid) (DOM : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1)) : dom_rel (r ⨾ ⦗event ↑₁ (T ∩₁ action ↓₁ eq a2)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1) ->\ndom_rel (r ⨾ ⦗event ↑₁ (action ↓₁ eq a2 ∩₁ T)⦘)\n⊆₁ event ↑₁ (T ∩₁ action ↓₁ eq a1).","proofString":"basic_solver 10."},{"statement":"(a : trav_action) (B : actid -> Prop) : event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B) ≡₁ B.","proofString":"split; try basic_solver.\nintros b Bb.\nexists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) : B ⊆₁ event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B).","proofString":"intros b Bb.\nexists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b) : (event ↑₁ (fst ↓₁ eq a ∩₁ snd ↓₁ B)) b.","proofString":"exists (mkTL a b).\nvauto."},{"statement":"(a : trav_action) (B : actid -> Prop) (b : actid) (Bb : B b) : (fst ↓₁ eq a ∩₁ snd ↓₁ B) (mkTL a b) /\\ event (mkTL a b) = b.","proofString":"vauto."},{"statement":"(a : trav_action) (e : actid) : (fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n≡₁ eq (mkTL a e).","proofString":"split; try basic_solver.\nintros [? ?] [-> ->].\nauto."},{"statement":"(a : trav_action) (e : actid) : (fun ab : trav_action * actid => let (a0, b) := ab in a = a0 /\\ e = b)\n⊆₁ eq (mkTL a e).","proofString":"intros [? ?] [-> ->].\nauto."},{"statement":"(t : trav_action) (a0 : actid) : mkTL t a0 = (t, a0).","proofString":"auto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n≡ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘.","proofString":"split; [| basic_solver].\napply dom_helper_3.\nunfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n⊆ ⦗set_compl (action ↓₁ eq ta_reserve)⦘\n  ⨾ iord G sc ⨾ ⦗set_compl (action ↓₁ eq ta_reserve)⦘.","proofString":"apply dom_helper_3.\nunfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : iord G sc\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve).","proofString":"unfold iord.\niord_dom_unfolder; ins; subst; vauto."},{"statement":"(G : execution) (sc : relation actid) : restr_rel (event ↓₁ (acts_set G \\₁ (fun a : actid => is_init a)))\n  (SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc)\n⊆ set_compl (action ↓₁ eq ta_reserve) × set_compl (action ↓₁ eq ta_reserve).","proofString":"iord_dom_unfolder; ins; subst; vauto."},{"statement":"restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n  (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP)\n≡ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n    (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","proofString":"iord_simpl_dom_unfolder.\neapply sb_sc_acyclic; eauto.\napply CONS.\neapply ar_rf_ppo_loc_acyclic; eauto."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a) : False.","proofString":"eapply sb_sc_acyclic; eauto.\napply CONS."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b0 : (fun x y : actid => sb x y \\/ sc x y)⁺ a a) : acyc_ext G sc.","proofString":"apply CONS."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (a : actid) (b5 : true) (b2 : (fun x y : actid =>\n ar x y \\/ (exists z : actid, rf x z /\\ ppo z y /\\ same_loc z y))⁺ a a) (b4 : is_w lab a) : False.","proofString":"eapply ar_rf_ppo_loc_acyclic; eauto."},{"statement":"(WF : Wf G) (COMP : complete G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP).","proofString":"auto using iord_simpl_irreflexive."},{"statement":"transitive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘).","proofString":"rewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"transitive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))).","proofString":"apply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"transitive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)).","proofString":"apply transitiveI.\nrewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"rewrite map_rel_seq.\napply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"event\n↓ ((⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n   ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"apply map_rel_mori; auto.\nhahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘.","proofString":"hahn_frame.\narewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘ ⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"arewrite_id ⦗W⦘.\nnow rewrite !seq_id_l, ct_ct."},{"statement":"(ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⨾ ⦗fun _ : actid => True⦘\n  ⨾ ⦗fun _ : actid => True⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺\n⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"now rewrite !seq_id_l, ct_ct."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘).","proofString":"rewrite <- restr_relE.\napply irreflexive_restr.\napply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (restr_rel (action ↓₁ eq ta_issue)\n     (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘))).","proofString":"apply irreflexive_restr.\napply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)).","proofString":"apply map_rel_irr.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive\n  (⦗fun _ : actid => True⦘\n   ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗fun _ : actid => True⦘).","proofString":"rewrite !seq_id_l, seq_id_r.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (COMP : complete G) (CONS : imm_consistent G sc) : irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"apply ar_rf_ppo_loc_acyclic; auto."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺.","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ (sb ∪ sc)⁺.","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (event ↑ SB).","proofString":"rewrite eSB_in_sb_sc_ct.\nred.\nrewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (sb ∪ sc)⁺.","proofString":"red.\nrewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive ((sb ∪ sc)⁺)⁺.","proofString":"rewrite ct_of_ct.\napply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive (sb ∪ sc)⁺.","proofString":"apply sb_sc_acyclic; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyc_ext G sc.","proofString":"apply CONS."},{"statement":"transitive\n  (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘).","proofString":"rewrite <- restr_relE.\napply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"transitive (restr_rel (action ↓₁ eq ta_cover) (event ↓ (sb ∪ sc)⁺)).","proofString":"apply transitive_restr.\napply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"transitive (event ↓ (sb ∪ sc)⁺).","proofString":"apply transitiveI.\nrewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"event ↓ (sb ∪ sc)⁺ ⨾ event ↓ (sb ∪ sc)⁺ ⊆ event ↓ (sb ∪ sc)⁺.","proofString":"rewrite map_rel_seq.\nnow rewrite ct_ct."},{"statement":"event ↓ ((sb ∪ sc)⁺ ⨾ (sb ∪ sc)⁺) ⊆ event ↓ (sb ∪ sc)⁺.","proofString":"now rewrite ct_ct."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : irreflexive SB⁺.","proofString":"now apply SB_acyclic."},{"statement":"FWBOB ⨾ FWBOB ⊆ FWBOB.","proofString":"rewrite FWBOBFWBOB.\nclear; basic_solver 1."},{"statement":"∅₂ ⊆ FWBOB.","proofString":"clear; basic_solver 1."},{"statement":"IPROP ⨾ IPROP ⊆ IPROP.","proofString":"iord_dom_solver."},{"statement":"PROP ⨾ PROP ⊆ PROP.","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyclic (SB ⨾ RF).","proofString":"rewrite SBRF.\napply false_acyclic."},{"statement":"(RF ⨾ SB) ⨾ RF ⨾ SB ⊆ RF ⨾ SB.","proofString":"rewrite !seqA.\nsin_rewrite SBRF.\nclear.\nbasic_solver 1."},{"statement":"RF ⨾ SB ⨾ RF ⨾ SB ⊆ RF ⨾ SB.","proofString":"sin_rewrite SBRF.\nclear.\nbasic_solver 1."},{"statement":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB.","proofString":"clear.\nbasic_solver 1."},{"statement":"RF ⨾ ∅₂ ⨾ SB ⊆ RF ⨾ SB.","proofString":"basic_solver 1."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?.","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⊆ rf^?.","proofString":"basic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob.","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)\n⊆ fwbob.","proofString":"basic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"clear.\nbasic_solver 10."},{"statement":"event\n↑ (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘) ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n  ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"rewrite !seqA.\nhahn_frame.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ⦗action ↓₁ eq ta_issue⦘\n⨾ event ↓ (⦗W⦘ ⨾ rf^?)\n  ⨾ ⦗action ↓₁ eq ta_cover⦘\n    ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n      ⨾ ⦗action ↓₁ eq ta_cover⦘\n        ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n⊆ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘.","proofString":"hahn_frame.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)^?\n    ⨾ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?)\n⨾ ⦗fun _ : trav_label => True⦘\n  ⨾ (⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗fun _ : trav_label => True⦘)^?\n    ⨾ ⦗fun _ : trav_label => True⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"rewrite !seq_id_l, !seq_id_r.\nrewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (⦗W⦘ ⨾ rf^?) ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ (fwbob ⨾ ⦗W⦘)\n⊆ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘).","proofString":"rewrite <- !map_rel_seq2; auto with lbase.\nrewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (event ↓ ⦗W⦘ ⨾ event ↓ rf^?)\n⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘.","proofString":"rewrite !seqA.\nhahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ ⦗W⦘\n⨾ event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob ⨾ event ↓ ⦗W⦘\n⊆ event ↓ ⦗W⦘ ⨾ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ event ↓ ⦗W⦘.","proofString":"hahn_frame.\nrewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ rf^? ⨾ (event ↓ (sb ∪ sc)⁺)^? ⨾ event ↓ fwbob\n⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"rewrite map_rel_cr, !map_rel_seq.\napply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : event ↓ (rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob) ⊆ event ↓ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"apply map_rel_mori; auto.\nrewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"rewrite cr_of_ct.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"rewrite sb_sc_rt; auto; try apply CONS.\nrewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"rewrite !seqA.\nrewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ sb^? ⨾ sc^? ⨾ sb^? ⨾ fwbob ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"rewrite rf_sb_sc_sb_fwbob_in_ar; auto.\napply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ar⁺ ⊆ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"apply clos_trans_mori.\neauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc.","proofString":"eauto with hahn."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (event ↑ RF)^? ⨾ (event ↑ SB)^? ⨾ event ↑ FWBOB ⊆ ar⁺.","proofString":"rewrite ERF, eSB_in_sb_sc_ct, EFWBOB.\nrewrite cr_of_cr.\nrewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : (rf^?)^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺.","proofString":"rewrite cr_of_cr.\nrewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ ((sb ∪ sc)⁺)^? ⨾ fwbob ⊆ ar⁺.","proofString":"rewrite cr_of_ct.\napply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : rf^? ⨾ (sb ∪ sc)＊ ⨾ fwbob ⊆ ar⁺.","proofString":"apply rf_sb_sc_rt_sb_fwbob_in_ar; auto.\napply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) : acyc_ext G sc.","proofString":"apply CONS."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ RF)⁺ ⨾ FWBOB).","proofString":"rewrite path_ut2; auto with lbase.\nrewrite ct_of_trans; auto with lbase.\nrepeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB⁺ ∪ SB＊ ⨾ (RF ⨾ SB⁺)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB).","proofString":"rewrite ct_of_trans; auto with lbase.\nrepeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ SB＊ ⨾ (RF ⨾ SB)＊ ⨾ RF ⨾ SB＊) ⨾ FWBOB).","proofString":"repeat (rewrite rt_of_trans; auto with lbase).\narewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⨾ SB^?) ⨾ FWBOB).","proofString":"arewrite (SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF).\nrewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1.\nrewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : SB^? ⨾ (RF ⨾ SB)^? ⨾ RF ⊆ RF.","proofString":"rewrite !crE, !seq_union_l, !seqA.\nrewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : ⦗fun _ : trav_label => True⦘\n⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF)\n∪ SB ⨾ (⦗fun _ : trav_label => True⦘ ⨾ RF ∪ RF ⨾ SB ⨾ RF) ⊆ RF.","proofString":"rewrite !seq_union_r, !seq_id_l.\nrewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : RF ∪ RF ⨾ SB ⨾ RF ∪ (SB ⨾ RF ∪ SB ⨾ RF ⨾ SB ⨾ RF) ⊆ RF.","proofString":"rewrite SBRF.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : RF ∪ RF ⨾ ∅₂ ∪ (∅₂ ∪ SB ⨾ RF ⨾ ∅₂) ⊆ RF.","proofString":"clear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic ((SB ∪ RF ⨾ SB^?) ⨾ FWBOB).","proofString":"rewrite acyclic_seqC.\nrewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ (SB ∪ RF ⨾ SB^?)).","proofString":"rewrite !seq_union_r.\nrewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ SB ∪ FWBOB ⨾ RF ⨾ SB^?).","proofString":"rewrite FWBOBSB, union_false_l.\nrewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (FWBOB ⨾ RF ⨾ SB^?).","proofString":"rewrite acyclic_seqC, !seqA.\nrewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic (RF ⨾ SB^? ⨾ FWBOB).","proofString":"rewrite RFSBFWBOBINAR; auto.\napply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : acyclic AR.","proofString":"apply AR_acyc; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) : transitive sb.","proofString":"apply sb_trans."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic\n  (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊).","proofString":"arewrite (PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂).\niord_dom_solver.\nrewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : PROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP) ⊆ ∅₂.","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP)＊).","proofString":"rewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊).","proofString":"arewrite (IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂).\niord_dom_solver.\nrewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : IPROP ⨾ (SB ∪ RF ∪ FWBOB ∪ AR) ⊆ ∅₂.","proofString":"iord_dom_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (∅₂ ⨾ (SB ∪ RF ∪ FWBOB ∪ AR)＊).","proofString":"rewrite seq_false_l.\napply false_acyclic."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : FWBOB ⊆ SB^? ⨾ FWBOB.","proofString":"clear.\nbasic_solver 10."},{"statement":"FWBOB ⊆ SB^? ⨾ FWBOB.","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ (RF ∪ SB^? ⨾ FWBOB) ⊆ RF ∪ SB^? ⨾ FWBOB.","proofString":"rewrite seq_union_r.\nrewrite SBRF, union_false_l.\nunionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ RF ∪ SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB.","proofString":"rewrite SBRF, union_false_l.\nunionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⨾ FWBOB ⊆ RF ∪ SB^? ⨾ FWBOB.","proofString":"unionR right.\nhahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⨾ FWBOB ⊆ SB^? ⨾ FWBOB.","proofString":"hahn_frame_r.\nrewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB ⨾ SB^? ⊆ SB^?.","proofString":"rewrite rewrite_trans_seq_cr_r; eauto with hahn lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : SB⁺ ⊆ SB.","proofString":"apply ct_of_trans; auto with lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (((RF ∪ SB^? ⨾ FWBOB)⁺ ∪ SB ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB) ⨾ AR).","proofString":"rewrite !seq_union_l, !seqA.\nrewrite !SBAR.\nrewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic\n  ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ SB ⨾ AR ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ SB ⨾ AR).","proofString":"rewrite !SBAR.\nrewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR ∪ ∅₂ ∪ (RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ ∅₂).","proofString":"rewrite seq_false_r, !union_false_r.\nrewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF ∪ SB^? ⨾ FWBOB)⁺ ⨾ AR).","proofString":"rewrite path_union, !seq_union_l.\narewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (RF⁺ ⨾ AR ∪ ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊) ⨾ AR).","proofString":"arewrite (RF⁺ ⊆ RF).\napply ct_of_trans; auto with lbase.\nrewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : RF⁺ ⊆ RF.","proofString":"apply ct_of_trans; auto with lbase."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (RF ⨾ AR ∪ (RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR).","proofString":"rewrite RFAR, !union_false_l.\nrewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF＊ ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF＊ ⨾ AR).","proofString":"rewrite rt_of_trans; auto with lbase.\narewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ RF^? ⨾ AR).","proofString":"arewrite (RF^? ⨾ AR ⊆ AR).\nrewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1.\neapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : RF^? ⨾ AR ⊆ AR.","proofString":"rewrite crE, !seq_union_l, !seq_id_l.\nrewrite RFAR.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : AR ∪ RF ⨾ AR ⊆ AR.","proofString":"rewrite RFAR.\nclear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : AR ∪ ∅₂ ⊆ AR.","proofString":"clear; basic_solver 1."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR).","proofString":"eapply collect_rel_acyclic with (f:=event).\nrewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (event ↑ ((RF^? ⨾ SB^? ⨾ FWBOB)⁺ ⨾ AR)).","proofString":"rewrite collect_rel_seqi, collect_rel_ct.\nrewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((event ↑ (RF^? ⨾ SB^? ⨾ FWBOB))⁺ ⨾ event ↑ AR).","proofString":"rewrite RFSBFINAR; auto.\nrewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((ar⁺)⁺ ⨾ event ↑ AR).","proofString":"rewrite ct_of_ct.\nrewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar⁺ ⨾ event ↑ AR).","proofString":"rewrite EAR.\narewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","proofString":"arewrite (ar ⊆ ar ∪ rf ⨾ ppo ∩ same_loc) at 1.\nrewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","proofString":"rewrite ct_ct.\nred.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : acyclic (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"red.\nrewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : irreflexive ((ar ∪ rf ⨾ ppo ∩ same_loc)⁺)⁺.","proofString":"rewrite ct_of_ct.\napply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (COMP : complete G) (CONS : imm_consistent G sc) (SBTRANS : transitive sb) : irreflexive (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"apply ar_rf_ppo_loc_acyclic; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"now apply fsupp_sb."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) SB).","proofString":"unfold \"SB\".\nrewrite inclusion_t_rt.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘)).","proofString":"rewrite inclusion_t_rt.\nrewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)＊ ⨾ ⦗action ↓₁ eq ta_cover⦘)).","proofString":"rewrite sb_sc_rt; auto; try apply CONS.\nrewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)).","proofString":"rewrite restr_seq_eqv_l.\narewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)).","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘ at 2.\nrewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?) ⨾ ⦗fun _ : trav_label => True⦘)).","proofString":"rewrite seq_id_r.\nrewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n       (event ↓ (sb^? ⨾ sc^? ⨾ sb^?))).","proofString":"rewrite <- map_rel_restr.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?)).","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (E \\₁ (fun a : actid => is_init a)) (sb^? ⨾ sc^? ⨾ sb^?)).","proofString":"rewrite !crE, !seq_union_l, !seq_union_r, !seq_id_l, !seq_id_r.\nrewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (E \\₁ (fun a : actid => is_init a))\n     (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","proofString":"rewrite restr_relE.\narewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))\n     ⨾ ⦗E \\₁ (fun a : actid => is_init a)⦘).","proofString":"arewrite_id ⦗E \\₁ is_init⦘ at 2.\nrewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb))) ⨾ ⦗\n     fun _ : actid => True⦘).","proofString":"rewrite !seq_id_r.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗E \\₁ (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","proofString":"arewrite (E \\₁ is_init ⊆₁ set_compl is_init).\nclear; basic_solver.\nrewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a).","proofString":"clear; basic_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ⨾ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","proofString":"rewrite rewrite_trans; eauto using sb_trans.\narewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb ∪ (sc ∪ sc ⨾ sb)\n      ∪ (sb ∪ sb ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ sb)))).","proofString":"arewrite (sc ⨾ sb ⊆ sc ⨾ ⦗set_compl is_init⦘ ⨾ sb).\nrewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver.\nrewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : sc ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","proofString":"rewrite (dom_r (wf_scD WFSC)) at 1.\narewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : (sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ sb ⊆ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb.","proofString":"arewrite (F ∩₁ Sc ⊆₁ set_compl is_init); [|easy].\nrewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : F ∩₁ Sc ⊆₁ set_compl (fun a : actid => is_init a).","proofString":"rewrite (init_w WF).\nclear.\nmode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : F ∩₁ Sc ⊆₁ set_compl W.","proofString":"clear.\nmode_solver."},{"statement":"F ∩₁ Sc ⊆₁ set_compl W.","proofString":"mode_solver."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (⦗fun _ : actid => True⦘ ∪ sb\n      ∪ (sc ∪ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n      ∪ (sb ∪ sb\n         ∪ (sb ⨾ sc ∪ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)))).","proofString":"rewrite !seq_union_r, !seq_id_r.\nassert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","proofString":"assert (fsupp ⦗set_compl is_init⦘) as AA.\nnow apply fsupp_eqv.\nassert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp ⦗set_compl (fun a : actid => is_init a)⦘.","proofString":"now apply fsupp_eqv."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","proofString":"assert (fsupp (⦗set_compl is_init⦘ ⨾ sc)) as BB.\napply fsupp_seq; auto.\nrepeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc).","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n        ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)\n   ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb\n      ∪ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc\n         ∪ ⦗set_compl (fun a : actid => is_init a)⦘\n           ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb))).","proofString":"repeat apply fsupp_union; auto.\nrewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\napply fsupp_seq; auto.\nrewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"rewrite <- !seqA.\nrewrite seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb).","proofString":"rewrite seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb ⨾ sc).","proofString":"rewrite <- !seqA.\napply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp ((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc).","proofString":"apply fsupp_seq; auto."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ sb ⨾ sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"rewrite <- !seqA.\nrewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  ((((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n    ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ sb).","proofString":"rewrite seqA.\nrepeat (apply fsupp_seq; auto)."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (CONS : imm_consistent G sc) (FSUPPSC : fsupp sc) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) (AA : fsupp ⦗set_compl (fun a : actid => is_init a)⦘) (BB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sc)) : fsupp\n  (((⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb) ⨾ sc)\n   ⨾ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"repeat (apply fsupp_seq; auto)."},{"statement":"(FSUPPRF : fsupp rf) : fsupp\n  (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘).","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\nrewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗fun _ : trav_label => True⦘).","proofString":"rewrite seq_id_r.\napply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?)).","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗W⦘ ⨾ rf^?).","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp (⦗fun _ : actid => True⦘ ⨾ rf^?).","proofString":"rewrite !seq_id_l.\nnow apply fsupp_cr."},{"statement":"(FSUPPRF : fsupp rf) : fsupp rf^?.","proofString":"now apply fsupp_cr."},{"statement":"(WF : Wf G) (WFSC : wf_sc G sc) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ ⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘\n⊆ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺.","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"now apply fsupp_sb."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) FWBOB).","proofString":"unfold \"FWBOB\".\narewrite_id ⦗action ↓₁ eq ta_issue⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘)).","proofString":"arewrite_id ⦗action ↓₁ eq ta_issue⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘)).","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘\n      ⨾ event ↓ (fwbob ⨾ ⦗fun _ : actid => True⦘)\n        ⨾ ⦗fun _ : trav_label => True⦘)).","proofString":"rewrite !seq_id_r.\nrewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a)))\n     (⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ fwbob)).","proofString":"rewrite restr_seq_eqv_l.\nrewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ restr_rel (event ↓₁ (E \\₁ (fun a : actid => is_init a))) (event ↓ fwbob)).","proofString":"rewrite restr_relE, <- !seqA.\napply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n    ⨾ event ↓ fwbob) ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘).","proofString":"apply fsupp_seq; auto using fsupp_eqv.\nrewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ ⦗event ↓₁ (E \\₁ (fun a : actid => is_init a))⦘)\n   ⨾ event ↓ fwbob).","proofString":"rewrite map_rel_eqv with (f:=event).\nrewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  ((⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘)\n   ⨾ event ↓ fwbob).","proofString":"rewrite !seqA.\nrewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ ⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ event ↓ fwbob).","proofString":"rewrite map_rel_seq.\napply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob)).","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ fwbob).","proofString":"rewrite fwbob_in_sb.\narewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : fsupp (⦗E \\₁ (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"arewrite (E \\₁ is_init ⊆₁ set_compl is_init); auto.\nclear; basic_solver."},{"statement":"(WF : Wf G) (FSUPPSB : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb)) : E \\₁ (fun a : actid => is_init a) ⊆₁ set_compl (fun a : actid => is_init a).","proofString":"clear; basic_solver."},{"statement":"fsupp\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘).","proofString":"rewrite <- seqA.\napply fsupp_seq; auto using fsupp_eqv.\napply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp\n  ((⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘))\n   ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘).","proofString":"apply fsupp_seq; auto using fsupp_eqv.\napply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp (⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (eq ⨾ ⦗W⦘)).","proofString":"apply fsupp_seq_l_map_rel; auto with lbase.\nrepeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"fsupp (eq ⨾ ⦗W⦘).","proofString":"repeat (apply fsupp_seq); auto using fsupp_eqv.\nred; ins.\nexists [y]; ins; eauto."},{"statement":"(y : actid) : exists findom : list actid, forall x : actid, x = y -> In x findom.","proofString":"exists [y]; ins; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?).","proofString":"rewrite crE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv, fsupp_sb."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb).","proofString":"apply fsupp_union; auto using fsupp_seq, fsupp_eqv, fsupp_sb."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊).","proofString":"rewrite rtE, seq_union_r.\napply fsupp_union; auto using fsupp_seq, fsupp_eqv.\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","proofString":"apply fsupp_union; auto using fsupp_seq, fsupp_eqv.\neapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺).","proofString":"eapply fsupp_ar_implies_fsupp_ar_rf_ppo_loc; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) : fsupp sc.","proofString":"eapply imm_s_fair_fsupp_sc; eauto.\napply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) : wf_sc G sc.","proofString":"apply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) : sc_per_loc G.","proofString":"apply coherence_sc_per_loc.\napply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) : coherence G.","proofString":"apply CONS."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp co.","proofString":"apply MF."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ furr G sc).","proofString":"eapply fsupp_furr; eauto."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : Basics.flip inclusion fr (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr).","proofString":"red.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr.","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr ⊆ fr.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (MF : mem_fair G) (CONS : imm_consistent G sc) (COMP : complete G) (IMM_FAIR : imm_s_fair G sc) (TB : fin_threads G) (FSUPPSBCR : fsupp (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ sb^?)) (FSUPPAR : fsupp\n  (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)＊)) (FSUPSC : fsupp sc) (SCPLOC : sc_per_loc G) : fsupp fr.","proofString":"apply MF."},{"statement":"(WF : Wf G) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ RF ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"rewrite <- seqA.\napply domb_helper.\nunfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"apply domb_helper.\nunfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ RF)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfold \"RF\".\nrewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite crE.\nrepeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"repeat case_union _ _.\nrewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘ ∪ ⦗W⦘ ⨾ rf)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite map_rel_union.\nrepeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ (event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ∪ event ↓ (⦗W⦘ ⨾ rf))\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"repeat case_union _ _.\napply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘\n   ∪ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n     ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"apply union_domb.\nunfolder.\nins.\ndesc.\ncongruence.\nrewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ ⦗fun _ : actid => True⦘) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfolder.\nins.\ndesc.\ncongruence."},{"statement":"(WF : Wf G) : forall x y : trav_label,\n(~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y ->\n~ is_init (event y).","proofString":"ins.\ndesc.\ncongruence."},{"statement":"(WF : Wf G) (x y : trav_label) (REL : (~ is_init (event x) /\\ ta_issue = action x) /\\\n(event x = event y /\\ is_w lab (event x) /\\ True) /\\ ta_cover = action y) : ~ is_init (event y).","proofString":"desc.\ncongruence."},{"statement":"(WF : Wf G) (x y : trav_label) (REL : ~ is_init (event x)) (REL4 : ta_issue = action x) (REL0 : event x = event y) (REL2 : is_w lab (event x)) (REL3 : True) (REL1 : ta_cover = action y) : ~ is_init (event y).","proofString":"congruence."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf) ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite no_rf_to_init; auto.\nbasic_solver."},{"statement":"(WF : Wf G) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_issue⦘\n     ⨾ event ↓ (⦗W⦘ ⨾ rf ⨾ ⦗fun x : actid => ~ is_init x⦘)\n       ⨾ ⦗action ↓₁ eq ta_cover⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : AR ⊆ AR ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"apply domb_helper.\nforward eapply no_ar_rf_ppo_loc_to_init as AR'_NI; eauto.\napply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"forward eapply no_ar_rf_ppo_loc_to_init as AR'_NI; eauto.\napply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗fun a : actid => is_init a⦘ ≡ ∅₂) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"apply seq_eqv_compl in AR'_NI.\nunfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb AR (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfold \"AR\".\nrewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite AR'_NI.\nrewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ ((ar ∪ rf ⨾ ppo ∩ same_loc)\n           ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)⁺ ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite ct_end.\nbasic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (AR'_NI : ar ∪ rf ⨾ ppo ∩ same_loc\n≡ (ar ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) : domb\n  (⦗action ↓₁ eq ta_issue⦘\n   ⨾ event\n     ↓ (⦗W⦘\n        ⨾ (((ar ∪ rf ⨾ ppo ∩ same_loc)\n            ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)＊\n           ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)\n             ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ⨾ ⦗action ↓₁ eq ta_issue⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"basic_solver."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n  ⨾ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"rewrite <- !seqA.\napply domb_helper.\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP\n⊆ (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"apply domb_helper.\nunfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘ ⨾ PROP)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfold \"PROP\".\nrewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite inclusion_inter_l1.\narewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"arewrite_id ⦗action ↓₁ eq ta_cover⦘.\narewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"arewrite_id ⦗action ↓₁ is_ta_propagate_to_G G⦘.\narewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘) ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"arewrite_id ⦗W⦘.\nrewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ ⦗fun _ : trav_label => True⦘\n     ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗fun _ : actid => True⦘)\n       ⨾ ⦗fun _ : trav_label => True⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite !seq_id_l, !seq_id_r.\nrewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite map_rel_eqv, map_rel_seq.\nassert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"assert (sc_per_loc G) as SC_PER_LOC.\napply coherence_sc_per_loc, CONS.\napply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) : sc_per_loc G.","proofString":"apply coherence_sc_per_loc, CONS."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (event\n   ↓ (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?))\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"apply domb_map_rel.\nrewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb (⦗set_compl (fun a : actid => is_init a)⦘ ⨾ fr^? ⨾ furr G sc ⨾ co^?)\n  (set_compl (fun a : actid => is_init a)).","proofString":"rewrite no_co_to_init; auto.\nrewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ fr^? ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","proofString":"rewrite no_fr_to_init; auto.\nrewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ furr G sc ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","proofString":"rewrite furr_to_ninit; auto; [| apply CONS].\nbasic_solver 10."},{"statement":"(WF : Wf G) (CONS : imm_consistent G sc) (SC_PER_LOC : sc_per_loc G) : domb\n  (⦗set_compl (fun a : actid => is_init a)⦘\n   ⨾ (fr ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n     ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n        ∪ ⦗fun a : actid => is_init a⦘)\n       ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^?)\n  (set_compl (fun a : actid => is_init a)).","proofString":"basic_solver 10."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) : forall x y z : A, (⦗s⦘ ⨾ r) x y -> (⦗s⦘ ⨾ r) y z -> (⦗s⦘ ⨾ r) x z.","proofString":"intros ? ? ? ?%seq_eqv_l ?%seq_eqv_l.\ndesc.\napply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x /\\ r x y) (H0 : s y /\\ r y z) : (⦗s⦘ ⨾ r) x z.","proofString":"desc.\napply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : (⦗s⦘ ⨾ r) x z.","proofString":"apply seq_eqv_l.\nsplit; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : s x /\\ r x z.","proofString":"split; auto.\neapply TRANS; eauto."},{"statement":"(A : Type) (r : relation A) (s : A -> Prop) (TRANS : transitive r) (x y z : A) (H : s x) (H2 : r x y) (H0 : s y) (H1 : r y z) : r x z.","proofString":"eapply TRANS; eauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : PROP ⊆ PROP ⨾ ⦗event ↓₁ set_compl (fun a : actid => is_init a)⦘.","proofString":"apply domb_helper.\nunfold PROP.\nrewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb PROP (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfold PROP.\nrewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite furr_to_ninit; auto.\nrelsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘\n           ∪ ⦗fun a : actid => is_init a⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"relsf.\nrewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘\n        ∪ fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite map_rel_union.\nrewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘))\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite inter_union_l.\nrepeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ (event\n      ↓ (fr^?\n         ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n           ⨾ co^? ⨾ ⦗W⦘)\n      ∩ (fun ta1 ta2 : trav_label =>\n         tid (event ta1) = ta_propagate_tid (action ta2))\n      ∪ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n        ∩ (fun ta1 ta2 : trav_label =>\n           tid (event ta1) = ta_propagate_tid (action ta2)))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"repeat case_union _ _.\napply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n   ∪ ⦗action ↓₁ eq ta_cover⦘\n     ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n       ∩ (fun ta1 ta2 : trav_label =>\n          tid (event ta1) = ta_propagate_tid (action ta2))\n       ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"apply union_domb.\nrewrite no_co_to_init; auto.\nbasic_solver 10.\nrewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite no_co_to_init; auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ (fr^?\n        ⨾ (furr G sc ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"basic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event ↓ (fr^? ⨾ ⦗fun a : actid => is_init a⦘ ⨾ co^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite crE, no_co_to_init; auto.\nrewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘)^? ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"rewrite crE, no_fr_to_init; auto.\nunfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfold is_ta_propagate_to_G.\nunfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : domb\n  (⦗action ↓₁ eq ta_cover⦘\n   ⨾ event\n     ↓ ((⦗fun _ : actid => True⦘ ∪ fr ⨾ ⦗fun x : actid => ~ is_init x⦘)\n        ⨾ ⦗fun a : actid => is_init a⦘\n          ⨾ (⦗fun _ : actid => True⦘\n             ∪ co ⨾ ⦗set_compl (fun a : actid => is_init a)⦘) ⨾ ⦗W⦘)\n     ∩ (fun ta1 ta2 : trav_label =>\n        tid (event ta1) = ta_propagate_tid (action ta2))\n     ⨾ ⦗action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t))⦘)\n  (event ↓₁ set_compl (fun a : actid => is_init a)).","proofString":"unfolder.\nins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) : forall x y : trav_label,\nta_cover = action x /\\\n((exists z : actid,\n    (event x = z /\\ True \\/\n     (exists z0 : actid, fr (event x) z0 /\\ z0 = z /\\ ~ is_init z0)) /\\\n    (exists z0 : actid,\n       (z = z0 /\\ is_init z) /\\\n       (exists z1 : actid,\n          (z0 = z1 /\\ True \\/\n           (exists z2 : actid, co z0 z2 /\\ z2 = z1 /\\ ~ is_init z2)) /\\\n          z1 = event y /\\ is_w lab z1))) /\\\n tid (event x) = ta_propagate_tid (action y)) /\\\n(exists y0 : thread_id,\n   (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = action y) ->\n~ is_init (event y).","proofString":"ins; desf; subst; destruct x, y, t0; ins; subst; splits; try by vauto.\ndestruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (SPL : sc_per_loc G) (a0 : actid) (REL11 : True) (REL9 : is_init a0) (REL10 : True) (REL8 : is_w lab a0) (y0 : thread_id) (REL1 : threads_set G y0) (REL3 : tid_init <> y0) (REL2 : ta_propagate y0 = ta_propagate (tid a0)) : ~ is_init a0.","proofString":"destruct a0; vauto."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : SB ∪ RF ∪ FWBOB ∪ AR ∪ IPROP ∪ PROP ⊆ event ↓ (E × E)^?.","proofString":"unfold SB, RF, FWBOB, AR, IPROP, PROP.\nrewrite ppo_in_sb, fwbob_in_sb; auto.\nrepeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (fwbob ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite ppo_in_sb, fwbob_in_sb; auto.\nrepeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_issue⦘ ⨾ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ ⦗action ↓₁ eq ta_cover⦘ ⨾ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n    ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ ⦗action ↓₁ eq ta_issue⦘\n  ⨾ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ ⦗action ↓₁ eq ta_cover⦘\n  ⨾ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n    ∩ (fun ta1 ta2 : trav_label =>\n       tid (event ta1) = ta_propagate_tid (action ta2))\n    ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"repeat rewrite inclusion_seq_eqv_l with (dom := action ↓₁ eq _).\nrepeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (⦗W⦘ ⨾ rf^?) ⨾ ⦗action ↓₁ eq ta_cover⦘\n∪ event ↓ (sb ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ eq ta_issue⦘\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"repeat rewrite inclusion_seq_eqv_r with (dom := action ↓₁ eq _).\nrewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb ∩ same_loc)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite inclusion_inter_l1 with (r := sb).\nrewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (sb ∪ sc)⁺ ∪ event ↓ (⦗W⦘ ⨾ rf^?) ∪ event ↓ (sb ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (ar ∪ rf ⨾ sb)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (fr^? ⨾ furr G sc ⨾ co^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite ?sb_E_ENI, ?rf_E_ENI, ?co_E_E, ?fr_E_E; auto.\nrewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ furr G sc ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite furr_E_E_cr; auto.\nrewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (ar\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite ar_E_ENI; auto.\nrewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ∪ sc)⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite sc_E_ENI with (G:=G) (sc:=sc); auto.\nrewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ∩ (fun ta1 ta2 : trav_label =>\n     tid (event ta1) = ta_propagate_tid (action ta2))\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"rewrite inclusion_inter_l1.\narewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event\n↓ (E × (E \\₁ (fun a : actid => is_init a))\n   ∪ E × (E \\₁ (fun a : actid => is_init a)))⁺\n∪ event ↓ (⦗W⦘ ⨾ (E × (E \\₁ (fun a : actid => is_init a)))^?)\n∪ event ↓ (E × (E \\₁ (fun a : actid => is_init a)) ⨾ ⦗W⦘)\n∪ event\n  ↓ (⦗W⦘\n     ⨾ (E × (E \\₁ (fun a : actid => is_init a))\n        ∪ E × (E \\₁ (fun a : actid => is_init a))\n          ⨾ E × (E \\₁ (fun a : actid => is_init a)))⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"arewrite (E × (E \\₁ is_init) ⊆ E × E) by basic_solver.\nremember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : event ↓ (E × E ∪ E × E)⁺ ∪ event ↓ (⦗W⦘ ⨾ (E × E)^?) ∪ event ↓ (E × E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E × E ∪ E × E ⨾ E × E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ ((E × E)^? ⨾ (E × E)^? ⨾ (E × E)^? ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ (E × E)^?.","proofString":"remember (E × E) as E_E.\nassert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?.","proofString":"assert (transitive E_E) as TEE.\napply transitiveI.\nsubst E_E.\nclear.\nbasic_solver.\nrewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : transitive E_E.","proofString":"apply transitiveI.\nsubst E_E.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) : E_E ⨾ E_E ⊆ E_E.","proofString":"subst E_E.\nclear.\nbasic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) : E × E ⨾ E × E ⊆ E × E.","proofString":"clear.\nbasic_solver."},{"statement":"E × E ⨾ E × E ⊆ E × E.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ (⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺ ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ E_E^? ⨾ E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n⊆ event ↓ E_E^?.","proofString":"rewrite <- !seqA.\nrewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ (E_E ∪ E_E)⁺ ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ (E_E ∪ E_E ⨾ E_E)⁺) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (((E_E^? ⨾ E_E^?) ⨾ E_E^?) ⨾ ⦗W⦘)\n  ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ event ↓ E_E^?.","proofString":"rewrite ?(@rt_of_trans _ E_E), ?(@rewrite_trans _ E_E),          ?unionK, ?(@rewrite_trans _ E_E),          ?(@rewrite_trans_seq_cr_cr _ E_E), ?(@ct_of_trans _ E_E),          ?cr_rt, ?rt_cr,          ?(@rt_of_trans _ E_E); auto.\nbasic_solver 10."},{"statement":"(WF : Wf G) (WFsc : wf_sc G sc) (E_E : actid -> actid -> Prop) (HeqE_E : E_E = E × E) (TEE : transitive E_E) : event ↓ E_E ∪ event ↓ (⦗W⦘ ⨾ E_E^?) ∪ event ↓ (E_E ⨾ ⦗W⦘)\n∪ event ↓ ((⦗W⦘ ⨾ E_E) ⨾ ⦗W⦘)\n∪ event ↓ (eq ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘\n∪ event ↓ (E_E^? ⨾ ⦗W⦘) ⨾ ⦗action ↓₁ is_ta_propagate_to_G G⦘ ⊆ \nevent ↓ E_E^?.","proofString":"basic_solver 10."}]}