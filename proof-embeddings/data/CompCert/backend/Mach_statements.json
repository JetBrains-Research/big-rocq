{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Mach.v","fileSamples":[{"statement":"(r : mreg) (rs : regset) (H : ~ False) : rs r = rs r.","proofString":"auto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, ~ In r rl -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : ~ (a = r \\/ In r rl)) : (undef_regs rl rs) # a <- Vundef r = rs r.","proofString":"rewrite Regmap.gso.\napply IHrl.\nintuition.\nintuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, ~ In r rl -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : ~ (a = r \\/ In r rl)) : undef_regs rl rs r = rs r.","proofString":"apply IHrl.\nintuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, ~ In r rl -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : ~ (a = r \\/ In r rl)) : ~ In r rl.","proofString":"intuition."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, ~ In r rl -> undef_regs rl rs0 r = rs0 r) (rs : regset) (H : ~ (a = r \\/ In r rl)) : r <> a.","proofString":"intuition."},{"statement":"(r : mreg) (rs : regset) (H : False) : rs r = Vundef.","proofString":"tauto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, In r rl -> undef_regs rl rs0 r = Vundef) (rs : regset) (H : a = r \\/ In r rl) : (undef_regs rl rs) # a <- Vundef r = Vundef.","proofString":"destruct H.\nsubst a.\napply Regmap.gss.\nunfold Regmap.set.\ndestruct (RegEq.eq r a); auto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, In r rl -> undef_regs rl rs0 r = Vundef) (rs : regset) (H : a = r) : (undef_regs rl rs) # a <- Vundef r = Vundef.","proofString":"subst a.\napply Regmap.gss."},{"statement":"(r : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, In r rl -> undef_regs rl rs0 r = Vundef) (rs : regset) : (undef_regs rl rs) # r <- Vundef r = Vundef.","proofString":"apply Regmap.gss."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, In r rl -> undef_regs rl rs0 r = Vundef) (rs : regset) (H : In r rl) : (undef_regs rl rs) # a <- Vundef r = Vundef.","proofString":"unfold Regmap.set.\ndestruct (RegEq.eq r a); auto."},{"statement":"(r a : mreg) (rl : list mreg) (IHrl : forall rs0 : regset, In r rl -> undef_regs rl rs0 r = Vundef) (rs : regset) (H : In r rl) : (if RegEq.eq r a then Vundef else undef_regs rl rs r) = Vundef.","proofString":"destruct (RegEq.eq r a); auto."},{"statement":"(lbl : label) (instr : instruction) : if is_label lbl instr then instr = Mlabel lbl else instr <> Mlabel lbl.","proofString":"destruct instr; simpl; try discriminate.\ncase (peq lbl l); intro; congruence."},{"statement":"(lbl l : label) : if if peq lbl l then true else false\nthen Mlabel l = Mlabel lbl\nelse Mlabel l <> Mlabel lbl.","proofString":"case (peq lbl l); intro; congruence."},{"statement":"(lbl : label) (c' : code) (H : None = Some c') : is_tail c' nil.","proofString":"discriminate."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : code) (H : (if is_label lbl a then Some c else find_label lbl c) = Some c') : is_tail c' (a :: c).","proofString":"destruct (is_label lbl a).\ninv H.\nauto with coqlib.\neauto with coqlib."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : code) (H : Some c = Some c') : is_tail c' (a :: c).","proofString":"inv H.\nauto with coqlib."},{"statement":"(lbl : label) (a : instruction) (c' : code) (IHc : forall c'0 : code, find_label lbl c' = Some c'0 -> is_tail c'0 c') : is_tail c' (a :: c').","proofString":"auto with coqlib."},{"statement":"(lbl : label) (a : instruction) (c : list instruction) (IHc : forall c'0 : code, find_label lbl c = Some c'0 -> is_tail c'0 c) (c' : code) (H : find_label lbl c = Some c') : is_tail c' (a :: c).","proofString":"eauto with coqlib."},{"statement":"(lbl : label) (c c' : code) (H : find_label lbl c = Some c') (a : instruction) (H0 : In a c') : In a c.","proofString":"eapply is_tail_incl; eauto.\neapply find_label_tail; eauto."},{"statement":"(lbl : label) (c c' : code) (H : find_label lbl c = Some c') (a : instruction) (H0 : In a c') : is_tail c' c.","proofString":"eapply find_label_tail; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f0)) : wf_state (Callstate (Stackframe fb sp (Vptr fb ra) c :: s) f' rs m).","proofString":"assert (f0 = f) by congruence.\nsubst f0.\nconstructor.\nconstructor; auto.\neconstructor; eauto with coqlib.\ndestruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f0)) (H2 : f0 = f) : wf_state (Callstate (Stackframe fb sp (Vptr fb ra) c :: s) f' rs m).","proofString":"subst f0.\nconstructor.\nconstructor; auto.\neconstructor; eauto with coqlib.\ndestruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : wf_state (Callstate (Stackframe fb sp (Vptr fb ra) c :: s) f' rs m).","proofString":"constructor.\nconstructor; auto.\neconstructor; eauto with coqlib.\ndestruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : Forall wf_frame (Stackframe fb sp (Vptr fb ra) c :: s).","proofString":"constructor; auto.\neconstructor; eauto with coqlib.\ndestruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : wf_frame (Stackframe fb sp (Vptr fb ra) c).","proofString":"econstructor; eauto with coqlib.\ndestruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : is_leaf_function f = false.","proofString":"destruct (is_leaf_function f) eqn:E; auto.\nunfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) (E : is_leaf_function f = true) : true = false.","proofString":"unfold is_leaf_function in E; rewrite forallb_forall in E.\nsymmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) (E : forall x : instruction,\nIn x (fn_code f) -> match x with\n                    | Mcall _ _ => false\n                    | _ => true\n                    end = true) : true = false.","proofString":"symmetry.\napply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) (E : forall x : instruction,\nIn x (fn_code f) -> match x with\n                    | Mcall _ _ => false\n                    | _ => true\n                    end = true) : false = true.","proofString":"apply (E (Mcall sig ros)).\neapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (sp : val) (sig : signature) (ros : mreg + ident) (c : code) (rs : regset) (m : mem) (f : function) (f' : block) (ra : ptrofs) (H : find_function_ptr ge ros rs = Some f') (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : rao f c ra) (STACK : Forall wf_frame s) (TAIL : is_tail (Mcall sig ros :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) (E : forall x : instruction,\nIn x (fn_code f) -> match x with\n                    | Mcall _ _ => false\n                    | _ => true\n                    end = true) : In (Mcall sig ros) (fn_code f).","proofString":"eapply is_tail_in; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (lbl : label) (c : list instruction) (rs : regset) (m : mem) (c' : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mgoto lbl :: c) (fn_code f0)) : wf_state (State s fb sp c' rs m).","proofString":"assert (f0 = f) by congruence.\nsubst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (lbl : label) (c : list instruction) (rs : regset) (m : mem) (c' : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mgoto lbl :: c) (fn_code f0)) (H1 : f0 = f) : wf_state (State s fb sp c' rs m).","proofString":"subst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (lbl : label) (c : list instruction) (rs : regset) (m : mem) (c' : code) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : find_label lbl (fn_code f) = Some c') (STACK : Forall wf_frame s) (TAIL : is_tail (Mgoto lbl :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : wf_state (State s fb sp c' rs m).","proofString":"econstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (cond : condition) (args : list RegEq.t) (lbl : label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (c' : code) (H : eval_condition cond rs ## args m = Some true) (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mcond cond args lbl :: c) (fn_code f0)) : wf_state (State s fb sp c' (undef_regs (destroyed_by_cond cond) rs) m).","proofString":"assert (f0 = f) by congruence.\nsubst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (cond : condition) (args : list RegEq.t) (lbl : label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (c' : code) (H : eval_condition cond rs ## args m = Some true) (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mcond cond args lbl :: c) (fn_code f0)) (H2 : f0 = f) : wf_state (State s fb sp c' (undef_regs (destroyed_by_cond cond) rs) m).","proofString":"subst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (cond : condition) (args : list RegEq.t) (lbl : label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (c' : code) (H : eval_condition cond rs ## args m = Some true) (H0 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H1 : find_label lbl (fn_code f) = Some c') (STACK : Forall wf_frame s) (TAIL : is_tail (Mcond cond args lbl :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : wf_state (State s fb sp c' (undef_regs (destroyed_by_cond cond) rs) m).","proofString":"econstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (arg : RegEq.t) (tbl : list label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (n : int) (lbl : label) (c' : code) (H : rs arg = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mjumptable arg tbl :: c) (fn_code f0)) : wf_state (State s fb sp c' (undef_regs destroyed_by_jumptable rs) m).","proofString":"assert (f0 = f) by congruence.\nsubst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (arg : RegEq.t) (tbl : list label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (n : int) (lbl : label) (c' : code) (H : rs arg = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : find_label lbl (fn_code f) = Some c') (f0 : function) (STACK : Forall wf_frame s) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f0)) (TAIL : is_tail (Mjumptable arg tbl :: c) (fn_code f0)) (H3 : f0 = f) : wf_state (State s fb sp c' (undef_regs destroyed_by_jumptable rs) m).","proofString":"subst f0.\neconstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (fb : block) (f : function) (sp : val) (arg : RegEq.t) (tbl : list label) (c : list instruction) (rs : RegEq.t -> val) (m : mem) (n : int) (lbl : label) (c' : code) (H : rs arg = Vint n) (H0 : list_nth_z tbl (Int.unsigned n) = Some lbl) (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : find_label lbl (fn_code f) = Some c') (STACK : Forall wf_frame s) (TAIL : is_tail (Mjumptable arg tbl :: c) (fn_code f)) (CODE : Genv.find_funct_ptr ge fb = Some (Internal f)) : wf_state (State s fb sp c' (undef_regs destroyed_by_jumptable rs) m).","proofString":"econstructor; eauto using find_label_tail."},{"statement":"(s : list stackframe) (f : block) (sp ra : val) (c : code) (rs : regset) (m : mem) (STACK : Forall wf_frame (Stackframe f sp ra c :: s)) : wf_state (State s f sp c rs m).","proofString":"inv STACK.\ninv H1.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : block) (sp ra : val) (c : code) (rs : regset) (m : mem) (H1 : wf_frame (Stackframe f sp ra c)) (H2 : Forall wf_frame s) : wf_state (State s f sp c rs m).","proofString":"inv H1.\neconstructor; eauto."},{"statement":"(s : list stackframe) (f : block) (sp ra : val) (c : code) (rs : regset) (m : mem) (H2 : Forall wf_frame s) (f0 : function) (CODE : Genv.find_funct_ptr ge f = Some (Internal f0)) (LEAF : is_leaf_function f0 = false) (TAIL : is_tail c (fn_code f0)) : wf_state (State s f sp c rs m).","proofString":"econstructor; eauto."},{"statement":"(p : program) (S : state) (H : initial_state p S) : wf_state (Genv.globalenv p) S.","proofString":"inv H.\nfold ge.\nconstructor.\nconstructor."},{"statement":"(p : program) (fb : block) (m0 : mem) (ge : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some fb) : wf_state ge (Callstate nil fb (Regmap.init Vundef) m0).","proofString":"constructor.\nconstructor."},{"statement":"(p : program) (fb : block) (m0 : mem) (ge : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge (prog_main p) = Some fb) : Forall (wf_frame ge) nil.","proofString":"constructor."}]}