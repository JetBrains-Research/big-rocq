{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/Generic_fmt.v","fileSamples":[{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (k <= l)%Z) : (fexp l < l)%Z.","proofString":"apply Znot_ge_lt.\nintros Hl.\napply Z.ge_le in Hl.\nassert (H' := proj2 (proj2 (valid_exp l) Hl) k).\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (k <= l)%Z) : ~ (fexp l >= l)%Z.","proofString":"intros Hl.\napply Z.ge_le in Hl.\nassert (H' := proj2 (proj2 (valid_exp l) Hl) k).\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (k <= l)%Z) (Hl : (fexp l >= l)%Z) : False.","proofString":"apply Z.ge_le in Hl.\nassert (H' := proj2 (proj2 (valid_exp l) Hl) k).\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (k <= l)%Z) (Hl : (l <= fexp l)%Z) : False.","proofString":"assert (H' := proj2 (proj2 (valid_exp l) Hl) k).\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (k <= l)%Z) (Hl : (l <= fexp l)%Z) (H' : (k <= fexp l)%Z -> fexp k = fexp l) : False.","proofString":"lia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) : (fexp l < k)%Z.","proofString":"apply Znot_ge_lt.\nintros H'.\napply Z.ge_le in H'.\nassert (Hl := Z.le_trans _ _ _ H H').\napply valid_exp in Hl.\nassert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) : ~ (fexp l >= k)%Z.","proofString":"intros H'.\napply Z.ge_le in H'.\nassert (Hl := Z.le_trans _ _ _ H H').\napply valid_exp in Hl.\nassert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) (H' : (fexp l >= k)%Z) : False.","proofString":"apply Z.ge_le in H'.\nassert (Hl := Z.le_trans _ _ _ H H').\napply valid_exp in Hl.\nassert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) (H' : (k <= fexp l)%Z) : False.","proofString":"assert (Hl := Z.le_trans _ _ _ H H').\napply valid_exp in Hl.\nassert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) (H' : (k <= fexp l)%Z) (Hl : (l <= fexp l)%Z) : False.","proofString":"apply valid_exp in Hl.\nassert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) (H' : (k <= fexp l)%Z) (Hl : (fexp (fexp l + 1) <= fexp l)%Z /\\\n(forall l0 : Z, (l0 <= fexp l)%Z -> fexp l0 = fexp l)) : False.","proofString":"assert (H1 := proj2 Hl k H').\nlia."},{"statement":"(k l : Z) (Hk : (fexp k < k)%Z) (H : (l <= k)%Z) (H' : (k <= fexp l)%Z) (Hl : (fexp (fexp l + 1) <= fexp l)%Z /\\\n(forall l0 : Z, (l0 <= fexp l)%Z -> fexp l0 = fexp l)) (H1 : fexp k = fexp l) : False.","proofString":"lia."},{"statement":"(x : R) : cexp (- x) = cexp x.","proofString":"unfold cexp.\nnow rewrite mag_opp."},{"statement":"(x : R) : fexp (mag beta (- x)) = fexp (mag beta x).","proofString":"now rewrite mag_opp."},{"statement":"(x : R) : cexp (Rabs x) = cexp x.","proofString":"unfold cexp.\nnow rewrite mag_abs."},{"statement":"(x : R) : fexp (mag beta (Rabs x)) = fexp (mag beta x).","proofString":"now rewrite mag_abs."},{"statement":"(x : R) (Hx : generic_format x) : exists f : float beta, x = F2R f /\\ canonical f.","proofString":"rewrite Hx.\neexists.\napply (conj eq_refl).\nunfold canonical.\nnow rewrite <- Hx."},{"statement":"(x : R) (Hx : generic_format x) : canonical {| Fnum := Ztrunc (scaled_mantissa x); Fexp := cexp x |}.","proofString":"unfold canonical.\nnow rewrite <- Hx."},{"statement":"(e : Z) (H : (fexp (e + 1) <= e)%Z) : generic_format (bpow e).","proofString":"unfold generic_format, scaled_mantissa, cexp.\nrewrite mag_bpow.\nrewrite <- bpow_plus.\nrewrite <- (IZR_Zpower beta (e + - fexp (e + 1))).\nrewrite Ztrunc_IZR.\nrewrite <- F2R_bpow.\nrewrite F2R_change_exp with (1 := H).\nnow rewrite Zmult_1_l.\nnow apply Zle_minus_le_0."},{"statement":"(e : Z) (H : (fexp (e + 1) <= e)%Z) : (0 <= e + - fexp (e + 1))%Z.","proofString":"now apply Zle_minus_le_0."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) : generic_format (bpow e).","proofString":"apply generic_format_bpow.\ndestruct (Zle_lt_or_eq _ _ He).\nnow apply valid_exp_.\nrewrite <- H.\napply valid_exp.\nrewrite H.\napply Z.le_refl."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) : (fexp (e + 1) <= e)%Z.","proofString":"destruct (Zle_lt_or_eq _ _ He).\nnow apply valid_exp_.\nrewrite <- H.\napply valid_exp.\nrewrite H.\napply Z.le_refl."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) (H : (fexp e < e)%Z) : (fexp (e + 1) <= e)%Z.","proofString":"now apply valid_exp_."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) (H : fexp e = e) : (fexp (e + 1) <= e)%Z.","proofString":"rewrite <- H.\napply valid_exp.\nrewrite H.\napply Z.le_refl."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) (H : fexp e = e) : (fexp (fexp e + 1) <= fexp e)%Z.","proofString":"apply valid_exp.\nrewrite H.\napply Z.le_refl."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) (H : fexp e = e) : (e <= fexp e)%Z.","proofString":"rewrite H.\napply Z.le_refl."},{"statement":"(e : Z) (He : (fexp e <= e)%Z) (H : fexp e = e) : (e <= e)%Z.","proofString":"apply Z.le_refl."},{"statement":"(m e : Z) (Zm : m = 0%Z) : generic_format 0.","proofString":"apply generic_format_0."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (e' : Z) (He : (e' <= e)%Z) : (m * beta ^ (e - e'))%Z = Ztrunc (IZR m * bpow e * bpow (- e')).","proofString":"rewrite Rmult_assoc, <- bpow_plus, <- IZR_Zpower, <- mult_IZR.\nnow rewrite Ztrunc_IZR.\nnow apply Zle_left."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (e' : Z) (He : (e' <= e)%Z) : (m * beta ^ (e - e'))%Z = Ztrunc (IZR (m * beta ^ (e + - e'))).","proofString":"now rewrite Ztrunc_IZR."},{"statement":"(m e : Z) (Zm : m <> 0%Z) (e' : Z) (He : (e' <= e)%Z) : (0 <= e + - e')%Z.","proofString":"now apply Zle_left."},{"statement":"(x : R) (f : float beta) (H1 : F2R f = x) (H2 : x <> 0%R -> (cexp x <= Fexp f)%Z) : generic_format x.","proofString":"rewrite <- H1; destruct f as (m,e).\napply generic_format_F2R.\nsimpl in *; intros H3.\nrewrite H1; apply H2.\nintros Y; apply H3.\napply eq_0_F2R with beta e.\nnow rewrite H1."},{"statement":"(m e : Z) (H : canonical {| Fnum := m; Fexp := e |}) : canonical {| Fnum := - m; Fexp := e |}.","proofString":"unfold canonical.\nnow rewrite F2R_Zopp, cexp_opp."},{"statement":"(m e : Z) (H : canonical {| Fnum := m; Fexp := e |}) : canonical {| Fnum := Z.abs m; Fexp := e |}.","proofString":"unfold canonical.\nnow rewrite F2R_Zabs, cexp_abs."},{"statement":"(x : R) (Hx : generic_format x) : scaled_mantissa x = IZR (Ztrunc (scaled_mantissa x)).","proofString":"unfold scaled_mantissa.\npattern x at 1 3 ; rewrite Hx.\nunfold F2R.\nsimpl.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nnow rewrite Ztrunc_IZR."},{"statement":"(x : R) (Hx : generic_format x) : (x * bpow (- cexp x))%R = IZR (Ztrunc (x * bpow (- cexp x))).","proofString":"pattern x at 1 3 ; rewrite Hx.\nunfold F2R.\nsimpl.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nnow rewrite Ztrunc_IZR."},{"statement":"(x : R) (Hx : generic_format x) : (IZR (Ztrunc (scaled_mantissa x)) * bpow (cexp x) * bpow (- cexp x))%R =\nIZR\n  (Ztrunc\n     (IZR (Ztrunc (scaled_mantissa x)) * bpow (cexp x) * bpow (- cexp x))).","proofString":"rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nnow rewrite Ztrunc_IZR."},{"statement":"(x : R) (Hx : generic_format x) : IZR (Ztrunc (scaled_mantissa x)) =\nIZR (Ztrunc (IZR (Ztrunc (scaled_mantissa x)))).","proofString":"now rewrite Ztrunc_IZR."},{"statement":"(x : R) : (scaled_mantissa x * bpow (cexp x))%R = x.","proofString":"unfold scaled_mantissa.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l.\napply Rmult_1_r."},{"statement":"(x : R) : (x * bpow (- cexp x) * bpow (cexp x))%R = x.","proofString":"rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l.\napply Rmult_1_r."},{"statement":"(x : R) : (x * bpow 0)%R = x.","proofString":"apply Rmult_1_r."},{"statement":"(x : R) : scaled_mantissa (- x) = (- scaled_mantissa x)%R.","proofString":"unfold scaled_mantissa.\nrewrite cexp_opp.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(x : R) : (- x * bpow (- cexp (- x)))%R = (- (x * bpow (- cexp x)))%R.","proofString":"rewrite cexp_opp.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(x : R) : (- x * bpow (- cexp x))%R = (- (x * bpow (- cexp x)))%R.","proofString":"now rewrite Ropp_mult_distr_l_reverse."},{"statement":"(x : R) : scaled_mantissa (Rabs x) = Rabs (scaled_mantissa x).","proofString":"unfold scaled_mantissa.\nrewrite cexp_abs, Rabs_mult.\napply f_equal.\napply sym_eq.\napply Rabs_pos_eq.\napply bpow_ge_0."},{"statement":"(x : R) : (Rabs x * bpow (- cexp (Rabs x)))%R = Rabs (x * bpow (- cexp x)).","proofString":"rewrite cexp_abs, Rabs_mult.\napply f_equal.\napply sym_eq.\napply Rabs_pos_eq.\napply bpow_ge_0."},{"statement":"(x : R) : (Rabs x * bpow (- cexp x))%R = (Rabs x * Rabs (bpow (- cexp x)))%R.","proofString":"apply f_equal.\napply sym_eq.\napply Rabs_pos_eq.\napply bpow_ge_0."},{"statement":"(x : R) : bpow (- cexp x) = Rabs (bpow (- cexp x)).","proofString":"apply sym_eq.\napply Rabs_pos_eq.\napply bpow_ge_0."},{"statement":"(x : R) : Rabs (bpow (- cexp x)) = bpow (- cexp x).","proofString":"apply Rabs_pos_eq.\napply bpow_ge_0."},{"statement":"(x : R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : generic_format x) : generic_format (- x).","proofString":"unfold generic_format.\nrewrite scaled_mantissa_opp, cexp_opp.\nrewrite Ztrunc_opp.\nrewrite F2R_Zopp.\nnow apply f_equal."},{"statement":"(x : R) (Hx : generic_format x) : generic_format (Rabs x).","proofString":"unfold generic_format.\nrewrite scaled_mantissa_abs, cexp_abs.\nrewrite Ztrunc_abs.\nrewrite F2R_Zabs.\nnow apply f_equal."},{"statement":"(x : R) : generic_format (Rabs x) -> generic_format x.","proofString":"unfold generic_format, Rabs.\ncase Rcase_abs ; intros _.\nrewrite scaled_mantissa_opp, cexp_opp, Ztrunc_opp.\nintros H.\nrewrite <- (Ropp_involutive x) at 1.\nrewrite H, F2R_Zopp.\napply Ropp_involutive.\neasy."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : cexp x = fexp ex.","proofString":"unfold cexp.\nnow rewrite mag_unique with (1 := Hx)."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : fexp (mag beta x) = fexp ex.","proofString":"now rewrite mag_unique with (1 := Hx)."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : cexp x = fexp ex.","proofString":"apply cexp_fexp.\nrewrite Rabs_pos_eq.\nexact Hx.\napply Rle_trans with (2 := proj1 Hx).\napply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nexact Hx.\napply Rle_trans with (2 := proj1 Hx).\napply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= x < bpow ex)%R.","proofString":"exact Hx."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (0 <= x)%R.","proofString":"apply Rle_trans with (2 := proj1 Hx).\napply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (0 <= bpow (ex - 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < x * bpow (- fexp ex) < 1)%R.","proofString":"split.\napply Rmult_lt_0_compat.\napply Rlt_le_trans with (2 := proj1 Hx).\napply bpow_gt_0.\napply bpow_gt_0.\napply Rmult_lt_reg_r with (bpow (fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l.\nrewrite Rmult_1_r, Rmult_1_l.\napply Rlt_le_trans with (1 := proj2 Hx).\nnow apply bpow_le."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < x * bpow (- fexp ex))%R.","proofString":"apply Rmult_lt_0_compat.\napply Rlt_le_trans with (2 := proj1 Hx).\napply bpow_gt_0.\napply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < x)%R.","proofString":"apply Rlt_le_trans with (2 := proj1 Hx).\napply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < bpow (ex - 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < bpow (- fexp ex))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (x * bpow (- fexp ex) < 1)%R.","proofString":"apply Rmult_lt_reg_r with (bpow (fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l.\nrewrite Rmult_1_r, Rmult_1_l.\napply Rlt_le_trans with (1 := proj2 Hx).\nnow apply bpow_le."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < bpow (fexp ex))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (x * bpow (- fexp ex) * bpow (fexp ex) < 1 * bpow (fexp ex))%R.","proofString":"rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_l.\nrewrite Rmult_1_r, Rmult_1_l.\napply Rlt_le_trans with (1 := proj2 Hx).\nnow apply bpow_le."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (x * bpow 0 < 1 * bpow (fexp ex))%R.","proofString":"rewrite Rmult_1_r, Rmult_1_l.\napply Rlt_le_trans with (1 := proj2 Hx).\nnow apply bpow_le."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (x < bpow (fexp ex))%R.","proofString":"apply Rlt_le_trans with (1 := proj2 Hx).\nnow apply bpow_le."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (bpow ex <= bpow (fexp ex))%R.","proofString":"now apply bpow_le."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (Rabs (scaled_mantissa x) < 1)%R.","proofString":"destruct (Req_dec x 0) as [Zx|Zx].\nrewrite Zx, scaled_mantissa_0, Rabs_R0.\nnow apply IZR_lt.\nrewrite <- scaled_mantissa_abs.\nunfold scaled_mantissa.\nrewrite cexp_abs.\nunfold cexp.\ndestruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x = 0%R) : (Rabs (scaled_mantissa x) < 1)%R.","proofString":"rewrite Zx, scaled_mantissa_0, Rabs_R0.\nnow apply IZR_lt."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x = 0%R) : (0 < 1)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) : (Rabs (scaled_mantissa x) < 1)%R.","proofString":"rewrite <- scaled_mantissa_abs.\nunfold scaled_mantissa.\nrewrite cexp_abs.\nunfold cexp.\ndestruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) : (scaled_mantissa (Rabs x) < 1)%R.","proofString":"unfold scaled_mantissa.\nrewrite cexp_abs.\nunfold cexp.\ndestruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) : (Rabs x * bpow (- cexp (Rabs x)) < 1)%R.","proofString":"rewrite cexp_abs.\nunfold cexp.\ndestruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) : (Rabs x * bpow (- cexp x) < 1)%R.","proofString":"unfold cexp.\ndestruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) : (Rabs x * bpow (- fexp (mag beta x)) < 1)%R.","proofString":"destruct (mag beta x) as (ex', Ex').\nsimpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : x <> 0%R -> (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (Rabs x * bpow (- fexp (Build_mag_prop beta x ex' Ex')) < 1)%R.","proofString":"simpl.\nspecialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : x <> 0%R -> (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (Rabs x * bpow (- fexp ex') < 1)%R.","proofString":"specialize (Ex' Zx).\napply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (Rabs x * bpow (- fexp ex') < 1)%R.","proofString":"apply (mantissa_small_pos _ _ Ex').\nassert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (ex' <= fexp ex')%Z.","proofString":"assert (ex' <= fexp ex)%Z.\napply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex).\nnow rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (ex' <= fexp ex)%Z.","proofString":"apply Z.le_trans with (2 := He).\napply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex)."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (ex' <= ex)%Z.","proofString":"apply bpow_lt_bpow with beta.\nnow apply Rle_lt_trans with (2 := Ex)."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) : (bpow (ex' - 1) < bpow ex)%R.","proofString":"now apply Rle_lt_trans with (2 := Ex)."},{"statement":"(x : R) (ex : Z) (Ex : (Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (Zx : x <> 0%R) (ex' : Z) (Ex' : (bpow (ex' - 1) <= Rabs x < bpow ex')%R) (H : (ex' <= fexp ex)%Z) : (ex' <= fexp ex')%Z.","proofString":"now rewrite (proj2 (proj2 (valid_exp _) He))."},{"statement":"(x : R) : (Rabs (scaled_mantissa x) < bpow (mag beta x - cexp x))%R.","proofString":"destruct (Req_dec x 0) as [Zx|Zx].\nrewrite Zx, scaled_mantissa_0, Rabs_R0.\napply bpow_gt_0.\napply Rlt_le_trans with (1 := bpow_mag_gt beta _).\napply bpow_le.\nunfold scaled_mantissa.\nrewrite mag_mult_bpow with (1 := Zx).\napply Z.le_refl."},{"statement":"(x : R) (Zx : x = 0%R) : (Rabs (scaled_mantissa x) < bpow (mag beta x - cexp x))%R.","proofString":"rewrite Zx, scaled_mantissa_0, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x = 0%R) : (0 < bpow (mag beta 0 - cexp 0))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) : (Rabs (scaled_mantissa x) < bpow (mag beta x - cexp x))%R.","proofString":"apply Rlt_le_trans with (1 := bpow_mag_gt beta _).\napply bpow_le.\nunfold scaled_mantissa.\nrewrite mag_mult_bpow with (1 := Zx).\napply Z.le_refl."},{"statement":"(x : R) (Zx : x <> 0%R) : (bpow (mag beta (scaled_mantissa x)) <= bpow (mag beta x - cexp x))%R.","proofString":"apply bpow_le.\nunfold scaled_mantissa.\nrewrite mag_mult_bpow with (1 := Zx).\napply Z.le_refl."},{"statement":"(x : R) (Zx : x <> 0%R) : (mag beta (scaled_mantissa x) <= mag beta x - cexp x)%Z.","proofString":"unfold scaled_mantissa.\nrewrite mag_mult_bpow with (1 := Zx).\napply Z.le_refl."},{"statement":"(x : R) (Zx : x <> 0%R) : (mag beta (x * bpow (- cexp x)) <= mag beta x - cexp x)%Z.","proofString":"rewrite mag_mult_bpow with (1 := Zx).\napply Z.le_refl."},{"statement":"(x : R) (Zx : x <> 0%R) : (mag beta x + - cexp x <= mag beta x - cexp x)%Z.","proofString":"apply Z.le_refl."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) : (cexp x < mag beta x)%Z.","proofString":"apply Znot_ge_lt.\nunfold cexp.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nspecialize (Ex Zx).\nintros H.\napply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) : ~ (cexp x >= mag beta x)%Z.","proofString":"unfold cexp.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nspecialize (Ex Zx).\nintros H.\napply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) : ~ (fexp (mag beta x) >= mag beta x)%Z.","proofString":"destruct (mag beta x) as (ex,Ex) ; simpl.\nspecialize (Ex Zx).\nintros H.\napply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : ~ (fexp ex >= ex)%Z.","proofString":"specialize (Ex Zx).\nintros H.\napply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : ~ (fexp ex >= ex)%Z.","proofString":"intros H.\napply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (fexp ex >= ex)%Z) : False.","proofString":"apply Z.ge_le in H.\ngeneralize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (ex <= fexp ex)%Z) : False.","proofString":"generalize (scaled_mantissa_lt_1 x ex (proj2 Ex) H).\ncontradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Zx : x <> 0%R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (ex <= fexp ex)%Z) : (Rabs (scaled_mantissa x) < 1)%R -> False.","proofString":"contradict Zx.\nrewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (ex <= fexp ex)%Z) (Zx : (Rabs (scaled_mantissa x) < 1)%R) : x = 0%R.","proofString":"rewrite Gx.\nreplace (Ztrunc (scaled_mantissa x)) with Z0.\napply F2R_0.\ncut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (Gx : generic_format x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (ex <= fexp ex)%Z) (Zx : (Rabs (scaled_mantissa x) < 1)%R) : 0%Z = Ztrunc (scaled_mantissa x).","proofString":"cut (Z.abs (Ztrunc (scaled_mantissa x)) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR.\nnow rewrite <- scaled_mantissa_generic."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : Zfloor (x * bpow (- fexp ex)) = 0%Z.","proofString":"apply Zfloor_imp.\nsimpl.\nassert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 <= x * bpow (- fexp ex) < IZR (0 + 1))%R.","proofString":"simpl.\nassert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 <= x * bpow (- fexp ex) < 1)%R.","proofString":"assert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (H : (0 < x * bpow (- fexp ex) < 1)%R) : (0 <= x * bpow (- fexp ex) < 1)%R.","proofString":"split ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : Zceil (x * bpow (- fexp ex)) = 1%Z.","proofString":"apply Zceil_imp.\nsimpl.\nassert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (IZR (1 - 1) < x * bpow (- fexp ex) <= 1)%R.","proofString":"simpl.\nassert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : (0 < x * bpow (- fexp ex) <= 1)%R.","proofString":"assert (H := mantissa_small_pos x ex Hx He).\nsplit ; try apply Rlt_le ; apply H."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) (H : (0 < x * bpow (- fexp ex) < 1)%R) : (0 < x * bpow (- fexp ex) <= 1)%R.","proofString":"split ; try apply Rlt_le ; apply H."},{"statement":"(emin : Z) (Emin : forall e : Z, (emin <= fexp e)%Z) (x : R) (Hx : (0 < x)%R) (Fx : generic_format x) : (bpow emin <= x)%R.","proofString":"rewrite Fx.\napply Rle_trans with (bpow (fexp (mag beta x))).\nnow apply bpow_le.\napply bpow_le_F2R.\napply gt_0_F2R with beta (cexp x).\nnow rewrite <- Fx."},{"statement":"(emin : Z) (Emin : forall e : Z, (emin <= fexp e)%Z) (x : R) (Hx : (0 < x)%R) (Fx : generic_format x) : (bpow emin <= bpow (fexp (mag beta x)))%R.","proofString":"now apply bpow_le."},{"statement":"(emin : Z) (Emin : forall e : Z, (emin <= fexp e)%Z) (x : R) (Hx : (0 < x)%R) (Fx : generic_format x) : (0 < Ztrunc (scaled_mantissa x))%Z.","proofString":"apply gt_0_F2R with beta (cexp x).\nnow rewrite <- Fx."},{"statement":"(e : Z) (He : generic_format (bpow e)) : (fexp e <= e)%Z.","proofString":"apply generic_format_bpow_inv' in He.\nassert (H := valid_exp_large' (e + 1) e).\nlia."},{"statement":"(e : Z) (He : (fexp (e + 1) <= e)%Z) : (fexp e <= e)%Z.","proofString":"assert (H := valid_exp_large' (e + 1) e).\nlia."},{"statement":"(e : Z) (He : (fexp (e + 1) <= e)%Z) (H : (fexp (e + 1) < e + 1)%Z -> (e <= e + 1)%Z -> (fexp e < e + 1)%Z) : (fexp e <= e)%Z.","proofString":"lia."},{"statement":"(x : R) : rnd x = Zfloor x \\/ rnd x = Zceil x.","proofString":"destruct (Zle_or_lt (rnd x) (Zfloor x)) as [Hx|Hx].\nleft.\napply Zle_antisym with (1 := Hx).\nrewrite <- (Zrnd_IZR (Zfloor x)).\napply Zrnd_le.\napply Zfloor_lb.\nright.\napply Zle_antisym.\nrewrite <- (Zrnd_IZR (Zceil x)).\napply Zrnd_le.\napply Zceil_ub.\nrewrite Zceil_floor_neq.\nlia.\nintros H.\nrewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (rnd x <= Zfloor x)%Z) : rnd x = Zfloor x \\/ rnd x = Zceil x.","proofString":"left.\napply Zle_antisym with (1 := Hx).\nrewrite <- (Zrnd_IZR (Zfloor x)).\napply Zrnd_le.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (rnd x <= Zfloor x)%Z) : rnd x = Zfloor x.","proofString":"apply Zle_antisym with (1 := Hx).\nrewrite <- (Zrnd_IZR (Zfloor x)).\napply Zrnd_le.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (rnd x <= Zfloor x)%Z) : (Zfloor x <= rnd x)%Z.","proofString":"rewrite <- (Zrnd_IZR (Zfloor x)).\napply Zrnd_le.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (rnd x <= Zfloor x)%Z) : (rnd (IZR (Zfloor x)) <= rnd x)%Z.","proofString":"apply Zrnd_le.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (rnd x <= Zfloor x)%Z) : (IZR (Zfloor x) <= x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : rnd x = Zfloor x \\/ rnd x = Zceil x.","proofString":"right.\napply Zle_antisym.\nrewrite <- (Zrnd_IZR (Zceil x)).\napply Zrnd_le.\napply Zceil_ub.\nrewrite Zceil_floor_neq.\nlia.\nintros H.\nrewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : rnd x = Zceil x.","proofString":"apply Zle_antisym.\nrewrite <- (Zrnd_IZR (Zceil x)).\napply Zrnd_le.\napply Zceil_ub.\nrewrite Zceil_floor_neq.\nlia.\nintros H.\nrewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : (rnd x <= Zceil x)%Z.","proofString":"rewrite <- (Zrnd_IZR (Zceil x)).\napply Zrnd_le.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : (rnd x <= rnd (IZR (Zceil x)))%Z.","proofString":"apply Zrnd_le.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : (x <= IZR (Zceil x))%R.","proofString":"apply Zceil_ub."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : (Zceil x <= rnd x)%Z.","proofString":"rewrite Zceil_floor_neq.\nlia.\nintros H.\nrewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : (Zfloor x + 1 <= rnd x)%Z.","proofString":"lia."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) : IZR (Zfloor x) <> x.","proofString":"intros H.\nrewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor x < rnd x)%Z) (H : IZR (Zfloor x) = x) : False.","proofString":"rewrite <- H in Hx.\nrewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor (IZR (Zfloor x)) < rnd (IZR (Zfloor x)))%Z) (H : IZR (Zfloor x) = x) : False.","proofString":"rewrite Zfloor_IZR, Zrnd_IZR in Hx.\napply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) (Hx : (Zfloor x < Zfloor x)%Z) (H : IZR (Zfloor x) = x) : False.","proofString":"apply Z.lt_irrefl with (1 := Hx)."},{"statement":"(x : R) : rnd x = Ztrunc x \\/ rnd x = Zaway x.","proofString":"unfold Ztrunc, Zaway.\ndestruct (Zrnd_DN_or_UP x) as [Hx|Hx] ;  case Rlt_bool.\nnow right.\nnow left.\nnow left.\nnow right."},{"statement":"(x : R) : rnd x = (if Rlt_bool x 0 then Zceil x else Zfloor x) \\/\nrnd x = (if Rlt_bool x 0 then Zfloor x else Zceil x).","proofString":"destruct (Zrnd_DN_or_UP x) as [Hx|Hx] ;  case Rlt_bool.\nnow right.\nnow left.\nnow left.\nnow right."},{"statement":"(x : R) (Hx : rnd x = Zfloor x) : rnd x = Zceil x \\/ rnd x = Zfloor x.","proofString":"now right."},{"statement":"(x : R) (Hx : rnd x = Zfloor x) : rnd x = Zfloor x \\/ rnd x = Zceil x.","proofString":"now left."},{"statement":"(x : R) (Hx : rnd x = Zceil x) : rnd x = Zceil x \\/ rnd x = Zfloor x.","proofString":"now left."},{"statement":"(x : R) (Hx : rnd x = Zceil x) : rnd x = Zfloor x \\/ rnd x = Zceil x.","proofString":"now right."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= round x <= bpow ex)%R.","proofString":"unfold round, scaled_mantissa.\nrewrite (cexp_fexp_pos _ _ Hx).\nunfold F2R.\nsimpl.\ndestruct (Zrnd_DN_or_UP (x * bpow (- fexp ex))) as [Hr|Hr] ; rewrite Hr.\nsplit.\nreplace (ex - 1)%Z with (ex - 1 + - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx.\napply Rle_trans with (2 := Rlt_le _ _ (proj2 Hx)).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb.\nsplit.\napply Rle_trans with (1 := proj1 Hx).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub.\npattern ex at 3 ; replace ex with (ex - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= IZR (rnd (x * bpow (- fexp ex))) * bpow (fexp ex) <=\n bpow ex)%R.","proofString":"destruct (Zrnd_DN_or_UP (x * bpow (- fexp ex))) as [Hr|Hr] ; rewrite Hr.\nsplit.\nreplace (ex - 1)%Z with (ex - 1 + - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx.\napply Rle_trans with (2 := Rlt_le _ _ (proj2 Hx)).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb.\nsplit.\napply Rle_trans with (1 := proj1 Hx).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub.\npattern ex at 3 ; replace ex with (ex - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (bpow (ex - 1) <= IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex) <=\n bpow ex)%R.","proofString":"split.\nreplace (ex - 1)%Z with (ex - 1 + - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx.\napply Rle_trans with (2 := Rlt_le _ _ (proj2 Hx)).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (bpow (ex - 1) <= IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"replace (ex - 1)%Z with (ex - 1 + - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (bpow (ex - 1 + - fexp ex + fexp ex) <=\n IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"rewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (bpow (ex - 1 + - fexp ex) * bpow (fexp ex) <=\n IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (0 <= bpow (fexp ex))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (bpow (ex - 1 + - fexp ex) <= IZR (Zfloor (x * bpow (- fexp ex))))%R.","proofString":"assert (Hf: IZR (Zpower beta (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex).","proofString":"apply IZR_Zpower.\nlia."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (0 <= ex - 1 + - fexp ex)%Z.","proofString":"lia."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (bpow (ex - 1 + - fexp ex) <= IZR (Zfloor (x * bpow (- fexp ex))))%R.","proofString":"rewrite <- Hf.\napply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (IZR (beta ^ (ex - 1 - fexp ex)) <= IZR (Zfloor (x * bpow (- fexp ex))))%R.","proofString":"apply IZR_le.\napply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (beta ^ (ex - 1 - fexp ex) <= Zfloor (x * bpow (- fexp ex)))%Z.","proofString":"apply Zfloor_lub.\nrewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (IZR (beta ^ (ex - 1 - fexp ex)) <= x * bpow (- fexp ex))%R.","proofString":"rewrite Hf.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (bpow (ex - 1 + - fexp ex) <= x * bpow (- fexp ex))%R.","proofString":"rewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (bpow (ex - 1) * bpow (- fexp ex) <= x * bpow (- fexp ex))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (0 <= bpow (- fexp ex))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - 1 - fexp ex)) = bpow (ex - 1 + - fexp ex)) : (bpow (ex - 1) <= x)%R.","proofString":"apply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex) <= bpow ex)%R.","proofString":"apply Rle_trans with (2 := Rlt_le _ _ (proj2 Hx)).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex) <= x)%R.","proofString":"apply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (0 < bpow (- fexp ex))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex) * bpow (- fexp ex) <=\n x * bpow (- fexp ex))%R.","proofString":"rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zfloor_lb."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) <= x * bpow (- fexp ex))%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (bpow (ex - 1) <= IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex) <=\n bpow ex)%R.","proofString":"split.\napply Rle_trans with (1 := proj1 Hx).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub.\npattern ex at 3 ; replace ex with (ex - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (bpow (ex - 1) <= IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"apply Rle_trans with (1 := proj1 Hx).\napply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (x <= IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"apply Rmult_le_reg_r with (bpow (- fexp ex)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (0 < bpow (- fexp ex))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (x * bpow (- fexp ex) <=\n IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex) * bpow (- fexp ex))%R.","proofString":"rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r.\napply Zceil_ub."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (x * bpow (- fexp ex) <= IZR (Zceil (x * bpow (- fexp ex))))%R.","proofString":"apply Zceil_ub."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex) <= bpow ex)%R.","proofString":"pattern ex at 3 ; replace ex with (ex - fexp ex + fexp ex)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex) <=\n bpow (ex - fexp ex + fexp ex))%R.","proofString":"rewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex) <=\n bpow (ex - fexp ex) * bpow (fexp ex))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\nassert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (0 <= bpow (fexp ex))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) <= bpow (ex - fexp ex))%R.","proofString":"assert (Hf: IZR (Zpower beta (ex - fexp ex)) = bpow (ex - fexp ex)).\napply IZR_Zpower.\nlia.\nrewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex).","proofString":"apply IZR_Zpower.\nlia."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (0 <= ex - fexp ex)%Z.","proofString":"lia."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (IZR (Zceil (x * bpow (- fexp ex))) <= bpow (ex - fexp ex))%R.","proofString":"rewrite <- Hf.\napply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (IZR (Zceil (x * bpow (- fexp ex))) <= IZR (beta ^ (ex - fexp ex)))%R.","proofString":"apply IZR_le.\napply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (Zceil (x * bpow (- fexp ex)) <= beta ^ (ex - fexp ex))%Z.","proofString":"apply Zceil_glb.\nrewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x * bpow (- fexp ex) <= IZR (beta ^ (ex - fexp ex)))%R.","proofString":"rewrite Hf.\nunfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x * bpow (- fexp ex) <= bpow (ex - fexp ex))%R.","proofString":"unfold Zminus.\nrewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x * bpow (- fexp ex) <= bpow (ex + - fexp ex))%R.","proofString":"rewrite bpow_plus.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x * bpow (- fexp ex) <= bpow ex * bpow (- fexp ex))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\napply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (0 <= bpow (- fexp ex))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x <= bpow ex)%R.","proofString":"apply Rlt_le.\napply Hx."},{"statement":"(x : R) (ex : Z) (He : (fexp ex < ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) (Hf : IZR (beta ^ (ex - fexp ex)) = bpow (ex - fexp ex)) : (x < bpow ex)%R.","proofString":"apply Hx."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : round x = 0%R \\/ round x = bpow (fexp ex).","proofString":"unfold round, scaled_mantissa.\nrewrite (cexp_fexp_pos _ _ Hx).\nunfold F2R.\nsimpl.\ndestruct (Zrnd_DN_or_UP (x * bpow (-fexp ex))) as [Hr|Hr] ; rewrite Hr.\nleft.\napply Rmult_eq_0_compat_r.\napply IZR_eq.\napply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos.\nright.\npattern (bpow (fexp ex)) at 2 ; rewrite <- Rmult_1_l.\napply (f_equal (fun m => (m * bpow (fexp ex))%R)).\napply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (IZR (rnd (x * bpow (- fexp ex))) * bpow (fexp ex))%R = 0%R \\/\n(IZR (rnd (x * bpow (- fexp ex))) * bpow (fexp ex))%R = bpow (fexp ex).","proofString":"destruct (Zrnd_DN_or_UP (x * bpow (-fexp ex))) as [Hr|Hr] ; rewrite Hr.\nleft.\napply Rmult_eq_0_compat_r.\napply IZR_eq.\napply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos.\nright.\npattern (bpow (fexp ex)) at 2 ; rewrite <- Rmult_1_l.\napply (f_equal (fun m => (m * bpow (fexp ex))%R)).\napply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R = 0%R \\/\n(IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R = bpow (fexp ex).","proofString":"left.\napply Rmult_eq_0_compat_r.\napply IZR_eq.\napply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (IZR (Zfloor (x * bpow (- fexp ex))) * bpow (fexp ex))%R = 0%R.","proofString":"apply Rmult_eq_0_compat_r.\napply IZR_eq.\napply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : IZR (Zfloor (x * bpow (- fexp ex))) = 0%R.","proofString":"apply IZR_eq.\napply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : Zfloor (x * bpow (- fexp ex)) = 0%Z.","proofString":"apply Zfloor_imp.\nrefine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (0 <= x * bpow (- fexp ex) < IZR (0 + 1))%R.","proofString":"refine (let H := _ in conj (Rlt_le _ _ (proj1 H)) (proj2 H)).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zfloor (x * bpow (- fexp ex))) : (0 < x * bpow (- fexp ex) < IZR (0 + 1))%R.","proofString":"now apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R = 0%R \\/\n(IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R = bpow (fexp ex).","proofString":"right.\npattern (bpow (fexp ex)) at 2 ; rewrite <- Rmult_1_l.\napply (f_equal (fun m => (m * bpow (fexp ex))%R)).\napply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R = bpow (fexp ex).","proofString":"pattern (bpow (fexp ex)) at 2 ; rewrite <- Rmult_1_l.\napply (f_equal (fun m => (m * bpow (fexp ex))%R)).\napply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (Zceil (x * bpow (- fexp ex))) * bpow (fexp ex))%R =\n(1 * bpow (fexp ex))%R.","proofString":"apply (f_equal (fun m => (m * bpow (fexp ex))%R)).\napply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : IZR (Zceil (x * bpow (- fexp ex))) = 1%R.","proofString":"apply IZR_eq.\napply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : Zceil (x * bpow (- fexp ex)) = 1%Z.","proofString":"apply Zceil_imp.\nrefine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (1 - 1) < x * bpow (- fexp ex) <= 1)%R.","proofString":"refine (let H := _ in conj (proj1 H) (Rlt_le _ _ (proj2 H))).\nnow apply mantissa_small_pos."},{"statement":"(x : R) (ex : Z) (He : (ex <= fexp ex)%Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (Hr : rnd (x * bpow (- fexp ex)) = Zceil (x * bpow (- fexp ex))) : (IZR (1 - 1) < x * bpow (- fexp ex) < 1)%R.","proofString":"now apply mantissa_small_pos."},{"statement":"(x : R) (Hx : generic_format x) : round x = x.","proofString":"unfold round.\nrewrite scaled_mantissa_generic with (1 := Hx).\nrewrite Zrnd_IZR.\nnow apply sym_eq."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (H1 : round x = 0%R) : (ex <= fexp ex)%Z.","proofString":"case (Zle_or_lt ex (fexp ex)); trivial; intros V.\ncontradict H1.\napply Rgt_not_eq.\napply Rlt_le_trans with (bpow (ex-1)).\napply bpow_gt_0.\napply (round_bounded_large_pos); assumption."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (H1 : round x = 0%R) (V : (fexp ex < ex)%Z) : (ex <= fexp ex)%Z.","proofString":"contradict H1.\napply Rgt_not_eq.\napply Rlt_le_trans with (bpow (ex-1)).\napply bpow_gt_0.\napply (round_bounded_large_pos); assumption."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (V : (fexp ex < ex)%Z) : round x <> 0%R.","proofString":"apply Rgt_not_eq.\napply Rlt_le_trans with (bpow (ex-1)).\napply bpow_gt_0.\napply (round_bounded_large_pos); assumption."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (V : (fexp ex < ex)%Z) : (round x > 0)%R.","proofString":"apply Rlt_le_trans with (bpow (ex-1)).\napply bpow_gt_0.\napply (round_bounded_large_pos); assumption."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (V : (fexp ex < ex)%Z) : (0 < bpow (ex - 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (H : (bpow (ex - 1) <= x < bpow ex)%R) (V : (fexp ex < ex)%Z) : (bpow (ex - 1) <= round x)%R.","proofString":"apply (round_bounded_large_pos); assumption."},{"statement":"(rnd1 rnd2 : R -> Z) (Hext : forall x0 : R, rnd1 x0 = rnd2 x0) (x : R) : round rnd1 x = round rnd2 x.","proofString":"unfold round.\nnow rewrite Hext."},{"statement":"(x : R) : round rnd (- x) = (- round Zrnd_opp x)%R.","proofString":"unfold round.\nrewrite <- F2R_Zopp, cexp_opp, scaled_mantissa_opp.\napply F2R_eq.\napply sym_eq.\nexact (Z.opp_involutive _)."},{"statement":"(x : R) : rnd (- scaled_mantissa x) = (- Zrnd_opp (scaled_mantissa x))%Z.","proofString":"apply sym_eq.\nexact (Z.opp_involutive _)."},{"statement":"(x : R) : (- Zrnd_opp (scaled_mantissa x))%Z = rnd (- scaled_mantissa x).","proofString":"exact (Z.opp_involutive _)."},{"statement":"(x : R) : round rnd x = round Zfloor x \\/ round rnd x = round Zceil x.","proofString":"unfold round.\ndestruct (Zrnd_DN_or_UP rnd (scaled_mantissa x)) as [Hx|Hx].\nleft.\nnow rewrite Hx.\nright.\nnow rewrite Hx."},{"statement":"(x : R) : round rnd x = round Ztrunc x \\/ round rnd x = round Zaway x.","proofString":"unfold round.\ndestruct (Zrnd_ZR_or_AW rnd (scaled_mantissa x)) as [Hx|Hx].\nleft.\nnow rewrite Hx.\nright.\nnow rewrite Hx."},{"statement":"(x y : R) (Hx : generic_format x) (Hxy : (x <= y)%R) : (x <= round rnd y)%R.","proofString":"rewrite <- (round_generic rnd x Hx).\nnow apply round_le."},{"statement":"(x y : R) (Hx : generic_format x) (Hxy : (x <= y)%R) : (round rnd x <= round rnd y)%R.","proofString":"now apply round_le."},{"statement":"(x y : R) (Hy : generic_format y) (Hxy : (x <= y)%R) : (round rnd x <= y)%R.","proofString":"rewrite <- (round_generic rnd y Hy).\nnow apply round_le."},{"statement":"(x y : R) (Hy : generic_format y) (Hxy : (x <= y)%R) : (round rnd x <= round rnd y)%R.","proofString":"now apply round_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : P (Rabs x) (Rabs (round rnd x)).","proofString":"rewrite 2!Rabs_pos_eq.\nnow apply HP.\nrewrite <- (round_0 rnd).\nnow apply round_le.\nexact Hx."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : P x (round rnd x).","proofString":"now apply HP."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : (0 <= round rnd x)%R.","proofString":"rewrite <- (round_0 rnd).\nnow apply round_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : (round rnd 0 <= round rnd x)%R.","proofString":"now apply round_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : (0 <= x)%R.","proofString":"exact Hx."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) : (0 <= - x)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) : (- 0 <= - x)%R.","proofString":"apply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(P : R -> R -> Prop) (HP : forall rnd0 : R -> Z,\nValid_rnd rnd0 -> forall x0 : R, (0 <= x0)%R -> P x0 (round rnd0 x0)) (rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (ex : Z) (H1 : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : round rnd x = 0%R) : (ex <= fexp ex)%Z.","proofString":"generalize Rabs_R0.\nrewrite <- H2 at 1.\napply (round_abs_abs (fun t rt => forall (ex : Z),(bpow (ex - 1) <= t < bpow ex)%R ->rt = 0%R -> (ex <= fexp ex)%Z)); trivial.\nclear; intros rnd Hr x Hx.\nnow apply exp_small_round_0_pos."},{"statement":"(rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (ex : Z) (H1 : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : round rnd x = 0%R) : Rabs 0 = 0%R -> (ex <= fexp ex)%Z.","proofString":"rewrite <- H2 at 1.\napply (round_abs_abs (fun t rt => forall (ex : Z),(bpow (ex - 1) <= t < bpow ex)%R ->rt = 0%R -> (ex <= fexp ex)%Z)); trivial.\nclear; intros rnd Hr x Hx.\nnow apply exp_small_round_0_pos."},{"statement":"(rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (ex : Z) (H1 : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : round rnd x = 0%R) : Rabs (round rnd x) = 0%R -> (ex <= fexp ex)%Z.","proofString":"apply (round_abs_abs (fun t rt => forall (ex : Z),(bpow (ex - 1) <= t < bpow ex)%R ->rt = 0%R -> (ex <= fexp ex)%Z)); trivial.\nclear; intros rnd Hr x Hx.\nnow apply exp_small_round_0_pos."},{"statement":"(rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (ex : Z) (H1 : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : round rnd x = 0%R) : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 <= x0)%R ->\nforall ex0 : Z,\n(bpow (ex0 - 1) <= x0 < bpow ex0)%R ->\nround rnd0 x0 = 0%R -> (ex0 <= fexp ex0)%Z.","proofString":"clear; intros rnd Hr x Hx.\nnow apply exp_small_round_0_pos."},{"statement":"(rnd : R -> Z) (Hr : Valid_rnd rnd) (x : R) (Hx : (0 <= x)%R) : forall ex : Z,\n(bpow (ex - 1) <= x < bpow ex)%R -> round rnd x = 0%R -> (ex <= fexp ex)%Z.","proofString":"now apply exp_small_round_0_pos."},{"statement":"(x : R) : round Zfloor (- x) = (- round Zceil x)%R.","proofString":"unfold round.\nrewrite scaled_mantissa_opp.\nrewrite <- F2R_Zopp.\nunfold Zceil.\nrewrite Z.opp_involutive.\nnow rewrite cexp_opp."},{"statement":"(x : R) : round Zceil (- x) = (- round Zfloor x)%R.","proofString":"unfold round.\nrewrite scaled_mantissa_opp.\nrewrite <- F2R_Zopp.\nunfold Zceil.\nrewrite Ropp_involutive.\nnow rewrite cexp_opp."},{"statement":"(x : R) : round Ztrunc (- x) = (- round Ztrunc x)%R.","proofString":"unfold round.\nrewrite scaled_mantissa_opp, cexp_opp, Ztrunc_opp.\napply F2R_Zopp."},{"statement":"(x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hx : (x >= 0)%R) : (0 <= x)%R.","proofString":"now apply Rge_le."},{"statement":"(x : R) : round Zaway (- x) = (- round Zaway x)%R.","proofString":"unfold round.\nrewrite scaled_mantissa_opp, cexp_opp, Zaway_opp.\napply F2R_Zopp."},{"statement":"(x : R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hx : (x >= 0)%R) : (0 <= x)%R.","proofString":"now apply Rge_le."},{"statement":"(x : R) (Hx : (0 <= x)%R) : round Ztrunc x = round Zfloor x.","proofString":"unfold round, Ztrunc.\ncase Rlt_bool_spec.\nintros H.\nelim Rlt_not_le with (1 := H).\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0.\neasy."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 <= scaled_mantissa x)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 * bpow (- cexp x) <= scaled_mantissa x)%R.","proofString":"apply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) : round Ztrunc x = round Zceil x.","proofString":"unfold round, Ztrunc.\ncase Rlt_bool_spec.\neasy.\nintros [H|H].\nelim Rlt_not_le with (1 := H).\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0.\nrewrite <- H.\nnow rewrite Zfloor_IZR, Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (scaled_mantissa x <= 0)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (scaled_mantissa x <= 0 * bpow (- cexp x))%R.","proofString":"apply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : (0 <= x)%R) : round Zaway x = round Zceil x.","proofString":"unfold round, Zaway.\ncase Rlt_bool_spec.\nintros H.\nelim Rlt_not_le with (1 := H).\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0.\neasy."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 <= scaled_mantissa x)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 * bpow (- cexp x) <= scaled_mantissa x)%R.","proofString":"apply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (0 <= x)%R) (H : (scaled_mantissa x < 0)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) : round Zaway x = round Zfloor x.","proofString":"unfold round, Zaway.\ncase Rlt_bool_spec.\neasy.\nintros [H|H].\nelim Rlt_not_le with (1 := H).\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0.\nrewrite <- H.\nnow rewrite Zfloor_IZR, Zceil_IZR."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (scaled_mantissa x <= 0)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (scaled_mantissa x <= 0 * bpow (- cexp x))%R.","proofString":"apply Rmult_le_compat_r with (2 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (Hx : (x <= 0)%R) (H : (0 < scaled_mantissa x)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) (Hr : round rnd (- - x) = round Zfloor (- - x)) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Hx : (x < 0)%R) (Hr : round rnd (- - x) = round Zceil (- - x)) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Hx : x = 0%R) : generic_format 0.","proofString":"apply generic_format_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) : generic_format (round rnd x).","proofString":"now apply generic_format_round_pos."},{"statement":"(x : R) : (round Zfloor x <= x)%R.","proofString":"pattern x at 2 ; rewrite <- scaled_mantissa_mult_bpow.\nunfold round, F2R.\nsimpl.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Zfloor_lb."},{"statement":"(x : R) : (round Zfloor x <= scaled_mantissa x * bpow (cexp x))%R.","proofString":"unfold round, F2R.\nsimpl.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply Zfloor_lb."},{"statement":"(x : R) : (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x) <=\n scaled_mantissa x * bpow (cexp x))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\napply Zfloor_lb."},{"statement":"(x : R) : (0 <= bpow (cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) : (IZR (Zfloor (scaled_mantissa x)) <= scaled_mantissa x)%R.","proofString":"apply Zfloor_lb."},{"statement":"generic_format 0.","proofString":"exact generic_format_0."},{"statement":"forall x : R, generic_format x -> generic_format (- x).","proofString":"exact generic_format_opp."},{"statement":"round_pred_total (Rnd_DN_pt generic_format).","proofString":"intros x.\neexists.\napply round_DN_pt."},{"statement":"(x : R) : exists f : R, Rnd_DN_pt generic_format x f.","proofString":"eexists.\napply round_DN_pt."},{"statement":"(x : R) : Rnd_UP_pt generic_format x (round Zceil x).","proofString":"rewrite <- (Ropp_involutive x).\nrewrite round_UP_opp.\napply Rnd_UP_pt_opp.\napply generic_format_opp.\napply round_DN_pt."},{"statement":"(x : R) : Rnd_UP_pt generic_format (- - x) (round Zceil (- - x)).","proofString":"rewrite round_UP_opp.\napply Rnd_UP_pt_opp.\napply generic_format_opp.\napply round_DN_pt."},{"statement":"(x : R) : Rnd_UP_pt generic_format (- - x) (- round Zfloor (- x)).","proofString":"apply Rnd_UP_pt_opp.\napply generic_format_opp.\napply round_DN_pt."},{"statement":"(x : R) : forall x0 : R, generic_format x0 -> generic_format (- x0).","proofString":"apply generic_format_opp."},{"statement":"(x : R) : Rnd_DN_pt generic_format (- x) (round Zfloor (- x)).","proofString":"apply round_DN_pt."},{"statement":"(x : R) : Rnd_ZR_pt generic_format x (round Ztrunc x).","proofString":"split ; intros Hx.\nrewrite round_ZR_DN with (1 := Hx).\napply round_DN_pt.\nrewrite round_ZR_UP with (1 := Hx).\napply round_UP_pt."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Rnd_DN_pt generic_format x (round Ztrunc x).","proofString":"rewrite round_ZR_DN with (1 := Hx).\napply round_DN_pt."},{"statement":"(x : R) (Hx : (0 <= x)%R) : Rnd_DN_pt generic_format x (round Zfloor x).","proofString":"apply round_DN_pt."},{"statement":"(x : R) (Hx : (x <= 0)%R) : Rnd_UP_pt generic_format x (round Ztrunc x).","proofString":"rewrite round_ZR_UP with (1 := Hx).\napply round_UP_pt."},{"statement":"(x : R) (Hx : (x <= 0)%R) : Rnd_UP_pt generic_format x (round Zceil x).","proofString":"apply round_UP_pt."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : round Zfloor x = 0%R.","proofString":"rewrite <- (F2R_0 beta (cexp x)).\nrewrite <- mantissa_DN_small_pos with (1 := Hx) (2 := He).\nnow rewrite <- cexp_fexp_pos with (1 := Hx)."},{"statement":"(x : R) (Fx : ~ generic_format x) : (round Zfloor x <= x <= round Zceil x)%R.","proofString":"split.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) (Fx : ~ generic_format x) : (round Zfloor x <= x)%R.","proofString":"apply round_DN_pt."},{"statement":"(x : R) (Fx : ~ generic_format x) : (x <= round Zceil x)%R.","proofString":"apply round_UP_pt."},{"statement":"(x : R) (ex : Z) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : round Zceil x = bpow (fexp ex).","proofString":"rewrite <- F2R_bpow.\nrewrite <- mantissa_UP_small_pos with (1 := Hx) (2 := He).\nnow rewrite <- cexp_fexp_pos with (1 := Hx)."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 < round Ztrunc (Rabs x))%R.","proofString":"rewrite round_ZR_abs.\nnow apply Rabs_pos_lt."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 < Rabs (round Ztrunc x))%R.","proofString":"now apply Rabs_pos_lt."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply Ex."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (round Ztrunc (Rabs x) < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 Ex).\nrewrite round_ZR_DN.\napply round_DN_pt.\napply Rabs_pos."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (round Ztrunc (Rabs x) <= Rabs x)%R.","proofString":"rewrite round_ZR_DN.\napply round_DN_pt.\napply Rabs_pos."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (round Zfloor (Rabs x) <= Rabs x)%R.","proofString":"apply round_DN_pt."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= Rabs x)%R.","proofString":"apply Rabs_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : round Zaway (Rabs x) = bpow (Z.max ex (fexp ex)).","proofString":"rewrite Z.max_r with (1 := He).\nrewrite round_AW_UP with (1 := Rabs_pos _).\nnow apply round_UP_small_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : round Zaway (Rabs x) = bpow (fexp ex).","proofString":"rewrite round_AW_UP with (1 := Rabs_pos _).\nnow apply round_UP_small_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (ex <= fexp ex)%Z) : round Zceil (Rabs x) = bpow (fexp ex).","proofString":"now apply round_UP_small_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (fexp ex < ex)%Z) (H1 : (bpow (ex - 1) <= round Zaway (Rabs x))%R) (H2 : (round Zaway (Rabs x) < bpow ex)%R) : (bpow (ex - 1) <= Rabs (round Zaway (Rabs x)) < bpow ex)%R.","proofString":"rewrite <- round_AW_abs, Rabs_Rabsolu.\nnow split."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (fexp ex < ex)%Z) (H1 : (bpow (ex - 1) <= round Zaway (Rabs x))%R) (H2 : (round Zaway (Rabs x) < bpow ex)%R) : (bpow (ex - 1) <= round Zaway (Rabs x) < bpow ex)%R.","proofString":"now split."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) (Zx : x <> 0%R) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He : (fexp ex < ex)%Z) (H1 : (bpow (ex - 1) <= round Zaway (Rabs x))%R) (H2 : round Zaway (Rabs x) = bpow ex) : round Zaway (Rabs x) = bpow (Z.max ex (fexp ex)).","proofString":"now rewrite Z.max_l with (1 := Zlt_le_weak _ _ He)."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : (0 < x)%R.","proofString":"apply Rlt_le_trans with (1 := Hd).\napply round_DN_pt."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : (round Zfloor x <= x)%R.","proofString":"apply round_DN_pt."},{"statement":"(x : R) (H : (0 < x)%R) (Hd : (0 < round Ztrunc x)%R) : round Ztrunc x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (H : (0 < x)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : cexp (round Zfloor x) = cexp x.","proofString":"apply (f_equal fexp).\nnow apply mag_DN."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : scaled_mantissa (round Zfloor x) = IZR (Zfloor (scaled_mantissa x)).","proofString":"unfold scaled_mantissa.\nrewrite cexp_DN with (1 := Hd).\nunfold round, F2R.\nsimpl.\nnow rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : (round Zfloor x * bpow (- cexp (round Zfloor x)))%R =\nIZR (Zfloor (x * bpow (- cexp x))).","proofString":"rewrite cexp_DN with (1 := Hd).\nunfold round, F2R.\nsimpl.\nnow rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : (round Zfloor x * bpow (- cexp x))%R = IZR (Zfloor (x * bpow (- cexp x))).","proofString":"unfold round, F2R.\nsimpl.\nnow rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r."},{"statement":"(x : R) (Hd : (0 < round Zfloor x)%R) : (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x) * bpow (- cexp x))%R =\nIZR (Zfloor (x * bpow (- cexp x))).","proofString":"now rewrite Rmult_assoc, <- bpow_plus, Zplus_opp_r, Rmult_1_r."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) : f = round Zfloor x \\/ f = round Zceil x.","proofString":"destruct (Rnd_N_pt_DN_or_UP _ _ _ Hxf).\nleft.\napply Rnd_DN_pt_unique with (1 := H).\napply round_DN_pt.\nright.\napply Rnd_UP_pt_unique with (1 := H).\napply round_UP_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_DN_pt generic_format x f) : f = round Zfloor x \\/ f = round Zceil x.","proofString":"left.\napply Rnd_DN_pt_unique with (1 := H).\napply round_DN_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_DN_pt generic_format x f) : f = round Zfloor x.","proofString":"apply Rnd_DN_pt_unique with (1 := H).\napply round_DN_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_DN_pt generic_format x f) : Rnd_DN_pt generic_format x (round Zfloor x).","proofString":"apply round_DN_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_UP_pt generic_format x f) : f = round Zfloor x \\/ f = round Zceil x.","proofString":"right.\napply Rnd_UP_pt_unique with (1 := H).\napply round_UP_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_UP_pt generic_format x f) : f = round Zceil x.","proofString":"apply Rnd_UP_pt_unique with (1 := H).\napply round_UP_pt."},{"statement":"(x f : R) (Hxf : Rnd_N_pt generic_format x f) (H : Rnd_UP_pt generic_format x f) : Rnd_UP_pt generic_format x (round Zceil x).","proofString":"apply round_UP_pt."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) : (cexp x <= fexp e)%Z.","proofString":"apply monotone_exp.\nnow apply mag_le_bpow."},{"statement":"(x : R) (e : Z) (Zx : x <> 0%R) (Hx : (Rabs x < bpow e)%R) : (mag beta x <= e)%Z.","proofString":"now apply mag_le_bpow."},{"statement":"(x : R) (e : Z) (Hx : (bpow (e - 1) <= Rabs x)%R) : (fexp e <= cexp x)%Z.","proofString":"apply monotone_exp.\nrewrite (Zsucc_pred e).\napply Zlt_le_succ.\nnow apply mag_gt_bpow."},{"statement":"(x : R) (e : Z) (Hx : (bpow (e - 1) <= Rabs x)%R) : (e <= mag beta x)%Z.","proofString":"rewrite (Zsucc_pred e).\napply Zlt_le_succ.\nnow apply mag_gt_bpow."},{"statement":"(x : R) (e : Z) (Hx : (bpow (e - 1) <= Rabs x)%R) : (Z.succ (Z.pred e) <= mag beta x)%Z.","proofString":"apply Zlt_le_succ.\nnow apply mag_gt_bpow."},{"statement":"(x : R) (e : Z) (Hx : (bpow (e - 1) <= Rabs x)%R) : (Z.pred e < mag beta x)%Z.","proofString":"now apply mag_gt_bpow."},{"statement":"(x y : R) (Zy : (0 < y)%R) (He : (cexp x < cexp y)%Z) : (x < y)%R.","proofString":"unfold cexp in He.\napply (lt_mag beta) with (1 := Zy).\ngeneralize (monotone_exp (mag beta y) (mag beta x)).\nlia."},{"statement":"(x y : R) (Zy : (0 < y)%R) (He : (fexp (mag beta x) < fexp (mag beta y))%Z) : (x < y)%R.","proofString":"apply (lt_mag beta) with (1 := Zy).\ngeneralize (monotone_exp (mag beta y) (mag beta x)).\nlia."},{"statement":"(x y : R) (Zy : (0 < y)%R) (He : (fexp (mag beta x) < fexp (mag beta y))%Z) : (mag beta x < mag beta y)%Z.","proofString":"generalize (monotone_exp (mag beta y) (mag beta x)).\nlia."},{"statement":"(x y : R) (Zy : (0 < y)%R) (He : (fexp (mag beta x) < fexp (mag beta y))%Z) : ((mag beta y <= mag beta x)%Z -> (fexp (mag beta y) <= fexp (mag beta x))%Z) ->\n(mag beta x < mag beta y)%Z.","proofString":"lia."},{"statement":"(x y : R) (Zy : y <> 0%R) (He : (cexp x < cexp y)%Z) : (Rabs x < Rabs y)%R.","proofString":"apply lt_cexp_pos.\nnow apply Rabs_pos_lt.\nnow rewrite 2!cexp_abs."},{"statement":"(x y : R) (Zy : y <> 0%R) (He : (cexp x < cexp y)%Z) : (0 < Rabs y)%R.","proofString":"now apply Rabs_pos_lt."},{"statement":"(x y : R) (Zy : y <> 0%R) (He : (cexp x < cexp y)%Z) : (cexp (Rabs x) < cexp (Rabs y))%Z.","proofString":"now rewrite 2!cexp_abs."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) : (mag beta x <= mag beta (round Ztrunc x))%Z.","proofString":"rewrite mag_round_ZR with (1 := Zr).\napply Z.le_refl."},{"statement":"(x : R) (Zr : round Ztrunc x <> 0%R) : (mag beta x <= mag beta x)%Z.","proofString":"apply Z.le_refl."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) : (Rabs x <= Rabs (round Zaway x))%R.","proofString":"rewrite <- round_AW_abs.\nrewrite round_AW_UP.\napply round_UP_pt.\napply Rabs_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) : (Rabs x <= round Zaway (Rabs x))%R.","proofString":"rewrite round_AW_UP.\napply round_UP_pt.\napply Rabs_pos."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) : (Rabs x <= round Zceil (Rabs x))%R.","proofString":"apply round_UP_pt."},{"statement":"(x : R) (Zr : round Zaway x <> 0%R) : (0 <= Rabs x)%R.","proofString":"apply Rabs_pos."},{"statement":"(x : R) (Zr : round rnd x <> 0%R) : (cexp x <= cexp (round rnd x))%Z.","proofString":"unfold cexp.\napply monotone_exp.\nnow apply mag_round_ge."},{"statement":"(x : R) (Zr : round rnd x <> 0%R) : (fexp (mag beta x) <= fexp (mag beta (round rnd x)))%Z.","proofString":"apply monotone_exp.\nnow apply mag_round_ge."},{"statement":"(x : R) (Zr : round rnd x <> 0%R) : (mag beta x <= mag beta (round rnd x))%Z.","proofString":"now apply mag_round_ge."},{"statement":"(x : R) : Znearest x = Zfloor x \\/ Znearest x = Zceil x.","proofString":"unfold Znearest.\ncase Rcompare_spec ; intros _.\nnow left.\ncase choice.\nnow right.\nnow left.\nnow right."},{"statement":"(x : R) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = Zfloor x \\/\nmatch Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend = Zceil x.","proofString":"case Rcompare_spec ; intros _.\nnow left.\ncase choice.\nnow right.\nnow left.\nnow right."},{"statement":"(x : R) : Zfloor x = Zfloor x \\/ Zfloor x = Zceil x.","proofString":"now left."},{"statement":"(x : R) : (if choice (Zfloor x) then Zceil x else Zfloor x) = Zfloor x \\/\n(if choice (Zfloor x) then Zceil x else Zfloor x) = Zceil x.","proofString":"case choice.\nnow right.\nnow left."},{"statement":"(x : R) : Zceil x = Zfloor x \\/ Zceil x = Zceil x.","proofString":"now right."},{"statement":"(x : R) : Zfloor x = Zfloor x \\/ Zfloor x = Zceil x.","proofString":"now left."},{"statement":"(x : R) : Zceil x = Zfloor x \\/ Zceil x = Zceil x.","proofString":"now right."},{"statement":"(x : R) : (Zfloor x <= Znearest x)%Z.","proofString":"destruct (Znearest_DN_or_UP x) as [Hx|Hx] ; rewrite Hx.\napply Z.le_refl.\napply le_IZR.\napply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zfloor x) : (Zfloor x <= Zfloor x)%Z.","proofString":"apply Z.le_refl."},{"statement":"(x : R) (Hx : Znearest x = Zceil x) : (Zfloor x <= Zceil x)%Z.","proofString":"apply le_IZR.\napply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zceil x) : (IZR (Zfloor x) <= IZR (Zceil x))%R.","proofString":"apply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zceil x) : (IZR (Zfloor x) <= x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (Hx : Znearest x = Zceil x) : (x <= IZR (Zceil x))%R.","proofString":"apply Zceil_ub."},{"statement":"(x : R) : (Znearest x <= Zceil x)%Z.","proofString":"destruct (Znearest_DN_or_UP x) as [Hx|Hx] ; rewrite Hx.\napply le_IZR.\napply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub.\napply Z.le_refl."},{"statement":"(x : R) (Hx : Znearest x = Zfloor x) : (Zfloor x <= Zceil x)%Z.","proofString":"apply le_IZR.\napply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zfloor x) : (IZR (Zfloor x) <= IZR (Zceil x))%R.","proofString":"apply Rle_trans with x.\napply Zfloor_lb.\napply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zfloor x) : (IZR (Zfloor x) <= x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (Hx : Znearest x = Zfloor x) : (x <= IZR (Zceil x))%R.","proofString":"apply Zceil_ub."},{"statement":"(x : R) (Hx : Znearest x = Zceil x) : (Zceil x <= Zceil x)%Z.","proofString":"apply Z.le_refl."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) : (Rabs (x - IZR (Znearest x)) < / 2)%R.","proofString":"unfold Znearest.\ncase Rcompare_spec ; intros H.\nrewrite Rabs_pos_eq.\nexact H.\napply Rle_0_minus.\napply Zfloor_lb.\nnow elim Hx.\nrewrite Rabs_left1.\nrewrite Ropp_minus_distr.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x).\napply Rle_minus.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) : (Rabs\n   (x -\n    IZR\n      match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n      | Eq => if choice (Zfloor x) then Zceil x else Zfloor x\n      | Lt => Zfloor x\n      | Gt => Zceil x\n      end) < / 2)%R.","proofString":"case Rcompare_spec ; intros H.\nrewrite Rabs_pos_eq.\nexact H.\napply Rle_0_minus.\napply Zfloor_lb.\nnow elim Hx.\nrewrite Rabs_left1.\nrewrite Ropp_minus_distr.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x).\napply Rle_minus.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (x - IZR (Zfloor x) < / 2)%R) : (Rabs (x - IZR (Zfloor x)) < / 2)%R.","proofString":"rewrite Rabs_pos_eq.\nexact H.\napply Rle_0_minus.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (x - IZR (Zfloor x) < / 2)%R) : (x - IZR (Zfloor x) < / 2)%R.","proofString":"exact H."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (x - IZR (Zfloor x) < / 2)%R) : (0 <= x - IZR (Zfloor x))%R.","proofString":"apply Rle_0_minus.\napply Zfloor_lb."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (x - IZR (Zfloor x) < / 2)%R) : (IZR (Zfloor x) <= x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (x - IZR (Zfloor x))%R = (/ 2)%R) : (Rabs (x - IZR (if choice (Zfloor x) then Zceil x else Zfloor x)) < / 2)%R.","proofString":"now elim Hx."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (Rabs (x - IZR (Zceil x)) < / 2)%R.","proofString":"rewrite Rabs_left1.\nrewrite Ropp_minus_distr.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x).\napply Rle_minus.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (- (x - IZR (Zceil x)) < / 2)%R.","proofString":"rewrite Ropp_minus_distr.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (IZR (Zceil x) - x < / 2)%R.","proofString":"rewrite Zceil_floor_neq.\nrewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (IZR (Zfloor x + 1) - x < / 2)%R.","proofString":"rewrite plus_IZR.\napply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (IZR (Zfloor x) + 1 - x < / 2)%R.","proofString":"apply Ropp_lt_cancel.\napply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (- / 2 < - (IZR (Zfloor x) + 1 - x))%R.","proofString":"apply Rplus_lt_reg_l with 1%R.\nreplace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (1 + - / 2 < 1 + - (IZR (Zfloor x) + 1 - x))%R.","proofString":"replace (1 + -/2)%R with (/2)%R by field.\nnow replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (/ 2 < 1 + - (IZR (Zfloor x) + 1 - x))%R.","proofString":"now replace (1 + - (IZR (Zfloor x) + 1 - x))%R with (x - IZR (Zfloor x))%R by ring."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : IZR (Zfloor x) <> x.","proofString":"apply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (IZR (Zfloor x) < x)%R.","proofString":"apply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\napply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (- IZR (Zfloor x) + IZR (Zfloor x) < - IZR (Zfloor x) + x)%R.","proofString":"apply Rlt_trans with (/2)%R.\nrewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nnow rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (- IZR (Zfloor x) + IZR (Zfloor x) < / 2)%R.","proofString":"rewrite Rplus_opp_l.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (/ 2 < - IZR (Zfloor x) + x)%R.","proofString":"now rewrite <- (Rplus_comm x)."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (x - IZR (Zceil x) <= 0)%R.","proofString":"apply Rle_minus.\napply Zceil_ub."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) (H : (/ 2 < x - IZR (Zfloor x))%R) : (x <= IZR (Zceil x))%R.","proofString":"apply Zceil_ub."},{"statement":"(x : R) : (Rabs (x - IZR (Znearest x)) <= / 2)%R.","proofString":"destruct (Req_dec (x - IZR (Zfloor x)) (/2)) as [Hx|Hx].\nassert (K: (Rabs (/2) <= /2)%R).\napply Req_le.\napply Rabs_pos_eq.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\ndestruct (Znearest_DN_or_UP x) as [H|H] ; rewrite H ; clear H.\nnow rewrite Hx.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\nreplace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply Rlt_le.\nnow apply Znearest_N_strict."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : (Rabs (x - IZR (Znearest x)) <= / 2)%R.","proofString":"assert (K: (Rabs (/2) <= /2)%R).\napply Req_le.\napply Rabs_pos_eq.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\ndestruct (Znearest_DN_or_UP x) as [H|H] ; rewrite H ; clear H.\nnow rewrite Hx.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\nreplace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : (Rabs (/ 2) <= / 2)%R.","proofString":"apply Req_le.\napply Rabs_pos_eq.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : Rabs (/ 2) = (/ 2)%R.","proofString":"apply Rabs_pos_eq.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - IZR (Znearest x)) <= / 2)%R.","proofString":"destruct (Znearest_DN_or_UP x) as [H|H] ; rewrite H ; clear H.\nnow rewrite Hx.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\nreplace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - IZR (Zfloor x)) <= / 2)%R.","proofString":"now rewrite Hx."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - IZR (Zceil x)) <= / 2)%R.","proofString":"rewrite Zceil_floor_neq.\nrewrite plus_IZR.\nreplace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field.\napply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - IZR (Zfloor x + 1)) <= / 2)%R.","proofString":"rewrite plus_IZR.\nreplace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - (IZR (Zfloor x) + 1)) <= / 2)%R.","proofString":"replace (x - (IZR (Zfloor x) + 1))%R with (x - IZR (Zfloor x) - 1)%R by ring.\nrewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (x - IZR (Zfloor x) - 1) <= / 2)%R.","proofString":"rewrite Hx.\nrewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (/ 2 - 1) <= / 2)%R.","proofString":"rewrite Rabs_minus_sym.\nnow replace (1 - /2)%R with (/2)%R by field."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (Rabs (1 - / 2) <= / 2)%R.","proofString":"now replace (1 - /2)%R with (/2)%R by field."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : IZR (Zfloor x) <> x.","proofString":"apply Rlt_not_eq.\napply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (IZR (Zfloor x) < x)%R.","proofString":"apply Rplus_lt_reg_l with (- IZR (Zfloor x))%R.\nrewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (- IZR (Zfloor x) + IZR (Zfloor x) < - IZR (Zfloor x) + x)%R.","proofString":"rewrite Rplus_opp_l, Rplus_comm.\nfold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (0 < x + - IZR (Zfloor x))%R.","proofString":"fold (x - IZR (Zfloor x))%R.\nrewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (0 < x - IZR (Zfloor x))%R.","proofString":"rewrite Hx.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R = (/ 2)%R) (K : (Rabs (/ 2) <= / 2)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) : (Rabs (x - IZR (Znearest x)) <= / 2)%R.","proofString":"apply Rlt_le.\nnow apply Znearest_N_strict."},{"statement":"(x : R) (Hx : (x - IZR (Zfloor x))%R <> (/ 2)%R) : (Rabs (x - IZR (Znearest x)) < / 2)%R.","proofString":"now apply Znearest_N_strict."},{"statement":"(x : R) (n : Z) (Hd : (Rabs (x - IZR n) < / 2)%R) : Znearest x = n.","proofString":"cut (Z.abs (Znearest x - n) < 1)%Z.\nclear ; lia.\napply lt_IZR.\nrewrite abs_IZR, minus_IZR.\nreplace (IZR (Znearest x) - IZR n)%R with (- (x - IZR (Znearest x)) + (x - IZR n))%R by ring.\napply Rle_lt_trans with (1 := Rabs_triang _ _).\nsimpl.\nreplace 1%R with (/2 + /2)%R by field.\napply Rplus_le_lt_compat with (2 := Hd).\nrewrite Rabs_Ropp.\napply Znearest_half."},{"statement":"(x : R) : (x - round Zfloor x)%R = (round Zceil x - x)%R ->\nround Znearest x =\n(if choice (Zfloor (scaled_mantissa x))\n then round Zceil x\n else round Zfloor x).","proofString":"pattern x at 1 4 ; rewrite <- scaled_mantissa_mult_bpow.\nunfold round, Znearest, F2R.\nsimpl.\ndestruct (Req_dec (IZR (Zfloor (scaled_mantissa x))) (scaled_mantissa x)) as [Fx|Fx].\nintros _.\nrewrite <- Fx.\nrewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m).\nintros H.\nrewrite Rcompare_floor_ceil_middle with (1 := Fx).\nrewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) : (scaled_mantissa x * bpow (cexp x) - round Zfloor x)%R =\n(round Zceil x - scaled_mantissa x * bpow (cexp x))%R ->\nround Znearest x =\n(if choice (Zfloor (scaled_mantissa x))\n then round Zceil x\n else round Zfloor x).","proofString":"unfold round, Znearest, F2R.\nsimpl.\ndestruct (Req_dec (IZR (Zfloor (scaled_mantissa x))) (scaled_mantissa x)) as [Fx|Fx].\nintros _.\nrewrite <- Fx.\nrewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m).\nintros H.\nrewrite Rcompare_floor_ceil_middle with (1 := Fx).\nrewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R ->\n(IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"destruct (Req_dec (IZR (Zfloor (scaled_mantissa x))) (scaled_mantissa x)) as [Fx|Fx].\nintros _.\nrewrite <- Fx.\nrewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m).\nintros H.\nrewrite Rcompare_floor_ceil_middle with (1 := Fx).\nrewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) = scaled_mantissa x) : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R ->\n(IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"intros _.\nrewrite <- Fx.\nrewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m)."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) = scaled_mantissa x) : (IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"rewrite <- Fx.\nrewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m)."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) = scaled_mantissa x) : (IZR\n   match\n     Rcompare\n       (IZR (Zfloor (scaled_mantissa x)) -\n        IZR (Zfloor (IZR (Zfloor (scaled_mantissa x))))) \n       (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (IZR (Zfloor (scaled_mantissa x))))\n       then Zceil (IZR (Zfloor (scaled_mantissa x)))\n       else Zfloor (IZR (Zfloor (scaled_mantissa x)))\n   | Lt => Zfloor (IZR (Zfloor (scaled_mantissa x)))\n   | Gt => Zceil (IZR (Zfloor (scaled_mantissa x)))\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (IZR (Zfloor (scaled_mantissa x))))\n then (IZR (Zceil (IZR (Zfloor (scaled_mantissa x)))) * bpow (cexp x))%R\n else (IZR (Zfloor (IZR (Zfloor (scaled_mantissa x)))) * bpow (cexp x))%R).","proofString":"rewrite Zceil_IZR, Zfloor_IZR.\nset (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m)."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) = scaled_mantissa x) : (IZR\n   match\n     Rcompare\n       (IZR (Zfloor (scaled_mantissa x)) - IZR (Zfloor (scaled_mantissa x)))\n       (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zfloor (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | _ => Zfloor (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"set (m := Zfloor (scaled_mantissa x)).\nnow case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m)."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) = scaled_mantissa x) (m : Z) : (IZR\n   match Rcompare (IZR m - IZR m) (/ 2) with\n   | Eq => if choice m then m else m\n   | _ => m\n   end * bpow (cexp x))%R =\n(if choice m then (IZR m * bpow (cexp x))%R else (IZR m * bpow (cexp x))%R).","proofString":"now case (Rcompare (IZR m - IZR m) (/ 2)) ; case (choice m)."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R ->\n(IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"intros H.\nrewrite Rcompare_floor_ceil_middle with (1 := Fx).\nrewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : (IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) (/ 2)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"rewrite Rcompare_floor_ceil_middle with (1 := Fx).\nrewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : (IZR\n   match\n     Rcompare (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x)))\n       (IZR (Zceil (scaled_mantissa x)) - scaled_mantissa x)\n   with\n   | Eq =>\n       if choice (Zfloor (scaled_mantissa x))\n       then Zceil (scaled_mantissa x)\n       else Zfloor (scaled_mantissa x)\n   | Lt => Zfloor (scaled_mantissa x)\n   | Gt => Zceil (scaled_mantissa x)\n   end * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"rewrite Rcompare_Eq.\nnow case choice.\napply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : (IZR\n   (if choice (Zfloor (scaled_mantissa x))\n    then Zceil (scaled_mantissa x)\n    else Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(if choice (Zfloor (scaled_mantissa x))\n then (IZR (Zceil (scaled_mantissa x)) * bpow (cexp x))%R\n else (IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R).","proofString":"now case choice."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : (scaled_mantissa x - IZR (Zfloor (scaled_mantissa x)))%R =\n(IZR (Zceil (scaled_mantissa x)) - scaled_mantissa x)%R.","proofString":"apply Rmult_eq_reg_r with (bpow (cexp x)).\nnow rewrite 2!Rmult_minus_distr_r.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : ((scaled_mantissa x - IZR (Zfloor (scaled_mantissa x))) * bpow (cexp x))%R =\n((IZR (Zceil (scaled_mantissa x)) - scaled_mantissa x) * bpow (cexp x))%R.","proofString":"now rewrite 2!Rmult_minus_distr_r."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : bpow (cexp x) <> 0%R.","proofString":"apply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(x : R) (Fx : IZR (Zfloor (scaled_mantissa x)) <> scaled_mantissa x) (H : (scaled_mantissa x * bpow (cexp x) -\n IZR (Zfloor (scaled_mantissa x)) * bpow (cexp x))%R =\n(IZR (Zceil (scaled_mantissa x)) * bpow (cexp x) -\n scaled_mantissa x * bpow (cexp x))%R) : (bpow (cexp x) > 0)%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : round Znearest x = 0%R.","proofString":"unfold round, F2R, scaled_mantissa, cexp; simpl.\napply (Rmult_eq_reg_r (bpow (- fexp (mag beta x))));  [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l, Rmult_assoc, <- bpow_plus.\nreplace (_ + - _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply IZR_eq.\napply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (IZR (Znearest (x * bpow (- fexp (mag beta x)))) * bpow (fexp (mag beta x)))%R =\n0%R.","proofString":"apply (Rmult_eq_reg_r (bpow (- fexp (mag beta x))));  [|now apply Rgt_not_eq; apply bpow_gt_0].\nrewrite Rmult_0_l, Rmult_assoc, <- bpow_plus.\nreplace (_ + - _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply IZR_eq.\napply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (IZR (Znearest (x * bpow (- fexp (mag beta x)))) * bpow (fexp (mag beta x)) *\n bpow (- fexp (mag beta x)))%R = (0 * bpow (- fexp (mag beta x)))%R.","proofString":"rewrite Rmult_0_l, Rmult_assoc, <- bpow_plus.\nreplace (_ + - _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply IZR_eq.\napply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (IZR (Znearest (x * bpow (- fexp (mag beta x)))) *\n bpow (fexp (mag beta x) + - fexp (mag beta x)))%R = 0%R.","proofString":"replace (_ + - _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply IZR_eq.\napply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : IZR (Znearest (x * bpow (- fexp (mag beta x)))) = 0%R.","proofString":"apply IZR_eq.\napply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : Znearest (x * bpow (- fexp (mag beta x))) = 0%Z.","proofString":"apply Znearest_imp.\nunfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (Rabs (x * bpow (- fexp (mag beta x)) - 0) < / 2)%R.","proofString":"unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.\nassert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (Rabs (x * bpow (- fexp (mag beta x))) < / 2)%R.","proofString":"assert (H : (x >= 0)%R).\napply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0.\nassert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (x >= 0)%R.","proofString":"apply Rle_ge; apply Rle_trans with (bpow (ex - 1)); [|exact (proj1 Hex)].\nnow apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) : (0 <= bpow (ex - 1))%R.","proofString":"now apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) : (Rabs (x * bpow (- fexp (mag beta x))) < / 2)%R.","proofString":"assert (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R).\napply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0.\nrewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) : (x * bpow (- fexp (mag beta x)) >= 0)%R.","proofString":"apply Rle_ge; apply Rmult_le_pos.\nnow apply Rge_le.\nnow apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) : (0 <= x)%R.","proofString":"now apply Rge_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) : (0 <= bpow (- fexp (mag beta x)))%R.","proofString":"now apply bpow_ge_0."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (Rabs (x * bpow (- fexp (mag beta x))) < / 2)%R.","proofString":"rewrite Rabs_right; [|exact H'].\napply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (x * bpow (- fexp (mag beta x)) < / 2)%R.","proofString":"apply (Rmult_lt_reg_r (bpow (fexp (mag beta x)))); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (x * bpow (- fexp (mag beta x)) * bpow (fexp (mag beta x)) <\n / 2 * bpow (fexp (mag beta x)))%R.","proofString":"rewrite Rmult_assoc, <- bpow_plus.\nreplace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (x * bpow (- fexp (mag beta x) + fexp (mag beta x)) <\n / 2 * bpow (fexp (mag beta x)))%R.","proofString":"replace (- _ + _)%Z with 0%Z by ring; simpl; rewrite Rmult_1_r.\napply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (x < / 2 * bpow (fexp (mag beta x)))%R.","proofString":"apply (Rlt_le_trans _ _ _ (proj2 Hex)).\napply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow ex <= / 2 * bpow (fexp (mag beta x)))%R.","proofString":"apply Rle_trans with (bpow (fexp (mag beta x) - 1)).\napply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right.\nunfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow ex <= bpow (fexp (mag beta x) - 1))%R.","proofString":"apply bpow_le.\nrewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (ex <= fexp (mag beta x) - 1)%Z.","proofString":"rewrite (mag_unique beta x ex); [lia|].\nnow rewrite Rabs_right."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow (ex - 1) <= Rabs x < bpow ex)%R.","proofString":"now rewrite Rabs_right."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow (fexp (mag beta x) - 1) <= / 2 * bpow (fexp (mag beta x)))%R.","proofString":"unfold Zminus; rewrite bpow_plus.\nrewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow (fexp (mag beta x)) * bpow (- (1)) <= / 2 * bpow (fexp (mag beta x)))%R.","proofString":"rewrite Rmult_comm.\napply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow (- (1)) * bpow (fexp (mag beta x)) <= / 2 * bpow (fexp (mag beta x)))%R.","proofString":"apply Rmult_le_compat_r; [now apply bpow_ge_0|].\nunfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (bpow (- (1)) <= / 2)%R.","proofString":"unfold Raux.bpow, Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (/ IZR (beta * 1) <= / 2)%R.","proofString":"rewrite Zmult_1_r.\napply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (/ IZR beta <= / 2)%R.","proofString":"apply Rinv_le; [exact Rlt_0_2|].\napply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (2 <= IZR beta)%R.","proofString":"apply IZR_le.\ndestruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x * bpow (- fexp (mag beta x)) >= 0)%R) : (2 <= beta)%Z.","proofString":"destruct beta as (beta_val,beta_prop).\nnow apply Zle_bool_imp_le."},{"statement":"(x : R) (ex beta_val : Z) (beta_prop : (2 <=? beta_val)%Z = true) (Hex : (Raux.bpow {| radix_val := beta_val; radix_prop := beta_prop |} (ex - 1) <=\n x < Raux.bpow {| radix_val := beta_val; radix_prop := beta_prop |} ex)%R) (Hf : (ex < fexp ex)%Z) (H : (x >= 0)%R) (H' : (x *\n Raux.bpow {| radix_val := beta_val; radix_prop := beta_prop |}\n   (- fexp (mag {| radix_val := beta_val; radix_prop := beta_prop |} x)) >= 0)%R) : (2 <= {| radix_val := beta_val; radix_prop := beta_prop |})%Z.","proofString":"now apply Zle_bool_imp_le."},{"statement":"(x : R) : Rnd_NA_pt generic_format x (round (Znearest (Z.leb 0)) x).","proofString":"generalize (round_N_pt (Zle_bool 0) x).\nset (f := round (Znearest (Zle_bool 0)) x).\nintros Rxf.\ndestruct (Req_dec (x - round Zfloor x) (round Zceil x - x)) as [Hm|Hm].\napply Rnd_NA_pt_N.\nexact generic_format_0.\nexact Rxf.\ndestruct (Rle_or_lt 0 x) as [Hx|Hx].\nrewrite Rabs_pos_eq with (1 := Hx).\nrewrite Rabs_pos_eq.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_true.\napply (round_UP_pt x).\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0.\napply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\nexact generic_format_0.\nrewrite Rabs_left with (1 := Hx).\nrewrite Rabs_left1.\napply Ropp_le_contravar.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_false.\napply (round_DN_pt x).\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0.\napply Rnd_N_pt_le_0 with (3 := Rxf).\nexact generic_format_0.\nnow apply Rlt_le.\nsplit.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) : Rnd_N_pt generic_format x (round (Znearest (Z.leb 0)) x) ->\nRnd_NA_pt generic_format x (round (Znearest (Z.leb 0)) x).","proofString":"set (f := round (Znearest (Zle_bool 0)) x).\nintros Rxf.\ndestruct (Req_dec (x - round Zfloor x) (round Zceil x - x)) as [Hm|Hm].\napply Rnd_NA_pt_N.\nexact generic_format_0.\nexact Rxf.\ndestruct (Rle_or_lt 0 x) as [Hx|Hx].\nrewrite Rabs_pos_eq with (1 := Hx).\nrewrite Rabs_pos_eq.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_true.\napply (round_UP_pt x).\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0.\napply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\nexact generic_format_0.\nrewrite Rabs_left with (1 := Hx).\nrewrite Rabs_left1.\napply Ropp_le_contravar.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_false.\napply (round_DN_pt x).\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0.\napply Rnd_N_pt_le_0 with (3 := Rxf).\nexact generic_format_0.\nnow apply Rlt_le.\nsplit.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) : generic_format 0.","proofString":"exact generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) : Rnd_N_pt generic_format x f.","proofString":"exact Rxf."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (x <= round (Znearest (Z.leb 0)) x)%R.","proofString":"rewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_true.\napply (round_UP_pt x).\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (x <=\n (if (0 <=? Zfloor (scaled_mantissa x))%Z\n  then round Zceil x\n  else round Zfloor x))%R.","proofString":"rewrite Zle_bool_true.\napply (round_UP_pt x).\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (x <= round Zceil x)%R.","proofString":"apply (round_UP_pt x)."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= Zfloor (scaled_mantissa x))%Z.","proofString":"apply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= scaled_mantissa x)%R.","proofString":"apply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= f)%R.","proofString":"apply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\nexact generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : generic_format 0.","proofString":"exact generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (round (Znearest (Z.leb 0)) x <= x)%R.","proofString":"rewrite round_N_middle with (1 := Hm).\nrewrite Zle_bool_false.\napply (round_DN_pt x).\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : ((if (0 <=? Zfloor (scaled_mantissa x))%Z\n  then round Zceil x\n  else round Zfloor x) <= x)%R.","proofString":"rewrite Zle_bool_false.\napply (round_DN_pt x).\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (round Zfloor x <= x)%R.","proofString":"apply (round_DN_pt x)."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (Zfloor (scaled_mantissa x) < 0)%Z.","proofString":"apply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (IZR (Zfloor (scaled_mantissa x)) < 0)%R.","proofString":"apply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (IZR (Zfloor (scaled_mantissa x)) <= scaled_mantissa x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0)%R.","proofString":"simpl.\nrewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- cexp x))).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0 * bpow (- cexp x))%R.","proofString":"apply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (0 < bpow (- cexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (f <= 0)%R.","proofString":"apply Rnd_N_pt_le_0 with (3 := Rxf).\nexact generic_format_0.\nnow apply Rlt_le."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : generic_format 0.","proofString":"exact generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : Rnd_NA_pt generic_format x f.","proofString":"split.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : Rnd_N_pt generic_format x f.","proofString":"apply Rxf."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : forall f2 : R, Rnd_N_pt generic_format x f2 -> (Rabs f2 <= Rabs f)%R.","proofString":"intros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : (Rabs g <= Rabs f)%R.","proofString":"rewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt.\napply round_UP_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : (Rabs g <= Rabs g)%R.","proofString":"apply Rle_refl."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : Rnd_DN_pt generic_format x (round Zfloor x).","proofString":"apply round_DN_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : Rnd_UP_pt generic_format x (round Zceil x).","proofString":"apply round_UP_pt."},{"statement":"(x : R) : Rnd_N0_pt generic_format x (round Znearest0 x).","proofString":"generalize (round_N_pt (fun t => Zlt_bool t 0) x).\nset (f := round (Znearest (fun t => Zlt_bool t 0)) x).\nintros Rxf.\ndestruct (Req_dec (x - round Zfloor x) (round Zceil x - x)) as [Hm|Hm].\napply Rnd_N0_pt_N.\napply generic_format_0.\nexact Rxf.\ndestruct (Rle_or_lt 0 x) as [Hx|Hx].\nrewrite Rabs_pos_eq with (1 := Hx).\nrewrite Rabs_pos_eq.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_false.\nnow apply round_DN_pt.\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0.\napply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\napply generic_format_0.\nrewrite Rabs_left with (1 := Hx).\nrewrite Rabs_left1.\napply Ropp_le_contravar.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_true.\nnow apply round_UP_pt.\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0.\napply Rnd_N_pt_le_0 with (3 := Rxf).\napply generic_format_0.\nnow apply Rlt_le.\nsplit.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt; easy.\napply round_UP_pt; easy."},{"statement":"(x : R) : Rnd_N_pt generic_format x (round Znearest0 x) ->\nRnd_N0_pt generic_format x (round Znearest0 x).","proofString":"set (f := round (Znearest (fun t => Zlt_bool t 0)) x).\nintros Rxf.\ndestruct (Req_dec (x - round Zfloor x) (round Zceil x - x)) as [Hm|Hm].\napply Rnd_N0_pt_N.\napply generic_format_0.\nexact Rxf.\ndestruct (Rle_or_lt 0 x) as [Hx|Hx].\nrewrite Rabs_pos_eq with (1 := Hx).\nrewrite Rabs_pos_eq.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_false.\nnow apply round_DN_pt.\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0.\napply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\napply generic_format_0.\nrewrite Rabs_left with (1 := Hx).\nrewrite Rabs_left1.\napply Ropp_le_contravar.\nunfold f.\nrewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_true.\nnow apply round_UP_pt.\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0.\napply Rnd_N_pt_le_0 with (3 := Rxf).\napply generic_format_0.\nnow apply Rlt_le.\nsplit.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt; easy.\napply round_UP_pt; easy."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) : generic_format 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) : Rnd_N_pt generic_format x f.","proofString":"exact Rxf."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (round Znearest0 x <= x)%R.","proofString":"rewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_false.\nnow apply round_DN_pt.\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : ((if (Zfloor (scaled_mantissa x) <? 0)%Z\n  then round Zceil x\n  else round Zfloor x) <= x)%R.","proofString":"rewrite Zlt_bool_false.\nnow apply round_DN_pt.\napply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (round Zfloor x <= x)%R.","proofString":"now apply round_DN_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= Zfloor (scaled_mantissa x))%Z.","proofString":"apply Zfloor_lub.\napply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= scaled_mantissa x)%R.","proofString":"apply Rmult_le_pos with (1 := Hx).\napply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= bpow (- cexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : (0 <= f)%R.","proofString":"apply Rnd_N_pt_ge_0 with (2 := Hx) (3 := Rxf).\napply generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (0 <= x)%R) : generic_format 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (x <= round Znearest0 x)%R.","proofString":"rewrite round_N_middle with (1 := Hm).\nrewrite Zlt_bool_true.\nnow apply round_UP_pt.\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (x <=\n (if (Zfloor (scaled_mantissa x) <? 0)%Z\n  then round Zceil x\n  else round Zfloor x))%R.","proofString":"rewrite Zlt_bool_true.\nnow apply round_UP_pt.\napply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (x <= round Zceil x)%R.","proofString":"now apply round_UP_pt."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (Zfloor (scaled_mantissa x) < 0)%Z.","proofString":"apply lt_IZR.\napply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (IZR (Zfloor (scaled_mantissa x)) < 0)%R.","proofString":"apply Rle_lt_trans with (scaled_mantissa x).\napply Zfloor_lb.\nsimpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (IZR (Zfloor (scaled_mantissa x)) <= scaled_mantissa x)%R.","proofString":"apply Zfloor_lb."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0)%R.","proofString":"simpl.\nrewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0)%R.","proofString":"rewrite <- (Rmult_0_l (bpow (- (cexp x))%Z)%R).\napply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (scaled_mantissa x < 0 * bpow (- cexp x))%R.","proofString":"apply Rmult_lt_compat_r with (2 := Hx).\napply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (0 < bpow (- cexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (f <= 0)%R.","proofString":"apply Rnd_N_pt_le_0 with (3 := Rxf).\napply generic_format_0.\nnow apply Rlt_le."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : generic_format 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R = (round Zceil x - x)%R) (Hx : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : Rnd_N0_pt generic_format x f.","proofString":"split.\napply Rxf.\nintros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt; easy.\napply round_UP_pt; easy."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : Rnd_N_pt generic_format x f.","proofString":"apply Rxf."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) : forall f2 : R, Rnd_N_pt generic_format x f2 -> (Rabs f <= Rabs f2)%R.","proofString":"intros g Rxg.\nrewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt; easy.\napply round_UP_pt; easy."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : (Rabs f <= Rabs g)%R.","proofString":"rewrite Rnd_N_pt_unique with (3 := Hm) (4 := Rxf) (5 := Rxg).\napply Rle_refl.\napply round_DN_pt; easy.\napply round_UP_pt; easy."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : (Rabs g <= Rabs g)%R.","proofString":"apply Rle_refl."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : Rnd_DN_pt generic_format x (round Zfloor x).","proofString":"apply round_DN_pt; easy."},{"statement":"(x : R) (f : R) (Rxf : Rnd_N_pt generic_format x f) (Hm : (x - round Zfloor x)%R <> (round Zceil x - x)%R) (g : R) (Rxg : Rnd_N_pt generic_format x g) : Rnd_UP_pt generic_format x (round Zceil x).","proofString":"apply round_UP_pt; easy."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : Znearest choice (- x) =\n(- Znearest (fun t : Z => negb (choice (- (t + 1)))) x)%Z.","proofString":"unfold Znearest.\nreplace (- x - IZR (Zfloor (-x)))%R with (IZR (Zceil x) - x)%R.\nrewrite Rcompare_ceil_floor_middle with (1 := Hx).\nrewrite Rcompare_floor_ceil_middle with (1 := Hx).\nrewrite Rcompare_sym.\nrewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive.\nunfold Zceil.\nrewrite opp_IZR.\napply Rplus_comm."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match Rcompare (- x - IZR (Zfloor (- x))) (/ 2) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n | Eq => if negb (choice (- (Zfloor x + 1))) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"replace (- x - IZR (Zfloor (-x)))%R with (IZR (Zceil x) - x)%R.\nrewrite Rcompare_ceil_floor_middle with (1 := Hx).\nrewrite Rcompare_floor_ceil_middle with (1 := Hx).\nrewrite Rcompare_sym.\nrewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive.\nunfold Zceil.\nrewrite opp_IZR.\napply Rplus_comm."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match Rcompare (IZR (Zceil x) - x) (/ 2) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n | Eq => if negb (choice (- (Zfloor x + 1))) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"rewrite Rcompare_ceil_floor_middle with (1 := Hx).\nrewrite Rcompare_floor_ceil_middle with (1 := Hx).\nrewrite Rcompare_sym.\nrewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match Rcompare (IZR (Zceil x) - x) (x - IZR (Zfloor x)) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n | Eq => if negb (choice (- (Zfloor x + 1))) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"rewrite Rcompare_floor_ceil_middle with (1 := Hx).\nrewrite Rcompare_sym.\nrewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match Rcompare (IZR (Zceil x) - x) (x - IZR (Zfloor x)) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x) with\n | Eq => if negb (choice (- (Zfloor x + 1))) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"rewrite Rcompare_sym.\nrewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match CompOpp (Rcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x)) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x) with\n | Eq => if negb (choice (- (Zfloor x + 1))) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"rewrite <- Zceil_floor_neq with (1 := Hx).\nunfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match CompOpp (Rcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x)) with\n| Eq => if choice (Zfloor (- x)) then Zceil (- x) else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => Zceil (- x)\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (IZR (Zceil x) - x) with\n | Eq => if negb (choice (- Zceil x)) then Zceil x else Zfloor x\n | Lt => Zfloor x\n | Gt => Zceil x\n end)%Z.","proofString":"unfold Zceil.\nrewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match CompOpp (Rcompare (x - IZR (Zfloor x)) (IZR (- Zfloor (- x)) - x)) with\n| Eq => if choice (Zfloor (- x)) then (- Zfloor (- - x))%Z else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => (- Zfloor (- - x))%Z\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (IZR (- Zfloor (- x)) - x) with\n | Eq =>\n     if negb (choice (- - Zfloor (- x))) then - Zfloor (- x) else Zfloor x\n | Lt => Zfloor x\n | Gt => - Zfloor (- x)\n end)%Z.","proofString":"rewrite Ropp_involutive.\ncase Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : match CompOpp (Rcompare (x - IZR (Zfloor x)) (IZR (- Zfloor (- x)) - x)) with\n| Eq => if choice (Zfloor (- x)) then (- Zfloor x)%Z else Zfloor (- x)\n| Lt => Zfloor (- x)\n| Gt => (- Zfloor x)%Z\nend =\n(-\n match Rcompare (x - IZR (Zfloor x)) (IZR (- Zfloor (- x)) - x) with\n | Eq =>\n     if negb (choice (- - Zfloor (- x))) then - Zfloor (- x) else Zfloor x\n | Lt => Zfloor x\n | Gt => - Zfloor (- x)\n end)%Z.","proofString":"case Rcompare ; simpl ; trivial.\nrewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : (if choice (Zfloor (- x)) then (- Zfloor x)%Z else Zfloor (- x)) =\n(- (if negb (choice (- - Zfloor (- x))) then - Zfloor (- x) else Zfloor x))%Z.","proofString":"rewrite Z.opp_involutive.\ncase (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : (if choice (Zfloor (- x)) then (- Zfloor x)%Z else Zfloor (- x)) =\n(- (if negb (choice (Zfloor (- x))) then - Zfloor (- x) else Zfloor x))%Z.","proofString":"case (choice (Zfloor (- x))) ; simpl ; trivial.\nnow rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : Zfloor (- x) = (- - Zfloor (- x))%Z.","proofString":"now rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : Zfloor (- x) = (- - Zfloor (- x))%Z.","proofString":"now rewrite Z.opp_involutive."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : (IZR (Zceil x) - x)%R = (- x - IZR (Zfloor (- x)))%R.","proofString":"unfold Zceil.\nrewrite opp_IZR.\napply Rplus_comm."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : (IZR (- Zfloor (- x)) - x)%R = (- x - IZR (Zfloor (- x)))%R.","proofString":"rewrite opp_IZR.\napply Rplus_comm."},{"statement":"(choice : Z -> bool) (x : R) (Hx : IZR (Zfloor x) <> x) : (- IZR (Zfloor (- x)) - x)%R = (- x - IZR (Zfloor (- x)))%R.","proofString":"apply Rplus_comm."},{"statement":"(choice : Z -> bool) (x : R) : round (Znearest choice) (- x) =\n(- round (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) x)%R.","proofString":"unfold round, F2R.\nsimpl.\nrewrite cexp_opp.\nrewrite scaled_mantissa_opp.\nrewrite Znearest_opp.\nrewrite opp_IZR.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(choice : Z -> bool) (x : R) : (IZR (Znearest choice (scaled_mantissa (- x))) * bpow (cexp (- x)))%R =\n(-\n (IZR\n    (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n  bpow (cexp x)))%R.","proofString":"rewrite cexp_opp.\nrewrite scaled_mantissa_opp.\nrewrite Znearest_opp.\nrewrite opp_IZR.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(choice : Z -> bool) (x : R) : (IZR (Znearest choice (scaled_mantissa (- x))) * bpow (cexp x))%R =\n(-\n (IZR\n    (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n  bpow (cexp x)))%R.","proofString":"rewrite scaled_mantissa_opp.\nrewrite Znearest_opp.\nrewrite opp_IZR.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(choice : Z -> bool) (x : R) : (IZR (Znearest choice (- scaled_mantissa x)) * bpow (cexp x))%R =\n(-\n (IZR\n    (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n  bpow (cexp x)))%R.","proofString":"rewrite Znearest_opp.\nrewrite opp_IZR.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(choice : Z -> bool) (x : R) : (IZR\n   (- Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n bpow (cexp x))%R =\n(-\n (IZR\n    (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n  bpow (cexp x)))%R.","proofString":"rewrite opp_IZR.\nnow rewrite Ropp_mult_distr_l_reverse."},{"statement":"(choice : Z -> bool) (x : R) : (-\n IZR\n   (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n bpow (cexp x))%R =\n(-\n (IZR\n    (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)) (scaled_mantissa x)) *\n  bpow (cexp x)))%R.","proofString":"now rewrite Ropp_mult_distr_l_reverse."},{"statement":"(x : R) : round Znearest0 (- x) = (- round Znearest0 x)%R.","proofString":"rewrite round_N_opp.\napply Ropp_eq_compat.\napply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) : (- round (Znearest (fun t : Z => negb (- (t + 1) <? 0)%Z)) x)%R =\n(- round Znearest0 x)%R.","proofString":"apply Ropp_eq_compat.\napply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) : round (Znearest (fun t : Z => negb (- (t + 1) <? 0)%Z)) x = round Znearest0 x.","proofString":"apply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) : forall x0 : R,\nZnearest (fun t : Z => negb (- (t + 1) <? 0)%Z) x0 = Znearest0 x0.","proofString":"clear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) : Znearest (fun t : Z => negb (- (t + 1) <? 0)%Z) x = Znearest0 x.","proofString":"unfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if negb (- (Zfloor x + 1) <? 0)%Z then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend =\nmatch Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if (Zfloor x <? 0)%Z then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend.","proofString":"case_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : Rcompare (x - IZR (Zfloor x)) (/ 2) = Eq) : (if negb (- (Zfloor x + 1) <? 0)%Z then Zceil x else Zfloor x) =\n(if (Zfloor x <? 0)%Z then Zceil x else Zfloor x).","proofString":"apply Rcompare_Eq_inv in C.\nassert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : (if negb (- (Zfloor x + 1) <? 0)%Z then Zceil x else Zfloor x) =\n(if (Zfloor x <? 0)%Z then Zceil x else Zfloor x).","proofString":"assert (H : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z);  [|now rewrite H].\nrewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : negb (- (Zfloor x + 1) <? 0)%Z = (Zfloor x <? 0)%Z.","proofString":"rewrite negb_Zlt_bool.\ncase_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : (0 <=? - (Zfloor x + 1))%Z = (Zfloor x <? 0)%Z.","proofString":"case_eq (Zfloor x <? 0)%Z; intro C'.\napply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia.\napply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x <? 0)%Z = true) : (0 <=? - (Zfloor x + 1))%Z = true.","proofString":"apply Zlt_is_lt_bool in C'.\napply Zle_bool_true.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x < 0)%Z) : (0 <=? - (Zfloor x + 1))%Z = true.","proofString":"apply Zle_bool_true.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x < 0)%Z) : (0 <= - (Zfloor x + 1))%Z.","proofString":"lia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x <? 0)%Z = false) : (0 <=? - (Zfloor x + 1))%Z = false.","proofString":"apply Z.ltb_ge in C'.\napply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <= Zfloor x)%Z) : (0 <=? - (Zfloor x + 1))%Z = false.","proofString":"apply Zle_bool_false.\nlia."},{"statement":"(x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <= Zfloor x)%Z) : (- (Zfloor x + 1) < 0)%Z.","proofString":"lia."},{"statement":"(choice : Z -> bool) (x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (ex < fexp ex)%Z) : round (Znearest choice) x = 0%R.","proofString":"destruct (Rle_or_lt 0 x) as [Px|Nx].\nnow revert Hex; apply round_N_small_pos; revert Hx; rewrite Rabs_pos_eq.\nrewrite <-(Ropp_involutive x), round_N_opp, <-Ropp_0; f_equal.\nnow revert Hex; apply round_N_small_pos; revert Hx; rewrite Rabs_left."},{"statement":"(choice : Z -> bool) (x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (ex < fexp ex)%Z) (Px : (0 <= x)%R) : round (Znearest choice) x = 0%R.","proofString":"now revert Hex; apply round_N_small_pos; revert Hx; rewrite Rabs_pos_eq."},{"statement":"(choice : Z -> bool) (x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (ex < fexp ex)%Z) (Nx : (x < 0)%R) : round (Znearest choice) x = 0%R.","proofString":"rewrite <-(Ropp_involutive x), round_N_opp, <-Ropp_0; f_equal.\nnow revert Hex; apply round_N_small_pos; revert Hx; rewrite Rabs_left."},{"statement":"(choice : Z -> bool) (x : R) (ex : Z) (Hx : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hex : (ex < fexp ex)%Z) (Nx : (x < 0)%R) : round (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- x) = 0%R.","proofString":"now revert Hex; apply round_N_small_pos; revert Hx; rewrite Rabs_left."},{"statement":"(x : R) (He : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z) (Fx : generic_format fexp1 x) : generic_format fexp2 x.","proofString":"rewrite Fx.\napply generic_format_F2R.\nintros Zx.\nrewrite <- Fx.\napply He.\ncontradict Zx.\nrewrite Zx, scaled_mantissa_0.\napply Ztrunc_IZR."},{"statement":"(x : R) (He : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z) (Fx : generic_format fexp1 x) (Zx : Ztrunc (scaled_mantissa fexp1 x) <> 0%Z) : (cexp fexp2 x <= cexp fexp1 x)%Z.","proofString":"apply He.\ncontradict Zx.\nrewrite Zx, scaled_mantissa_0.\napply Ztrunc_IZR."},{"statement":"(x : R) (He : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z) (Fx : generic_format fexp1 x) (Zx : Ztrunc (scaled_mantissa fexp1 x) <> 0%Z) : x <> 0%R.","proofString":"contradict Zx.\nrewrite Zx, scaled_mantissa_0.\napply Ztrunc_IZR."},{"statement":"(x : R) (He : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z) (Fx : generic_format fexp1 x) (Zx : x = 0%R) : Ztrunc (scaled_mantissa fexp1 x) = 0%Z.","proofString":"rewrite Zx, scaled_mantissa_0.\napply Ztrunc_IZR."},{"statement":"(x : R) (He : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z) (Fx : generic_format fexp1 x) (Zx : x = 0%R) : Ztrunc 0 = 0%Z.","proofString":"apply Ztrunc_IZR."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion_mag.\nintros Zx.\napply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"intros Zx.\napply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"apply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (e1 < mag beta x <= e2)%Z.","proofString":"split.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (e1 < mag beta x)%Z.","proofString":"now apply mag_gt_bpow."},{"statement":"(e1 e2 : Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (mag beta x <= e2)%Z.","proofString":"now apply mag_le_bpow."},{"statement":"(e : Z) (He : (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow (e - 1) <= Rabs x)%R) (Hx2 : (Rabs x < bpow e)%R) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion_mag.\nnow rewrite mag_unique with (1 := conj Hx1 Hx2)."},{"statement":"(e : Z) (He : (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow (e - 1) <= Rabs x)%R) (Hx2 : (Rabs x < bpow e)%R) : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"now rewrite mag_unique with (1 := conj Hx1 Hx2)."},{"statement":"(e : Z) (He : (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow (e - 1) <= Rabs x)%R) (Hx2 : Rabs x = bpow e) (Fx : generic_format fexp1 x) : generic_format fexp1 (bpow e).","proofString":"rewrite <- Hx2.\nnow apply generic_format_abs."},{"statement":"(e : Z) (He : (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow (e - 1) <= Rabs x)%R) (Hx2 : Rabs x = bpow e) (Fx : generic_format fexp1 x) : generic_format fexp1 (Rabs x).","proofString":"now apply generic_format_abs."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion_mag.\nintros Zx.\napply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"intros Zx.\napply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"apply He.\nsplit.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (e1 < mag beta x <= e2)%Z.","proofString":"split.\nnow apply mag_gt_bpow.\nnow apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (e1 < mag beta x)%Z.","proofString":"now apply mag_gt_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (mag beta x <= e2)%Z.","proofString":"now apply mag_le_bpow."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion with (e := e2).\napply He.\nsplit.\napply He'.\napply Z.le_refl.\nrewrite Hx2.\nsplit.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (fexp2 e2 <= fexp1 e2)%Z.","proofString":"apply He.\nsplit.\napply He'.\napply Z.le_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (e1 < e2 <= e2)%Z.","proofString":"split.\napply He'.\napply Z.le_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (e1 < e2)%Z.","proofString":"apply He'."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (e2 <= e2)%Z.","proofString":"apply Z.le_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (bpow (e2 - 1) <= Rabs x <= bpow e2)%R.","proofString":"rewrite Hx2.\nsplit.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (bpow (e2 - 1) <= bpow e2 <= bpow e2)%R.","proofString":"split.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (bpow (e2 - 1) <= bpow e2)%R.","proofString":"apply bpow_le.\napply Zle_pred."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (e2 - 1 <= e2)%Z.","proofString":"apply Zle_pred."},{"statement":"(e1 e2 : Z) (He' : (e1 < e2)%Z) (He : forall e : Z, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx1 : (bpow e1 <= Rabs x)%R) (Hx2 : Rabs x = bpow e2) : (bpow e2 <= bpow e2)%R.","proofString":"apply Rle_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (Rabs x < bpow e2)%R) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion_mag.\nintros Zx.\napply He.\nnow apply mag_le_bpow."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (Rabs x < bpow e2)%R) : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"intros Zx.\napply He.\nnow apply mag_le_bpow."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"apply He.\nnow apply mag_le_bpow."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (Rabs x < bpow e2)%R) (Zx : x <> 0%R) : (mag beta x <= e2)%Z.","proofString":"now apply mag_le_bpow."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion with (e := e2).\napply He.\napply Z.le_refl.\nrewrite Hx.\nsplit.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (fexp2 e2 <= fexp1 e2)%Z.","proofString":"apply He.\napply Z.le_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (e2 <= e2)%Z.","proofString":"apply Z.le_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (bpow (e2 - 1) <= Rabs x <= bpow e2)%R.","proofString":"rewrite Hx.\nsplit.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (bpow (e2 - 1) <= bpow e2 <= bpow e2)%R.","proofString":"split.\napply bpow_le.\napply Zle_pred.\napply Rle_refl."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (bpow (e2 - 1) <= bpow e2)%R.","proofString":"apply bpow_le.\napply Zle_pred."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (e2 - 1 <= e2)%Z.","proofString":"apply Zle_pred."},{"statement":"(e2 : Z) (He : forall e : Z, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : Rabs x = bpow e2) : (bpow e2 <= bpow e2)%R.","proofString":"apply Rle_refl."},{"statement":"(e1 : Z) (He : forall e : Z, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (bpow e1 <= Rabs x)%R) : generic_format fexp1 x -> generic_format fexp2 x.","proofString":"apply generic_inclusion_mag.\nintros Zx.\napply He.\nnow apply mag_gt_bpow."},{"statement":"(e1 : Z) (He : forall e : Z, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (bpow e1 <= Rabs x)%R) : x <> 0%R -> (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"intros Zx.\napply He.\nnow apply mag_gt_bpow."},{"statement":"(e1 : Z) (He : forall e : Z, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (bpow e1 <= Rabs x)%R) (Zx : x <> 0%R) : (fexp2 (mag beta x) <= fexp1 (mag beta x))%Z.","proofString":"apply He.\nnow apply mag_gt_bpow."},{"statement":"(e1 : Z) (He : forall e : Z, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z) (x : R) (Hx : (bpow e1 <= Rabs x)%R) (Zx : x <> 0%R) : (e1 < mag beta x)%Z.","proofString":"now apply mag_gt_bpow."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (ex <= fexp2 ex)%Z) (Hr : round fexp2 rnd x = 0%R) : generic_format fexp1 (round fexp2 rnd x).","proofString":"rewrite Hr.\napply generic_format_0."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (ex <= fexp2 ex)%Z) (Hr : round fexp2 rnd x = 0%R) : generic_format fexp1 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp2 x <= cexp fexp1 x)%Z) (Zx : Ztrunc (scaled_mantissa fexp1 x) <> 0%Z) : round fexp1 Ztrunc x <> 0%R.","proofString":"contradict Zx.\napply eq_0_F2R with (1 := Zx)."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp2 x <= cexp fexp1 x)%Z) (Zx : round fexp1 Ztrunc x = 0%R) : Ztrunc (scaled_mantissa fexp1 x) = 0%Z.","proofString":"apply eq_0_F2R with (1 := Zx)."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : (round fexp2 rnd x < bpow ex)%R) : generic_format fexp1 (round fexp2 rnd x).","proofString":"apply generic_format_F2R.\nintros Zx.\nfold (round fexp2 rnd x).\nunfold cexp at 1.\nrewrite mag_unique_pos with (1 := conj Hr1 Hr2).\nrewrite <- mag_unique_pos with (1 := Ex).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : (round fexp2 rnd x < bpow ex)%R) (Zx : rnd (scaled_mantissa fexp2 x) <> 0%Z) : (cexp fexp1 (round fexp2 rnd x) <= cexp fexp2 x)%Z.","proofString":"unfold cexp at 1.\nrewrite mag_unique_pos with (1 := conj Hr1 Hr2).\nrewrite <- mag_unique_pos with (1 := Ex).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : (round fexp2 rnd x < bpow ex)%R) (Zx : rnd (scaled_mantissa fexp2 x) <> 0%Z) : (fexp1 (mag beta (round fexp2 rnd x)) <= cexp fexp2 x)%Z.","proofString":"rewrite mag_unique_pos with (1 := conj Hr1 Hr2).\nrewrite <- mag_unique_pos with (1 := Ex).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : (round fexp2 rnd x < bpow ex)%R) (Zx : rnd (scaled_mantissa fexp2 x) <> 0%Z) : (fexp1 ex <= cexp fexp2 x)%Z.","proofString":"rewrite <- mag_unique_pos with (1 := Ex).\nnow apply Zlt_le_weak."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : (round fexp2 rnd x < bpow ex)%R) (Zx : rnd (scaled_mantissa fexp2 x) <> 0%Z) : (fexp1 (mag beta x) <= cexp fexp2 x)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : R) (Hx : (0 < x)%R) (Gx : generic_format fexp1 x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (He' : (fexp1 ex < ex)%Z) (He : (fexp2 ex < ex)%Z) (He'' : (cexp fexp1 x < cexp fexp2 x)%Z) (Hr1 : (bpow (ex - 1) <= round fexp2 rnd x)%R) (Hr2 : round fexp2 rnd x = bpow ex) : (fexp1 ex <= ex)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : R) (Hx : 0%R = x) (Gx : generic_format fexp1 x) : generic_format fexp1 0.","proofString":"apply generic_format_0."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : round beta fexp ZnearestA (- x) = (- round beta fexp ZnearestA x)%R.","proofString":"rewrite round_N_opp.\napply Ropp_eq_compat.\napply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : (- round beta fexp (Znearest (fun t : Z => negb (0 <=? - (t + 1))%Z)) x)%R =\n(- round beta fexp ZnearestA x)%R.","proofString":"apply Ropp_eq_compat.\napply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : round beta fexp (Znearest (fun t : Z => negb (0 <=? - (t + 1))%Z)) x =\nround beta fexp ZnearestA x.","proofString":"apply round_ext.\nclear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : forall x0 : R,\nZnearest (fun t : Z => negb (0 <=? - (t + 1))%Z) x0 = ZnearestA x0.","proofString":"clear x; intro x.\nunfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : Znearest (fun t : Z => negb (0 <=? - (t + 1))%Z) x = ZnearestA x.","proofString":"unfold Znearest.\ncase_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) : match Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if negb (0 <=? - (Zfloor x + 1))%Z then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend =\nmatch Rcompare (x - IZR (Zfloor x)) (/ 2) with\n| Eq => if (0 <=? Zfloor x)%Z then Zceil x else Zfloor x\n| Lt => Zfloor x\n| Gt => Zceil x\nend.","proofString":"case_eq (Rcompare (x - IZR (Zfloor x)) (/ 2)); intro C;[|reflexivity|reflexivity].\napply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : Rcompare (x - IZR (Zfloor x)) (/ 2) = Eq) : (if negb (0 <=? - (Zfloor x + 1))%Z then Zceil x else Zfloor x) =\n(if (0 <=? Zfloor x)%Z then Zceil x else Zfloor x).","proofString":"apply Rcompare_Eq_inv in C.\nassert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : (if negb (0 <=? - (Zfloor x + 1))%Z then Zceil x else Zfloor x) =\n(if (0 <=? Zfloor x)%Z then Zceil x else Zfloor x).","proofString":"assert (H : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z);  [|now rewrite H].\nrewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : negb (0 <=? - (Zfloor x + 1))%Z = (0 <=? Zfloor x)%Z.","proofString":"rewrite negb_Zle_bool.\ncase_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) : (- (Zfloor x + 1) <? 0)%Z = (0 <=? Zfloor x)%Z.","proofString":"case_eq (0 <=? Zfloor x)%Z; intro C'.\napply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia.\nrewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <=? Zfloor x)%Z = true) : (- (Zfloor x + 1) <? 0)%Z = true.","proofString":"apply Zle_bool_imp_le in C'.\napply Zlt_bool_true.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <= Zfloor x)%Z) : (- (Zfloor x + 1) <? 0)%Z = true.","proofString":"apply Zlt_bool_true.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <= Zfloor x)%Z) : (- (Zfloor x + 1) < 0)%Z.","proofString":"lia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (0 <=? Zfloor x)%Z = false) : (- (Zfloor x + 1) <? 0)%Z = false.","proofString":"rewrite Z.leb_gt in C'.\napply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x < 0)%Z) : (- (Zfloor x + 1) <? 0)%Z = false.","proofString":"apply Zlt_bool_false.\nlia."},{"statement":"(beta : radix) (fexp : Z -> Z) (x : R) (C : (x - IZR (Zfloor x))%R = (/ 2)%R) (C' : (Zfloor x < 0)%Z) : (0 <= - (Zfloor x + 1))%Z.","proofString":"lia."}]}