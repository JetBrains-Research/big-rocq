{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Kildall.v","fileSamples":[{"statement":"(n n3 : positive) (H : reachable n n3) : reachable n n3.","conclusion":"reachable n n3","hypotheses":"(n n3 : positive) (H : reachable n n3)","proofString":"auto."},{"statement":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable n2 n3) (IHreachable : forall n4 : positive, reachable n3 n4 -> reachable n2 n4) (n0 : positive) (H0 : reachable n3 n0) : reachable n1 n0.","conclusion":"reachable n1 n0","hypotheses":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable n2 n3) (IHreachable : forall n4 : positive, reachable n3 n4 -> reachable n2 n4) (n0 : positive) (H0 : reachable n3 n0)","proofString":"econstructor; eauto."},{"statement":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i)) : reachable n1 n3.","conclusion":"reachable n1 n3","hypotheses":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i))","proofString":"apply reachable_trans with n2; auto.\neconstructor; eauto.\nconstructor."},{"statement":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i)) : reachable n2 n3.","conclusion":"reachable n2 n3","hypotheses":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i))","proofString":"econstructor; eauto.\nconstructor."},{"statement":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i)) : reachable n3 n3.","conclusion":"reachable n3 n3","hypotheses":"(n1 n2 n3 : positive) (i : A) (H : reachable n1 n2) (H0 : code ! n2 = Some i) (H1 : In n3 (successors i))","proofString":"constructor."},{"statement":"(t : L.t) : L.ge t t.","conclusion":"L.ge t t","hypotheses":"(t : L.t)","proofString":"apply L.ge_refl; apply L.eq_refl."},{"statement":"(ol1 ol2 ol3 : option L.t) (H : optge ol1 ol2) (H0 : optge ol2 ol3) : optge ol1 ol3.","conclusion":"optge ol1 ol3","hypotheses":"(ol1 ol2 ol3 : option L.t) (H : optge ol1 ol2) (H0 : optge ol2 ol3)","proofString":"inv H0.\ninv H.\nconstructor.\neapply L.ge_trans; eauto.\nconstructor."},{"statement":"(ol1 : option L.t) (l : L.t) (H : optge ol1 (Some l)) (l' : L.t) (H1 : L.ge l l') : optge ol1 (Some l').","conclusion":"optge ol1 (Some l')","hypotheses":"(ol1 : option L.t) (l : L.t) (H : optge ol1 (Some l)) (l' : L.t) (H1 : L.ge l l')","proofString":"inv H.\nconstructor.\neapply L.ge_trans; eauto."},{"statement":"(l l' : L.t) (H1 : L.ge l l') (l0 : L.t) (H3 : L.ge l0 l) : optge (Some l0) (Some l').","conclusion":"optge (Some l0) (Some l')","hypotheses":"(l l' : L.t) (H1 : L.ge l l') (l0 : L.t) (H3 : L.ge l0 l)","proofString":"constructor.\neapply L.ge_trans; eauto."},{"statement":"(l l' : L.t) (H1 : L.ge l l') (l0 : L.t) (H3 : L.ge l0 l) : L.ge l0 l'.","conclusion":"L.ge l0 l'","hypotheses":"(l l' : L.t) (H1 : L.ge l l') (l0 : L.t) (H3 : L.ge l0 l)","proofString":"eapply L.ge_trans; eauto."},{"statement":"(ol1 ol2 : option L.t) (H : optge ol1 ol2) : optge ol1 None.","conclusion":"optge ol1 None","hypotheses":"(ol1 ol2 : option L.t) (H : optge ol1 ol2)","proofString":"constructor."},{"statement":"(st st' : state) (n : positive) (H : optge (aval st) ! n (aval st') ! n) : L.ge (abstr_value n st) (abstr_value n st').","conclusion":"L.ge (abstr_value n st) (abstr_value n st')","hypotheses":"(st st' : state) (n : positive) (H : optge (aval st) ! n (aval st') ! n)","proofString":"unfold abstr_value.\ninv H.\nauto.\napply L.ge_bot."},{"statement":"(st st' : state) (n : positive) (H : optge (aval st) ! n (aval st') ! n) : L.ge match (aval st) ! n with\n     | Some v => v\n     | None => L.bot\n     end match (aval st') ! n with\n         | Some v => v\n         | None => L.bot\n         end.","conclusion":"L.ge match (aval st) ! n with\n     | Some v => v\n     | None => L.bot\n     end match (aval st') ! n with\n         | Some v => v\n         | None => L.bot\n         end","hypotheses":"(st st' : state) (n : positive) (H : optge (aval st) ! n (aval st') ! n)","proofString":"inv H.\nauto.\napply L.ge_bot."},{"statement":"(st st' : state) (n : positive) (l l' : L.t) (H2 : L.ge l l') (H0 : Some l = (aval st) ! n) (H1 : Some l' = (aval st') ! n) : L.ge l l'.","conclusion":"L.ge l l'","hypotheses":"(st st' : state) (n : positive) (l l' : L.t) (H2 : L.ge l l') (H0 : Some l = (aval st) ! n) (H1 : Some l' = (aval st') ! n)","proofString":"auto."},{"statement":"(st st' : state) (n : positive) (H2 : None = (aval st') ! n) : L.ge match (aval st) ! n with\n     | Some v => v\n     | None => L.bot\n     end L.bot.","conclusion":"L.ge match (aval st) ! n with\n     | Some v => v\n     | None => L.bot\n     end L.bot","hypotheses":"(st st' : state) (n : positive) (H2 : None = (aval st') ! n)","proofString":"apply L.ge_bot."},{"statement":"(st : state) (out : L.t) (n : positive) : optge\n  (aval\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl out)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl out) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n out (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) \\/\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end)) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n') /\\\n(forall n' : positive,\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n' ->\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! n' <> None ->\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n').","conclusion":"optge\n  (aval\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl out)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl out) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n out (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) \\/\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end)) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n') /\\\n(forall n' : positive,\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n' ->\n NS.In n'\n   (worklist\n      match (aval st) ! n with\n      | Some oldl =>\n          if L.beq oldl (L.lub oldl out)\n          then st\n          else\n           {|\n             aval := PTree.set n (L.lub oldl out) (aval st);\n             worklist := NS.add n (worklist st);\n             visited := fun p : positive => p = n \\/ visited st p\n           |}\n      | None =>\n          {|\n            aval := PTree.set n out (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n      end) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    match (aval st) ! n with\n    | Some oldl =>\n        if L.beq oldl (L.lub oldl out)\n        then st\n        else\n         {|\n           aval := PTree.set n (L.lub oldl out) (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n    | None =>\n        {|\n          aval := PTree.set n out (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n    end) ! n' <> None ->\n visited\n   match (aval st) ! n with\n   | Some oldl =>\n       if L.beq oldl (L.lub oldl out)\n       then st\n       else\n        {|\n          aval := PTree.set n (L.lub oldl out) (aval st);\n          worklist := NS.add n (worklist st);\n          visited := fun p : positive => p = n \\/ visited st p\n        |}\n   | None =>\n       {|\n         aval := PTree.set n out (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}\n   end n')","hypotheses":"(st : state) (out : L.t) (n : positive)","proofString":"destruct st.(aval)!n as [v|] eqn:E;  [predSpec L.beq L.beq_correct v (L.lub v out) | idtac].\nrepeat split; intros.\nrewrite E.\nconstructor.\neapply L.ge_trans.\napply L.ge_refl.\napply H; auto.\napply L.ge_lub_right.\napply optge_refl.\nright; auto.\nauto.\nauto.\nauto.\nauto.\ncongruence.\nsimpl; repeat split; intros.\nrewrite PTree.gss.\nconstructor.\napply L.ge_lub_right.\nrewrite PTree.gso by auto.\nauto.\nrewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply L.ge_lub_left.\napply optge_refl.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec in H0.\nintuition.\nauto.\ndestruct H0; auto.\nsubst n'.\nrewrite NS.add_spec; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq n' n).\nauto.\ncongruence.\nsimpl; repeat split; intros.\nrewrite PTree.gss.\napply optge_refl.\nrewrite PTree.gso by auto.\nauto.\nrewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply optge_refl.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec in H.\nintuition.\nauto.\ndestruct H; auto.\nsubst n'.\nrewrite NS.add_spec.\nauto.\nrewrite PTree.gsspec in H0.\ndestruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) : optge (aval st) ! n (Some out) /\\\n(forall s : positive, n <> s -> (aval st) ! s = (aval st) ! s) /\\\n(forall s : positive, optge (aval st) ! s (aval st) ! s) /\\\n(NS.In n (worklist st) \\/ (aval st) ! n = Some v) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st)) /\\\n(forall n' : positive,\n NS.In n' (worklist st) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st n') /\\\n(forall n' : positive,\n visited st n' -> NS.In n' (worklist st) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st) ! n' <> None -> visited st n').","conclusion":"optge (aval st) ! n (Some out) /\\\n(forall s : positive, n <> s -> (aval st) ! s = (aval st) ! s) /\\\n(forall s : positive, optge (aval st) ! s (aval st) ! s) /\\\n(NS.In n (worklist st) \\/ (aval st) ! n = Some v) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st)) /\\\n(forall n' : positive,\n NS.In n' (worklist st) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st n') /\\\n(forall n' : positive,\n visited st n' -> NS.In n' (worklist st) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st) ! n' <> None -> visited st n')","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out))","proofString":"repeat split; intros.\nrewrite E.\nconstructor.\neapply L.ge_trans.\napply L.ge_refl.\napply H; auto.\napply L.ge_lub_right.\napply optge_refl.\nright; auto.\nauto.\nauto.\nauto.\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) : optge (aval st) ! n (Some out).","conclusion":"optge (aval st) ! n (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out))","proofString":"rewrite E.\nconstructor.\neapply L.ge_trans.\napply L.ge_refl.\napply H; auto.\napply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) : optge (Some v) (Some out).","conclusion":"optge (Some v) (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out))","proofString":"constructor.\neapply L.ge_trans.\napply L.ge_refl.\napply H; auto.\napply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) : L.ge v out.","conclusion":"L.ge v out","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out))","proofString":"eapply L.ge_trans.\napply L.ge_refl.\napply H; auto.\napply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (s : positive) : optge (aval st) ! s (aval st) ! s.","conclusion":"optge (aval st) ! s (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (s : positive)","proofString":"apply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) : NS.In n (worklist st) \\/ (aval st) ! n = Some v.","conclusion":"NS.In n (worklist st) \\/ (aval st) ! n = Some v","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out))","proofString":"right; auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st)) : NS.In n' (worklist st).","conclusion":"NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st)) : n' = n \\/ NS.In n' (worklist st).","conclusion":"n' = n \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n') : visited st n'.","conclusion":"visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n')","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n') : NS.In n' (worklist st) \\/ visited st n'.","conclusion":"NS.In n' (worklist st) \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n')","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (aval st) ! n' <> None) : visited st n'.","conclusion":"visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : true = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (aval st) ! n' <> None)","proofString":"congruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : optge\n  (aval\n     {|\n       aval := PTree.set n (L.lub v out) (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n = Some v) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |})) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n') /\\\n(forall n' : positive,\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n' ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n' <> None ->\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n').","conclusion":"optge\n  (aval\n     {|\n       aval := PTree.set n (L.lub v out) (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n = Some v) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |})) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n') /\\\n(forall n' : positive,\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n' ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n (L.lub v out) (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    {|\n      aval := PTree.set n (L.lub v out) (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n' <> None ->\n visited\n   {|\n     aval := PTree.set n (L.lub v out) (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n')","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"simpl; repeat split; intros.\nrewrite PTree.gss.\nconstructor.\napply L.ge_lub_right.\nrewrite PTree.gso by auto.\nauto.\nrewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply L.ge_lub_left.\napply optge_refl.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec in H0.\nintuition.\nauto.\ndestruct H0; auto.\nsubst n'.\nrewrite NS.add_spec; auto.\nrewrite PTree.gsspec in H1.\ndestruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : optge (PTree.set n (L.lub v out) (aval st)) ! n (Some out).","conclusion":"optge (PTree.set n (L.lub v out) (aval st)) ! n (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"rewrite PTree.gss.\nconstructor.\napply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : optge (Some (L.lub v out)) (Some out).","conclusion":"optge (Some (L.lub v out)) (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"constructor.\napply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : L.ge (L.lub v out) out.","conclusion":"L.ge (L.lub v out) out","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"apply L.ge_lub_right."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (H0 : n <> s) : (PTree.set n (L.lub v out) (aval st)) ! s = (aval st) ! s.","conclusion":"(PTree.set n (L.lub v out) (aval st)) ! s = (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (H0 : n <> s)","proofString":"rewrite PTree.gso by auto.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (H0 : n <> s) : (aval st) ! s = (aval st) ! s.","conclusion":"(aval st) ! s = (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (H0 : n <> s)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) : optge (PTree.set n (L.lub v out) (aval st)) ! s (aval st) ! s.","conclusion":"optge (PTree.set n (L.lub v out) (aval st)) ! s (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive)","proofString":"rewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply L.ge_lub_left.\napply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) : optge (if peq s n then Some (L.lub v out) else (aval st) ! s) (aval st) ! s.","conclusion":"optge (if peq s n then Some (L.lub v out) else (aval st) ! s) (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive)","proofString":"destruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply L.ge_lub_left.\napply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (e : s = n) : optge (Some (L.lub v out)) (aval st) ! s.","conclusion":"optge (Some (L.lub v out)) (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (e : s = n)","proofString":"subst s.\nrewrite E.\nconstructor.\napply L.ge_lub_left."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : optge (Some (L.lub v out)) (aval st) ! n.","conclusion":"optge (Some (L.lub v out)) (aval st) ! n","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"rewrite E.\nconstructor.\napply L.ge_lub_left."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : optge (Some (L.lub v out)) (Some v).","conclusion":"optge (Some (L.lub v out)) (Some v)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"constructor.\napply L.ge_lub_left."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : L.ge (L.lub v out) v.","conclusion":"L.ge (L.lub v out) v","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"apply L.ge_lub_left."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (n0 : s <> n) : optge (aval st) ! s (aval st) ! s.","conclusion":"optge (aval st) ! s (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (s : positive) (n0 : s <> n)","proofString":"apply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : NS.In n (NS.add n (worklist st)) \\/\n(PTree.set n (L.lub v out) (aval st)) ! n = Some v.","conclusion":"NS.In n (NS.add n (worklist st)) \\/\n(PTree.set n (L.lub v out) (aval st)) ! n = Some v","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"rewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : (n = n \\/ NS.In n (worklist st)) \\/\n(PTree.set n (L.lub v out) (aval st)) ! n = Some v.","conclusion":"(n = n \\/ NS.In n (worklist st)) \\/\n(PTree.set n (L.lub v out) (aval st)) ! n = Some v","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st)) : NS.In n' (NS.add n (worklist st)).","conclusion":"NS.In n' (NS.add n (worklist st))","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st))","proofString":"rewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st)) : n = n' \\/ NS.In n' (worklist st).","conclusion":"n = n' \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (NS.add n (worklist st))) : n' = n \\/ NS.In n' (worklist st).","conclusion":"n' = n \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : NS.In n' (NS.add n (worklist st)))","proofString":"rewrite NS.add_spec in H0.\nintuition."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n = n' \\/ NS.In n' (worklist st)) : n' = n \\/ NS.In n' (worklist st).","conclusion":"n' = n \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n = n' \\/ NS.In n' (worklist st))","proofString":"intuition."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n') : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : visited st n')","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n' = n \\/ visited st n') : NS.In n' (NS.add n (worklist st)) \\/ visited st n'.","conclusion":"NS.In n' (NS.add n (worklist st)) \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n' = n \\/ visited st n')","proofString":"destruct H0; auto.\nsubst n'.\nrewrite NS.add_spec; auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n' = n) : NS.In n' (NS.add n (worklist st)) \\/ visited st n'.","conclusion":"NS.In n' (NS.add n (worklist st)) \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : n' = n)","proofString":"subst n'.\nrewrite NS.add_spec; auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) : NS.In n (NS.add n (worklist st)) \\/ visited st n.","conclusion":"NS.In n (NS.add n (worklist st)) \\/ visited st n","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out))","proofString":"rewrite NS.add_spec; auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (PTree.set n (L.lub v out) (aval st)) ! n' <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (PTree.set n (L.lub v out) (aval st)) ! n' <> None)","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (if peq n' n then Some (L.lub v out) else (aval st) ! n') <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (H1 : (if peq n' n then Some (L.lub v out) else (aval st) ! n') <> None)","proofString":"destruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (e : n' = n) (H1 : Some (L.lub v out) <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (e : n' = n) (H1 : Some (L.lub v out) <> None)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (n0 : n' <> n) (H1 : (aval st) ! n' <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (v : L.t) (E : (aval st) ! n = Some v) (H : false = true -> L.eq v (L.lub v out)) (n' : positive) (H0 : (aval st) ! n' = None) (n0 : n' <> n) (H1 : (aval st) ! n' <> None)","proofString":"congruence."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : optge\n  (aval\n     {|\n       aval := PTree.set n out (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n = None) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |})) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n') /\\\n(forall n' : positive,\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n' ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n' <> None ->\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n').","conclusion":"optge\n  (aval\n     {|\n       aval := PTree.set n out (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}) ! n (Some out) /\\\n(forall s : positive,\n n <> s ->\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! s = (aval st) ! s) /\\\n(forall s : positive,\n optge\n   (aval\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) ! s (aval st) ! s) /\\\n(NS.In n\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n = None) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |})) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) -> n' = n \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n') /\\\n(forall n' : positive,\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n' ->\n NS.In n'\n   (worklist\n      {|\n        aval := PTree.set n out (aval st);\n        worklist := NS.add n (worklist st);\n        visited := fun p : positive => p = n \\/ visited st p\n      |}) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval\n    {|\n      aval := PTree.set n out (aval st);\n      worklist := NS.add n (worklist st);\n      visited := fun p : positive => p = n \\/ visited st p\n    |}) ! n' <> None ->\n visited\n   {|\n     aval := PTree.set n out (aval st);\n     worklist := NS.add n (worklist st);\n     visited := fun p : positive => p = n \\/ visited st p\n   |} n')","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"simpl; repeat split; intros.\nrewrite PTree.gss.\napply optge_refl.\nrewrite PTree.gso by auto.\nauto.\nrewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply optge_refl.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec.\nauto.\nrewrite NS.add_spec in H.\nintuition.\nauto.\ndestruct H; auto.\nsubst n'.\nrewrite NS.add_spec.\nauto.\nrewrite PTree.gsspec in H0.\ndestruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : optge (PTree.set n out (aval st)) ! n (Some out).","conclusion":"optge (PTree.set n out (aval st)) ! n (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"rewrite PTree.gss.\napply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : optge (Some out) (Some out).","conclusion":"optge (Some out) (Some out)","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"apply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (H : n <> s) : (PTree.set n out (aval st)) ! s = (aval st) ! s.","conclusion":"(PTree.set n out (aval st)) ! s = (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (H : n <> s)","proofString":"rewrite PTree.gso by auto.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (H : n <> s) : (aval st) ! s = (aval st) ! s.","conclusion":"(aval st) ! s = (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (H : n <> s)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) : optge (PTree.set n out (aval st)) ! s (aval st) ! s.","conclusion":"optge (PTree.set n out (aval st)) ! s (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive)","proofString":"rewrite PTree.gsspec.\ndestruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) : optge (if peq s n then Some out else (aval st) ! s) (aval st) ! s.","conclusion":"optge (if peq s n then Some out else (aval st) ! s) (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive)","proofString":"destruct (peq s n).\nsubst s.\nrewrite E.\nconstructor.\napply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (e : s = n) : optge (Some out) (aval st) ! s.","conclusion":"optge (Some out) (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (e : s = n)","proofString":"subst s.\nrewrite E.\nconstructor."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : optge (Some out) (aval st) ! n.","conclusion":"optge (Some out) (aval st) ! n","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"rewrite E.\nconstructor."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : optge (Some out) None.","conclusion":"optge (Some out) None","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"constructor."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (n0 : s <> n) : optge (aval st) ! s (aval st) ! s.","conclusion":"optge (aval st) ! s (aval st) ! s","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (s : positive) (n0 : s <> n)","proofString":"apply optge_refl."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : NS.In n (NS.add n (worklist st)) \\/ (PTree.set n out (aval st)) ! n = None.","conclusion":"NS.In n (NS.add n (worklist st)) \\/ (PTree.set n out (aval st)) ! n = None","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"rewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : (n = n \\/ NS.In n (worklist st)) \\/ (PTree.set n out (aval st)) ! n = None.","conclusion":"(n = n \\/ NS.In n (worklist st)) \\/ (PTree.set n out (aval st)) ! n = None","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (worklist st)) : NS.In n' (NS.add n (worklist st)).","conclusion":"NS.In n' (NS.add n (worklist st))","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (worklist st))","proofString":"rewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (worklist st)) : n = n' \\/ NS.In n' (worklist st).","conclusion":"n = n' \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (NS.add n (worklist st))) : n' = n \\/ NS.In n' (worklist st).","conclusion":"n' = n \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : NS.In n' (NS.add n (worklist st)))","proofString":"rewrite NS.add_spec in H.\nintuition."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n = n' \\/ NS.In n' (worklist st)) : n' = n \\/ NS.In n' (worklist st).","conclusion":"n' = n \\/ NS.In n' (worklist st)","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n = n' \\/ NS.In n' (worklist st))","proofString":"intuition."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : visited st n') : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : visited st n')","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n' = n \\/ visited st n') : NS.In n' (NS.add n (worklist st)) \\/ visited st n'.","conclusion":"NS.In n' (NS.add n (worklist st)) \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n' = n \\/ visited st n')","proofString":"destruct H; auto.\nsubst n'.\nrewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n' = n) : NS.In n' (NS.add n (worklist st)) \\/ visited st n'.","conclusion":"NS.In n' (NS.add n (worklist st)) \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : n' = n)","proofString":"subst n'.\nrewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : NS.In n (NS.add n (worklist st)) \\/ visited st n.","conclusion":"NS.In n (NS.add n (worklist st)) \\/ visited st n","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"rewrite NS.add_spec.\nauto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) : (n = n \\/ NS.In n (worklist st)) \\/ visited st n.","conclusion":"(n = n \\/ NS.In n (worklist st)) \\/ visited st n","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (H0 : (PTree.set n out (aval st)) ! n' <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (H0 : (PTree.set n out (aval st)) ! n' <> None)","proofString":"rewrite PTree.gsspec in H0.\ndestruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (H0 : (if peq n' n then Some out else (aval st) ! n') <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (H0 : (if peq n' n then Some out else (aval st) ! n') <> None)","proofString":"destruct (peq n' n).\nauto.\ncongruence."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (e : n' = n) (H0 : Some out <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (e : n' = n) (H0 : Some out <> None)","proofString":"auto."},{"statement":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (n0 : n' <> n) (H0 : (aval st) ! n' <> None) : n' = n \\/ visited st n'.","conclusion":"n' = n \\/ visited st n'","hypotheses":"(st : state) (out : L.t) (n : positive) (E : (aval st) ! n = None) (n' : positive) (H : (aval st) ! n' = None) (n0 : n' <> n) (H0 : (aval st) ! n' <> None)","proofString":"congruence."},{"statement":"(out : L.t) (st : state) : (forall n : positive, False -> optge (aval st) ! n (Some out)) /\\\n(forall n : positive, ~ False -> (aval st) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st) ! n (aval st) ! n) /\\\n(forall n : positive, NS.In n (worklist st) \\/ (aval st) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st)) /\\\n(forall n' : positive,\n NS.In n' (worklist st) -> False \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st n') /\\\n(forall n' : positive,\n visited st n' -> NS.In n' (worklist st) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st) ! n' <> None -> visited st n').","conclusion":"(forall n : positive, False -> optge (aval st) ! n (Some out)) /\\\n(forall n : positive, ~ False -> (aval st) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st) ! n (aval st) ! n) /\\\n(forall n : positive, NS.In n (worklist st) \\/ (aval st) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st)) /\\\n(forall n' : positive,\n NS.In n' (worklist st) -> False \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st n') /\\\n(forall n' : positive,\n visited st n' -> NS.In n' (worklist st) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st) ! n' <> None -> visited st n')","hypotheses":"(out : L.t) (st : state)","proofString":"repeat split; intros.\ncontradiction.\napply optge_refl.\nauto.\nauto.\nauto.\nauto.\nauto.\ncongruence."},{"statement":"(out : L.t) (st : state) (n : positive) (H : False) : optge (aval st) ! n (Some out).","conclusion":"optge (aval st) ! n (Some out)","hypotheses":"(out : L.t) (st : state) (n : positive) (H : False)","proofString":"contradiction."},{"statement":"(out : L.t) (st : state) (n : positive) : optge (aval st) ! n (aval st) ! n.","conclusion":"optge (aval st) ! n (aval st) ! n","hypotheses":"(out : L.t) (st : state) (n : positive)","proofString":"apply optge_refl."},{"statement":"(out : L.t) (st : state) (n : positive) : NS.In n (worklist st) \\/ (aval st) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st) \\/ (aval st) ! n = (aval st) ! n","hypotheses":"(out : L.t) (st : state) (n : positive)","proofString":"auto."},{"statement":"(out : L.t) (st : state) (n' : positive) (H : NS.In n' (worklist st)) : NS.In n' (worklist st).","conclusion":"NS.In n' (worklist st)","hypotheses":"(out : L.t) (st : state) (n' : positive) (H : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(out : L.t) (st : state) (n' : positive) (H : NS.In n' (worklist st)) : False \\/ NS.In n' (worklist st).","conclusion":"False \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (st : state) (n' : positive) (H : NS.In n' (worklist st))","proofString":"auto."},{"statement":"(out : L.t) (st : state) (n' : positive) (H : visited st n') : visited st n'.","conclusion":"visited st n'","hypotheses":"(out : L.t) (st : state) (n' : positive) (H : visited st n')","proofString":"auto."},{"statement":"(out : L.t) (st : state) (n' : positive) (H : visited st n') : NS.In n' (worklist st) \\/ visited st n'.","conclusion":"NS.In n' (worklist st) \\/ visited st n'","hypotheses":"(out : L.t) (st : state) (n' : positive) (H : visited st n')","proofString":"auto."},{"statement":"(out : L.t) (st : state) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st) ! n' <> None) : visited st n'.","conclusion":"visited st n'","hypotheses":"(out : L.t) (st : state) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st) ! n' <> None)","proofString":"congruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) : (forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list (propagate_succ st out a) out l) n' ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n' <> None ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n').","conclusion":"(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list (propagate_succ st out a) out l) n' ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n' <> None ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state)","proofString":"generalize (propagate_succ_charact st out a).\nset (st1 := propagate_succ st out a).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\ngeneralize (IHl st1).\nset (st2 := propagate_succ_list st1 out l).\nintros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) : (let st' := propagate_succ st out a in\n optge (aval st') ! a (Some out) /\\\n (forall s : positive, a <> s -> (aval st') ! s = (aval st) ! s) /\\\n (forall s : positive, optge (aval st') ! s (aval st) ! s) /\\\n (NS.In a (worklist st') \\/ (aval st') ! a = (aval st) ! a) /\\\n (forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> n' = a \\/ NS.In n' (worklist st)) /\\\n (forall n' : positive, visited st n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st n') /\\\n (forall n' : positive,\n  (aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list (propagate_succ st out a) out l) n' ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n' <> None ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n').","conclusion":"(let st' := propagate_succ st out a in\n optge (aval st') ! a (Some out) /\\\n (forall s : positive, a <> s -> (aval st') ! s = (aval st) ! s) /\\\n (forall s : positive, optge (aval st') ! s (aval st) ! s) /\\\n (NS.In a (worklist st') \\/ (aval st') ! a = (aval st) ! a) /\\\n (forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> n' = a \\/ NS.In n' (worklist st)) /\\\n (forall n' : positive, visited st n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st n') /\\\n (forall n' : positive,\n  (aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n\n   (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n =\n (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list (propagate_succ st out a) out l) n' ->\n NS.In n' (worklist (propagate_succ_list (propagate_succ st out a) out l)) \\/\n visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list (propagate_succ st out a) out l)) ! n' <> None ->\n visited (propagate_succ_list (propagate_succ st out a) out l) n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state)","proofString":"set (st1 := propagate_succ st out a).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\ngeneralize (IHl st1).\nset (st2 := propagate_succ_list st1 out l).\nintros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) : (let st' := st1 in\n optge (aval st') ! a (Some out) /\\\n (forall s : positive, a <> s -> (aval st') ! s = (aval st) ! s) /\\\n (forall s : positive, optge (aval st') ! s (aval st) ! s) /\\\n (NS.In a (worklist st') \\/ (aval st') ! a = (aval st) ! a) /\\\n (forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> n' = a \\/ NS.In n' (worklist st)) /\\\n (forall n' : positive, visited st n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st n') /\\\n (forall n' : positive,\n  (aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n').","conclusion":"(let st' := st1 in\n optge (aval st') ! a (Some out) /\\\n (forall s : positive, a <> s -> (aval st') ! s = (aval st) ! s) /\\\n (forall s : positive, optge (aval st') ! s (aval st) ! s) /\\\n (NS.In a (worklist st') \\/ (aval st') ! a = (aval st) ! a) /\\\n (forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> n' = a \\/ NS.In n' (worklist st)) /\\\n (forall n' : positive, visited st n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st n') /\\\n (forall n' : positive,\n  (aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state)","proofString":"intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\ngeneralize (IHl st1).\nset (st2 := propagate_succ_list st1 out l).\nintros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') : (forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n').","conclusion":"(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n')","proofString":"generalize (IHl st1).\nset (st2 := propagate_succ_list st1 out l).\nintros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') : (let st' := propagate_succ_list st1 out l in\n (forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n (forall n : positive, ~ In n l -> (aval st') ! n = (aval st1) ! n) /\\\n (forall n : positive, optge (aval st') ! n (aval st1) ! n) /\\\n (forall n : positive,\n  NS.In n (worklist st') \\/ (aval st') ! n = (aval st1) ! n) /\\\n (forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st1)) /\\\n (forall n' : positive, visited st1 n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st1 n') /\\\n (forall n' : positive,\n  (aval st1) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n').","conclusion":"(let st' := propagate_succ_list st1 out l in\n (forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n (forall n : positive, ~ In n l -> (aval st') ! n = (aval st1) ! n) /\\\n (forall n : positive, optge (aval st') ! n (aval st1) ! n) /\\\n (forall n : positive,\n  NS.In n (worklist st') \\/ (aval st') ! n = (aval st1) ! n) /\\\n (forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st1)) /\\\n (forall n' : positive, visited st1 n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st1 n') /\\\n (forall n' : positive,\n  (aval st1) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive,\n a = n \\/ In n l ->\n optge (aval (propagate_succ_list st1 out l)) ! n (Some out)) /\\\n(forall n : positive,\n ~ (a = n \\/ In n l) ->\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n : positive,\n optge (aval (propagate_succ_list st1 out l)) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist (propagate_succ_list st1 out l)) \\/\n (aval (propagate_succ_list st1 out l)) ! n = (aval st) ! n) /\\\n(forall n' : positive,\n NS.In n' (worklist st) ->\n NS.In n' (worklist (propagate_succ_list st1 out l))) /\\\n(forall n' : positive,\n NS.In n' (worklist (propagate_succ_list st1 out l)) ->\n (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive,\n visited st n' -> visited (propagate_succ_list st1 out l) n') /\\\n(forall n' : positive,\n visited (propagate_succ_list st1 out l) n' ->\n NS.In n' (worklist (propagate_succ_list st1 out l)) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None ->\n (aval (propagate_succ_list st1 out l)) ! n' <> None ->\n visited (propagate_succ_list st1 out l) n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n')","proofString":"set (st2 := propagate_succ_list st1 out l).\nintros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) : (let st' := st2 in\n (forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n (forall n : positive, ~ In n l -> (aval st') ! n = (aval st1) ! n) /\\\n (forall n : positive, optge (aval st') ! n (aval st1) ! n) /\\\n (forall n : positive,\n  NS.In n (worklist st') \\/ (aval st') ! n = (aval st1) ! n) /\\\n (forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st1)) /\\\n (forall n' : positive, visited st1 n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st1 n') /\\\n (forall n' : positive,\n  (aval st1) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n').","conclusion":"(let st' := st2 in\n (forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n (forall n : positive, ~ In n l -> (aval st') ! n = (aval st1) ! n) /\\\n (forall n : positive, optge (aval st') ! n (aval st1) ! n) /\\\n (forall n : positive,\n  NS.In n (worklist st') \\/ (aval st') ! n = (aval st1) ! n) /\\\n (forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st1)) /\\\n (forall n' : positive, visited st1 n' -> visited st' n') /\\\n (forall n' : positive,\n  visited st' n' -> NS.In n' (worklist st') \\/ visited st1 n') /\\\n (forall n' : positive,\n  (aval st1) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) ->\n(forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state)","proofString":"intros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9).\nclear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') : (forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n').","conclusion":"(forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (IHl : forall st0 : state,\nlet st' := propagate_succ_list st0 out l in\n(forall n : positive, In n l -> optge (aval st') ! n (Some out)) /\\\n(forall n : positive, ~ In n l -> (aval st') ! n = (aval st0) ! n) /\\\n(forall n : positive, optge (aval st') ! n (aval st0) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st') \\/ (aval st') ! n = (aval st0) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st0) -> NS.In n' (worklist st')) /\\\n(forall n' : positive,\n NS.In n' (worklist st') -> In n' l \\/ NS.In n' (worklist st0)) /\\\n(forall n' : positive, visited st0 n' -> visited st' n') /\\\n(forall n' : positive,\n visited st' n' -> NS.In n' (worklist st') \\/ visited st0 n') /\\\n(forall n' : positive,\n (aval st0) ! n' = None -> (aval st') ! n' <> None -> visited st' n')) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","proofString":"clear IHl.\nrepeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') : (forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n').","conclusion":"(forall n : positive, a = n \\/ In n l -> optge (aval st2) ! n (Some out)) /\\\n(forall n : positive, ~ (a = n \\/ In n l) -> (aval st2) ! n = (aval st) ! n) /\\\n(forall n : positive, optge (aval st2) ! n (aval st) ! n) /\\\n(forall n : positive,\n NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n) /\\\n(forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st2)) /\\\n(forall n' : positive,\n NS.In n' (worklist st2) -> (a = n' \\/ In n' l) \\/ NS.In n' (worklist st)) /\\\n(forall n' : positive, visited st n' -> visited st2 n') /\\\n(forall n' : positive,\n visited st2 n' -> NS.In n' (worklist st2) \\/ visited st n') /\\\n(forall n' : positive,\n (aval st) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","proofString":"repeat split; intros.\ndestruct H.\nsubst n.\neapply optge_trans; eauto.\nauto.\nrewrite B2 by tauto.\napply A2; tauto.\neapply optge_trans; eauto.\ndestruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto.\neauto.\nexploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition.\neauto.\nspecialize (B8 n'); specialize (A8 n').\nintuition.\ndestruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : a = n \\/ In n l) : optge (aval st2) ! n (Some out).","conclusion":"optge (aval st2) ! n (Some out)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : a = n \\/ In n l)","proofString":"destruct H.\nsubst n.\neapply optge_trans; eauto.\nauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : a = n) : optge (aval st2) ! n (Some out).","conclusion":"optge (aval st2) ! n (Some out)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : a = n)","proofString":"subst n.\neapply optge_trans; eauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') : optge (aval st2) ! a (Some out).","conclusion":"optge (aval st2) ! a (Some out)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n')","proofString":"eapply optge_trans; eauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : In n l) : optge (aval st2) ! n (Some out).","conclusion":"optge (aval st2) ! n (Some out)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : In n l)","proofString":"auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : ~ (a = n \\/ In n l)) : (aval st2) ! n = (aval st) ! n.","conclusion":"(aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : ~ (a = n \\/ In n l))","proofString":"rewrite B2 by tauto.\napply A2; tauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : ~ (a = n \\/ In n l)) : (aval st1) ! n = (aval st) ! n.","conclusion":"(aval st1) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : ~ (a = n \\/ In n l))","proofString":"apply A2; tauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) : optge (aval st2) ! n (aval st) ! n.","conclusion":"optge (aval st2) ! n (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive)","proofString":"eapply optge_trans; eauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) : NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive)","proofString":"destruct (B4 n).\nauto.\ndestruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : NS.In n (worklist st2)) : NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : NS.In n (worklist st2))","proofString":"auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) : NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n)","proofString":"destruct (peq n a).\nsubst n.\ndestruct A4.\nleft; auto.\nright; congruence.\nright.\nrewrite H.\nauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (e : n = a) : NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n0 : positive, In n0 l -> optge (aval st2) ! n0 (Some out)) (B2 : forall n0 : positive, ~ In n0 l -> (aval st2) ! n0 = (aval st1) ! n0) (B3 : forall n0 : positive, optge (aval st2) ! n0 (aval st1) ! n0) (B4 : forall n0 : positive,\nNS.In n0 (worklist st2) \\/ (aval st2) ! n0 = (aval st1) ! n0) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (e : n = a)","proofString":"subst n.\ndestruct A4.\nleft; auto.\nright; congruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a) : NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a.","conclusion":"NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a)","proofString":"destruct A4.\nleft; auto.\nright; congruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (H0 : NS.In a (worklist st1)) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a) : NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a.","conclusion":"NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (H0 : NS.In a (worklist st1)) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a)","proofString":"left; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (H0 : (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a) : NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a.","conclusion":"NS.In a (worklist st2) \\/ (aval st2) ! a = (aval st) ! a","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (H0 : (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (H : (aval st2) ! a = (aval st1) ! a)","proofString":"right; congruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a) : NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n.","conclusion":"NS.In n (worklist st2) \\/ (aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a)","proofString":"right.\nrewrite H.\nauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a) : (aval st2) ! n = (aval st) ! n.","conclusion":"(aval st2) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a)","proofString":"rewrite H.\nauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a) : (aval st1) ! n = (aval st) ! n.","conclusion":"(aval st1) ! n = (aval st) ! n","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n' : positive, NS.In n' (worklist st) -> NS.In n' (worklist st1)) (A6 : forall n' : positive,\nNS.In n' (worklist st1) -> n' = a \\/ NS.In n' (worklist st)) (A7 : forall n' : positive, visited st n' -> visited st1 n') (A8 : forall n' : positive,\nvisited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st1) ! n' <> None -> visited st1 n') (st2 : state) (B1 : forall n1 : positive, In n1 l -> optge (aval st2) ! n1 (Some out)) (B2 : forall n1 : positive, ~ In n1 l -> (aval st2) ! n1 = (aval st1) ! n1) (B3 : forall n1 : positive, optge (aval st2) ! n1 (aval st1) ! n1) (B4 : forall n1 : positive,\nNS.In n1 (worklist st2) \\/ (aval st2) ! n1 = (aval st1) ! n1) (B5 : forall n' : positive, NS.In n' (worklist st1) -> NS.In n' (worklist st2)) (B6 : forall n' : positive,\nNS.In n' (worklist st2) -> In n' l \\/ NS.In n' (worklist st1)) (B7 : forall n' : positive, visited st1 n' -> visited st2 n') (B8 : forall n' : positive,\nvisited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n' : positive,\n(aval st1) ! n' = None -> (aval st2) ! n' <> None -> visited st2 n') (n : positive) (H : (aval st2) ! n = (aval st1) ! n) (n0 : n <> a)","proofString":"auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st)) : NS.In n' (worklist st2).","conclusion":"NS.In n' (worklist st2)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st))","proofString":"eauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) : (a = n' \\/ In n' l) \\/ NS.In n' (worklist st).","conclusion":"(a = n' \\/ In n' l) \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2))","proofString":"exploit B6; eauto.\nintros [P|P].\nauto.\nexploit A6; eauto.\nintuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) : In n' l \\/ NS.In n' (worklist st1) ->\n(a = n' \\/ In n' l) \\/ NS.In n' (worklist st).","conclusion":"In n' l \\/ NS.In n' (worklist st1) ->\n(a = n' \\/ In n' l) \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2))","proofString":"intros [P|P].\nauto.\nexploit A6; eauto.\nintuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : In n' l) : (a = n' \\/ In n' l) \\/ NS.In n' (worklist st).","conclusion":"(a = n' \\/ In n' l) \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : In n' l)","proofString":"auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : NS.In n' (worklist st1)) : (a = n' \\/ In n' l) \\/ NS.In n' (worklist st).","conclusion":"(a = n' \\/ In n' l) \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : NS.In n' (worklist st1))","proofString":"exploit A6; eauto.\nintuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : NS.In n' (worklist st1)) : n' = a \\/ NS.In n' (worklist st) ->\n(a = n' \\/ In n' l) \\/ NS.In n' (worklist st).","conclusion":"n' = a \\/ NS.In n' (worklist st) ->\n(a = n' \\/ In n' l) \\/ NS.In n' (worklist st)","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : NS.In n' (worklist st2)) (P : NS.In n' (worklist st1))","proofString":"intuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : visited st n') : visited st2 n'.","conclusion":"visited st2 n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : visited st n')","proofString":"eauto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : visited st2 n') : NS.In n' (worklist st2) \\/ visited st n'.","conclusion":"NS.In n' (worklist st2) \\/ visited st n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : visited st2 n')","proofString":"specialize (B8 n'); specialize (A8 n').\nintuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (n' : positive) (A8 : visited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : visited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (H : visited st2 n') : NS.In n' (worklist st2) \\/ visited st n'.","conclusion":"NS.In n' (worklist st2) \\/ visited st n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (n' : positive) (A8 : visited st1 n' -> NS.In n' (worklist st1) \\/ visited st n') (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : visited st2 n' -> NS.In n' (worklist st2) \\/ visited st1 n') (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (H : visited st2 n')","proofString":"intuition."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) : visited st2 n'.","conclusion":"visited st2 n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None)","proofString":"destruct st1.(aval)!n' eqn:ST1.\napply B7.\napply A9; auto.\ncongruence.\napply B9; auto."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t) : visited st2 n'.","conclusion":"visited st2 n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t)","proofString":"apply B7.\napply A9; auto.\ncongruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t) : visited st1 n'.","conclusion":"visited st1 n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t)","proofString":"apply A9; auto.\ncongruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t) : (aval st1) ! n' <> None.","conclusion":"(aval st1) ! n' <> None","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (t : L.t) (ST1 : (aval st1) ! n' = Some t)","proofString":"congruence."},{"statement":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (ST1 : (aval st1) ! n' = None) : visited st2 n'.","conclusion":"visited st2 n'","hypotheses":"(out : L.t) (a : positive) (l : list positive) (st : state) (st1 : state) (A1 : optge (aval st1) ! a (Some out)) (A2 : forall s : positive, a <> s -> (aval st1) ! s = (aval st) ! s) (A3 : forall s : positive, optge (aval st1) ! s (aval st) ! s) (A4 : NS.In a (worklist st1) \\/ (aval st1) ! a = (aval st) ! a) (A5 : forall n'0 : positive, NS.In n'0 (worklist st) -> NS.In n'0 (worklist st1)) (A6 : forall n'0 : positive,\nNS.In n'0 (worklist st1) -> n'0 = a \\/ NS.In n'0 (worklist st)) (A7 : forall n'0 : positive, visited st n'0 -> visited st1 n'0) (A8 : forall n'0 : positive,\nvisited st1 n'0 -> NS.In n'0 (worklist st1) \\/ visited st n'0) (A9 : forall n'0 : positive,\n(aval st) ! n'0 = None -> (aval st1) ! n'0 <> None -> visited st1 n'0) (st2 : state) (B1 : forall n : positive, In n l -> optge (aval st2) ! n (Some out)) (B2 : forall n : positive, ~ In n l -> (aval st2) ! n = (aval st1) ! n) (B3 : forall n : positive, optge (aval st2) ! n (aval st1) ! n) (B4 : forall n : positive,\nNS.In n (worklist st2) \\/ (aval st2) ! n = (aval st1) ! n) (B5 : forall n'0 : positive, NS.In n'0 (worklist st1) -> NS.In n'0 (worklist st2)) (B6 : forall n'0 : positive,\nNS.In n'0 (worklist st2) -> In n'0 l \\/ NS.In n'0 (worklist st1)) (B7 : forall n'0 : positive, visited st1 n'0 -> visited st2 n'0) (B8 : forall n'0 : positive,\nvisited st2 n'0 -> NS.In n'0 (worklist st2) \\/ visited st1 n'0) (B9 : forall n'0 : positive,\n(aval st1) ! n'0 = None -> (aval st2) ! n'0 <> None -> visited st2 n'0) (n' : positive) (H : (aval st) ! n' = None) (H0 : (aval st2) ! n' <> None) (ST1 : (aval st1) ! n' = None)","proofString":"apply B9; auto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) : exists st : state,\n  steps start st /\\ NS.pick (worklist st) = None /\\ res = (L.bot, aval st).","conclusion":"exists st : state,\n  steps start st /\\ NS.pick (worklist st) = None /\\ res = (L.bot, aval st)","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res)","proofString":"eapply (PrimIter.iterate_prop _ _ step              (fun st => steps start st)              (fun res => exists st, steps start st /\\ NS.pick (worklist st) = None /\\ res = (L.bot, aval st))); eauto.\nintros.\ndestruct (step a) eqn:E.\nexists a; split; auto.\nunfold step in E.\ndestruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto.\neapply steps_right; eauto.\nconstructor."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) : forall a : state,\nsteps start a ->\nmatch step a with\n| inl b =>\n    exists st : state,\n      steps start st /\\ NS.pick (worklist st) = None /\\ b = (L.bot, aval st)\n| inr a' => steps start a'\nend.","conclusion":"forall a : state,\nsteps start a ->\nmatch step a with\n| inl b =>\n    exists st : state,\n      steps start st /\\ NS.pick (worklist st) = None /\\ b = (L.bot, aval st)\n| inr a' => steps start a'\nend","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res)","proofString":"intros.\ndestruct (step a) eqn:E.\nexists a; split; auto.\nunfold step in E.\ndestruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto.\neapply steps_right; eauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) : match step a with\n| inl b =>\n    exists st : state,\n      steps start st /\\ NS.pick (worklist st) = None /\\ b = (L.bot, aval st)\n| inr a' => steps start a'\nend.","conclusion":"match step a with\n| inl b =>\n    exists st : state,\n      steps start st /\\ NS.pick (worklist st) = None /\\ b = (L.bot, aval st)\n| inr a' => steps start a'\nend","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a)","proofString":"destruct (step a) eqn:E.\nexists a; split; auto.\nunfold step in E.\ndestruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto.\neapply steps_right; eauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : step a = inl t) : exists st : state,\n  steps start st /\\ NS.pick (worklist st) = None /\\ t = (L.bot, aval st).","conclusion":"exists st : state,\n  steps start st /\\ NS.pick (worklist st) = None /\\ t = (L.bot, aval st)","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : step a = inl t)","proofString":"exists a; split; auto.\nunfold step in E.\ndestruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : step a = inl t) : NS.pick (worklist a) = None /\\ t = (L.bot, aval a).","conclusion":"NS.pick (worklist a) = None /\\ t = (L.bot, aval a)","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : step a = inl t)","proofString":"unfold step in E.\ndestruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : match NS.pick (worklist a) with\n| Some (n, rem) =>\n    match code ! n with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval a; worklist := rem; visited := visited a |}\n             (transf n (abstr_value n a)) (successors instr))\n    | None => inr {| aval := aval a; worklist := rem; visited := visited a |}\n    end\n| None => inl (L.bot, aval a)\nend = inl t) : NS.pick (worklist a) = None /\\ t = (L.bot, aval a).","conclusion":"NS.pick (worklist a) = None /\\ t = (L.bot, aval a)","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (E : match NS.pick (worklist a) with\n| Some (n, rem) =>\n    match code ! n with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval a; worklist := rem; visited := visited a |}\n             (transf n (abstr_value n a)) (successors instr))\n    | None => inr {| aval := aval a; worklist := rem; visited := visited a |}\n    end\n| None => inl (L.bot, aval a)\nend = inl t)","proofString":"destruct (NS.pick (worklist a)) as [[n rem]|].\ndestruct (code!n); discriminate.\ninv E.\nauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (n : positive) (rem : NS.t) (E : match code ! n with\n| Some instr =>\n    inr\n      (propagate_succ_list\n         {| aval := aval a; worklist := rem; visited := visited a |}\n         (transf n (abstr_value n a)) (successors instr))\n| None => inr {| aval := aval a; worklist := rem; visited := visited a |}\nend = inl t) : Some (n, rem) = None /\\ t = (L.bot, aval a).","conclusion":"Some (n, rem) = None /\\ t = (L.bot, aval a)","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (t : PMap.t L.t) (n : positive) (rem : NS.t) (E : match code ! n with\n| Some instr =>\n    inr\n      (propagate_succ_list\n         {| aval := aval a; worklist := rem; visited := visited a |}\n         (transf n (abstr_value n a)) (successors instr))\n| None => inr {| aval := aval a; worklist := rem; visited := visited a |}\nend = inl t)","proofString":"destruct (code!n); discriminate."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (s : state) (E : step a = inr s) : steps start s.","conclusion":"steps start s","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) (a : state) (H0 : steps start a) (s : state) (E : step a = inr s)","proofString":"eapply steps_right; eauto."},{"statement":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res) : steps start start.","conclusion":"steps start start","hypotheses":"(start : state) (res : PMap.t L.t) (H : fixpoint_from start = Some res)","proofString":"constructor."},{"statement":"(n : positive) (s1 s2 : state) (H : match NS.pick (worklist s1) with\n| Some (n0, rem) =>\n    match code ! n0 with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval s1; worklist := rem; visited := visited s1 |}\n             (transf n0 (abstr_value n0 s1)) (successors instr))\n    | None =>\n        inr {| aval := aval s1; worklist := rem; visited := visited s1 |}\n    end\n| None => inl (L.bot, aval s1)\nend = inr s2) : optge (aval s2) ! n (aval s1) ! n /\\ (visited s1 n -> visited s2 n).","conclusion":"optge (aval s2) ! n (aval s1) ! n /\\ (visited s1 n -> visited s2 n)","hypotheses":"(n : positive) (s1 s2 : state) (H : match NS.pick (worklist s1) with\n| Some (n0, rem) =>\n    match code ! n0 with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval s1; worklist := rem; visited := visited s1 |}\n             (transf n0 (abstr_value n0 s1)) (successors instr))\n    | None =>\n        inr {| aval := aval s1; worklist := rem; visited := visited s1 |}\n    end\n| None => inl (L.bot, aval s1)\nend = inr s2)","proofString":"destruct (NS.pick (worklist s1)) as [[p rem] | ]; try discriminate.\ndestruct (code!p) as [instr|]; inv H.\ngeneralize (propagate_succ_list_charact                     (transf p (abstr_value p s1))                     (successors instr)                     {| aval := aval s1; worklist := rem; visited := visited s1 |}).\nsimpl.\nset (s' := propagate_succ_list {| aval := aval s1; worklist := rem; visited := visited s1 |}                    (transf p (abstr_value p s1)) (successors instr)).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nauto.\nsplit.\napply optge_refl.\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) : optge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n).","conclusion":"optge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A)","proofString":"generalize (propagate_succ_list_charact                     (transf p (abstr_value p s1))                     (successors instr)                     {| aval := aval s1; worklist := rem; visited := visited s1 |}).\nsimpl.\nset (s' := propagate_succ_list {| aval := aval s1; worklist := rem; visited := visited s1 |}                    (transf p (abstr_value p s1)) (successors instr)).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) : (let st' :=\n   propagate_succ_list\n     {| aval := aval s1; worklist := rem; visited := visited s1 |}\n     (transf p (abstr_value p s1)) (successors instr) in\n (forall n0 : positive,\n  In n0 (successors instr) ->\n  optge (aval st') ! n0 (Some (transf p (abstr_value p s1)))) /\\\n (forall n0 : positive,\n  ~ In n0 (successors instr) ->\n  (aval st') ! n0 =\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n0 : positive,\n  optge (aval st') ! n0\n    (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n0 : positive,\n  NS.In n0 (worklist st') \\/\n  (aval st') ! n0 =\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n' : positive,\n  NS.In n'\n    (worklist {| aval := aval s1; worklist := rem; visited := visited s1 |}) ->\n  NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') ->\n  In n' (successors instr) \\/\n  NS.In n'\n    (worklist {| aval := aval s1; worklist := rem; visited := visited s1 |})) /\\\n (forall n' : positive,\n  visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n' ->\n  visited st' n') /\\\n (forall n' : positive,\n  visited st' n' ->\n  NS.In n' (worklist st') \\/\n  visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n') /\\\n (forall n' : positive,\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n' =\n  None -> (aval st') ! n' <> None -> visited st' n')) ->\noptge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n).","conclusion":"(let st' :=\n   propagate_succ_list\n     {| aval := aval s1; worklist := rem; visited := visited s1 |}\n     (transf p (abstr_value p s1)) (successors instr) in\n (forall n0 : positive,\n  In n0 (successors instr) ->\n  optge (aval st') ! n0 (Some (transf p (abstr_value p s1)))) /\\\n (forall n0 : positive,\n  ~ In n0 (successors instr) ->\n  (aval st') ! n0 =\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n0 : positive,\n  optge (aval st') ! n0\n    (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n0 : positive,\n  NS.In n0 (worklist st') \\/\n  (aval st') ! n0 =\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n0) /\\\n (forall n' : positive,\n  NS.In n'\n    (worklist {| aval := aval s1; worklist := rem; visited := visited s1 |}) ->\n  NS.In n' (worklist st')) /\\\n (forall n' : positive,\n  NS.In n' (worklist st') ->\n  In n' (successors instr) \\/\n  NS.In n'\n    (worklist {| aval := aval s1; worklist := rem; visited := visited s1 |})) /\\\n (forall n' : positive,\n  visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n' ->\n  visited st' n') /\\\n (forall n' : positive,\n  visited st' n' ->\n  NS.In n' (worklist st') \\/\n  visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n') /\\\n (forall n' : positive,\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n' =\n  None -> (aval st') ! n' <> None -> visited st' n')) ->\noptge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A)","proofString":"simpl.\nset (s' := propagate_succ_list {| aval := aval s1; worklist := rem; visited := visited s1 |}                    (transf p (abstr_value p s1)) (successors instr)).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) : (forall n0 : positive,\n In n0 (successors instr) ->\n optge\n   (aval\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ! n0\n   (Some (transf p (abstr_value p s1)))) /\\\n(forall n0 : positive,\n ~ In n0 (successors instr) ->\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n0 =\n (aval s1) ! n0) /\\\n(forall n0 : positive,\n optge\n   (aval\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ! n0\n   (aval s1) ! n0) /\\\n(forall n0 : positive,\n NS.In n0\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) \\/\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n0 =\n (aval s1) ! n0) /\\\n(forall n' : positive,\n NS.In n' rem ->\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr)))) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ->\n In n' (successors instr) \\/ NS.In n' rem) /\\\n(forall n' : positive,\n visited s1 n' ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n') /\\\n(forall n' : positive,\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n' ->\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) \\/ \n visited s1 n') /\\\n(forall n' : positive,\n (aval s1) ! n' = None ->\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n' <> None ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n') ->\noptge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n).","conclusion":"(forall n0 : positive,\n In n0 (successors instr) ->\n optge\n   (aval\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ! n0\n   (Some (transf p (abstr_value p s1)))) /\\\n(forall n0 : positive,\n ~ In n0 (successors instr) ->\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n0 =\n (aval s1) ! n0) /\\\n(forall n0 : positive,\n optge\n   (aval\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ! n0\n   (aval s1) ! n0) /\\\n(forall n0 : positive,\n NS.In n0\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) \\/\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n0 =\n (aval s1) ! n0) /\\\n(forall n' : positive,\n NS.In n' rem ->\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr)))) /\\\n(forall n' : positive,\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) ->\n In n' (successors instr) \\/ NS.In n' rem) /\\\n(forall n' : positive,\n visited s1 n' ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n') /\\\n(forall n' : positive,\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n' ->\n NS.In n'\n   (worklist\n      (propagate_succ_list\n         {| aval := aval s1; worklist := rem; visited := visited s1 |}\n         (transf p (abstr_value p s1)) (successors instr))) \\/ \n visited s1 n') /\\\n(forall n' : positive,\n (aval s1) ! n' = None ->\n (aval\n    (propagate_succ_list\n       {| aval := aval s1; worklist := rem; visited := visited s1 |}\n       (transf p (abstr_value p s1)) (successors instr))) ! n' <> None ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n') ->\noptge\n  (aval\n     (propagate_succ_list\n        {| aval := aval s1; worklist := rem; visited := visited s1 |}\n        (transf p (abstr_value p s1)) (successors instr))) ! n \n  (aval s1) ! n /\\\n(visited s1 n ->\n visited\n   (propagate_succ_list\n      {| aval := aval s1; worklist := rem; visited := visited s1 |}\n      (transf p (abstr_value p s1)) (successors instr)) n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A)","proofString":"set (s' := propagate_succ_list {| aval := aval s1; worklist := rem; visited := visited s1 |}                    (transf p (abstr_value p s1)) (successors instr)).\nintros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) (s' : state) : (forall n0 : positive,\n In n0 (successors instr) ->\n optge (aval s') ! n0 (Some (transf p (abstr_value p s1)))) /\\\n(forall n0 : positive,\n ~ In n0 (successors instr) -> (aval s') ! n0 = (aval s1) ! n0) /\\\n(forall n0 : positive, optge (aval s') ! n0 (aval s1) ! n0) /\\\n(forall n0 : positive,\n NS.In n0 (worklist s') \\/ (aval s') ! n0 = (aval s1) ! n0) /\\\n(forall n' : positive, NS.In n' rem -> NS.In n' (worklist s')) /\\\n(forall n' : positive,\n NS.In n' (worklist s') -> In n' (successors instr) \\/ NS.In n' rem) /\\\n(forall n' : positive, visited s1 n' -> visited s' n') /\\\n(forall n' : positive,\n visited s' n' -> NS.In n' (worklist s') \\/ visited s1 n') /\\\n(forall n' : positive,\n (aval s1) ! n' = None -> (aval s') ! n' <> None -> visited s' n') ->\noptge (aval s') ! n (aval s1) ! n /\\ (visited s1 n -> visited s' n).","conclusion":"(forall n0 : positive,\n In n0 (successors instr) ->\n optge (aval s') ! n0 (Some (transf p (abstr_value p s1)))) /\\\n(forall n0 : positive,\n ~ In n0 (successors instr) -> (aval s') ! n0 = (aval s1) ! n0) /\\\n(forall n0 : positive, optge (aval s') ! n0 (aval s1) ! n0) /\\\n(forall n0 : positive,\n NS.In n0 (worklist s') \\/ (aval s') ! n0 = (aval s1) ! n0) /\\\n(forall n' : positive, NS.In n' rem -> NS.In n' (worklist s')) /\\\n(forall n' : positive,\n NS.In n' (worklist s') -> In n' (successors instr) \\/ NS.In n' rem) /\\\n(forall n' : positive, visited s1 n' -> visited s' n') /\\\n(forall n' : positive,\n visited s' n' -> NS.In n' (worklist s') \\/ visited s1 n') /\\\n(forall n' : positive,\n (aval s1) ! n' = None -> (aval s') ! n' <> None -> visited s' n') ->\noptge (aval s') ! n (aval s1) ! n /\\ (visited s1 n -> visited s' n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) (s' : state)","proofString":"intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) (s' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) ->\noptge (aval s') ! n0 (Some (transf p (abstr_value p s1)))) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval s') ! n0 = (aval s1) ! n0) (A3 : forall n0 : positive, optge (aval s') ! n0 (aval s1) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist s') \\/ (aval s') ! n0 = (aval s1) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist s')) (A6 : forall n' : positive,\nNS.In n' (worklist s') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited s1 n' -> visited s' n') (A8 : forall n' : positive,\nvisited s' n' -> NS.In n' (worklist s') \\/ visited s1 n') (A9 : forall n' : positive,\n(aval s1) ! n' = None -> (aval s') ! n' <> None -> visited s' n') : optge (aval s') ! n (aval s1) ! n /\\ (visited s1 n -> visited s' n).","conclusion":"optge (aval s') ! n (aval s1) ! n /\\ (visited s1 n -> visited s' n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) (instr : A) (s' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) ->\noptge (aval s') ! n0 (Some (transf p (abstr_value p s1)))) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval s') ! n0 = (aval s1) ! n0) (A3 : forall n0 : positive, optge (aval s') ! n0 (aval s1) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist s') \\/ (aval s') ! n0 = (aval s1) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist s')) (A6 : forall n' : positive,\nNS.In n' (worklist s') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited s1 n' -> visited s' n') (A8 : forall n' : positive,\nvisited s' n' -> NS.In n' (worklist s') \\/ visited s1 n') (A9 : forall n' : positive,\n(aval s1) ! n' = None -> (aval s') ! n' <> None -> visited s' n')","proofString":"auto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) : optge\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n\n  (aval s1) ! n /\\\n(visited s1 n ->\n visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n).","conclusion":"optge\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n\n  (aval s1) ! n /\\\n(visited s1 n ->\n visited {| aval := aval s1; worklist := rem; visited := visited s1 |} n)","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t)","proofString":"split.\napply optge_refl.\nauto."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) : optge\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n\n  (aval s1) ! n.","conclusion":"optge\n  (aval {| aval := aval s1; worklist := rem; visited := visited s1 |}) ! n\n  (aval s1) ! n","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t)","proofString":"apply optge_refl."},{"statement":"(n : positive) (s1 : state) (p : positive) (rem : NS.t) : visited s1 n ->\nvisited {| aval := aval s1; worklist := rem; visited := visited s1 |} n.","conclusion":"visited s1 n ->\nvisited {| aval := aval s1; worklist := rem; visited := visited s1 |} n","hypotheses":"(n : positive) (s1 : state) (p : positive) (rem : NS.t)","proofString":"auto."},{"statement":"(n : positive) (s : state) : optge (aval s) ! n (aval s) ! n /\\ (visited s n -> visited s n).","conclusion":"optge (aval s) ! n (aval s) ! n /\\ (visited s n -> visited s n)","hypotheses":"(n : positive) (s : state)","proofString":"split.\napply optge_refl.\nauto."},{"statement":"(n : positive) (s : state) : optge (aval s) ! n (aval s) ! n.","conclusion":"optge (aval s) ! n (aval s) ! n","hypotheses":"(n : positive) (s : state)","proofString":"apply optge_refl."},{"statement":"(n : positive) (s : state) : visited s n -> visited s n.","conclusion":"visited s n -> visited s n","hypotheses":"(n : positive) (s : state)","proofString":"auto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (IHsteps : optge (aval s2) ! n (aval s1) ! n /\\ (visited s1 n -> visited s2 n)) : optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n).","conclusion":"optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n)","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (IHsteps : optge (aval s2) ! n (aval s1) ! n /\\ (visited s1 n -> visited s2 n))","proofString":"destruct IHsteps.\nexploit (step_incr n); eauto.\nintros [P Q].\nsplit.\neapply optge_trans; eauto.\neauto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) : optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n).","conclusion":"optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n)","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n)","proofString":"exploit (step_incr n); eauto.\nintros [P Q].\nsplit.\neapply optge_trans; eauto.\neauto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) : optge (aval s3) ! n (aval s2) ! n /\\ (visited s2 n -> visited s3 n) ->\noptge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n).","conclusion":"optge (aval s3) ! n (aval s2) ! n /\\ (visited s2 n -> visited s3 n) ->\noptge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n)","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n)","proofString":"intros [P Q].\nsplit.\neapply optge_trans; eauto.\neauto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n) : optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n).","conclusion":"optge (aval s3) ! n (aval s1) ! n /\\ (visited s1 n -> visited s3 n)","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n)","proofString":"split.\neapply optge_trans; eauto.\neauto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n) : optge (aval s3) ! n (aval s1) ! n.","conclusion":"optge (aval s3) ! n (aval s1) ! n","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n)","proofString":"eapply optge_trans; eauto."},{"statement":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n) : visited s1 n -> visited s3 n.","conclusion":"visited s1 n -> visited s3 n","hypotheses":"(n : positive) (s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (H0 : optge (aval s2) ! n (aval s1) ! n) (H1 : visited s1 n -> visited s2 n) (P : optge (aval s3) ! n (aval s2) ! n) (Q : visited s2 n -> visited s3 n)","proofString":"eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) : good_state\n  (propagate_succ_list\n     {| aval := aval st; worklist := rem; visited := visited st |}\n     (transf pc (abstr_value pc st)) (successors instr)).","conclusion":"good_state\n  (propagate_succ_list\n     {| aval := aval st; worklist := rem; visited := visited st |}\n     (transf pc (abstr_value pc st)) (successors instr))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n)","proofString":"generalize (NS.pick_some _ _ _ PICK); intro PICK2.\nset (out := transf pc (abstr_value pc st)).\ngeneralize (propagate_succ_list_charact out (successors instr) {| aval := aval st; worklist := rem; visited := visited st |}).\nset (st' := propagate_succ_list {| aval := aval st; worklist := rem; visited := visited st |} out                                  (successors instr)).\nsimpl; intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nconstructor; intros.\ndestruct (A8 n H); auto.\ndestruct (A4 n); auto.\nreplace (abstr_value n st') with (abstr_value n st)  by (unfold abstr_value; rewrite H1; auto).\nexploit GOOD1; eauto.\nintros [P|P].\nrewrite PICK2 in P; destruct P.\nsubst n.\nfold out.\nright; intros.\nassert (i = instr) by congruence.\nsubst i.\napply A1; auto.\nleft.\napply A5; auto.\nright; intros.\napply optge_trans with st.(aval)!s; eauto.\ndestruct st.(aval)!n as [v'|] eqn:ST.\napply A7.\neapply GOOD2; eauto.\napply A9; auto.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) : good_state\n  (propagate_succ_list\n     {| aval := aval st; worklist := rem; visited := visited st |}\n     (transf pc (abstr_value pc st)) (successors instr)).","conclusion":"good_state\n  (propagate_succ_list\n     {| aval := aval st; worklist := rem; visited := visited st |}\n     (transf pc (abstr_value pc st)) (successors instr))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem)","proofString":"set (out := transf pc (abstr_value pc st)).\ngeneralize (propagate_succ_list_charact out (successors instr) {| aval := aval st; worklist := rem; visited := visited st |}).\nset (st' := propagate_succ_list {| aval := aval st; worklist := rem; visited := visited st |} out                                  (successors instr)).\nsimpl; intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).\nconstructor; intros.\ndestruct (A8 n H); auto.\ndestruct (A4 n); auto.\nreplace (abstr_value n st') with (abstr_value n st)  by (unfold abstr_value; rewrite H1; auto).\nexploit GOOD1; eauto.\nintros [P|P].\nrewrite PICK2 in P; destruct P.\nsubst n.\nfold out.\nright; intros.\nassert (i = instr) by congruence.\nsubst i.\napply A1; auto.\nleft.\napply A5; auto.\nright; intros.\napply optge_trans with st.(aval)!s; eauto.\ndestruct st.(aval)!n as [v'|] eqn:ST.\napply A7.\neapply GOOD2; eauto.\napply A9; auto.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) : NS.In pc (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! pc = Some i -> In s (successors i) -> optge (aval st') ! s (Some out)).","conclusion":"NS.In pc (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! pc = Some i -> In s (successors i) -> optge (aval st') ! s (Some out))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc)","proofString":"right; intros.\nassert (i = instr) by congruence.\nsubst i.\napply A1; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (i : A) (s : positive) (H2 : code ! pc = Some i) (H3 : In s (successors i)) : optge (aval st') ! s (Some out).","conclusion":"optge (aval st') ! s (Some out)","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (i : A) (s : positive) (H2 : code ! pc = Some i) (H3 : In s (successors i))","proofString":"assert (i = instr) by congruence.\nsubst i.\napply A1; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (i : A) (s : positive) (H2 : code ! pc = Some i) (H3 : In s (successors i)) (H4 : i = instr) : optge (aval st') ! s (Some out).","conclusion":"optge (aval st') ! s (Some out)","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (i : A) (s : positive) (H2 : code ! pc = Some i) (H3 : In s (successors i)) (H4 : i = instr)","proofString":"subst i.\napply A1; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (s : positive) (H3 : In s (successors instr)) (H2 : code ! pc = Some instr) : optge (aval st') ! s (Some out).","conclusion":"optge (aval st') ! s (Some out)","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n : positive,\nIn n (successors instr) -> optge (aval st') ! n (Some out)) (A2 : forall n : positive,\n~ In n (successors instr) -> (aval st') ! n = (aval st) ! n) (A3 : forall n : positive, optge (aval st') ! n (aval st) ! n) (A4 : forall n : positive, NS.In n (worklist st') \\/ (aval st') ! n = (aval st) ! n) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (H1 : (aval st') ! pc = (aval st) ! pc) (H0 : visited st pc) (H : visited st' pc) (s : positive) (H3 : In s (successors instr)) (H2 : code ! pc = Some instr)","proofString":"apply A1; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (H2 : NS.In n rem) : NS.In n (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st') ! s (Some (transf n (abstr_value n st)))).","conclusion":"NS.In n (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st') ! s (Some (transf n (abstr_value n st))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (H2 : NS.In n rem)","proofString":"left.\napply A5; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (H2 : NS.In n rem) : NS.In n (worklist st').","conclusion":"NS.In n (worklist st')","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (H2 : NS.In n rem)","proofString":"apply A5; auto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (P : forall (i : A) (s : positive),\ncode ! n = Some i ->\nIn s (successors i) ->\noptge (aval st) ! s (Some (transf n (abstr_value n st)))) : NS.In n (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st') ! s (Some (transf n (abstr_value n st)))).","conclusion":"NS.In n (worklist st') \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st') ! s (Some (transf n (abstr_value n st))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (P : forall (i : A) (s : positive),\ncode ! n = Some i ->\nIn s (successors i) ->\noptge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"right; intros.\napply optge_trans with st.(aval)!s; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n0 = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (P : forall (i0 : A) (s0 : positive),\ncode ! n = Some i0 ->\nIn s0 (successors i0) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (i : A) (s : positive) (H2 : code ! n = Some i) (H3 : In s (successors i)) : optge (aval st') ! s (Some (transf n (abstr_value n st))).","conclusion":"optge (aval st') ! s (Some (transf n (abstr_value n st)))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n0 = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (H : visited st' n) (H0 : visited st n) (H1 : (aval st') ! n = (aval st) ! n) (P : forall (i0 : A) (s0 : positive),\ncode ! n = Some i0 ->\nIn s0 (successors i0) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (i : A) (s : positive) (H2 : code ! n = Some i) (H3 : In s (successors i))","proofString":"apply optge_trans with st.(aval)!s; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) : visited st' n.","conclusion":"visited st' n","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v)","proofString":"destruct st.(aval)!n as [v'|] eqn:ST.\napply A7.\neapply GOOD2; eauto.\napply A9; auto.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (v' : L.t) (ST : (aval st) ! n = Some v') : visited st' n.","conclusion":"visited st' n","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (v' : L.t) (ST : (aval st) ! n = Some v')","proofString":"apply A7.\neapply GOOD2; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (v' : L.t) (ST : (aval st) ! n = Some v') : visited st n.","conclusion":"visited st n","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (v' : L.t) (ST : (aval st) ! n = Some v')","proofString":"eapply GOOD2; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (ST : (aval st) ! n = None) : visited st' n.","conclusion":"visited st' n","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (ST : (aval st) ! n = None)","proofString":"apply A9; auto.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (ST : (aval st) ! n = None) : (aval st') ! n <> None.","conclusion":"(aval st') ! n <> None","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (instr : A) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODEAT : code ! pc = Some instr) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (out : L.t) (st' : state) (A1 : forall n0 : positive,\nIn n0 (successors instr) -> optge (aval st') ! n0 (Some out)) (A2 : forall n0 : positive,\n~ In n0 (successors instr) -> (aval st') ! n0 = (aval st) ! n0) (A3 : forall n0 : positive, optge (aval st') ! n0 (aval st) ! n0) (A4 : forall n0 : positive,\nNS.In n0 (worklist st') \\/ (aval st') ! n0 = (aval st) ! n0) (A5 : forall n' : positive, NS.In n' rem -> NS.In n' (worklist st')) (A6 : forall n' : positive,\nNS.In n' (worklist st') -> In n' (successors instr) \\/ NS.In n' rem) (A7 : forall n' : positive, visited st n' -> visited st' n') (A8 : forall n' : positive,\nvisited st' n' -> NS.In n' (worklist st') \\/ visited st n') (A9 : forall n' : positive,\n(aval st) ! n' = None -> (aval st') ! n' <> None -> visited st' n') (n : positive) (v : L.t) (H : (aval st') ! n = Some v) (ST : (aval st) ! n = None)","proofString":"congruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) : good_state {| aval := aval st; worklist := rem; visited := visited st |}.","conclusion":"good_state {| aval := aval st; worklist := rem; visited := visited st |}","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None)","proofString":"generalize (NS.pick_some _ _ _ PICK); intro PICK2.\nconstructor; simpl; intros.\nexploit GOOD1; eauto.\nintros [P | P].\nrewrite PICK2 in P.\ndestruct P; auto.\nsubst n.\nright; intros.\ncongruence.\nright; exact P.\neapply GOOD2; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) : good_state {| aval := aval st; worklist := rem; visited := visited st |}.","conclusion":"good_state {| aval := aval st; worklist := rem; visited := visited st |}","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem)","proofString":"constructor; simpl; intros.\nexploit GOOD1; eauto.\nintros [P | P].\nrewrite PICK2 in P.\ndestruct P; auto.\nsubst n.\nright; intros.\ncongruence.\nright; exact P.\neapply GOOD2; eauto."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) : NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n)","proofString":"exploit GOOD1; eauto.\nintros [P | P].\nrewrite PICK2 in P.\ndestruct P; auto.\nsubst n.\nright; intros.\ncongruence.\nright; exact P."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) : NS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st)))) ->\nNS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st)))) ->\nNS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n)","proofString":"intros [P | P].\nrewrite PICK2 in P.\ndestruct P; auto.\nsubst n.\nright; intros.\ncongruence.\nright; exact P."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : NS.In n (worklist st)) : NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : NS.In n (worklist st))","proofString":"rewrite PICK2 in P.\ndestruct P; auto.\nsubst n.\nright; intros.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : pc = n \\/ NS.In n rem) : NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : pc = n \\/ NS.In n rem)","proofString":"destruct P; auto.\nsubst n.\nright; intros.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (H0 : pc = n) : NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (H0 : pc = n)","proofString":"subst n.\nright; intros.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (H : visited st pc) : NS.In pc rem \\/\n(forall (i : A) (s : positive),\n code ! pc = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf pc\n         (abstr_value pc\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In pc rem \\/\n(forall (i : A) (s : positive),\n code ! pc = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf pc\n         (abstr_value pc\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (H : visited st pc)","proofString":"right; intros.\ncongruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (H : visited st pc) (i : A) (s : positive) (H0 : code ! pc = Some i) (H1 : In s (successors i)) : optge (aval st) ! s\n  (Some\n     (transf pc\n        (abstr_value pc\n           {| aval := aval st; worklist := rem; visited := visited st |}))).","conclusion":"optge (aval st) ! s\n  (Some\n     (transf pc\n        (abstr_value pc\n           {| aval := aval st; worklist := rem; visited := visited st |})))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i0 : A) (s0 : positive),\n code ! n = Some i0 ->\n In s0 (successors i0) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (H : visited st pc) (i : A) (s : positive) (H0 : code ! pc = Some i) (H1 : In s (successors i))","proofString":"congruence."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : forall (i : A) (s : positive),\ncode ! n = Some i ->\nIn s (successors i) ->\noptge (aval st) ! s (Some (transf n (abstr_value n st)))) : NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |})))).","conclusion":"NS.In n rem \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {| aval := aval st; worklist := rem; visited := visited st |}))))","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (H : visited st n) (P : forall (i : A) (s : positive),\ncode ! n = Some i ->\nIn s (successors i) ->\noptge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"right; exact P."},{"statement":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (v : L.t) (H : (aval st) ! n = Some v) : visited st n.","conclusion":"visited st n","hypotheses":"(st : state) (pc : positive) (rem : NS.t) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (PICK : NS.pick (worklist st) = Some (pc, rem)) (CODE : code ! pc = None) (PICK2 : forall n' : positive, NS.In n' (worklist st) <-> pc = n' \\/ NS.In n' rem) (n : positive) (v : L.t) (H : (aval st) ! n = Some v)","proofString":"eapply GOOD2; eauto."},{"statement":"(s : state) (H : good_state s) : good_state s.","conclusion":"good_state s","hypotheses":"(s : state) (H : good_state s)","proofString":"auto."},{"statement":"(s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1) : good_state s3.","conclusion":"good_state s3","hypotheses":"(s1 s2 s3 : state) (H : steps s1 s2) (e : step s2 = inr s3) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1)","proofString":"unfold step in e.\ndestruct (NS.pick (worklist s2)) as [[n rem] | ] eqn:PICK; try discriminate.\ndestruct (code!n) as [instr|] eqn:CODE; inv e.\neapply step_state_good; eauto.\neapply step_state_good_2; eauto."},{"statement":"(s1 s2 s3 : state) (H : steps s1 s2) (e : match NS.pick (worklist s2) with\n| Some (n, rem) =>\n    match code ! n with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval s2; worklist := rem; visited := visited s2 |}\n             (transf n (abstr_value n s2)) (successors instr))\n    | None =>\n        inr {| aval := aval s2; worklist := rem; visited := visited s2 |}\n    end\n| None => inl (L.bot, aval s2)\nend = inr s3) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1) : good_state s3.","conclusion":"good_state s3","hypotheses":"(s1 s2 s3 : state) (H : steps s1 s2) (e : match NS.pick (worklist s2) with\n| Some (n, rem) =>\n    match code ! n with\n    | Some instr =>\n        inr\n          (propagate_succ_list\n             {| aval := aval s2; worklist := rem; visited := visited s2 |}\n             (transf n (abstr_value n s2)) (successors instr))\n    | None =>\n        inr {| aval := aval s2; worklist := rem; visited := visited s2 |}\n    end\n| None => inl (L.bot, aval s2)\nend = inr s3) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1)","proofString":"destruct (NS.pick (worklist s2)) as [[n rem] | ] eqn:PICK; try discriminate.\ndestruct (code!n) as [instr|] eqn:CODE; inv e.\neapply step_state_good; eauto.\neapply step_state_good_2; eauto."},{"statement":"(s1 s2 : state) (H : steps s1 s2) (n : positive) (rem : NS.t) (PICK : NS.pick (worklist s2) = Some (n, rem)) (instr : A) (CODE : code ! n = Some instr) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1) : good_state\n  (propagate_succ_list\n     {| aval := aval s2; worklist := rem; visited := visited s2 |}\n     (transf n (abstr_value n s2)) (successors instr)).","conclusion":"good_state\n  (propagate_succ_list\n     {| aval := aval s2; worklist := rem; visited := visited s2 |}\n     (transf n (abstr_value n s2)) (successors instr))","hypotheses":"(s1 s2 : state) (H : steps s1 s2) (n : positive) (rem : NS.t) (PICK : NS.pick (worklist s2) = Some (n, rem)) (instr : A) (CODE : code ! n = Some instr) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1)","proofString":"eapply step_state_good; eauto."},{"statement":"(s1 s2 : state) (H : steps s1 s2) (n : positive) (rem : NS.t) (PICK : NS.pick (worklist s2) = Some (n, rem)) (CODE : code ! n = None) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1) : good_state {| aval := aval s2; worklist := rem; visited := visited s2 |}.","conclusion":"good_state {| aval := aval s2; worklist := rem; visited := visited s2 |}","hypotheses":"(s1 s2 : state) (H : steps s1 s2) (n : positive) (rem : NS.t) (PICK : NS.pick (worklist s2) = Some (n, rem)) (CODE : code ! n = None) (IHsteps : good_state s1 -> good_state s2) (H0 : good_state s1)","proofString":"eapply step_state_good_2; eauto."},{"statement":"(enode : positive) (eval : L.t) : good_state (start_state enode eval).","conclusion":"good_state (start_state enode eval)","hypotheses":"(enode : positive) (eval : L.t)","proofString":"unfold start_state; constructor; simpl; intros.\nsubst n.\nrewrite NS.add_spec; auto.\nrewrite PTree.gsspec in H.\nrewrite PTree.gempty in H.\ndestruct (peq n enode).\nauto.\ndiscriminate."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (H : n = enode) : NS.In n (NS.add enode NS.empty) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.set enode eval (PTree.empty L.t)) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.set enode eval (PTree.empty L.t);\n              worklist := NS.add enode NS.empty;\n              visited := fun n0 : positive => n0 = enode\n            |})))).","conclusion":"NS.In n (NS.add enode NS.empty) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.set enode eval (PTree.empty L.t)) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.set enode eval (PTree.empty L.t);\n              worklist := NS.add enode NS.empty;\n              visited := fun n0 : positive => n0 = enode\n            |}))))","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (H : n = enode)","proofString":"subst n.\nrewrite NS.add_spec; auto."},{"statement":"(enode : positive) (eval : L.t) : NS.In enode (NS.add enode NS.empty) \\/\n(forall (i : A) (s : positive),\n code ! enode = Some i ->\n In s (successors i) ->\n optge (PTree.set enode eval (PTree.empty L.t)) ! s\n   (Some\n      (transf enode\n         (abstr_value enode\n            {|\n              aval := PTree.set enode eval (PTree.empty L.t);\n              worklist := NS.add enode NS.empty;\n              visited := fun n : positive => n = enode\n            |})))).","conclusion":"NS.In enode (NS.add enode NS.empty) \\/\n(forall (i : A) (s : positive),\n code ! enode = Some i ->\n In s (successors i) ->\n optge (PTree.set enode eval (PTree.empty L.t)) ! s\n   (Some\n      (transf enode\n         (abstr_value enode\n            {|\n              aval := PTree.set enode eval (PTree.empty L.t);\n              worklist := NS.add enode NS.empty;\n              visited := fun n : positive => n = enode\n            |}))))","hypotheses":"(enode : positive) (eval : L.t)","proofString":"rewrite NS.add_spec; auto."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (PTree.set enode eval (PTree.empty L.t)) ! n = Some v) : n = enode.","conclusion":"n = enode","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (PTree.set enode eval (PTree.empty L.t)) ! n = Some v)","proofString":"rewrite PTree.gsspec in H.\nrewrite PTree.gempty in H.\ndestruct (peq n enode).\nauto.\ndiscriminate."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (if peq n enode then Some eval else (PTree.empty L.t) ! n) = Some v) : n = enode.","conclusion":"n = enode","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (if peq n enode then Some eval else (PTree.empty L.t) ! n) = Some v)","proofString":"rewrite PTree.gempty in H.\ndestruct (peq n enode).\nauto.\ndiscriminate."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (if peq n enode then Some eval else None) = Some v) : n = enode.","conclusion":"n = enode","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (H : (if peq n enode then Some eval else None) = Some v)","proofString":"destruct (peq n enode).\nauto.\ndiscriminate."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (e : n = enode) (H : Some eval = Some v) : n = enode.","conclusion":"n = enode","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (e : n = enode) (H : Some eval = Some v)","proofString":"auto."},{"statement":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (n0 : n <> enode) (H : None = Some v) : n = enode.","conclusion":"n = enode","hypotheses":"(enode : positive) (eval : L.t) (n : positive) (v : L.t) (n0 : n <> enode) (H : None = Some v)","proofString":"discriminate."},{"statement":"(enodes : NS.t) : good_state (start_state_nodeset enodes).","conclusion":"good_state (start_state_nodeset enodes)","hypotheses":"(enodes : NS.t)","proofString":"unfold start_state_nodeset; constructor; simpl; intros.\nleft.\nauto.\nrewrite PTree.gempty in H.\ncongruence."},{"statement":"(enodes : NS.t) (n : positive) (H : NS.In n enodes) : NS.In n enodes \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := enodes;\n              visited := fun n0 : positive => NS.In n0 enodes\n            |})))).","conclusion":"NS.In n enodes \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := enodes;\n              visited := fun n0 : positive => NS.In n0 enodes\n            |}))))","hypotheses":"(enodes : NS.t) (n : positive) (H : NS.In n enodes)","proofString":"left.\nauto."},{"statement":"(enodes : NS.t) (n : positive) (H : NS.In n enodes) : NS.In n enodes.","conclusion":"NS.In n enodes","hypotheses":"(enodes : NS.t) (n : positive) (H : NS.In n enodes)","proofString":"auto."},{"statement":"(enodes : NS.t) (n : positive) (v : L.t) (H : (PTree.empty L.t) ! n = Some v) : NS.In n enodes.","conclusion":"NS.In n enodes","hypotheses":"(enodes : NS.t) (n : positive) (v : L.t) (H : (PTree.empty L.t) ! n = Some v)","proofString":"rewrite PTree.gempty in H.\ncongruence."},{"statement":"(enodes : NS.t) (n : positive) (v : L.t) (H : None = Some v) : NS.In n enodes.","conclusion":"NS.In n enodes","hypotheses":"(enodes : NS.t) (n : positive) (v : L.t) (H : None = Some v)","proofString":"congruence."},{"statement":"(n : positive) (H : exists instr : A, code ! n = Some instr) : NS.In n (NS.all_nodes code) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := NS.all_nodes code;\n              visited :=\n                fun n0 : positive => exists instr : A, code ! n0 = Some instr\n            |})))).","conclusion":"NS.In n (NS.all_nodes code) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := NS.all_nodes code;\n              visited :=\n                fun n0 : positive => exists instr : A, code ! n0 = Some instr\n            |}))))","hypotheses":"(n : positive) (H : exists instr : A, code ! n = Some instr)","proofString":"destruct H as [instr CODE].\nleft.\neapply NS.all_nodes_spec; eauto."},{"statement":"(n : positive) (instr : A) (CODE : code ! n = Some instr) : NS.In n (NS.all_nodes code) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := NS.all_nodes code;\n              visited :=\n                fun n0 : positive =>\n                exists instr0 : A, code ! n0 = Some instr0\n            |})))).","conclusion":"NS.In n (NS.all_nodes code) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (PTree.empty L.t) ! s\n   (Some\n      (transf n\n         (abstr_value n\n            {|\n              aval := PTree.empty L.t;\n              worklist := NS.all_nodes code;\n              visited :=\n                fun n0 : positive =>\n                exists instr0 : A, code ! n0 = Some instr0\n            |}))))","hypotheses":"(n : positive) (instr : A) (CODE : code ! n = Some instr)","proofString":"left.\neapply NS.all_nodes_spec; eauto."},{"statement":"(n : positive) (instr : A) (CODE : code ! n = Some instr) : NS.In n (NS.all_nodes code).","conclusion":"NS.In n (NS.all_nodes code)","hypotheses":"(n : positive) (instr : A) (CODE : code ! n = Some instr)","proofString":"eapply NS.all_nodes_spec; eauto."},{"statement":"(n : positive) (v : L.t) (H : (PTree.empty L.t) ! n = Some v) : exists instr : A, code ! n = Some instr.","conclusion":"exists instr : A, code ! n = Some instr","hypotheses":"(n : positive) (v : L.t) (H : (PTree.empty L.t) ! n = Some v)","proofString":"rewrite PTree.gempty in H.\ncongruence."},{"statement":"(n : positive) (v : L.t) (H : None = Some v) : exists instr : A, code ! n = Some instr.","conclusion":"exists instr : A, code ! n = Some instr","hypotheses":"(n : positive) (v : L.t) (H : None = Some v)","proofString":"congruence."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) : forall p q : positive,\nreachable code successors p q -> visited st p -> visited st q.","conclusion":"forall p q : positive,\nreachable code successors p q -> visited st p -> visited st q","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None)","proofString":"induction 1; intros.\nauto.\neapply IHreachable; eauto.\nexploit GOOD1; eauto.\nintros [P | P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = None) (n : positive) (H : visited st n) : visited st n.","conclusion":"visited st n","hypotheses":"(st : state) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s : positive),\n code ! n0 = Some i ->\n In s (successors i) ->\n optge (aval st) ! s (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (PICK : NS.pick (worklist st) = None) (n : positive) (H : visited st n)","proofString":"auto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) : visited st n3.","conclusion":"visited st n3","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1)","proofString":"eapply IHreachable; eauto.\nexploit GOOD1; eauto.\nintros [P | P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) : visited st n2.","conclusion":"visited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1)","proofString":"exploit GOOD1; eauto.\nintros [P | P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) : NS.In n1 (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n1 = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) -> \nvisited st n2.","conclusion":"NS.In n1 (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n1 = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) -> \nvisited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1)","proofString":"intros [P | P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : NS.In n1 (worklist st)) : visited st n2.","conclusion":"visited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : NS.In n1 (worklist st))","proofString":"eelim NS.pick_none; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) : visited st n2.","conclusion":"visited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st))))","proofString":"exploit P; eauto.\nintros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) : optge (aval st) ! n2 (Some (transf n1 (abstr_value n1 st))) -> visited st n2.","conclusion":"optge (aval st) ! n2 (Some (transf n1 (abstr_value n1 st))) -> visited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st))))","proofString":"intros OGE; inv OGE.\neapply GOOD2; eauto."},{"statement":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) (l : L.t) (H3 : L.ge l (transf n1 (abstr_value n1 st))) (H1 : Some l = (aval st) ! n2) : visited st n2.","conclusion":"visited st n2","hypotheses":"(st : state) (GOOD1 : forall n : positive,\nvisited st n ->\nNS.In n (worklist st) \\/\n(forall (i1 : A) (s : positive),\n code ! n = Some i1 ->\n In s (successors i1) ->\n optge (aval st) ! s (Some (transf n (abstr_value n st))))) (GOOD2 : forall (n : positive) (v : L.t), (aval st) ! n = Some v -> visited st n) (PICK : NS.pick (worklist st) = None) (n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : visited st n2 -> visited st n3) (H0 : visited st n1) (P : forall (i1 : A) (s : positive),\ncode ! n1 = Some i1 ->\nIn s (successors i1) ->\noptge (aval st) ! s (Some (transf n1 (abstr_value n1 st)))) (l : L.t) (H3 : L.ge l (transf n1 (abstr_value n1 st))) (H1 : Some l = (aval st) ! n2)","proofString":"eapply GOOD2; eauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot)","proofString":"exploit fixpoint_from_charact; eauto.\nintros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_good.\nintros [GOOD1 GOOD2].\nrewrite RES; unfold PMap.get; simpl.\ndestruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) : (exists st : state,\n   steps (start_state ep ev) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n).","conclusion":"(exists st : state,\n   steps (start_state ep ev) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot)","proofString":"intros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_good.\nintros [GOOD1 GOOD2].\nrewrite RES; unfold PMap.get; simpl.\ndestruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"exploit steps_state_good; eauto.\napply start_state_good.\nintros [GOOD1 GOOD2].\nrewrite RES; unfold PMap.get; simpl.\ndestruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state (start_state ep ev).","conclusion":"good_state (start_state ep ev)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"apply start_state_good."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state st -> L.ge res !! s (transf n res !! n).","conclusion":"good_state st -> L.ge res !! s (transf n res !! n)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"intros [GOOD1 GOOD2].\nrewrite RES; unfold PMap.get; simpl.\ndestruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0)","proofString":"rewrite RES; unfold PMap.get; simpl.\ndestruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0)","proofString":"destruct st.(aval)!n as [v|] eqn:STN.\ndestruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v)","proofString":"destruct (GOOD1 n) as [P|P]; eauto.\neelim NS.pick_none; eauto.\nexploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : NS.In n (worklist st)) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : NS.In n (worklist st))","proofString":"eelim NS.pick_none; eauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"exploit P; eauto.\nunfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v).","conclusion":"optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"unfold abstr_value; rewrite STN.\nintros OGE; inv OGE.\nauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : optge (aval st) ! s (Some (transf n v)) ->\nL.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v).","conclusion":"optge (aval st) ! s (Some (transf n v)) ->\nL.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"intros OGE; inv OGE.\nauto."},{"statement":"(ep : positive) (ev : L.t) (n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from (start_state ep ev) = Some (L.bot, aval st)) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H5 : L.ge l (transf n v)) (H3 : Some l = (aval st) ! s) : L.ge l (transf n v).","conclusion":"L.ge l (transf n v)","hypotheses":"(ep : positive) (ev : L.t) (n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from (start_state ep ev) = Some (L.bot, aval st)) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v0 : L.t), (aval st) ! n0 = Some v0 -> visited st n0) (v : L.t) (STN : (aval st) ! n = Some v) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H5 : L.ge l (transf n v)) (H3 : Some l = (aval st) ! s)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n L.bot).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end (transf n L.bot)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None)","proofString":"apply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end L.bot.","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end L.bot","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None)","proofString":"apply L.ge_bot."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None) : L.ge L.bot (transf n L.bot).","conclusion":"L.ge L.bot (transf n L.bot)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None)","proofString":"apply L.ge_refl.\napply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None) : L.eq L.bot (transf n L.bot).","conclusion":"L.eq L.bot (transf n L.bot)","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None)","proofString":"apply L.eq_sym.\neauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None) : L.eq (transf n L.bot) L.bot.","conclusion":"L.eq (transf n L.bot) L.bot","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state ep ev) = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall n0 : positive, L.eq (transf n0 L.bot) L.bot) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (STN : (aval st) ! n = None)","proofString":"eauto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) : L.ge res !! ep ev.","conclusion":"L.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res)","proofString":"exploit fixpoint_from_charact; eauto.\nintros (st & STEPS & PICK & RES).\nexploit (steps_incr ep); eauto.\nsimpl.\nrewrite PTree.gss.\nintros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) : (exists st : state,\n   steps (start_state ep ev) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! ep ev.","conclusion":"(exists st : state,\n   steps (start_state ep ev) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res)","proofString":"intros (st & STEPS & PICK & RES).\nexploit (steps_incr ep); eauto.\nsimpl.\nrewrite PTree.gss.\nintros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : L.ge res !! ep ev.","conclusion":"L.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"exploit (steps_incr ep); eauto.\nsimpl.\nrewrite PTree.gss.\nintros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : optge (aval st) ! ep (aval (start_state ep ev)) ! ep /\\\n(visited (start_state ep ev) ep -> visited st ep) -> \nL.ge res !! ep ev.","conclusion":"optge (aval st) ! ep (aval (start_state ep ev)) ! ep /\\\n(visited (start_state ep ev) ep -> visited st ep) -> \nL.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"simpl.\nrewrite PTree.gss.\nintros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : optge (aval st) ! ep (PTree.set ep ev (PTree.empty L.t)) ! ep /\\\n(ep = ep -> visited st ep) -> L.ge res !! ep ev.","conclusion":"optge (aval st) ! ep (PTree.set ep ev (PTree.empty L.t)) ! ep /\\\n(ep = ep -> visited st ep) -> L.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"rewrite PTree.gss.\nintros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : optge (aval st) ! ep (Some ev) /\\ (ep = ep -> visited st ep) ->\nL.ge res !! ep ev.","conclusion":"optge (aval st) ! ep (Some ev) /\\ (ep = ep -> visited st ep) ->\nL.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"intros [P Q].\nrewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (P : optge (aval st) ! ep (Some ev)) (Q : ep = ep -> visited st ep) : L.ge res !! ep ev.","conclusion":"L.ge res !! ep ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (P : optge (aval st) ! ep (Some ev)) (Q : ep = ep -> visited st ep)","proofString":"rewrite RES; unfold PMap.get; simpl.\ninv P; auto."},{"statement":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (P : optge (aval st) ! ep (Some ev)) (Q : ep = ep -> visited st ep) : L.ge match (aval st) ! ep with\n     | Some x => x\n     | None => L.bot\n     end ev.","conclusion":"L.ge match (aval st) ! ep with\n     | Some x => x\n     | None => L.bot\n     end ev","hypotheses":"(ep : positive) (ev : L.t) (res : PMap.t L.t) (H : fixpoint_from (start_state ep ev) = Some res) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (P : optge (aval st) ! ep (Some ev)) (Q : ep = ep -> visited st ep)","proofString":"inv P; auto."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"exploit fixpoint_from_charact; eauto.\nintros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_allnodes_good.\nintros [GOOD1 GOOD2].\nexploit (steps_incr n); eauto.\nsimpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : (exists st : state,\n   steps start_state_allnodes st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n).","conclusion":"(exists st : state,\n   steps start_state_allnodes st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"intros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_allnodes_good.\nintros [GOOD1 GOOD2].\nexploit (steps_incr n); eauto.\nsimpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"exploit steps_state_good; eauto.\napply start_state_allnodes_good.\nintros [GOOD1 GOOD2].\nexploit (steps_incr n); eauto.\nsimpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state start_state_allnodes.","conclusion":"good_state start_state_allnodes","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"apply start_state_allnodes_good."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state st -> L.ge res !! s (transf n res !! n).","conclusion":"good_state st -> L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"intros [GOOD1 GOOD2].\nexploit (steps_incr n); eauto.\nsimpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0)","proofString":"exploit (steps_incr n); eauto.\nsimpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) : optge (aval st) ! n (aval start_state_allnodes) ! n /\\\n(visited start_state_allnodes n -> visited st n) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! n (aval start_state_allnodes) ! n /\\\n(visited start_state_allnodes n -> visited st n) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0)","proofString":"simpl.\nintros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) : optge (aval st) ! n (PTree.empty L.t) ! n /\\\n((exists instr0 : A, code ! n = Some instr0) -> visited st n) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! n (PTree.empty L.t) ! n /\\\n((exists instr0 : A, code ! n = Some instr0) -> visited st n) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0)","proofString":"intros [U V].\nexploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n)","proofString":"exploit (GOOD1 n).\napply V.\nexists instr; auto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) : visited st n.","conclusion":"visited st n","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n)","proofString":"apply V.\nexists instr; auto."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) : exists instr0 : A, code ! n = Some instr0.","conclusion":"exists instr0 : A, code ! n = Some instr0","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n)","proofString":"exists instr; auto."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) : NS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st)))) ->\nL.ge res !! s (transf n res !! n).","conclusion":"NS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st)))) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n)","proofString":"intros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : NS.In n (worklist st)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : NS.In n (worklist st))","proofString":"eelim NS.pick_none; eauto."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"exploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"intros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st)))) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"rewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st)))) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end)","hypotheses":"(res : PMap.t L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_from start_state_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (st : state) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"inv OGE.\nassumption."},{"statement":"(n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from start_state_allnodes = Some (L.bot, aval st)) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H4 : L.ge l (transf n (abstr_value n st))) (H2 : Some l = (aval st) ! s) : L.ge l (transf n match (aval st) ! n with\n                 | Some x => x\n                 | None => L.bot\n                 end).","conclusion":"L.ge l (transf n match (aval st) ! n with\n                 | Some x => x\n                 | None => L.bot\n                 end)","hypotheses":"(n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from start_state_allnodes = Some (L.bot, aval st)) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (STEPS : steps start_state_allnodes st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! n (PTree.empty L.t) ! n) (V : (exists instr0 : A, code ! n = Some instr0) -> visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H4 : L.ge l (transf n (abstr_value n st))) (H2 : Some l = (aval st) ! s)","proofString":"assumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr))","proofString":"exploit fixpoint_from_charact; eauto.\nintros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_nodeset_good.\nintros GOOD.\nexploit (steps_incr e); eauto.\nsimpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) : (exists st : state,\n   steps (start_state_nodeset enodes) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n).","conclusion":"(exists st : state,\n   steps (start_state_nodeset enodes) st /\\\n   NS.pick (worklist st) = None /\\ res = (L.bot, aval st)) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr))","proofString":"intros (st & STEPS & PICK & RES).\nexploit steps_state_good; eauto.\napply start_state_nodeset_good.\nintros GOOD.\nexploit (steps_incr e); eauto.\nsimpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"exploit steps_state_good; eauto.\napply start_state_nodeset_good.\nintros GOOD.\nexploit (steps_incr e); eauto.\nsimpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state (start_state_nodeset enodes).","conclusion":"good_state (start_state_nodeset enodes)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"apply start_state_nodeset_good."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : good_state st -> L.ge res !! s (transf n res !! n).","conclusion":"good_state st -> L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"intros GOOD.\nexploit (steps_incr e); eauto.\nsimpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st)","proofString":"exploit (steps_incr e); eauto.\nsimpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) : optge (aval st) ! e (aval (start_state_nodeset enodes)) ! e /\\\n(visited (start_state_nodeset enodes) e -> visited st e) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! e (aval (start_state_nodeset enodes)) ! e /\\\n(visited (start_state_nodeset enodes) e -> visited st e) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st)","proofString":"simpl.\nintros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) : optge (aval st) ! e (PTree.empty L.t) ! e /\\ (NS.In e enodes -> visited st e) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! e (PTree.empty L.t) ! e /\\ (NS.In e enodes -> visited st e) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st)","proofString":"intros [U V].\nassert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e)","proofString":"assert (st.(visited) n).\neapply reachable_visited; eauto.\ndestruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) : visited st n.","conclusion":"visited st n","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e)","proofString":"eapply reachable_visited; eauto."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD : good_state st) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n)","proofString":"destruct GOOD as [GOOD1 GOOD2].\nexploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n)","proofString":"exploit (GOOD1 n); eauto.\nintros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) : NS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st)))) ->\nL.ge res !! s (transf n res !! n).","conclusion":"NS.In n (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n (abstr_value n st)))) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n)","proofString":"intros [P|P].\neelim NS.pick_none; eauto.\nexploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : NS.In n (worklist st)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : NS.In n (worklist st))","proofString":"eelim NS.pick_none; eauto."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"exploit P; eauto.\nintros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) : optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge res !! s (transf n res !! n).","conclusion":"optge (aval st) ! s (Some (transf n (abstr_value n st))) ->\nL.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st))))","proofString":"intros OGE.\nrewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st)))) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"rewrite RES; unfold PMap.get; simpl.\ninv OGE.\nassumption."},{"statement":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st)))) : L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end).","conclusion":"L.ge match (aval st) ! s with\n     | Some x => x\n     | None => L.bot\n     end\n  (transf n match (aval st) ! n with\n            | Some x => x\n            | None => L.bot\n            end)","hypotheses":"(enodes : NS.t) (res : PMap.t L.t) (e n : positive) (instr : A) (s : positive) (H : fixpoint_from (start_state_nodeset enodes) = Some res) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (st : state) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (OGE : optge (aval st) ! s (Some (transf n (abstr_value n st))))","proofString":"inv OGE.\nassumption."},{"statement":"(enodes : NS.t) (e n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from (start_state_nodeset enodes) = Some (L.bot, aval st)) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H7 : L.ge l (transf n (abstr_value n st))) (H5 : Some l = (aval st) ! s) : L.ge l (transf n match (aval st) ! n with\n                 | Some x => x\n                 | None => L.bot\n                 end).","conclusion":"L.ge l (transf n match (aval st) ! n with\n                 | Some x => x\n                 | None => L.bot\n                 end)","hypotheses":"(enodes : NS.t) (e n : positive) (instr : A) (s : positive) (st : state) (H : fixpoint_from (start_state_nodeset enodes) = Some (L.bot, aval st)) (H0 : NS.In e enodes) (H1 : reachable code successors e n) (H2 : code ! n = Some instr) (H3 : In s (successors instr)) (STEPS : steps (start_state_nodeset enodes) st) (PICK : NS.pick (worklist st) = None) (GOOD1 : forall n0 : positive,\nvisited st n0 ->\nNS.In n0 (worklist st) \\/\n(forall (i : A) (s0 : positive),\n code ! n0 = Some i ->\n In s0 (successors i) ->\n optge (aval st) ! s0 (Some (transf n0 (abstr_value n0 st))))) (GOOD2 : forall (n0 : positive) (v : L.t), (aval st) ! n0 = Some v -> visited st n0) (U : optge (aval st) ! e (PTree.empty L.t) ! e) (V : NS.In e enodes -> visited st e) (H4 : visited st n) (P : forall (i : A) (s0 : positive),\ncode ! n = Some i ->\nIn s0 (successors i) ->\noptge (aval st) ! s0 (Some (transf n (abstr_value n st)))) (l : L.t) (H7 : L.ge l (transf n (abstr_value n st))) (H5 : Some l = (aval st) ! s)","proofString":"assumption."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) : P res !! pc.","conclusion":"P res !! pc","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res)","proofString":"set (inv := fun st => forall x, P (abstr_value x st)).\nassert (inv (start_state ep ev)).\nred; simpl; intros.\nunfold abstr_value, start_state; simpl.\nrewrite PTree.gsspec.\nrewrite PTree.gempty.\ndestruct (peq x ep).\nauto.\nauto.\nassert (forall st v n, inv st -> P v -> inv (propagate_succ st v n)).\nunfold inv, propagate_succ.\nintros.\ndestruct (aval st)!n as [oldl|] eqn:E.\ndestruct (L.beq oldl (L.lub oldl v)).\nauto.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1.\nassert (forall l st v, inv st -> P v -> inv (propagate_succ_list st v l)).\ninduction l; intros; simpl.\nauto.\napply IHl; auto.\nassert (forall st1 st2, steps st1 st2 -> inv st1 -> inv st2).\ninduction 1; intros.\nauto.\nunfold step in e.\ndestruct (NS.pick (worklist s2)) as [[n rem]|]; try discriminate.\ndestruct (code!n) as [instr|] eqn:INSTR; inv e.\napply H2.\napply IHsteps; auto.\neapply P_transf; eauto.\napply IHsteps; auto.\napply IHsteps; auto.\nunfold fixpoint in H.\nexploit fixpoint_from_charact; eauto.\nintros (st & STEPS & PICK & RES).\nreplace (res!!pc) with (abstr_value pc st).\neapply H3; eauto.\nrewrite RES; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) : P (abstr_value x (start_state ep ev)).","conclusion":"P (abstr_value x (start_state ep ev))","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive)","proofString":"unfold abstr_value, start_state; simpl.\nrewrite PTree.gsspec.\nrewrite PTree.gempty.\ndestruct (peq x ep).\nauto.\nauto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) : P\n  match (PTree.set ep ev (PTree.empty L.t)) ! x with\n  | Some v => v\n  | None => L.bot\n  end.","conclusion":"P\n  match (PTree.set ep ev (PTree.empty L.t)) ! x with\n  | Some v => v\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive)","proofString":"rewrite PTree.gsspec.\nrewrite PTree.gempty.\ndestruct (peq x ep).\nauto.\nauto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) : P\n  match (if peq x ep then Some ev else (PTree.empty L.t) ! x) with\n  | Some v => v\n  | None => L.bot\n  end.","conclusion":"P\n  match (if peq x ep then Some ev else (PTree.empty L.t) ! x) with\n  | Some v => v\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive)","proofString":"rewrite PTree.gempty.\ndestruct (peq x ep).\nauto.\nauto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) : P\n  match (if peq x ep then Some ev else None) with\n  | Some v => v\n  | None => L.bot\n  end.","conclusion":"P\n  match (if peq x ep then Some ev else None) with\n  | Some v => v\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive)","proofString":"destruct (peq x ep).\nauto.\nauto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) (e : x = ep) : P ev.","conclusion":"P ev","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) (e : x = ep)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) (n : x <> ep) : P L.bot.","conclusion":"P L.bot","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (x : positive) (n : x <> ep)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) : forall (st : state) (v : L.t) (n : positive),\n(forall x : positive, P (abstr_value x st)) ->\nP v ->\nforall x : positive,\nP\n  (abstr_value x\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl v)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl v) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n v (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end).","conclusion":"forall (st : state) (v : L.t) (n : positive),\n(forall x : positive, P (abstr_value x st)) ->\nP v ->\nforall x : positive,\nP\n  (abstr_value x\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl v)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl v) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n v (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev))","proofString":"intros.\ndestruct (aval st)!n as [oldl|] eqn:E.\ndestruct (L.beq oldl (L.lub oldl v)).\nauto.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) : P\n  (abstr_value x\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl v)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl v) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n v (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end).","conclusion":"P\n  (abstr_value x\n     match (aval st) ! n with\n     | Some oldl =>\n         if L.beq oldl (L.lub oldl v)\n         then st\n         else\n          {|\n            aval := PTree.set n (L.lub oldl v) (aval st);\n            worklist := NS.add n (worklist st);\n            visited := fun p : positive => p = n \\/ visited st p\n          |}\n     | None =>\n         {|\n           aval := PTree.set n v (aval st);\n           worklist := NS.add n (worklist st);\n           visited := fun p : positive => p = n \\/ visited st p\n         |}\n     end)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive)","proofString":"destruct (aval st)!n as [oldl|] eqn:E.\ndestruct (L.beq oldl (L.lub oldl v)).\nauto.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P\n  (abstr_value x\n     (if L.beq oldl (L.lub oldl v)\n      then st\n      else\n       {|\n         aval := PTree.set n (L.lub oldl v) (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |})).","conclusion":"P\n  (abstr_value x\n     (if L.beq oldl (L.lub oldl v)\n      then st\n      else\n       {|\n         aval := PTree.set n (L.lub oldl v) (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}))","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"destruct (L.beq oldl (L.lub oldl v)).\nauto.\nunfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P (abstr_value x st).","conclusion":"P (abstr_value x st)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P\n  (abstr_value x\n     {|\n       aval := PTree.set n (L.lub oldl v) (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}).","conclusion":"P\n  (abstr_value x\n     {|\n       aval := PTree.set n (L.lub oldl v) (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |})","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"unfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P\n  match\n    (aval\n       {|\n         aval := PTree.set n (L.lub oldl v) (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}) ! x\n  with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match\n    (aval\n       {|\n         aval := PTree.set n (L.lub oldl v) (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}) ! x\n  with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"simpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P\n  match (PTree.set n (L.lub oldl v) (aval st)) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match (PTree.set n (L.lub oldl v) (aval st)) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"rewrite PTree.gsspec.\ndestruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) : P\n  match (if peq x n then Some (L.lub oldl v) else (aval st) ! x) with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match (if peq x n then Some (L.lub oldl v) else (aval st) ! x) with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl)","proofString":"destruct (peq x n).\napply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n) : P (L.lub oldl v).","conclusion":"P (L.lub oldl v)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n)","proofString":"apply P_lub; auto.\nreplace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n) : P oldl.","conclusion":"P oldl","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n)","proofString":"replace oldl with (abstr_value n st).\nauto.\nunfold abstr_value; rewrite E; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n) : P (abstr_value n st).","conclusion":"P (abstr_value n st)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n) : abstr_value n st = oldl.","conclusion":"abstr_value n st = oldl","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (e : x = n)","proofString":"unfold abstr_value; rewrite E; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (n0 : x <> n) : P match (aval st) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P match (aval st) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (oldl : L.t) (E : (aval st) ! n = Some oldl) (n0 : x <> n)","proofString":"apply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) : P\n  (abstr_value x\n     {|\n       aval := PTree.set n v (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |}).","conclusion":"P\n  (abstr_value x\n     {|\n       aval := PTree.set n v (aval st);\n       worklist := NS.add n (worklist st);\n       visited := fun p : positive => p = n \\/ visited st p\n     |})","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None)","proofString":"unfold abstr_value.\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) : P\n  match\n    (aval\n       {|\n         aval := PTree.set n v (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}) ! x\n  with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match\n    (aval\n       {|\n         aval := PTree.set n v (aval st);\n         worklist := NS.add n (worklist st);\n         visited := fun p : positive => p = n \\/ visited st p\n       |}) ! x\n  with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None)","proofString":"simpl.\nrewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) : P\n  match (PTree.set n v (aval st)) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match (PTree.set n v (aval st)) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None)","proofString":"rewrite PTree.gsspec.\ndestruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) : P\n  match (if peq x n then Some v else (aval st) ! x) with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P\n  match (if peq x n then Some v else (aval st) ! x) with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None)","proofString":"destruct (peq x n).\nauto.\napply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) (e : x = n) : P v.","conclusion":"P v","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) (e : x = n)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) (n0 : x <> n) : P match (aval st) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end.","conclusion":"P match (aval st) ! x with\n  | Some v0 => v0\n  | None => L.bot\n  end","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x0 y : L.t, P x0 -> P y -> P (L.lub x0 y)) (P_transf : forall (pc0 : positive) (instr : A) (x0 : L.t),\ncode ! pc0 = Some instr -> P x0 -> P (transf pc0 x0)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (st : state) (v : L.t) (n : positive) (H1 : forall x0 : positive, P (abstr_value x0 st)) (H2 : P v) (x : positive) (E : (aval st) ! n = None) (n0 : x <> n)","proofString":"apply H1."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st : state) (v : L.t) (n : positive),\ninv st -> P v -> inv (propagate_succ st v n)) : forall (l : list positive) (st : state) (v : L.t),\ninv st -> P v -> inv (propagate_succ_list st v l).","conclusion":"forall (l : list positive) (st : state) (v : L.t),\ninv st -> P v -> inv (propagate_succ_list st v l)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st : state) (v : L.t) (n : positive),\ninv st -> P v -> inv (propagate_succ st v n))","proofString":"induction l; intros; simpl.\nauto.\napply IHl; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v0 : L.t) (n : positive),\ninv st0 -> P v0 -> inv (propagate_succ st0 v0 n)) (st : state) (v : L.t) (H2 : inv st) (H3 : P v) : inv st.","conclusion":"inv st","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v0 : L.t) (n : positive),\ninv st0 -> P v0 -> inv (propagate_succ st0 v0 n)) (st : state) (v : L.t) (H2 : inv st) (H3 : P v)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v0 : L.t) (n : positive),\ninv st0 -> P v0 -> inv (propagate_succ st0 v0 n)) (a : positive) (l : list positive) (IHl : forall (st0 : state) (v0 : L.t),\ninv st0 -> P v0 -> inv (propagate_succ_list st0 v0 l)) (st : state) (v : L.t) (H2 : inv st) (H3 : P v) : inv (propagate_succ_list (propagate_succ st v a) v l).","conclusion":"inv (propagate_succ_list (propagate_succ st v a) v l)","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v0 : L.t) (n : positive),\ninv st0 -> P v0 -> inv (propagate_succ st0 v0 n)) (a : positive) (l : list positive) (IHl : forall (st0 : state) (v0 : L.t),\ninv st0 -> P v0 -> inv (propagate_succ_list st0 v0 l)) (st : state) (v : L.t) (H2 : inv st) (H3 : P v)","proofString":"apply IHl; auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st : state) (v : L.t) (n : positive),\ninv st -> P v -> inv (propagate_succ st v n)) (H2 : forall (l : list positive) (st : state) (v : L.t),\ninv st -> P v -> inv (propagate_succ_list st v l)) (s : state) (H3 : inv s) : inv s.","conclusion":"inv s","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint ep ev = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st : state) (v : L.t) (n : positive),\ninv st -> P v -> inv (propagate_succ st v n)) (H2 : forall (l : list positive) (st : state) (v : L.t),\ninv st -> P v -> inv (propagate_succ_list st v l)) (s : state) (H3 : inv s)","proofString":"auto."},{"statement":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint_from (start_state ep ev) = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v : L.t) (n : positive),\ninv st0 -> P v -> inv (propagate_succ st0 v n)) (H2 : forall (l : list positive) (st0 : state) (v : L.t),\ninv st0 -> P v -> inv (propagate_succ_list st0 v l)) (H3 : forall st1 st2 : state, steps st1 st2 -> inv st1 -> inv st2) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st)) : abstr_value pc st = res !! pc.","conclusion":"abstr_value pc st = res !! pc","hypotheses":"(ep : positive) (ev : L.t) (P : L.t -> Prop) (P_bot : P L.bot) (P_lub : forall x y : L.t, P x -> P y -> P (L.lub x y)) (P_transf : forall (pc0 : positive) (instr : A) (x : L.t),\ncode ! pc0 = Some instr -> P x -> P (transf pc0 x)) (P_entrypoint : P ev) (res : PMap.t L.t) (pc : positive) (H : fixpoint_from (start_state ep ev) = Some res) (inv : state -> Prop) (H0 : inv (start_state ep ev)) (H1 : forall (st0 : state) (v : L.t) (n : positive),\ninv st0 -> P v -> inv (propagate_succ st0 v n)) (H2 : forall (l : list positive) (st0 : state) (v : L.t),\ninv st0 -> P v -> inv (propagate_succ_list st0 v l)) (H3 : forall st1 st2 : state, steps st1 st2 -> inv st1 -> inv st2) (st : state) (STEPS : steps (start_state ep ev) st) (PICK : NS.pick (worklist st) = None) (RES : res = (L.bot, aval st))","proofString":"rewrite RES; auto."},{"statement":"(from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ False) : In n pred !!! s.","conclusion":"In n pred !!! s","hypotheses":"(from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ False)","proofString":"tauto."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) : In n\n  (add_successors (PTree.set a (from :: pred !!! a) pred) from tolist) !!! s.","conclusion":"In n\n  (add_successors (PTree.set a (from :: pred !!! a) pred) from tolist) !!! s","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist))","proofString":"apply IHtolist.\nunfold successors_list at 1.\nrewrite PTree.gsspec.\ndestruct (peq s a).\nsubst a.\ndestruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib.\nfold (successors_list pred s).\nintuition congruence."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) : In n (PTree.set a (from :: pred !!! a) pred) !!! s \\/ n = from /\\ In s tolist.","conclusion":"In n (PTree.set a (from :: pred !!! a) pred) !!! s \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist))","proofString":"unfold successors_list at 1.\nrewrite PTree.gsspec.\ndestruct (peq s a).\nsubst a.\ndestruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib.\nfold (successors_list pred s).\nintuition congruence."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) : In n\n  match (PTree.set a (from :: pred !!! a) pred) ! s with\n  | Some l => l\n  | None => nil\n  end \\/ n = from /\\ In s tolist.","conclusion":"In n\n  match (PTree.set a (from :: pred !!! a) pred) ! s with\n  | Some l => l\n  | None => nil\n  end \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist))","proofString":"rewrite PTree.gsspec.\ndestruct (peq s a).\nsubst a.\ndestruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib.\nfold (successors_list pred s).\nintuition congruence."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) : In n\n  match (if peq s a then Some (from :: pred !!! a) else pred ! s) with\n  | Some l => l\n  | None => nil\n  end \\/ n = from /\\ In s tolist.","conclusion":"In n\n  match (if peq s a then Some (from :: pred !!! a) else pred ! s) with\n  | Some l => l\n  | None => nil\n  end \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist))","proofString":"destruct (peq s a).\nsubst a.\ndestruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib.\nfold (successors_list pred s).\nintuition congruence."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (e : s = a) : In n (from :: pred !!! a) \\/ n = from /\\ In s tolist.","conclusion":"In n (from :: pred !!! a) \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (e : s = a)","proofString":"subst a.\ndestruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib."},{"statement":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (s = s \\/ In s tolist)) : In n (from :: pred !!! s) \\/ n = from /\\ In s tolist.","conclusion":"In n (from :: pred !!! s) \\/ n = from /\\ In s tolist","hypotheses":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (s = s \\/ In s tolist))","proofString":"destruct H.\nauto with coqlib.\ndestruct H.\nsubst n.\nauto with coqlib."},{"statement":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s) : In n (from :: pred !!! s) \\/ n = from /\\ In s tolist.","conclusion":"In n (from :: pred !!! s) \\/ n = from /\\ In s tolist","hypotheses":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s)","proofString":"auto with coqlib."},{"statement":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : n = from /\\ (s = s \\/ In s tolist)) : In n (from :: pred !!! s) \\/ n = from /\\ In s tolist.","conclusion":"In n (from :: pred !!! s) \\/ n = from /\\ In s tolist","hypotheses":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : n = from /\\ (s = s \\/ In s tolist))","proofString":"destruct H.\nsubst n.\nauto with coqlib."},{"statement":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : n = from) (H0 : s = s \\/ In s tolist) : In n (from :: pred !!! s) \\/ n = from /\\ In s tolist.","conclusion":"In n (from :: pred !!! s) \\/ n = from /\\ In s tolist","hypotheses":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n0 s0 : positive),\nIn n0 pred0 !!! s0 \\/ n0 = from0 /\\ In s0 tolist ->\nIn n0 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : n = from) (H0 : s = s \\/ In s tolist)","proofString":"subst n.\nauto with coqlib."},{"statement":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive)) (n s0 : positive),\nIn n pred0 !!! s0 \\/ n = from0 /\\ In s0 tolist ->\nIn n (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (s : positive) (H0 : s = s \\/ In s tolist) : In from (from :: pred !!! s) \\/ from = from /\\ In s tolist.","conclusion":"In from (from :: pred !!! s) \\/ from = from /\\ In s tolist","hypotheses":"(tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive)) (n s0 : positive),\nIn n pred0 !!! s0 \\/ n = from0 /\\ In s0 tolist ->\nIn n (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (s : positive) (H0 : s = s \\/ In s tolist)","proofString":"auto with coqlib."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n1 s0 : positive),\nIn n1 pred0 !!! s0 \\/ n1 = from0 /\\ In s0 tolist ->\nIn n1 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (n0 : s <> a) : In n match pred ! s with\n     | Some l => l\n     | None => nil\n     end \\/ n = from /\\ In s tolist.","conclusion":"In n match pred ! s with\n     | Some l => l\n     | None => nil\n     end \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n1 s0 : positive),\nIn n1 pred0 !!! s0 \\/ n1 = from0 /\\ In s0 tolist ->\nIn n1 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (n0 : s <> a)","proofString":"fold (successors_list pred s).\nintuition congruence."},{"statement":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n1 s0 : positive),\nIn n1 pred0 !!! s0 \\/ n1 = from0 /\\ In s0 tolist ->\nIn n1 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (n0 : s <> a) : In n pred !!! s \\/ n = from /\\ In s tolist.","conclusion":"In n pred !!! s \\/ n = from /\\ In s tolist","hypotheses":"(a : positive) (tolist : list positive) (IHtolist : forall (from0 : positive) (pred0 : PTree.t (list positive))\n  (n1 s0 : positive),\nIn n1 pred0 !!! s0 \\/ n1 = from0 /\\ In s0 tolist ->\nIn n1 (add_successors pred0 from0 tolist) !!! s0) (from : positive) (pred : PTree.t (list positive)) (n s : positive) (H : In n pred !!! s \\/ n = from /\\ (a = s \\/ In s tolist)) (n0 : s <> a)","proofString":"intuition congruence."},{"statement":"(n : positive) (instr : A) (s : positive) : code ! n = Some instr ->\nIn s (successors instr) -> In n make_predecessors !!! s.","conclusion":"code ! n = Some instr ->\nIn s (successors instr) -> In n make_predecessors !!! s","hypotheses":"(n : positive) (instr : A) (s : positive)","proofString":"set (P := fun m p => m!n = Some instr -> In s (successors instr) ->                       In n p!!!s).\nunfold make_predecessors.\napply PTree_Properties.fold_rec with (P := P); unfold P; intros.\napply H0; auto.\nrewrite H; auto.\nrewrite PTree.gempty in H; congruence.\napply add_successors_correct.\nrewrite PTree.gsspec in H2.\ndestruct (peq n k).\ninv H2.\nauto.\nauto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m m' : PTree.t A) (a : PTree.t (list positive)) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H1 : m' ! n = Some instr) (H2 : In s (successors instr)) : In n a !!! s.","conclusion":"In n a !!! s","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m m' : PTree.t A) (a : PTree.t (list positive)) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H1 : m' ! n = Some instr) (H2 : In s (successors instr))","proofString":"apply H0; auto.\nrewrite H; auto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m m' : PTree.t A) (a : PTree.t (list positive)) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H1 : m' ! n = Some instr) (H2 : In s (successors instr)) : m ! n = Some instr.","conclusion":"m ! n = Some instr","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m m' : PTree.t A) (a : PTree.t (list positive)) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H1 : m' ! n = Some instr) (H2 : In s (successors instr))","proofString":"rewrite H; auto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (H : (PTree.empty A) ! n = Some instr) (H0 : In s (successors instr)) : In n (PTree.empty (list positive)) !!! s.","conclusion":"In n (PTree.empty (list positive)) !!! s","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (H : (PTree.empty A) ! n = Some instr) (H0 : In s (successors instr))","proofString":"rewrite PTree.gempty in H; congruence."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (PTree.set k v m) ! n = Some instr) (H3 : In s (successors instr)) : In n (add_successors a k (successors v)) !!! s.","conclusion":"In n (add_successors a k (successors v)) !!! s","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (PTree.set k v m) ! n = Some instr) (H3 : In s (successors instr))","proofString":"apply add_successors_correct.\nrewrite PTree.gsspec in H2.\ndestruct (peq n k).\ninv H2.\nauto.\nauto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (PTree.set k v m) ! n = Some instr) (H3 : In s (successors instr)) : In n a !!! s \\/ n = k /\\ In s (successors v).","conclusion":"In n a !!! s \\/ n = k /\\ In s (successors v)","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (PTree.set k v m) ! n = Some instr) (H3 : In s (successors instr))","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq n k).\ninv H2.\nauto.\nauto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (if peq n k then Some v else m ! n) = Some instr) (H3 : In s (successors instr)) : In n a !!! s \\/ n = k /\\ In s (successors v).","conclusion":"In n a !!! s \\/ n = k /\\ In s (successors v)","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (H2 : (if peq n k then Some v else m ! n) = Some instr) (H3 : In s (successors instr))","proofString":"destruct (peq n k).\ninv H2.\nauto.\nauto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (e : n = k) (H2 : Some v = Some instr) (H3 : In s (successors instr)) : In n a !!! s \\/ n = k /\\ In s (successors v).","conclusion":"In n a !!! s \\/ n = k /\\ In s (successors v)","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (e : n = k) (H2 : Some v = Some instr) (H3 : In s (successors instr))","proofString":"inv H2.\nauto."},{"statement":"(instr : A) (s : positive) (k : PTree.elt) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (H : m ! k = None) (H0 : code ! k = Some instr) (H1 : m ! k = Some instr -> In s (successors instr) -> In k a !!! s) (H3 : In s (successors instr)) : In k a !!! s \\/ k = k /\\ In s (successors instr).","conclusion":"In k a !!! s \\/ k = k /\\ In s (successors instr)","hypotheses":"(instr : A) (s : positive) (k : PTree.elt) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (H : m ! k = None) (H0 : code ! k = Some instr) (H1 : m ! k = Some instr -> In s (successors instr) -> In k a !!! s) (H3 : In s (successors instr))","proofString":"auto."},{"statement":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (n0 : n <> k) (H2 : m ! n = Some instr) (H3 : In s (successors instr)) : In n a !!! s \\/ n = k /\\ In s (successors v).","conclusion":"In n a !!! s \\/ n = k /\\ In s (successors v)","hypotheses":"(n : positive) (instr : A) (s : positive) (P : PTree.tree A -> PTree.t (list positive) -> Prop) (m : PTree.t A) (a : PTree.t (list positive)) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In s (successors instr) -> In n a !!! s) (n0 : n <> k) (H2 : m ! n = Some instr) (H3 : In s (successors instr))","proofString":"auto."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : exists l : list positive, make_predecessors ! s = Some l /\\ In n l.","conclusion":"exists l : list positive, make_predecessors ! s = Some l /\\ In n l","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"exploit make_predecessors_correct_1; eauto.\nunfold successors_list.\ndestruct (make_predecessors!s); simpl; intros.\nexists l; auto.\ncontradiction."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : In n make_predecessors !!! s ->\nexists l : list positive, make_predecessors ! s = Some l /\\ In n l.","conclusion":"In n make_predecessors !!! s ->\nexists l : list positive, make_predecessors ! s = Some l /\\ In n l","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"unfold successors_list.\ndestruct (make_predecessors!s); simpl; intros.\nexists l; auto.\ncontradiction."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : In n match make_predecessors ! s with\n     | Some l => l\n     | None => nil\n     end ->\nexists l : list positive, make_predecessors ! s = Some l /\\ In n l.","conclusion":"In n match make_predecessors ! s with\n     | Some l => l\n     | None => nil\n     end ->\nexists l : list positive, make_predecessors ! s = Some l /\\ In n l","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"destruct (make_predecessors!s); simpl; intros.\nexists l; auto.\ncontradiction."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) (l : list positive) (H1 : In n l) : exists l0 : list positive, Some l = Some l0 /\\ In n l0.","conclusion":"exists l0 : list positive, Some l = Some l0 /\\ In n l0","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) (l : list positive) (H1 : In n l)","proofString":"exists l; auto."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) (H1 : False) : exists l : list positive, None = Some l /\\ In n l.","conclusion":"exists l : list positive, None = Some l /\\ In n l","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) (H1 : False)","proofString":"contradiction."},{"statement":"(n : positive) : reachable make_predecessors (fun l : list positive => l) n n.","conclusion":"reachable make_predecessors (fun l : list positive => l) n n","hypotheses":"(n : positive)","proofString":"constructor."},{"statement":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l : list positive => l) n3 n2) : reachable make_predecessors (fun l : list positive => l) n3 n1.","conclusion":"reachable make_predecessors (fun l : list positive => l) n3 n1","hypotheses":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l : list positive => l) n3 n2)","proofString":"exploit make_predecessors_correct_2; eauto.\nintros [l [P Q]].\neapply reachable_right; eauto."},{"statement":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l : list positive => l) n3 n2) : (exists l : list positive, make_predecessors ! n2 = Some l /\\ In n1 l) ->\nreachable make_predecessors (fun l : list positive => l) n3 n1.","conclusion":"(exists l : list positive, make_predecessors ! n2 = Some l /\\ In n1 l) ->\nreachable make_predecessors (fun l : list positive => l) n3 n1","hypotheses":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l : list positive => l) n3 n2)","proofString":"intros [l [P Q]].\neapply reachable_right; eauto."},{"statement":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l0 : list positive => l0) n3 n2) (l : list positive) (P : make_predecessors ! n2 = Some l) (Q : In n1 l) : reachable make_predecessors (fun l0 : list positive => l0) n3 n1.","conclusion":"reachable make_predecessors (fun l0 : list positive => l0) n3 n1","hypotheses":"(n1 n2 n3 : positive) (i : A) (e : code ! n1 = Some i) (i0 : In n2 (successors i)) (H : reachable code successors n2 n3) (IHreachable : reachable make_predecessors (fun l0 : list positive => l0) n3 n2) (l : list positive) (P : make_predecessors ! n2 = Some l) (Q : In n1 l)","proofString":"eapply reachable_right; eauto."},{"statement":"(n : positive) : NS.In n exit_points <->\n(exists i : A, code ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n exit_points <->\n(exists i : A, code ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"unfold exit_points.\neapply PTree_Properties.fold_rec.\nintros.\nrewrite <- H.\nauto.\nsimpl.\nsplit; intros.\neelim NS.empty_spec; eauto.\ndestruct H as [i [P Q]].\nrewrite PTree.gempty in P.\ncongruence.\nintros.\ndestruct (sequential_node k v) eqn:SN.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto.\nrewrite NS.add_spec.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) : NS.In n\n  (PTree.fold\n     (fun (ep : NS.t) (pc : positive) (instr : A) =>\n      if sequential_node pc instr then ep else NS.add pc ep) code NS.empty) <->\n(exists i : A, code ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n\n  (PTree.fold\n     (fun (ep : NS.t) (pc : positive) (instr : A) =>\n      if sequential_node pc instr then ep else NS.add pc ep) code NS.empty) <->\n(exists i : A, code ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"eapply PTree_Properties.fold_rec.\nintros.\nrewrite <- H.\nauto.\nsimpl.\nsplit; intros.\neelim NS.empty_spec; eauto.\ndestruct H as [i [P Q]].\nrewrite PTree.gempty in P.\ncongruence.\nintros.\ndestruct (sequential_node k v) eqn:SN.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto.\nrewrite NS.add_spec.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) : forall (m m' : PTree.t A) (a : NS.t),\n(forall x : PTree.elt, m ! x = m' ! x) ->\nNS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nNS.In n a <-> (exists i : A, m' ! n = Some i /\\ sequential_node n i = false).","conclusion":"forall (m m' : PTree.t A) (a : NS.t),\n(forall x : PTree.elt, m ! x = m' ! x) ->\nNS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nNS.In n a <-> (exists i : A, m' ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"intros.\nrewrite <- H.\nauto."},{"statement":"(n : positive) (m m' : PTree.t A) (a : NS.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) : NS.In n a <-> (exists i : A, m' ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n a <-> (exists i : A, m' ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m m' : PTree.t A) (a : NS.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false))","proofString":"rewrite <- H.\nauto."},{"statement":"(n : positive) (m m' : PTree.t A) (a : NS.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m m' : PTree.t A) (a : NS.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false))","proofString":"auto."},{"statement":"(n : positive) : NS.In n NS.empty <->\n(exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n NS.empty <->\n(exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"simpl.\nsplit; intros.\neelim NS.empty_spec; eauto.\ndestruct H as [i [P Q]].\nrewrite PTree.gempty in P.\ncongruence."},{"statement":"(n : positive) : NS.In n NS.empty <->\n(exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n NS.empty <->\n(exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"split; intros.\neelim NS.empty_spec; eauto.\ndestruct H as [i [P Q]].\nrewrite PTree.gempty in P.\ncongruence."},{"statement":"(n : positive) (H : NS.In n NS.empty) : exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false.","conclusion":"exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false","hypotheses":"(n : positive) (H : NS.In n NS.empty)","proofString":"eelim NS.empty_spec; eauto."},{"statement":"(n : positive) (H : exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false) : NS.In n NS.empty.","conclusion":"NS.In n NS.empty","hypotheses":"(n : positive) (H : exists i : A, (PTree.empty A) ! n = Some i /\\ sequential_node n i = false)","proofString":"destruct H as [i [P Q]].\nrewrite PTree.gempty in P.\ncongruence."},{"statement":"(n : positive) (i : A) (P : (PTree.empty A) ! n = Some i) (Q : sequential_node n i = false) : NS.In n NS.empty.","conclusion":"NS.In n NS.empty","hypotheses":"(n : positive) (i : A) (P : (PTree.empty A) ! n = Some i) (Q : sequential_node n i = false)","proofString":"rewrite PTree.gempty in P.\ncongruence."},{"statement":"(n : positive) (i : A) (P : None = Some i) (Q : sequential_node n i = false) : NS.In n NS.empty.","conclusion":"NS.In n NS.empty","hypotheses":"(n : positive) (i : A) (P : None = Some i) (Q : sequential_node n i = false)","proofString":"congruence."},{"statement":"(n : positive) : forall (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A),\nm ! k = None ->\ncode ! k = Some v ->\nNS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nNS.In n (if sequential_node k v then a else NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"forall (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A),\nm ! k = None ->\ncode ! k = Some v ->\nNS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nNS.In n (if sequential_node k v then a else NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive)","proofString":"intros.\ndestruct (sequential_node k v) eqn:SN.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto.\nrewrite NS.add_spec.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) : NS.In n (if sequential_node k v then a else NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n (if sequential_node k v then a else NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false))","proofString":"destruct (sequential_node k v) eqn:SN.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto.\nrewrite NS.add_spec.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) : NS.In n a <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n a <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true)","proofString":"rewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) : (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"(exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true)","proofString":"rewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) : (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A,\n   (if peq n k then Some v else m ! n) = Some i /\\\n   sequential_node n i = false).","conclusion":"(exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A,\n   (if peq n k then Some v else m ! n) = Some i /\\\n   sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true)","proofString":"destruct (peq n k).\nsubst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence.\ntauto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) (e : n = k) : (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node n i = false).","conclusion":"(exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) (e : n = k)","proofString":"subst.\nsplit; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = true) : (exists i : A, m ! k = Some i /\\ sequential_node k i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node k i = false).","conclusion":"(exists i : A, m ! k = Some i /\\ sequential_node k i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node k i = false)","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = true)","proofString":"split; intros [i [P Q]].\ncongruence.\ninv P.\ncongruence."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k v = true) (i : A) (P : m ! k = Some i) (Q : sequential_node k i = false) : exists i0 : A, Some v = Some i0 /\\ sequential_node k i0 = false.","conclusion":"exists i0 : A, Some v = Some i0 /\\ sequential_node k i0 = false","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k v = true) (i : A) (P : m ! k = Some i) (Q : sequential_node k i = false)","proofString":"congruence."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k v = true) (i : A) (P : Some v = Some i) (Q : sequential_node k i = false) : exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false.","conclusion":"exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k v = true) (i : A) (P : Some v = Some i) (Q : sequential_node k i = false)","proofString":"inv P.\ncongruence."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (H : m ! k = None) (i : A) (H0 : code ! k = Some i) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k i = true) (Q : sequential_node k i = false) : exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false.","conclusion":"exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (H : m ! k = None) (i : A) (H0 : code ! k = Some i) (H1 : NS.In k a <->\n(exists i0 : A, m ! k = Some i0 /\\ sequential_node k i0 = false)) (SN : sequential_node k i = true) (Q : sequential_node k i = false)","proofString":"congruence."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) (n0 : n <> k) : (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, m ! n = Some i /\\ sequential_node n i = false).","conclusion":"(exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, m ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = true) (n0 : n <> k)","proofString":"tauto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) : NS.In n (NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"NS.In n (NS.add k a) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false)","proofString":"rewrite NS.add_spec.\nrewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) : k = n \\/ NS.In n a <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"k = n \\/ NS.In n a <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false)","proofString":"rewrite H1.\nrewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) : k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false).","conclusion":"k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, (PTree.set k v m) ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false)","proofString":"rewrite PTree.gsspec.\ndestruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) : k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A,\n   (if peq n k then Some v else m ! n) = Some i /\\\n   sequential_node n i = false).","conclusion":"k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A,\n   (if peq n k then Some v else m ! n) = Some i /\\\n   sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false)","proofString":"destruct (peq n k).\nsubst.\nsplit.\nintros.\nexists v; auto.\nauto.\nsplit.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (e : n = k) : k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node n i = false).","conclusion":"k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (e : n = k)","proofString":"subst.\nsplit.\nintros.\nexists v; auto.\nauto."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false) : k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node k i = false).","conclusion":"k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false) <->\n(exists i : A, Some v = Some i /\\ sequential_node k i = false)","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false)","proofString":"split.\nintros.\nexists v; auto.\nauto."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false) : k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false) ->\nexists i : A, Some v = Some i /\\ sequential_node k i = false.","conclusion":"k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false) ->\nexists i : A, Some v = Some i /\\ sequential_node k i = false","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false)","proofString":"intros.\nexists v; auto."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false) (H2 : k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) : exists i : A, Some v = Some i /\\ sequential_node k i = false.","conclusion":"exists i : A, Some v = Some i /\\ sequential_node k i = false","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false) (H2 : k = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false))","proofString":"exists v; auto."},{"statement":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false) : (exists i : A, Some v = Some i /\\ sequential_node k i = false) ->\nk = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false).","conclusion":"(exists i : A, Some v = Some i /\\ sequential_node k i = false) ->\nk = k \\/ (exists i : A, m ! k = Some i /\\ sequential_node k i = false)","hypotheses":"(m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In k a <-> (exists i : A, m ! k = Some i /\\ sequential_node k i = false)) (SN : sequential_node k v = false)","proofString":"auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k) : k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, m ! n = Some i /\\ sequential_node n i = false).","conclusion":"k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) <->\n(exists i : A, m ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k)","proofString":"split.\nintros [P | [i [P Q]]].\ncongruence.\nexists i; auto.\nintros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k) : k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nexists i : A, m ! n = Some i /\\ sequential_node n i = false.","conclusion":"k = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nexists i : A, m ! n = Some i /\\ sequential_node n i = false","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k)","proofString":"intros [P | [i [P Q]]].\ncongruence.\nexists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k) (P : k = n) : exists i : A, m ! n = Some i /\\ sequential_node n i = false.","conclusion":"exists i : A, m ! n = Some i /\\ sequential_node n i = false","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k) (P : k = n)","proofString":"congruence."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <->\n(exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false)) (SN : sequential_node k v = false) (n0 : n <> k) (i : A) (P : m ! n = Some i) (Q : sequential_node n i = false) : exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false.","conclusion":"exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <->\n(exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false)) (SN : sequential_node k v = false) (n0 : n <> k) (i : A) (P : m ! n = Some i) (Q : sequential_node n i = false)","proofString":"exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k) : (exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nk = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false).","conclusion":"(exists i : A, m ! n = Some i /\\ sequential_node n i = false) ->\nk = n \\/ (exists i : A, m ! n = Some i /\\ sequential_node n i = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <-> (exists i : A, m ! n = Some i /\\ sequential_node n i = false)) (SN : sequential_node k v = false) (n0 : n <> k)","proofString":"intros [i [P Q]].\nright; exists i; auto."},{"statement":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <->\n(exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false)) (SN : sequential_node k v = false) (n0 : n <> k) (i : A) (P : m ! n = Some i) (Q : sequential_node n i = false) : k = n \\/ (exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false).","conclusion":"k = n \\/ (exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false)","hypotheses":"(n : positive) (m : PTree.t A) (a : NS.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : NS.In n a <->\n(exists i0 : A, m ! n = Some i0 /\\ sequential_node n i0 = false)) (SN : sequential_node k v = false) (n0 : n <> k) (i : A) (P : m ! n = Some i) (Q : sequential_node n i = false)","proofString":"right; exists i; auto."},{"statement":"(pc0 : positive) : forall i : A,\ncode ! pc0 = Some i ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors pc0 x.","conclusion":"forall i : A,\ncode ! pc0 = Some i ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors pc0 x","hypotheses":"(pc0 : positive)","proofString":"pattern pc0.\napply (well_founded_ind Plt_wf).\nintros pc HR i CODE.\ndestruct (sequential_node pc i) eqn:SN.\nunfold sequential_node in SN.\nrewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto.\nexists pc; split.\nrewrite exit_points_charact.\nexists i; auto.\nconstructor."},{"statement":"(pc0 : positive) : (fun p : positive =>\n forall i : A,\n code ! p = Some i ->\n exists x : positive, NS.In x exit_points /\\ reachable code successors p x)\n  pc0.","conclusion":"(fun p : positive =>\n forall i : A,\n code ! p = Some i ->\n exists x : positive, NS.In x exit_points /\\ reachable code successors p x)\n  pc0","hypotheses":"(pc0 : positive)","proofString":"apply (well_founded_ind Plt_wf).\nintros pc HR i CODE.\ndestruct (sequential_node pc i) eqn:SN.\nunfold sequential_node in SN.\nrewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto.\nexists pc; split.\nrewrite exit_points_charact.\nexists i; auto.\nconstructor."},{"statement":"(pc0 : positive) : forall x : positive,\n(forall y : positive,\n Plt y x ->\n forall i : A,\n code ! y = Some i ->\n exists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) ->\nforall i : A,\ncode ! x = Some i ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors x x0.","conclusion":"forall x : positive,\n(forall y : positive,\n Plt y x ->\n forall i : A,\n code ! y = Some i ->\n exists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) ->\nforall i : A,\ncode ! x = Some i ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors x x0","hypotheses":"(pc0 : positive)","proofString":"intros pc HR i CODE.\ndestruct (sequential_node pc i) eqn:SN.\nunfold sequential_node in SN.\nrewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto.\nexists pc; split.\nrewrite exit_points_charact.\nexists i; auto.\nconstructor."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) : exists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"exists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i)","proofString":"destruct (sequential_node pc i) eqn:SN.\nunfold sequential_node in SN.\nrewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto.\nexists pc; split.\nrewrite exit_points_charact.\nexists i; auto.\nconstructor."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = true) : exists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"exists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = true)","proofString":"unfold sequential_node in SN.\nrewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : existsb\n  (fun s : positive =>\n   match code ! s with\n   | Some _ => plt s pc\n   | None => false\n   end) (successors i) = true) : exists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"exists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : existsb\n  (fun s : positive =>\n   match code ! s with\n   | Some _ => plt s pc\n   | None => false\n   end) (successors i) = true)","proofString":"rewrite existsb_exists in SN.\ndestruct SN as [s [P Q]].\ndestruct (code!s) as [i'|] eqn:CS; try discriminate.\nInvBooleans.\nexploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) : exists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"exists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc)","proofString":"exploit (HR s); eauto.\nintros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) : (exists x : positive, NS.In x exit_points /\\ reachable code successors s x) ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"(exists x : positive, NS.In x exit_points /\\ reachable code successors s x) ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc)","proofString":"intros [x [U V]].\nexists x; split; auto.\neapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) (x : positive) (U : NS.In x exit_points) (V : reachable code successors s x) : exists x0 : positive, NS.In x0 exit_points /\\ reachable code successors pc x0.","conclusion":"exists x0 : positive, NS.In x0 exit_points /\\ reachable code successors pc x0","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) (x : positive) (U : NS.In x exit_points) (V : reachable code successors s x)","proofString":"exists x; split; auto.\neapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) (x : positive) (U : NS.In x exit_points) (V : reachable code successors s x) : reachable code successors pc x.","conclusion":"reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x0 : positive, NS.In x0 exit_points /\\ reachable code successors y x0) (i : A) (CODE : code ! pc = Some i) (s : positive) (P : In s (successors i)) (i' : A) (CS : code ! s = Some i') (H : Plt s pc) (x : positive) (U : NS.In x exit_points) (V : reachable code successors s x)","proofString":"eapply reachable_left; eauto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false) : exists x : positive, NS.In x exit_points /\\ reachable code successors pc x.","conclusion":"exists x : positive, NS.In x exit_points /\\ reachable code successors pc x","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false)","proofString":"exists pc; split.\nrewrite exit_points_charact.\nexists i; auto.\nconstructor."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false) : NS.In pc exit_points.","conclusion":"NS.In pc exit_points","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false)","proofString":"rewrite exit_points_charact.\nexists i; auto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false) : exists i0 : A, code ! pc = Some i0 /\\ sequential_node pc i0 = false.","conclusion":"exists i0 : A, code ! pc = Some i0 /\\ sequential_node pc i0 = false","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false)","proofString":"exists i; auto."},{"statement":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false) : reachable code successors pc pc.","conclusion":"reachable code successors pc pc","hypotheses":"(pc0 pc : positive) (HR : forall y : positive,\nPlt y pc ->\nforall i0 : A,\ncode ! y = Some i0 ->\nexists x : positive, NS.In x exit_points /\\ reachable code successors y x) (i : A) (CODE : code ! pc = Some i) (SN : sequential_node pc i = false)","proofString":"constructor."},{"statement":"(pc : positive) (i : A) (H : code ! pc = Some i) : exists x : positive,\n  NS.In x exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x pc.","conclusion":"exists x : positive,\n  NS.In x exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x pc","hypotheses":"(pc : positive) (i : A) (H : code ! pc = Some i)","proofString":"exploit reachable_exit_points; eauto.\nintros [x [P Q]].\nexists x; split; auto.\napply reachable_predecessors.\nauto."},{"statement":"(pc : positive) (i : A) (H : code ! pc = Some i) : (exists x : positive, NS.In x exit_points /\\ reachable code successors pc x) ->\nexists x : positive,\n  NS.In x exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x pc.","conclusion":"(exists x : positive, NS.In x exit_points /\\ reachable code successors pc x) ->\nexists x : positive,\n  NS.In x exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x pc","hypotheses":"(pc : positive) (i : A) (H : code ! pc = Some i)","proofString":"intros [x [P Q]].\nexists x; split; auto.\napply reachable_predecessors.\nauto."},{"statement":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x) : exists x0 : positive,\n  NS.In x0 exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x0 pc.","conclusion":"exists x0 : positive,\n  NS.In x0 exit_points /\\\n  reachable (make_predecessors code successors) (fun l : list positive => l)\n    x0 pc","hypotheses":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x)","proofString":"exists x; split; auto.\napply reachable_predecessors.\nauto."},{"statement":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x) : reachable (make_predecessors code successors) (fun l : list positive => l) x\n  pc.","conclusion":"reachable (make_predecessors code successors) (fun l : list positive => l) x\n  pc","hypotheses":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x)","proofString":"apply reachable_predecessors.\nauto."},{"statement":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x) : reachable code successors pc x.","conclusion":"reachable code successors pc x","hypotheses":"(pc : positive) (i : A) (H : code ! pc = Some i) (x : positive) (P : NS.In x exit_points) (Q : reachable code successors pc x)","proofString":"auto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot)","proofString":"exploit (make_predecessors_correct_2 code); eauto.\nintros [l [P Q]].\ndestruct code!s as [instr'|] eqn:CS.\nexploit reachable_exit_points_predecessor.\neexact CS.\nintros (ep & U & V).\nunfold fixpoint in H.\neapply DS.fixpoint_nodeset_solution; eauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) : (exists l : list positive,\n   (make_predecessors code successors) ! s = Some l /\\ In n l) ->\nL.ge res !! n (transf s res !! s).","conclusion":"(exists l : list positive,\n   (make_predecessors code successors) ! s = Some l /\\ In n l) ->\nL.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot)","proofString":"intros [l [P Q]].\ndestruct code!s as [instr'|] eqn:CS.\nexploit reachable_exit_points_predecessor.\neexact CS.\nintros (ep & U & V).\nunfold fixpoint in H.\neapply DS.fixpoint_nodeset_solution; eauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l)","proofString":"destruct code!s as [instr'|] eqn:CS.\nexploit reachable_exit_points_predecessor.\neexact CS.\nintros (ep & U & V).\nunfold fixpoint in H.\neapply DS.fixpoint_nodeset_solution; eauto.\napply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr') : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr')","proofString":"exploit reachable_exit_points_predecessor.\neexact CS.\nintros (ep & U & V).\nunfold fixpoint in H.\neapply DS.fixpoint_nodeset_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr') (ep : positive) (U : NS.In ep exit_points) (V : reachable (make_predecessors code successors) (fun l0 : list positive => l0)\n  ep s) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr') (ep : positive) (U : NS.In ep exit_points) (V : reachable (make_predecessors code successors) (fun l0 : list positive => l0)\n  ep s)","proofString":"unfold fixpoint in H.\neapply DS.fixpoint_nodeset_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : DS.fixpoint_nodeset (make_predecessors code successors)\n  (fun l0 : list positive => l0) transf exit_points = \nSome res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr') (ep : positive) (U : NS.In ep exit_points) (V : reachable (make_predecessors code successors) (fun l0 : list positive => l0)\n  ep s) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : DS.fixpoint_nodeset (make_predecessors code successors)\n  (fun l0 : list positive => l0) transf exit_points = \nSome res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (instr' : A) (CS : code ! s = Some instr') (ep : positive) (U : NS.In ep exit_points) (V : reachable (make_predecessors code successors) (fun l0 : list positive => l0)\n  ep s)","proofString":"eapply DS.fixpoint_nodeset_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None)","proofString":"apply L.ge_trans with L.bot.\napply L.ge_bot.\napply L.ge_refl.\napply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None) : L.ge res !! n L.bot.","conclusion":"L.ge res !! n L.bot","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None)","proofString":"apply L.ge_bot."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None) : L.ge L.bot (transf s res !! s).","conclusion":"L.ge L.bot (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None)","proofString":"apply L.ge_refl.\napply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None) : L.eq L.bot (transf s res !! s).","conclusion":"L.eq L.bot (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None)","proofString":"apply L.eq_sym.\nauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None) : L.eq (transf s res !! s) L.bot.","conclusion":"L.eq (transf s res !! s) L.bot","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : forall (n0 : positive) (a : L.t),\ncode ! n0 = None -> L.eq (transf n0 a) L.bot) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) (CS : code ! s = None)","proofString":"auto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"exploit (make_predecessors_correct_2 code); eauto.\nintros [l [P Q]].\nunfold fixpoint_allnodes in H.\neapply DS.fixpoint_allnodes_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : (exists l : list positive,\n   (make_predecessors code successors) ! s = Some l /\\ In n l) ->\nL.ge res !! n (transf s res !! s).","conclusion":"(exists l : list positive,\n   (make_predecessors code successors) ! s = Some l /\\ In n l) ->\nL.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"intros [l [P Q]].\nunfold fixpoint_allnodes in H.\neapply DS.fixpoint_allnodes_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : fixpoint_allnodes = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l)","proofString":"unfold fixpoint_allnodes in H.\neapply DS.fixpoint_allnodes_solution; eauto."},{"statement":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : DS.fixpoint_allnodes (make_predecessors code successors)\n  (fun l0 : list positive => l0) transf = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l) : L.ge res !! n (transf s res !! s).","conclusion":"L.ge res !! n (transf s res !! s)","hypotheses":"(res : PMap.t DS.L.t) (n : positive) (instr : A) (s : positive) (H : DS.fixpoint_allnodes (make_predecessors code successors)\n  (fun l0 : list positive => l0) transf = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (l : list positive) (P : (make_predecessors code successors) ! s = Some l) (Q : In n l)","proofString":"eapply DS.fixpoint_allnodes_solution; eauto."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : In n predecessors !!! s.","conclusion":"In n predecessors !!! s","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"unfold predecessors.\neapply make_predecessors_correct_1; eauto."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : In n (make_predecessors code successors) !!! s.","conclusion":"In n (make_predecessors code successors) !!! s","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"eapply make_predecessors_correct_1; eauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) : basic_block_map s = true.","conclusion":"basic_block_map s = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2)","proofString":"assert (In n1 predecessors!!!s).\neapply predecessors_correct; eauto.\nassert (In n2 predecessors!!!s).\neapply predecessors_correct; eauto.\nunfold basic_block_map, is_basic_block_head.\ndestruct (peq s entrypoint).\nauto.\nfold predecessors.\ndestruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) : In n1 predecessors !!! s.","conclusion":"In n1 predecessors !!! s","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2)","proofString":"eapply predecessors_correct; eauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) : basic_block_map s = true.","conclusion":"basic_block_map s = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s)","proofString":"assert (In n2 predecessors!!!s).\neapply predecessors_correct; eauto.\nunfold basic_block_map, is_basic_block_head.\ndestruct (peq s entrypoint).\nauto.\nfold predecessors.\ndestruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) : In n2 predecessors !!! s.","conclusion":"In n2 predecessors !!! s","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s)","proofString":"eapply predecessors_correct; eauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) : basic_block_map s = true.","conclusion":"basic_block_map s = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s)","proofString":"unfold basic_block_map, is_basic_block_head.\ndestruct (peq s entrypoint).\nauto.\nfold predecessors.\ndestruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) : (if peq s entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! s with\n  | nil => false\n  | s0 :: nil => peq s0 s\n  | s0 :: _ :: _ => true\n  end) = true.","conclusion":"(if peq s entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! s with\n  | nil => false\n  | s0 :: nil => peq s0 s\n  | s0 :: _ :: _ => true\n  end) = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s)","proofString":"destruct (peq s entrypoint).\nauto.\nfold predecessors.\ndestruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (e : s = entrypoint) : true = true.","conclusion":"true = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (e : s = entrypoint)","proofString":"auto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (n : s <> entrypoint) : match (make_predecessors code successors) !!! s with\n| nil => false\n| s0 :: nil => peq s0 s\n| s0 :: _ :: _ => true\nend = true.","conclusion":"match (make_predecessors code successors) !!! s with\n| nil => false\n| s0 :: nil => peq s0 s\n| s0 :: _ :: _ => true\nend = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (n : s <> entrypoint)","proofString":"fold predecessors.\ndestruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (n : s <> entrypoint) : match predecessors !!! s with\n| nil => false\n| s0 :: nil => peq s0 s\n| s0 :: _ :: _ => true\nend = true.","conclusion":"match predecessors !!! s with\n| nil => false\n| s0 :: nil => peq s0 s\n| s0 :: _ :: _ => true\nend = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 predecessors !!! s) (H5 : In n2 predecessors !!! s) (n : s <> entrypoint)","proofString":"destruct (predecessors!!!s).\nauto.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in *.\nintuition congruence.\nauto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 nil) (H5 : In n2 nil) (n : s <> entrypoint) : false = true.","conclusion":"false = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (H4 : In n1 nil) (H5 : In n2 nil) (n : s <> entrypoint)","proofString":"auto."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p : positive) (H4 : In n1 (p :: nil)) (H5 : In n2 (p :: nil)) (n : s <> entrypoint) : p = s.","conclusion":"p = s","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p : positive) (H4 : In n1 (p :: nil)) (H5 : In n2 (p :: nil)) (n : s <> entrypoint)","proofString":"simpl in *.\nintuition congruence."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p : positive) (H4 : p = n1 \\/ False) (H5 : p = n2 \\/ False) (n : s <> entrypoint) : p = s.","conclusion":"p = s","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p : positive) (H4 : p = n1 \\/ False) (H5 : p = n2 \\/ False) (n : s <> entrypoint)","proofString":"intuition congruence."},{"statement":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p p0 : positive) (l : list positive) (H4 : In n1 (p :: p0 :: l)) (H5 : In n2 (p :: p0 :: l)) (n : s <> entrypoint) : true = true.","conclusion":"true = true","hypotheses":"(s n1 : positive) (instr1 : A) (n2 : positive) (instr2 : A) (H : code ! n1 = Some instr1) (H0 : In s (successors instr1)) (H1 : code ! n2 = Some instr2) (H2 : In s (successors instr2)) (H3 : n1 <> n2) (p p0 : positive) (l : list positive) (H4 : In n1 (p :: p0 :: l)) (H5 : In n2 (p :: p0 :: l)) (n : s <> entrypoint)","proofString":"auto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) : basic_block_map n = true.","conclusion":"basic_block_map n = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr))","proofString":"unfold basic_block_map, is_basic_block_head.\ndestruct (peq n entrypoint).\nauto.\nfold predecessors.\nexploit predecessors_correct; eauto.\nintros.\ndestruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) : (if peq n entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! n with\n  | nil => false\n  | s :: nil => peq s n\n  | s :: _ :: _ => true\n  end) = true.","conclusion":"(if peq n entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! n with\n  | nil => false\n  | s :: nil => peq s n\n  | s :: _ :: _ => true\n  end) = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr))","proofString":"destruct (peq n entrypoint).\nauto.\nfold predecessors.\nexploit predecessors_correct; eauto.\nintros.\ndestruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (e : n = entrypoint) : true = true.","conclusion":"true = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (e : n = entrypoint)","proofString":"auto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) : match (make_predecessors code successors) !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true.","conclusion":"match (make_predecessors code successors) !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint)","proofString":"fold predecessors.\nexploit predecessors_correct; eauto.\nintros.\ndestruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) : match predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true.","conclusion":"match predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint)","proofString":"exploit predecessors_correct; eauto.\nintros.\ndestruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) : In n predecessors !!! n ->\nmatch predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true.","conclusion":"In n predecessors !!! n ->\nmatch predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint)","proofString":"intros.\ndestruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (H1 : In n predecessors !!! n) : match predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true.","conclusion":"match predecessors !!! n with\n| nil => false\n| s :: nil => peq s n\n| s :: _ :: _ => true\nend = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (H1 : In n predecessors !!! n)","proofString":"destruct (predecessors!!!n).\ncontradiction.\ndestruct l.\napply proj_sumbool_is_true.\nsimpl in H1.\ntauto.\nauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (H1 : In n nil) : false = true.","conclusion":"false = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (H1 : In n nil)","proofString":"contradiction."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p : positive) (H1 : In n (p :: nil)) : p = n.","conclusion":"p = n","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p : positive) (H1 : In n (p :: nil))","proofString":"simpl in H1.\ntauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p : positive) (H1 : p = n \\/ False) : p = n.","conclusion":"p = n","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p : positive) (H1 : p = n \\/ False)","proofString":"tauto."},{"statement":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p p0 : positive) (l : list positive) (H1 : In n (p :: p0 :: l)) : true = true.","conclusion":"true = true","hypotheses":"(n : positive) (instr : A) (H : code ! n = Some instr) (H0 : In n (successors instr)) (n0 : n <> entrypoint) (p p0 : positive) (l : list positive) (H1 : In n (p :: p0 :: l))","proofString":"auto."},{"statement":"(bb : bbmap) (l : L.t) (st : state) : incl (worklist st) (worklist st).","conclusion":"incl (worklist st) (worklist st)","hypotheses":"(bb : bbmap) (l : L.t) (st : state)","proofString":"apply incl_refl."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (worklist st)\n  (worklist\n     (if bb a\n      then propagate_successors bb succs l st\n      else\n       propagate_successors bb succs l\n         {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})).","conclusion":"incl (worklist st)\n  (worklist\n     (if bb a\n      then propagate_successors bb succs l st\n      else\n       propagate_successors bb succs l\n         {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"case (bb a).\nauto.\napply incl_tran with (a :: worklist st).\napply incl_tl.\napply incl_refl.\nset (st1 := (mkstate (PMap.set a l (aval st)) (a :: worklist st))).\nchange (a :: worklist st) with (worklist st1).\nauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (worklist st) (worklist (propagate_successors bb succs l st)).","conclusion":"incl (worklist st) (worklist (propagate_successors bb succs l st))","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"auto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (worklist st)\n  (worklist\n     (propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})).","conclusion":"incl (worklist st)\n  (worklist\n     (propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"apply incl_tran with (a :: worklist st).\napply incl_tl.\napply incl_refl.\nset (st1 := (mkstate (PMap.set a l (aval st)) (a :: worklist st))).\nchange (a :: worklist st) with (worklist st1).\nauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (worklist st) (a :: worklist st).","conclusion":"incl (worklist st) (a :: worklist st)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"apply incl_tl.\napply incl_refl."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (worklist st) (worklist st).","conclusion":"incl (worklist st) (worklist st)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"apply incl_refl."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) : incl (a :: worklist st)\n  (worklist\n     (propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})).","conclusion":"incl (a :: worklist st)\n  (worklist\n     (propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state)","proofString":"set (st1 := (mkstate (PMap.set a l (aval st)) (a :: worklist st))).\nchange (a :: worklist st) with (worklist st1).\nauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) (st1 : state) : incl (worklist st1) (worklist (propagate_successors bb succs l st1)).","conclusion":"incl (worklist st1) (worklist (propagate_successors bb succs l st1))","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state),\nincl (worklist st0) (worklist (propagate_successors bb succs l0 st0))) (l : L.t) (st : state) (st1 : state)","proofString":"auto."},{"statement":"(bb : bbmap) (l : L.t) (st : state) (n : positive) : (False -> bb n = false -> In n (worklist st) /\\ (aval st) !! n = l) /\\\n(~ False \\/ bb n = true -> (aval st) !! n = (aval st) !! n).","conclusion":"(False -> bb n = false -> In n (worklist st) /\\ (aval st) !! n = l) /\\\n(~ False \\/ bb n = true -> (aval st) !! n = (aval st) !! n)","hypotheses":"(bb : bbmap) (l : L.t) (st : state) (n : positive)","proofString":"split.\ntauto.\nauto."},{"statement":"(bb : bbmap) (l : L.t) (st : state) (n : positive) : False -> bb n = false -> In n (worklist st) /\\ (aval st) !! n = l.","conclusion":"False -> bb n = false -> In n (worklist st) /\\ (aval st) !! n = l","hypotheses":"(bb : bbmap) (l : L.t) (st : state) (n : positive)","proofString":"tauto."},{"statement":"(bb : bbmap) (l : L.t) (st : state) (n : positive) : ~ False \\/ bb n = true -> (aval st) !! n = (aval st) !! n.","conclusion":"~ False \\/ bb n = true -> (aval st) !! n = (aval st) !! n","hypotheses":"(bb : bbmap) (l : L.t) (st : state) (n : positive)","proofString":"auto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) : (a = n \\/ In n succs ->\n bb n = false ->\n In n\n   (worklist\n      (if bb a\n       then propagate_successors bb succs l st\n       else\n        propagate_successors bb succs l\n          {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})) /\\\n (aval\n    (if bb a\n     then propagate_successors bb succs l st\n     else\n      propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval\n    (if bb a\n     then propagate_successors bb succs l st\n     else\n      propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = (aval st) !! n).","conclusion":"(a = n \\/ In n succs ->\n bb n = false ->\n In n\n   (worklist\n      (if bb a\n       then propagate_successors bb succs l st\n       else\n        propagate_successors bb succs l\n          {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})) /\\\n (aval\n    (if bb a\n     then propagate_successors bb succs l st\n     else\n      propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval\n    (if bb a\n     then propagate_successors bb succs l st\n     else\n      propagate_successors bb succs l\n        {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = (aval st) !! n)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive)","proofString":"caseEq (bb a); intro.\nelim (IHsuccs l st n); intros U V.\nsplit; intros.\napply U; auto.\nelim H0; intro.\nsubst a.\ncongruence.\nauto.\napply V.\ntauto.\nset (st1 := mkstate (PMap.set a l (aval st)) (a :: worklist st)).\nelim (IHsuccs l st1 n); intros U V.\nsplit; intros.\nelim H0; intros.\nsubst n.\nsplit.\napply propagate_successors_charact1.\nsimpl.\ntauto.\ncase (In_dec peq a succs); intro.\nelim (U i H1); auto.\nrewrite V.\nunfold st1; simpl.\napply PMap.gss.\ntauto.\napply U; auto.\nrewrite V.\nunfold st1; simpl.\napply PMap.gso.\nred; intro; subst n.\nelim H0; intro.\ntauto.\ncongruence.\ntauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) : (a = n \\/ In n succs ->\n bb n = false ->\n In n (worklist (propagate_successors bb succs l st)) /\\\n (aval (propagate_successors bb succs l st)) !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval (propagate_successors bb succs l st)) !! n = (aval st) !! n).","conclusion":"(a = n \\/ In n succs ->\n bb n = false ->\n In n (worklist (propagate_successors bb succs l st)) /\\\n (aval (propagate_successors bb succs l st)) !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval (propagate_successors bb succs l st)) !! n = (aval st) !! n)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true)","proofString":"elim (IHsuccs l st n); intros U V.\nsplit; intros.\napply U; auto.\nelim H0; intro.\nsubst a.\ncongruence.\nauto.\napply V.\ntauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) : (a = n \\/ In n succs ->\n bb n = false ->\n In n (worklist (propagate_successors bb succs l st)) /\\\n (aval (propagate_successors bb succs l st)) !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval (propagate_successors bb succs l st)) !! n = (aval st) !! n).","conclusion":"(a = n \\/ In n succs ->\n bb n = false ->\n In n (worklist (propagate_successors bb succs l st)) /\\\n (aval (propagate_successors bb succs l st)) !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval (propagate_successors bb succs l st)) !! n = (aval st) !! n)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n)","proofString":"split; intros.\napply U; auto.\nelim H0; intro.\nsubst a.\ncongruence.\nauto.\napply V.\ntauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) : In n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l.","conclusion":"In n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false)","proofString":"apply U; auto.\nelim H0; intro.\nsubst a.\ncongruence.\nauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) : In n succs.","conclusion":"In n succs","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false)","proofString":"elim H0; intro.\nsubst a.\ncongruence.\nauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : a = n) : In n succs.","conclusion":"In n succs","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : a = n)","proofString":"subst a.\ncongruence."},{"statement":"(bb : bbmap) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb n = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : n = n \\/ In n succs) (H1 : bb n = false) : In n succs.","conclusion":"In n succs","hypotheses":"(bb : bbmap) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb n = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : n = n \\/ In n succs) (H1 : bb n = false)","proofString":"congruence."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : In n succs) : In n succs.","conclusion":"In n succs","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : In n succs)","proofString":"auto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true) : (aval (propagate_successors bb succs l st)) !! n = (aval st) !! n.","conclusion":"(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true)","proofString":"apply V.\ntauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true) : ~ In n succs \\/ bb n = true.","conclusion":"~ In n succs \\/ bb n = true","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = true) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st)) /\\\n(aval (propagate_successors bb succs l st)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st)) !! n = (aval st) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true)","proofString":"tauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) : (a = n \\/ In n succs ->\n bb n = false ->\n In n\n   (worklist\n      (propagate_successors bb succs l\n         {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})) /\\\n (aval\n    (propagate_successors bb succs l\n       {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval\n    (propagate_successors bb succs l\n       {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = (aval st) !! n).","conclusion":"(a = n \\/ In n succs ->\n bb n = false ->\n In n\n   (worklist\n      (propagate_successors bb succs l\n         {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})) /\\\n (aval\n    (propagate_successors bb succs l\n       {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = l) /\\\n(~ (a = n \\/ In n succs) \\/ bb n = true ->\n (aval\n    (propagate_successors bb succs l\n       {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}))\n !! n = (aval st) !! n)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false)","proofString":"set (st1 := mkstate (PMap.set a l (aval st)) (a :: worklist st)).\nelim (IHsuccs l st1 n); intros U V.\nsplit; intros.\nelim H0; intros.\nsubst n.\nsplit.\napply propagate_successors_charact1.\nsimpl.\ntauto.\ncase (In_dec peq a succs); intro.\nelim (U i H1); auto.\nrewrite V.\nunfold st1; simpl.\napply PMap.gss.\ntauto.\napply U; auto.\nrewrite V.\nunfold st1; simpl.\napply PMap.gso.\nred; intro; subst n.\nelim H0; intro.\ntauto.\ncongruence.\ntauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) : a = a \\/ In a (worklist st).","conclusion":"a = a \\/ In a (worklist st)","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l)","proofString":"tauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (i : In a succs) : (aval (propagate_successors bb succs l st1)) !! a = l.","conclusion":"(aval (propagate_successors bb succs l st1)) !! a = l","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (i : In a succs)","proofString":"elim (U i H1); auto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (n : ~ In a succs) : (PMap.set a l (aval st)) !! a = l.","conclusion":"(PMap.set a l (aval st)) !! a = l","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (n : ~ In a succs)","proofString":"apply PMap.gss."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (n : ~ In a succs) : ~ In a succs \\/ bb a = true.","conclusion":"~ In a succs \\/ bb a = true","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H1 : bb a = false) (H0 : a = a \\/ In a succs) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (n : ~ In a succs)","proofString":"tauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : In n succs) : In n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l.","conclusion":"In n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : a = n \\/ In n succs) (H1 : bb n = false) (H2 : In n succs)","proofString":"apply U; auto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true) : (PMap.set a l (aval st)) !! n = (aval st) !! n.","conclusion":"(PMap.set a l (aval st)) !! n = (aval st) !! n","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true)","proofString":"apply PMap.gso.\nred; intro; subst n.\nelim H0; intro.\ntauto.\ncongruence."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true) : n <> a.","conclusion":"n <> a","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true)","proofString":"red; intro; subst n.\nelim H0; intro.\ntauto.\ncongruence."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) : False.","conclusion":"False","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l)","proofString":"elim H0; intro.\ntauto.\ncongruence."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (H1 : ~ (a = a \\/ In a succs)) : False.","conclusion":"False","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (H1 : ~ (a = a \\/ In a succs))","proofString":"tauto."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (H1 : bb a = true) : False.","conclusion":"False","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n succs -> bb n = false -> In n (worklist st') /\\ (aval st') !! n = l0) /\\\n(~ In n succs \\/ bb n = true -> (aval st') !! n = (aval st0) !! n)) (l : L.t) (st : state) (H : bb a = false) (st1 : state) (H0 : ~ (a = a \\/ In a succs) \\/ bb a = true) (V : ~ In a succs \\/ bb a = true ->\n(aval (propagate_successors bb succs l st1)) !! a = (aval st1) !! a) (U : In a succs ->\nbb a = false ->\nIn a (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! a = l) (H1 : bb a = true)","proofString":"congruence."},{"statement":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true) : ~ In n succs \\/ bb n = true.","conclusion":"~ In n succs \\/ bb n = true","hypotheses":"(bb : bbmap) (a : positive) (succs : list positive) (IHsuccs : forall (l0 : L.t) (st0 : state) (n0 : positive),\nlet st' := propagate_successors bb succs l0 st0 in\n(In n0 succs ->\n bb n0 = false -> In n0 (worklist st') /\\ (aval st') !! n0 = l0) /\\\n(~ In n0 succs \\/ bb n0 = true -> (aval st') !! n0 = (aval st0) !! n0)) (l : L.t) (st : state) (n : positive) (H : bb a = false) (st1 : state) (U : In n succs ->\nbb n = false ->\nIn n (worklist (propagate_successors bb succs l st1)) /\\\n(aval (propagate_successors bb succs l st1)) !! n = l) (V : ~ In n succs \\/ bb n = true ->\n(aval (propagate_successors bb succs l st1)) !! n = (aval st1) !! n) (H0 : ~ (a = n \\/ In n succs) \\/ bb n = true)","proofString":"tauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) : code ! pc = Some instr ->\nstate_invariant {| aval := res; worklist := pc :: rem |} ->\nstate_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |}).","conclusion":"code ! pc = Some instr ->\nstate_invariant {| aval := res; worklist := pc :: rem |} ->\nstate_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |})","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive)","proofString":"intros CODE [INV1 INV2].\nsimpl in INV1.\nsimpl in INV2.\nset (l := transf pc res!!pc).\ngeneralize (propagate_successors_charact1 basic_block_map                (successors instr) l (mkstate res rem)).\ngeneralize (propagate_successors_charact2 basic_block_map                (successors instr) l (mkstate res rem)).\nset (st1 := propagate_successors basic_block_map                 (successors instr) l (mkstate res rem)).\nintros U V.\nsimpl in U.\nsplit; intros.\nelim (U n); intros C D.\nrewrite D.\nsimpl.\napply INV1.\nauto.\ntauto.\ndestruct (peq pc n).\nsubst n.\nright; intros.\nassert (instr0 = instr) by congruence.\nsubst instr0.\nelim (U s); intros C D.\nreplace (st1.(aval)!!pc) with res!!pc.\nfold l.\ndestruct (basic_block_map s) eqn:BB.\nrewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto.\nelim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge.\nelim (U pc); intros E F.\nrewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto.\nelim (INV2 n); intro.\nleft.\napply V.\nsimpl.\ntauto.\nassert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive,\nbasic_block_map n = true ->\n(aval {| aval := res; worklist := pc :: rem |}) !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n))) : state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |}).","conclusion":"state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |})","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive,\nbasic_block_map n = true ->\n(aval {| aval := res; worklist := pc :: rem |}) !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n)))","proofString":"simpl in INV1.\nsimpl in INV2.\nset (l := transf pc res!!pc).\ngeneralize (propagate_successors_charact1 basic_block_map                (successors instr) l (mkstate res rem)).\ngeneralize (propagate_successors_charact2 basic_block_map                (successors instr) l (mkstate res rem)).\nset (st1 := propagate_successors basic_block_map                 (successors instr) l (mkstate res rem)).\nintros U V.\nsimpl in U.\nsplit; intros.\nelim (U n); intros C D.\nrewrite D.\nsimpl.\napply INV1.\nauto.\ntauto.\ndestruct (peq pc n).\nsubst n.\nright; intros.\nassert (instr0 = instr) by congruence.\nsubst instr0.\nelim (U s); intros C D.\nreplace (st1.(aval)!!pc) with res!!pc.\nfold l.\ndestruct (basic_block_map s) eqn:BB.\nrewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto.\nelim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge.\nelim (U pc); intros E F.\nrewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto.\nelim (INV2 n); intro.\nleft.\napply V.\nsimpl.\ntauto.\nassert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n))) : state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |}).","conclusion":"state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |})","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n)))","proofString":"simpl in INV2.\nset (l := transf pc res!!pc).\ngeneralize (propagate_successors_charact1 basic_block_map                (successors instr) l (mkstate res rem)).\ngeneralize (propagate_successors_charact2 basic_block_map                (successors instr) l (mkstate res rem)).\nset (st1 := propagate_successors basic_block_map                 (successors instr) l (mkstate res rem)).\nintros U V.\nsimpl in U.\nsplit; intros.\nelim (U n); intros C D.\nrewrite D.\nsimpl.\napply INV1.\nauto.\ntauto.\ndestruct (peq pc n).\nsubst n.\nright; intros.\nassert (instr0 = instr) by congruence.\nsubst instr0.\nelim (U s); intros C D.\nreplace (st1.(aval)!!pc) with res!!pc.\nfold l.\ndestruct (basic_block_map s) eqn:BB.\nrewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto.\nelim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge.\nelim (U pc); intros E F.\nrewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto.\nelim (INV2 n); intro.\nleft.\napply V.\nsimpl.\ntauto.\nassert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n res !! n))) : state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |}).","conclusion":"state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc res !! pc) {| aval := res; worklist := rem |})","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n res !! n)))","proofString":"set (l := transf pc res!!pc).\ngeneralize (propagate_successors_charact1 basic_block_map                (successors instr) l (mkstate res rem)).\ngeneralize (propagate_successors_charact2 basic_block_map                (successors instr) l (mkstate res rem)).\nset (st1 := propagate_successors basic_block_map                 (successors instr) l (mkstate res rem)).\nintros U V.\nsimpl in U.\nsplit; intros.\nelim (U n); intros C D.\nrewrite D.\nsimpl.\napply INV1.\nauto.\ntauto.\ndestruct (peq pc n).\nsubst n.\nright; intros.\nassert (instr0 = instr) by congruence.\nsubst instr0.\nelim (U s); intros C D.\nreplace (st1.(aval)!!pc) with res!!pc.\nfold l.\ndestruct (basic_block_map s) eqn:BB.\nrewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto.\nelim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge.\nelim (U pc); intros E F.\nrewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto.\nelim (INV2 n); intro.\nleft.\napply V.\nsimpl.\ntauto.\nassert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) : (aval st1) !! n = L.top.","conclusion":"(aval st1) !! n = L.top","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true)","proofString":"elim (U n); intros C D.\nrewrite D.\nsimpl.\napply INV1.\nauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : (aval st1) !! n = L.top.","conclusion":"(aval st1) !! n = L.top","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"rewrite D.\nsimpl.\napply INV1.\nauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : res !! n = L.top.","conclusion":"res !! n = L.top","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"simpl.\napply INV1.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : res !! n = L.top.","conclusion":"res !! n = L.top","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"apply INV1.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : basic_block_map n = true.","conclusion":"basic_block_map n = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : ~ In n (successors instr) \\/ basic_block_map n = true.","conclusion":"~ In n (successors instr) \\/ basic_block_map n = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n0 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (H : basic_block_map n = true) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"tauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) : L.ge (aval st1) !! s l.","conclusion":"L.ge (aval st1) !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s)","proofString":"destruct (basic_block_map s) eqn:BB.\nrewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto.\nelim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : L.ge (aval st1) !! s l.","conclusion":"L.ge (aval st1) !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"rewrite D.\nsimpl.\nrewrite INV1.\napply L.top_ge.\nauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : L.ge res !! s l.","conclusion":"L.ge res !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"simpl.\nrewrite INV1.\napply L.top_ge.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : L.ge res !! s l.","conclusion":"L.ge res !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"rewrite INV1.\napply L.top_ge.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : L.ge L.top l.","conclusion":"L.ge L.top l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"apply L.top_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : basic_block_map s = true.","conclusion":"basic_block_map s = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s) : ~ In s (successors instr) \\/ true = true.","conclusion":"~ In s (successors instr) \\/ true = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = true) (C : In s (successors instr) ->\ntrue = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ true = true -> (aval st1) !! s = res !! s)","proofString":"tauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) : L.ge (aval st1) !! s l.","conclusion":"L.ge (aval st1) !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s)","proofString":"elim (C H0 (eq_refl _)).\nintros X Y.\nrewrite Y.\napply L.refl_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) : In s (worklist st1) -> (aval st1) !! s = l -> L.ge (aval st1) !! s l.","conclusion":"In s (worklist st1) -> (aval st1) !! s = l -> L.ge (aval st1) !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s)","proofString":"intros X Y.\nrewrite Y.\napply L.refl_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) (X : In s (worklist st1)) (Y : (aval st1) !! s = l) : L.ge (aval st1) !! s l.","conclusion":"L.ge (aval st1) !! s l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) (X : In s (worklist st1)) (Y : (aval st1) !! s = l)","proofString":"rewrite Y.\napply L.refl_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) (X : In s (worklist st1)) (Y : (aval st1) !! s = l) : L.ge l l.","conclusion":"L.ge l l","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (BB : basic_block_map s = false) (C : In s (successors instr) ->\nfalse = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ false = true -> (aval st1) !! s = res !! s) (X : In s (worklist st1)) (Y : (aval st1) !! s = l)","proofString":"apply L.refl_ge."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) : res !! pc = (aval st1) !! pc.","conclusion":"res !! pc = (aval st1) !! pc","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s)","proofString":"elim (U pc); intros E F.\nrewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) : res !! pc = (aval st1) !! pc.","conclusion":"res !! pc = (aval st1) !! pc","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc)","proofString":"rewrite F.\nreflexivity.\ndestruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) : res !! pc = res !! pc.","conclusion":"res !! pc = res !! pc","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc)","proofString":"reflexivity."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) : ~ In pc (successors instr) \\/ basic_block_map pc = true.","conclusion":"~ In pc (successors instr) \\/ basic_block_map pc = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc)","proofString":"destruct (In_dec peq pc (successors instr)).\nright.\neapply no_self_loop; eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (i : In pc (successors instr)) : ~ In pc (successors instr) \\/ basic_block_map pc = true.","conclusion":"~ In pc (successors instr) \\/ basic_block_map pc = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (i : In pc (successors instr))","proofString":"right.\neapply no_self_loop; eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (i : In pc (successors instr)) : basic_block_map pc = true.","conclusion":"basic_block_map pc = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))) (l : L.t) (st1 : state) (U : forall n : positive,\n(In n (successors instr) ->\n basic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) /\\\n(~ In n (successors instr) \\/ basic_block_map n = true ->\n (aval st1) !! n = res !! n)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (i : In pc (successors instr))","proofString":"eapply no_self_loop; eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (n : ~ In pc (successors instr)) : ~ In pc (successors instr) \\/ basic_block_map pc = true.","conclusion":"~ In pc (successors instr) \\/ basic_block_map pc = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (l : L.t) (st1 : state) (U : forall n0 : positive,\n(In n0 (successors instr) ->\n basic_block_map n0 = false -> In n0 (worklist st1) /\\ (aval st1) !! n0 = l) /\\\n(~ In n0 (successors instr) \\/ basic_block_map n0 = true ->\n (aval st1) !! n0 = res !! n0)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (s : positive) (H0 : In s (successors instr)) (H : code ! pc = Some instr) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (E : In pc (successors instr) ->\nbasic_block_map pc = false -> In pc (worklist st1) /\\ (aval st1) !! pc = l) (F : ~ In pc (successors instr) \\/ basic_block_map pc = true ->\n(aval st1) !! pc = res !! pc) (n : ~ In pc (successors instr))","proofString":"left; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n)","proofString":"elim (INV2 n); intro.\nleft.\napply V.\nsimpl.\ntauto.\nassert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem)","proofString":"left.\napply V.\nsimpl.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem) : In n (worklist st1).","conclusion":"In n (worklist st1)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem)","proofString":"apply V.\nsimpl.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem) : In n (worklist {| aval := res; worklist := rem |}).","conclusion":"In n (worklist {| aval := res; worklist := rem |})","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem)","proofString":"simpl.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem) : In n rem.","conclusion":"In n rem","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : pc = n \\/ In n rem)","proofString":"tauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n))","proofString":"assert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).\nintros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto.\ndestruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s.","conclusion":"forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n))","proofString":"intros.\nelim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) : (aval st1) !! s = res !! s.","conclusion":"(aval st1) !! s = res !! s","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr'))","proofString":"elim (U s); intros C D.\nrewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) : (aval st1) !! s = res !! s.","conclusion":"(aval st1) !! s = res !! s","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s)","proofString":"rewrite D.\nreflexivity.\ndestruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) : res !! s = res !! s.","conclusion":"res !! s = res !! s","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s)","proofString":"reflexivity."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) : ~ In s (successors instr) \\/ basic_block_map s = true.","conclusion":"~ In s (successors instr) \\/ basic_block_map s = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s)","proofString":"destruct (In_dec peq s (successors instr)).\nright.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.\nleft; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (i : In s (successors instr)) : ~ In s (successors instr) \\/ basic_block_map s = true.","conclusion":"~ In s (successors instr) \\/ basic_block_map s = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (i : In s (successors instr))","proofString":"right.\neapply multiple_predecessors with (n1 := pc) (n2 := n); eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (i : In s (successors instr)) : basic_block_map s = true.","conclusion":"basic_block_map s = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n1 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (i : In s (successors instr))","proofString":"eapply multiple_predecessors with (n1 := pc) (n2 := n); eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n2 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (n1 : ~ In s (successors instr)) : ~ In s (successors instr) \\/ basic_block_map s = true.","conclusion":"~ In s (successors instr) \\/ basic_block_map s = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n2 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) (s : positive) (instr' : A) (H0 : code ! n = Some instr') (H1 : In s (successors instr')) (C : In s (successors instr) ->\nbasic_block_map s = false -> In s (worklist st1) /\\ (aval st1) !! s = l) (D : ~ In s (successors instr) \\/ basic_block_map s = true ->\n(aval st1) !! s = res !! s) (n1 : ~ In s (successors instr))","proofString":"left; auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s)","proofString":"destruct (In_dec peq n (successors instr)).\ndestruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr))","proofString":"destruct (basic_block_map n) eqn:BB.\nright; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto.\nleft.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = true) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = true)","proofString":"right; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) : L.ge (aval st1) !! s (transf n (aval st1) !! n).","conclusion":"L.ge (aval st1) !! s (transf n (aval st1) !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0))","proofString":"elim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : L.ge (aval st1) !! s (transf n (aval st1) !! n).","conclusion":"L.ge (aval st1) !! s (transf n (aval st1) !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"rewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : L.ge (aval st1) !! s (transf n res !! n).","conclusion":"L.ge (aval st1) !! s (transf n res !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"erewrite INV3; eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : ~ In n (successors instr) \\/ basic_block_map n = true.","conclusion":"~ In n (successors instr) \\/ basic_block_map n = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n1 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (i : In n (successors instr)) (BB : basic_block_map n = true) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"tauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false)","proofString":"left.\nelim (U n); intros C D.\nelim (C i BB); intros.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) : In n (worklist st1).","conclusion":"In n (worklist st1)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false)","proofString":"elim (U n); intros C D.\nelim (C i BB); intros.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : In n (worklist st1).","conclusion":"In n (worklist st1)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"elim (C i BB); intros.\nauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) (H0 : In n (worklist st1)) (H1 : (aval st1) !! n = l) : In n (worklist st1).","conclusion":"In n (worklist st1)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n1 : positive, basic_block_map n1 = true -> res !! n1 = L.top) (INV2 : forall n1 : positive,\n(pc = n1 \\/ In n1 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n1 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n1 res !! n1))) (l : L.t) (st1 : state) (U : forall n1 : positive,\n(In n1 (successors instr) ->\n basic_block_map n1 = false -> In n1 (worklist st1) /\\ (aval st1) !! n1 = l) /\\\n(~ In n1 (successors instr) \\/ basic_block_map n1 = true ->\n (aval st1) !! n1 = res !! n1)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (i : In n (successors instr)) (BB : basic_block_map n = false) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) (H0 : In n (worklist st1)) (H1 : (aval st1) !! n = l)","proofString":"auto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n2 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (n1 : ~ In n (successors instr)) : In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n)).","conclusion":"In n (worklist st1) \\/\n(forall (instr0 : A) (s : positive),\n code ! n = Some instr0 ->\n In s (successors instr0) -> L.ge (aval st1) !! s (transf n (aval st1) !! n))","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr0 : A) (s : positive),\n code ! n2 = Some instr0 ->\n In s (successors instr0) -> L.ge res !! s (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr0 : A) (s : positive),\ncode ! n = Some instr0 ->\nIn s (successors instr0) -> L.ge res !! s (transf n res !! n)) (INV3 : forall (s : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s (successors instr') -> (aval st1) !! s = res !! s) (n1 : ~ In n (successors instr))","proofString":"right; intros.\nelim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) : L.ge (aval st1) !! s (transf n (aval st1) !! n).","conclusion":"L.ge (aval st1) !! s (transf n (aval st1) !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0))","proofString":"elim (U n); intros C D.\nrewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : L.ge (aval st1) !! s (transf n (aval st1) !! n).","conclusion":"L.ge (aval st1) !! s (transf n (aval st1) !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"rewrite D.\nerewrite INV3; eauto.\ntauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : L.ge (aval st1) !! s (transf n res !! n).","conclusion":"L.ge (aval st1) !! s (transf n res !! n)","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"erewrite INV3; eauto."},{"statement":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n) : ~ In n (successors instr) \\/ basic_block_map n = true.","conclusion":"~ In n (successors instr) \\/ basic_block_map n = true","hypotheses":"(pc : positive) (instr : A) (res : result) (rem : list positive) (CODE : code ! pc = Some instr) (INV1 : forall n2 : positive, basic_block_map n2 = true -> res !! n2 = L.top) (INV2 : forall n2 : positive,\n(pc = n2 \\/ In n2 rem) \\/\n(forall (instr1 : A) (s0 : positive),\n code ! n2 = Some instr1 ->\n In s0 (successors instr1) -> L.ge res !! s0 (transf n2 res !! n2))) (l : L.t) (st1 : state) (U : forall n2 : positive,\n(In n2 (successors instr) ->\n basic_block_map n2 = false -> In n2 (worklist st1) /\\ (aval st1) !! n2 = l) /\\\n(~ In n2 (successors instr) \\/ basic_block_map n2 = true ->\n (aval st1) !! n2 = res !! n2)) (V : incl (worklist {| aval := res; worklist := rem |}) (worklist st1)) (n : positive) (n0 : pc <> n) (H : forall (instr1 : A) (s0 : positive),\ncode ! n = Some instr1 ->\nIn s0 (successors instr1) -> L.ge res !! s0 (transf n res !! n)) (INV3 : forall (s0 : positive) (instr' : A),\ncode ! n = Some instr' ->\nIn s0 (successors instr') -> (aval st1) !! s0 = res !! s0) (n1 : ~ In n (successors instr)) (instr0 : A) (s : positive) (H0 : code ! n = Some instr0) (H1 : In s (successors instr0)) (C : In n (successors instr) ->\nbasic_block_map n = false -> In n (worklist st1) /\\ (aval st1) !! n = l) (D : ~ In n (successors instr) \\/ basic_block_map n = true ->\n(aval st1) !! n = res !! n)","proofString":"tauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) : code ! pc = None ->\nstate_invariant {| aval := res; worklist := pc :: rem |} ->\nstate_invariant {| aval := res; worklist := rem |}.","conclusion":"code ! pc = None ->\nstate_invariant {| aval := res; worklist := pc :: rem |} ->\nstate_invariant {| aval := res; worklist := rem |}","hypotheses":"(pc : positive) (res : result) (rem : list positive)","proofString":"intros CODE [INV1 INV2].\nsimpl in INV1.\nsimpl in INV2.\nsplit; simpl; intros.\napply INV1; auto.\ndestruct (INV2 n) as [[U | U] | U].\nsubst n.\nright; intros; congruence.\nauto.\nauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive,\nbasic_block_map n = true ->\n(aval {| aval := res; worklist := pc :: rem |}) !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n))) : state_invariant {| aval := res; worklist := rem |}.","conclusion":"state_invariant {| aval := res; worklist := rem |}","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive,\nbasic_block_map n = true ->\n(aval {| aval := res; worklist := pc :: rem |}) !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n)))","proofString":"simpl in INV1.\nsimpl in INV2.\nsplit; simpl; intros.\napply INV1; auto.\ndestruct (INV2 n) as [[U | U] | U].\nsubst n.\nright; intros; congruence.\nauto.\nauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n))) : state_invariant {| aval := res; worklist := rem |}.","conclusion":"state_invariant {| aval := res; worklist := rem |}","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\nIn n (worklist {| aval := res; worklist := pc :: rem |}) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (aval {| aval := res; worklist := pc :: rem |}) !! s\n   (transf n (aval {| aval := res; worklist := pc :: rem |}) !! n)))","proofString":"simpl in INV2.\nsplit; simpl; intros.\napply INV1; auto.\ndestruct (INV2 n) as [[U | U] | U].\nsubst n.\nright; intros; congruence.\nauto.\nauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : state_invariant {| aval := res; worklist := rem |}.","conclusion":"state_invariant {| aval := res; worklist := rem |}","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"split; simpl; intros.\napply INV1; auto.\ndestruct (INV2 n) as [[U | U] | U].\nsubst n.\nright; intros; congruence.\nauto.\nauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (H : basic_block_map n = true) : res !! n = L.top.","conclusion":"res !! n = L.top","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (H : basic_block_map n = true)","proofString":"apply INV1; auto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) : In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)).","conclusion":"In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive)","proofString":"destruct (INV2 n) as [[U | U] | U].\nsubst n.\nright; intros; congruence.\nauto.\nauto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : pc = n) : In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)).","conclusion":"In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : pc = n)","proofString":"subst n.\nright; intros; congruence."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : In pc rem \\/\n(forall (instr : A) (s : positive),\n code ! pc = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf pc res !! pc)).","conclusion":"In pc rem \\/\n(forall (instr : A) (s : positive),\n code ! pc = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf pc res !! pc))","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (INV2 : forall n : positive,\n(pc = n \\/ In n rem) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"right; intros; congruence."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : In n rem) : In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)).","conclusion":"In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : In n rem)","proofString":"auto."},{"statement":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : forall (instr : A) (s : positive),\ncode ! n = Some instr ->\nIn s (successors instr) -> L.ge res !! s (transf n res !! n)) : In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)).","conclusion":"In n rem \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))","hypotheses":"(pc : positive) (res : result) (rem : list positive) (CODE : code ! pc = None) (INV1 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (INV2 : forall n0 : positive,\n(pc = n0 \\/ In n0 rem) \\/\n(forall (instr : A) (s : positive),\n code ! n0 = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n0 res !! n0))) (n : positive) (U : forall (instr : A) (s : positive),\ncode ! n = Some instr ->\nIn s (successors instr) -> L.ge res !! s (transf n res !! n))","proofString":"auto."},{"statement":"(n : positive) (H : basic_block_map n = true) : (PMap.init L.top) !! n = L.top.","conclusion":"(PMap.init L.top) !! n = L.top","hypotheses":"(n : positive) (H : basic_block_map n = true)","proofString":"apply PMap.gi."},{"statement":"(n : positive) : In n (basic_block_list basic_block_map) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n)).","conclusion":"In n (basic_block_list basic_block_map) \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) ->\n L.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n))","hypotheses":"(n : positive)","proofString":"right.\nintros.\nrepeat rewrite PMap.gi.\napply L.top_ge."},{"statement":"(n : positive) : forall (instr : A) (s : positive),\ncode ! n = Some instr ->\nIn s (successors instr) ->\nL.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n).","conclusion":"forall (instr : A) (s : positive),\ncode ! n = Some instr ->\nIn s (successors instr) ->\nL.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n)","hypotheses":"(n : positive)","proofString":"intros.\nrepeat rewrite PMap.gi.\napply L.top_ge."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : L.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n).","conclusion":"L.ge (PMap.init L.top) !! s (transf n (PMap.init L.top) !! n)","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"repeat rewrite PMap.gi.\napply L.top_ge."},{"statement":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr)) : L.ge L.top (transf n L.top).","conclusion":"L.ge L.top (transf n L.top)","hypotheses":"(n : positive) (instr : A) (s : positive) (H : code ! n = Some instr) (H0 : In s (successors instr))","proofString":"apply L.top_ge."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : state_invariant {| aval := res; worklist := nil |}.","conclusion":"state_invariant {| aval := res; worklist := nil |}","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"pattern res.\neapply (PrimIter.iterate_prop _ _ (step basic_block_map)           state_invariant).\nintros st INV.\ndestruct st as [stin stwrk].\nunfold step.\nsimpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto.\neauto.\napply initial_state_invariant."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : (fun r : result => state_invariant {| aval := r; worklist := nil |}) res.","conclusion":"(fun r : result => state_invariant {| aval := r; worklist := nil |}) res","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"eapply (PrimIter.iterate_prop _ _ (step basic_block_map)           state_invariant).\nintros st INV.\ndestruct st as [stin stwrk].\nunfold step.\nsimpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto.\neauto.\napply initial_state_invariant."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : forall a : state,\nstate_invariant a ->\nmatch step basic_block_map a with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"forall a : state,\nstate_invariant a ->\nmatch step basic_block_map a with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"intros st INV.\ndestruct st as [stin stwrk].\nunfold step.\nsimpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (INV : state_invariant st) : match step basic_block_map st with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"match step basic_block_map st with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (INV : state_invariant st)","proofString":"destruct st as [stin stwrk].\nunfold step.\nsimpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |}) : match step basic_block_map {| aval := stin; worklist := stwrk |} with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"match step basic_block_map {| aval := stin; worklist := stwrk |} with\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |})","proofString":"unfold step.\nsimpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |}) : match\n  match worklist {| aval := stin; worklist := stwrk |} with\n  | nil => inl (aval {| aval := stin; worklist := stwrk |})\n  | pc :: rem =>\n      match code ! pc with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr)\n               (transf pc (aval {| aval := stin; worklist := stwrk |}) !! pc)\n               {|\n                 aval := aval {| aval := stin; worklist := stwrk |};\n                 worklist := rem\n               |})\n      | None =>\n          inr\n            {|\n              aval := aval {| aval := stin; worklist := stwrk |};\n              worklist := rem\n            |}\n      end\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"match\n  match worklist {| aval := stin; worklist := stwrk |} with\n  | nil => inl (aval {| aval := stin; worklist := stwrk |})\n  | pc :: rem =>\n      match code ! pc with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr)\n               (transf pc (aval {| aval := stin; worklist := stwrk |}) !! pc)\n               {|\n                 aval := aval {| aval := stin; worklist := stwrk |};\n                 worklist := rem\n               |})\n      | None =>\n          inr\n            {|\n              aval := aval {| aval := stin; worklist := stwrk |};\n              worklist := rem\n            |}\n      end\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |})","proofString":"simpl.\ndestruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |}) : match\n  match stwrk with\n  | nil => inl stin\n  | pc :: rem =>\n      match code ! pc with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr) (transf pc stin !! pc)\n               {| aval := stin; worklist := rem |})\n      | None => inr {| aval := stin; worklist := rem |}\n      end\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"match\n  match stwrk with\n  | nil => inl stin\n  | pc :: rem =>\n      match code ! pc with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr) (transf pc stin !! pc)\n               {| aval := stin; worklist := rem |})\n      | None => inr {| aval := stin; worklist := rem |}\n      end\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (INV : state_invariant {| aval := stin; worklist := stwrk |})","proofString":"destruct stwrk as [ | pc rem ] eqn:WRK.\nauto.\ndestruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (WRK : stwrk = nil) (INV : state_invariant {| aval := stin; worklist := nil |}) : state_invariant {| aval := stin; worklist := nil |}.","conclusion":"state_invariant {| aval := stin; worklist := nil |}","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (WRK : stwrk = nil) (INV : state_invariant {| aval := stin; worklist := nil |})","proofString":"auto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |}) : match\n  match code ! pc with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf pc stin !! pc) {| aval := stin; worklist := rem |})\n  | None => inr {| aval := stin; worklist := rem |}\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend.","conclusion":"match\n  match code ! pc with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf pc stin !! pc) {| aval := stin; worklist := rem |})\n  | None => inr {| aval := stin; worklist := rem |}\n  end\nwith\n| inl b => state_invariant {| aval := b; worklist := nil |}\n| inr a' => state_invariant a'\nend","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |})","proofString":"destruct (code!pc) as [instr|] eqn:CODE.\neapply propagate_successors_invariant; eauto.\neapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |}) (instr : A) (CODE : code ! pc = Some instr) : state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc stin !! pc) {| aval := stin; worklist := rem |}).","conclusion":"state_invariant\n  (propagate_successors basic_block_map (successors instr)\n     (transf pc stin !! pc) {| aval := stin; worklist := rem |})","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |}) (instr : A) (CODE : code ! pc = Some instr)","proofString":"eapply propagate_successors_invariant; eauto."},{"statement":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |}) (CODE : code ! pc = None) : state_invariant {| aval := stin; worklist := rem |}.","conclusion":"state_invariant {| aval := stin; worklist := rem |}","hypotheses":"(res : result) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (stin : result) (stwrk : list positive) (pc : positive) (rem : list positive) (WRK : stwrk = pc :: rem) (INV : state_invariant {| aval := stin; worklist := pc :: rem |}) (CODE : code ! pc = None)","proofString":"eapply propagate_successors_invariant_2; eauto."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"assert (state_invariant (mkstate res nil)).\neapply analyze_invariant; eauto.\nelim H2; simpl; intros.\nelim (H4 n); intros.\ncontradiction.\neauto."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) : state_invariant {| aval := res; worklist := nil |}.","conclusion":"state_invariant {| aval := res; worklist := nil |}","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr))","proofString":"eapply analyze_invariant; eauto."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |})","proofString":"elim H2; simpl; intros.\nelim (H4 n); intros.\ncontradiction.\neauto."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0)))","proofString":"elim (H4 n); intros.\ncontradiction.\neauto."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (H5 : False) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (H5 : False)","proofString":"contradiction."},{"statement":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (H5 : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n)) : L.ge res !! s (transf n res !! n).","conclusion":"L.ge res !! s (transf n res !! n)","hypotheses":"(res : result) (n : positive) (instr : A) (s : positive) (H : fixpoint = Some res) (H0 : code ! n = Some instr) (H1 : In s (successors instr)) (H2 : state_invariant {| aval := res; worklist := nil |}) (H3 : forall n0 : positive, basic_block_map n0 = true -> res !! n0 = L.top) (H4 : forall n0 : positive,\nFalse \\/\n(forall (instr0 : A) (s0 : positive),\n code ! n0 = Some instr0 ->\n In s0 (successors instr0) -> L.ge res !! s0 (transf n0 res !! n0))) (H5 : forall (instr0 : A) (s0 : positive),\ncode ! n = Some instr0 ->\nIn s0 (successors instr0) -> L.ge res !! s0 (transf n res !! n))","proofString":"eauto."},{"statement":"(res : result) (H : fixpoint = Some res) : res !! entrypoint = L.top.","conclusion":"res !! entrypoint = L.top","hypotheses":"(res : result) (H : fixpoint = Some res)","proofString":"assert (state_invariant (mkstate res nil)).\neapply analyze_invariant; eauto.\nelim H0; simpl; intros.\napply H1.\nunfold basic_block_map, is_basic_block_head.\nfold predecessors.\napply peq_true."},{"statement":"(res : result) (H : fixpoint = Some res) : state_invariant {| aval := res; worklist := nil |}.","conclusion":"state_invariant {| aval := res; worklist := nil |}","hypotheses":"(res : result) (H : fixpoint = Some res)","proofString":"eapply analyze_invariant; eauto."},{"statement":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) : res !! entrypoint = L.top.","conclusion":"res !! entrypoint = L.top","hypotheses":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |})","proofString":"elim H0; simpl; intros.\napply H1.\nunfold basic_block_map, is_basic_block_head.\nfold predecessors.\napply peq_true."},{"statement":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : res !! entrypoint = L.top.","conclusion":"res !! entrypoint = L.top","hypotheses":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"apply H1.\nunfold basic_block_map, is_basic_block_head.\nfold predecessors.\napply peq_true."},{"statement":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : basic_block_map entrypoint = true.","conclusion":"basic_block_map entrypoint = true","hypotheses":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"unfold basic_block_map, is_basic_block_head.\nfold predecessors.\napply peq_true."},{"statement":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : (if peq entrypoint entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! entrypoint with\n  | nil => false\n  | s :: nil => peq s entrypoint\n  | s :: _ :: _ => true\n  end) = true.","conclusion":"(if peq entrypoint entrypoint\n then true\n else\n  match (make_predecessors code successors) !!! entrypoint with\n  | nil => false\n  | s :: nil => peq s entrypoint\n  | s :: _ :: _ => true\n  end) = true","hypotheses":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"fold predecessors.\napply peq_true."},{"statement":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n))) : (if peq entrypoint entrypoint\n then true\n else\n  match predecessors !!! entrypoint with\n  | nil => false\n  | s :: nil => peq s entrypoint\n  | s :: _ :: _ => true\n  end) = true.","conclusion":"(if peq entrypoint entrypoint\n then true\n else\n  match predecessors !!! entrypoint with\n  | nil => false\n  | s :: nil => peq s entrypoint\n  | s :: _ :: _ => true\n  end) = true","hypotheses":"(res : result) (H : fixpoint = Some res) (H0 : state_invariant {| aval := res; worklist := nil |}) (H1 : forall n : positive, basic_block_map n = true -> res !! n = L.top) (H2 : forall n : positive,\nFalse \\/\n(forall (instr : A) (s : positive),\n code ! n = Some instr ->\n In s (successors instr) -> L.ge res !! s (transf n res !! n)))","proofString":"apply peq_true."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (st : state) (H0 : Pstate st) : Pstate st.","conclusion":"Pstate st","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (st : state) (H0 : Pstate st)","proofString":"auto."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) : Pstate\n  (if bb a\n   then propagate_successors bb succs l st\n   else\n    propagate_successors bb succs l\n      {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}).","conclusion":"Pstate\n  (if bb a\n   then propagate_successors bb succs l st\n   else\n    propagate_successors bb succs l\n      {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st)","proofString":"case (bb a).\nauto.\napply IHsuccs.\nred; simpl; intros.\nrewrite PMap.gsspec.\ncase (peq pc a); intro.\nauto.\napply H0."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) : Pstate (propagate_successors bb succs l st).","conclusion":"Pstate (propagate_successors bb succs l st)","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st)","proofString":"auto."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) : Pstate\n  (propagate_successors bb succs l\n     {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}).","conclusion":"Pstate\n  (propagate_successors bb succs l\n     {| aval := PMap.set a l (aval st); worklist := a :: worklist st |})","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st)","proofString":"apply IHsuccs.\nred; simpl; intros.\nrewrite PMap.gsspec.\ncase (peq pc a); intro.\nauto.\napply H0."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) : Pstate {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}.","conclusion":"Pstate {| aval := PMap.set a l (aval st); worklist := a :: worklist st |}","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st)","proofString":"red; simpl; intros.\nrewrite PMap.gsspec.\ncase (peq pc a); intro.\nauto.\napply H0."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) : P (PMap.set a l (aval st)) !! pc.","conclusion":"P (PMap.set a l (aval st)) !! pc","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive)","proofString":"rewrite PMap.gsspec.\ncase (peq pc a); intro.\nauto.\napply H0."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) : P (if peq pc a then l else (aval st) !! pc).","conclusion":"P (if peq pc a then l else (aval st) !! pc)","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive)","proofString":"case (peq pc a); intro.\nauto.\napply H0."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) (e : pc = a) : P l.","conclusion":"P l","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) (e : pc = a)","proofString":"auto."},{"statement":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) (n : pc <> a) : P (aval st) !! pc.","conclusion":"P (aval st) !! pc","hypotheses":"(bb : bbmap) (l : L.t) (H : P l) (a : positive) (succs : list positive) (IHsuccs : forall st0 : state,\nPstate st0 -> Pstate (propagate_successors bb succs l st0)) (st : state) (H0 : Pstate st) (pc : positive) (n : pc <> a)","proofString":"apply H0."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : P res !! pc.","conclusion":"P res !! pc","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"pattern res.\neapply (PrimIter.iterate_prop _ _ (step basic_block_map) Pstate).\nintros st PS.\nunfold step.\ndestruct (st.(worklist)).\napply PS.\nassert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto.\neauto.\nred; intro; simpl.\nrewrite PMap.gi.\napply Ptop."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : (fun r : result => P r !! pc) res.","conclusion":"(fun r : result => P r !! pc) res","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"eapply (PrimIter.iterate_prop _ _ (step basic_block_map) Pstate).\nintros st PS.\nunfold step.\ndestruct (st.(worklist)).\napply PS.\nassert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto.\neauto.\nred; intro; simpl.\nrewrite PMap.gi.\napply Ptop."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) : forall a : state,\nPstate a ->\nmatch step basic_block_map a with\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend.","conclusion":"forall a : state,\nPstate a ->\nmatch step basic_block_map a with\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res)","proofString":"intros st PS.\nunfold step.\ndestruct (st.(worklist)).\napply PS.\nassert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) : match step basic_block_map st with\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend.","conclusion":"match step basic_block_map st with\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st)","proofString":"unfold step.\ndestruct (st.(worklist)).\napply PS.\nassert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) : match\n  match worklist st with\n  | nil => inl (aval st)\n  | pc0 :: rem =>\n      match code ! pc0 with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr) (transf pc0 (aval st) !! pc0)\n               {| aval := aval st; worklist := rem |})\n      | None => inr {| aval := aval st; worklist := rem |}\n      end\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend.","conclusion":"match\n  match worklist st with\n  | nil => inl (aval st)\n  | pc0 :: rem =>\n      match code ! pc0 with\n      | Some instr =>\n          inr\n            (propagate_successors basic_block_map \n               (successors instr) (transf pc0 (aval st) !! pc0)\n               {| aval := aval st; worklist := rem |})\n      | None => inr {| aval := aval st; worklist := rem |}\n      end\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st)","proofString":"destruct (st.(worklist)).\napply PS.\nassert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) : P (aval st) !! pc.","conclusion":"P (aval st) !! pc","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st)","proofString":"apply PS."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) : match\n  match code ! p with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf p (aval st) !! p) {| aval := aval st; worklist := l |})\n  | None => inr {| aval := aval st; worklist := l |}\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend.","conclusion":"match\n  match code ! p with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf p (aval st) !! p) {| aval := aval st; worklist := l |})\n  | None => inr {| aval := aval st; worklist := l |}\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive)","proofString":"assert (PS2: Pstate (mkstate st.(aval) l)).\nred; intro; simpl.\napply PS.\ndestruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) : Pstate {| aval := aval st; worklist := l |}.","conclusion":"Pstate {| aval := aval st; worklist := l |}","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive)","proofString":"red; intro; simpl.\napply PS."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (pc0 : positive) : P (aval st) !! pc0.","conclusion":"P (aval st) !! pc0","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (pc0 : positive)","proofString":"apply PS."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) : match\n  match code ! p with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf p (aval st) !! p) {| aval := aval st; worklist := l |})\n  | None => inr {| aval := aval st; worklist := l |}\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend.","conclusion":"match\n  match code ! p with\n  | Some instr =>\n      inr\n        (propagate_successors basic_block_map (successors instr)\n           (transf p (aval st) !! p) {| aval := aval st; worklist := l |})\n  | None => inr {| aval := aval st; worklist := l |}\n  end\nwith\n| inl b => P b !! pc\n| inr a' => Pstate a'\nend","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |})","proofString":"destruct (code!p) as [instr|] eqn:CODE.\napply propagate_successors_P.\neauto.\nauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr) : Pstate\n  (propagate_successors basic_block_map (successors instr)\n     (transf p (aval st) !! p) {| aval := aval st; worklist := l |}).","conclusion":"Pstate\n  (propagate_successors basic_block_map (successors instr)\n     (transf p (aval st) !! p) {| aval := aval st; worklist := l |})","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr)","proofString":"apply propagate_successors_P.\neauto.\nauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr) : P (transf p (aval st) !! p).","conclusion":"P (transf p (aval st) !! p)","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr)","proofString":"eauto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr) : Pstate {| aval := aval st; worklist := l |}.","conclusion":"Pstate {| aval := aval st; worklist := l |}","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (instr : A) (CODE : code ! p = Some instr)","proofString":"auto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (CODE : code ! p = None) : Pstate {| aval := aval st; worklist := l |}.","conclusion":"Pstate {| aval := aval st; worklist := l |}","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (st : state) (PS : Pstate st) (p : positive) (l : list positive) (PS2 : Pstate {| aval := aval st; worklist := l |}) (CODE : code ! p = None)","proofString":"auto."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (pc0 : positive) : P (PMap.init L.top) !! pc0.","conclusion":"P (PMap.init L.top) !! pc0","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (pc0 : positive)","proofString":"rewrite PMap.gi.\napply Ptop."},{"statement":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (pc0 : positive) : P L.top.","conclusion":"P L.top","hypotheses":"(res : result) (pc : positive) (H : PrimIter.iterate state result (step basic_block_map)\n  {| aval := PMap.init L.top; worklist := basic_block_list basic_block_map |} =\nSome res) (pc0 : positive)","proofString":"apply Ptop."},{"statement":"(n : positive) : ~ In n empty.","conclusion":"~ In n empty","hypotheses":"(n : positive)","proofString":"apply PHeap.In_empty."},{"statement":"(n n' : positive) (s : t) : In n' (add n s) <-> n = n' \\/ In n' s.","conclusion":"In n' (add n s) <-> n = n' \\/ In n' s","hypotheses":"(n n' : positive) (s : t)","proofString":"rewrite PHeap.In_insert.\nunfold In.\nintuition."},{"statement":"(n n' : positive) (s : t) : n' = n \\/ PHeap.In n' s <-> n = n' \\/ In n' s.","conclusion":"n' = n \\/ PHeap.In n' s <-> n = n' \\/ In n' s","hypotheses":"(n n' : positive) (s : t)","proofString":"unfold In.\nintuition."},{"statement":"(n n' : positive) (s : t) : n' = n \\/ PHeap.In n' s <-> n = n' \\/ PHeap.In n' s.","conclusion":"n' = n \\/ PHeap.In n' s <-> n = n' \\/ PHeap.In n' s","hypotheses":"(n n' : positive) (s : t)","proofString":"intuition."},{"statement":"(s : t) (n : positive) : match PHeap.findMax s with\n| Some n0 => Some (n0, PHeap.deleteMax s)\n| None => None\nend = None -> ~ In n s.","conclusion":"match PHeap.findMax s with\n| Some n0 => Some (n0, PHeap.deleteMax s)\n| None => None\nend = None -> ~ In n s","hypotheses":"(s : t) (n : positive)","proofString":"caseEq (PHeap.findMax s); intros.\ncongruence.\napply PHeap.findMax_empty.\nauto."},{"statement":"(s : t) (n p : positive) (H : PHeap.findMax s = Some p) (H0 : Some (p, PHeap.deleteMax s) = None) : ~ In n s.","conclusion":"~ In n s","hypotheses":"(s : t) (n p : positive) (H : PHeap.findMax s = Some p) (H0 : Some (p, PHeap.deleteMax s) = None)","proofString":"congruence."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) : match PHeap.findMax s with\n| Some n0 => Some (n0, PHeap.deleteMax s)\n| None => None\nend = Some (n, s') -> forall n' : positive, In n' s <-> n = n' \\/ In n' s'.","conclusion":"match PHeap.findMax s with\n| Some n0 => Some (n0, PHeap.deleteMax s)\n| None => None\nend = Some (n, s') -> forall n' : positive, In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t)","proofString":"caseEq (PHeap.findMax s); intros.\ninv H0.\ngeneralize (PHeap.In_deleteMax s n n' H).\nunfold In.\nintuition.\ncongruence."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) (p : positive) (H : PHeap.findMax s = Some p) (H0 : Some (p, PHeap.deleteMax s) = Some (n, s')) (n' : positive) : In n' s <-> n = n' \\/ In n' s'.","conclusion":"In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t) (p : positive) (H : PHeap.findMax s = Some p) (H0 : Some (p, PHeap.deleteMax s) = Some (n, s')) (n' : positive)","proofString":"inv H0.\ngeneralize (PHeap.In_deleteMax s n n' H).\nunfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive) : In n' s <-> n = n' \\/ In n' (PHeap.deleteMax s).","conclusion":"In n' s <-> n = n' \\/ In n' (PHeap.deleteMax s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive)","proofString":"generalize (PHeap.In_deleteMax s n n' H).\nunfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive) : PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMax s) ->\nIn n' s <-> n = n' \\/ In n' (PHeap.deleteMax s).","conclusion":"PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMax s) ->\nIn n' s <-> n = n' \\/ In n' (PHeap.deleteMax s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive)","proofString":"unfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive) : PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMax s) ->\nPHeap.In n' s <-> n = n' \\/ PHeap.In n' (PHeap.deleteMax s).","conclusion":"PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMax s) ->\nPHeap.In n' s <-> n = n' \\/ PHeap.In n' (PHeap.deleteMax s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMax s = Some n) (n' : positive)","proofString":"intuition."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) (H : PHeap.findMax s = None) (H0 : None = Some (n, s')) (n' : positive) : In n' s <-> n = n' \\/ In n' s'.","conclusion":"In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t) (H : PHeap.findMax s = None) (H0 : None = Some (n, s')) (n' : positive)","proofString":"congruence."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) : code ! n = Some instr -> In n (all_nodes code).","conclusion":"code ! n = Some instr -> In n (all_nodes code)","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A)","proofString":"apply PTree_Properties.fold_rec with      (P := fun m set => m!n = Some instr -> In n set).\nintros.\napply H0.\nrewrite H.\nauto.\nrewrite PTree.gempty.\ncongruence.\nintros.\nrewrite PTree.gsspec in H2.\nrewrite add_spec.\ndestruct (peq n k).\nauto.\neauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) : forall (m m' : PTree.t A) (a : PHeap.t),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! n = Some instr -> In n a) -> m' ! n = Some instr -> In n a.","conclusion":"forall (m m' : PTree.t A) (a : PHeap.t),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! n = Some instr -> In n a) -> m' ! n = Some instr -> In n a","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A)","proofString":"intros.\napply H0.\nrewrite H.\nauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr) : In n a.","conclusion":"In n a","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr)","proofString":"apply H0.\nrewrite H.\nauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr) : m ! n = Some instr.","conclusion":"m ! n = Some instr","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr)","proofString":"rewrite H.\nauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr) : m' ! n = Some instr.","conclusion":"m' ! n = Some instr","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m m' : PTree.t A) (a : PHeap.t) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! n = Some instr -> In n a) (H1 : m' ! n = Some instr)","proofString":"auto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) : (PTree.empty A) ! n = Some instr -> In n PHeap.empty.","conclusion":"(PTree.empty A) ! n = Some instr -> In n PHeap.empty","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A)","proofString":"rewrite PTree.gempty.\ncongruence."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) : None = Some instr -> In n PHeap.empty.","conclusion":"None = Some instr -> In n PHeap.empty","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A)","proofString":"congruence."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) : forall (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A),\nm ! k = None ->\ncode ! k = Some v ->\n(m ! n = Some instr -> In n a) ->\n(PTree.set k v m) ! n = Some instr -> In n (PHeap.insert k a).","conclusion":"forall (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A),\nm ! k = None ->\ncode ! k = Some v ->\n(m ! n = Some instr -> In n a) ->\n(PTree.set k v m) ! n = Some instr -> In n (PHeap.insert k a)","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A)","proofString":"intros.\nrewrite PTree.gsspec in H2.\nrewrite add_spec.\ndestruct (peq n k).\nauto.\neauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (PTree.set k v m) ! n = Some instr) : In n (PHeap.insert k a).","conclusion":"In n (PHeap.insert k a)","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (PTree.set k v m) ! n = Some instr)","proofString":"rewrite PTree.gsspec in H2.\nrewrite add_spec.\ndestruct (peq n k).\nauto.\neauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (if peq n k then Some v else m ! n) = Some instr) : In n (PHeap.insert k a).","conclusion":"In n (PHeap.insert k a)","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (if peq n k then Some v else m ! n) = Some instr)","proofString":"rewrite add_spec.\ndestruct (peq n k).\nauto.\neauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (if peq n k then Some v else m ! n) = Some instr) : k = n \\/ In n a.","conclusion":"k = n \\/ In n a","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (H2 : (if peq n k then Some v else m ! n) = Some instr)","proofString":"destruct (peq n k).\nauto.\neauto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (e : n = k) (H2 : Some v = Some instr) : k = n \\/ In n a.","conclusion":"k = n \\/ In n a","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (e : n = k) (H2 : Some v = Some instr)","proofString":"auto."},{"statement":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (n0 : n <> k) (H2 : m ! n = Some instr) : k = n \\/ In n a.","conclusion":"k = n \\/ In n a","hypotheses":"(A : Type) (code : PTree.t A) (n : positive) (instr : A) (m : PTree.t A) (a : PHeap.t) (k : PTree.elt) (v : A) (H : m ! k = None) (H0 : code ! k = Some v) (H1 : m ! n = Some instr -> In n a) (n0 : n <> k) (H2 : m ! n = Some instr)","proofString":"eauto."},{"statement":"(s : t) (n : positive) : match PHeap.findMin s with\n| Some n0 => Some (n0, PHeap.deleteMin s)\n| None => None\nend = None -> ~ In n s.","conclusion":"match PHeap.findMin s with\n| Some n0 => Some (n0, PHeap.deleteMin s)\n| None => None\nend = None -> ~ In n s","hypotheses":"(s : t) (n : positive)","proofString":"caseEq (PHeap.findMin s); intros.\ncongruence.\napply PHeap.findMin_empty.\nauto."},{"statement":"(s : t) (n p : positive) (H : PHeap.findMin s = Some p) (H0 : Some (p, PHeap.deleteMin s) = None) : ~ In n s.","conclusion":"~ In n s","hypotheses":"(s : t) (n p : positive) (H : PHeap.findMin s = Some p) (H0 : Some (p, PHeap.deleteMin s) = None)","proofString":"congruence."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) : match PHeap.findMin s with\n| Some n0 => Some (n0, PHeap.deleteMin s)\n| None => None\nend = Some (n, s') -> forall n' : positive, In n' s <-> n = n' \\/ In n' s'.","conclusion":"match PHeap.findMin s with\n| Some n0 => Some (n0, PHeap.deleteMin s)\n| None => None\nend = Some (n, s') -> forall n' : positive, In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t)","proofString":"caseEq (PHeap.findMin s); intros.\ninv H0.\ngeneralize (PHeap.In_deleteMin s n n' H).\nunfold In.\nintuition.\ncongruence."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) (p : positive) (H : PHeap.findMin s = Some p) (H0 : Some (p, PHeap.deleteMin s) = Some (n, s')) (n' : positive) : In n' s <-> n = n' \\/ In n' s'.","conclusion":"In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t) (p : positive) (H : PHeap.findMin s = Some p) (H0 : Some (p, PHeap.deleteMin s) = Some (n, s')) (n' : positive)","proofString":"inv H0.\ngeneralize (PHeap.In_deleteMin s n n' H).\nunfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive) : In n' s <-> n = n' \\/ In n' (PHeap.deleteMin s).","conclusion":"In n' s <-> n = n' \\/ In n' (PHeap.deleteMin s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive)","proofString":"generalize (PHeap.In_deleteMin s n n' H).\nunfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive) : PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMin s) ->\nIn n' s <-> n = n' \\/ In n' (PHeap.deleteMin s).","conclusion":"PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMin s) ->\nIn n' s <-> n = n' \\/ In n' (PHeap.deleteMin s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive)","proofString":"unfold In.\nintuition."},{"statement":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive) : PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMin s) ->\nPHeap.In n' s <-> n = n' \\/ PHeap.In n' (PHeap.deleteMin s).","conclusion":"PHeap.In n' s <-> n' = n \\/ PHeap.In n' (PHeap.deleteMin s) ->\nPHeap.In n' s <-> n = n' \\/ PHeap.In n' (PHeap.deleteMin s)","hypotheses":"(s : t) (n : positive) (H : PHeap.findMin s = Some n) (n' : positive)","proofString":"intuition."},{"statement":"(s : t) (n : positive) (s' : PHeap.t) (H : PHeap.findMin s = None) (H0 : None = Some (n, s')) (n' : positive) : In n' s <-> n = n' \\/ In n' s'.","conclusion":"In n' s <-> n = n' \\/ In n' s'","hypotheses":"(s : t) (n : positive) (s' : PHeap.t) (H : PHeap.findMin s = None) (H0 : None = Some (n, s')) (n' : positive)","proofString":"congruence."}]}