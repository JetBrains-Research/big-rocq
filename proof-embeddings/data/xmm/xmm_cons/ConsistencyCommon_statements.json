{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/xmm_cons/ConsistencyCommon.v","fileSamples":[{"statement":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂) : irreflexive (hb ⨾ eco).","proofString":"apply irreflexive_inclusion   with (r' := hb ⨾ eco^?); eauto.\napply inclusion_seq_mon; basic_solver."},{"statement":"(WF : Wf G) (cons_coherence : irreflexive (hb ⨾ eco^?)) (cons_atomicity : rmw ∩ (fr ⨾ co) ≡ ∅₂) : hb ⨾ eco ⊆ hb ⨾ eco^?.","proofString":"apply inclusion_seq_mon; basic_solver."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive ((⦗E⦘ ⨾ ⦗W⦘ ⨾ rf^? ⨾ hb^?) ⨾ hb).","proofString":"arewrite_id ⦗W⦘; arewrite_id ⦗E⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ rf^? ⨾ hb^? ⨾ hb).","proofString":"rels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive (rf^? ⨾ hb^? ⨾ hb).","proofString":"arewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) : irreflexive (eco^? ⨾ hb^? ⨾ hb).","proofString":"generalize (eco_trans WF); ins; relsf.\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) : irreflexive (eco^? ⨾ hb^? ⨾ hb).","proofString":"generalize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb).","proofString":"relsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply CONS."},{"statement":"(WF : Wf G) (CONS : WCore.is_cons G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb).","proofString":"by rotate 1; apply CONS."}]}