{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Ctyping.v","fileSamples":[{"statement":"(t1 t2 : type) (x : unit) (H : match classify_cast t1 t2 with\n| cast_case_default => Error (msg \"illegal cast\")\n| _ => OK tt\nend = OK x) : classify_cast t1 t2 <> cast_case_default.","conclusion":"classify_cast t1 t2 <> cast_case_default","hypotheses":"(t1 t2 : type) (x : unit) (H : match classify_cast t1 t2 with\n| cast_case_default => Error (msg \"illegal cast\")\n| _ => OK tt\nend = OK x)","proofString":"destruct (classify_cast t1 t2); congruence."},{"statement":"(t : type) (x : unit) (H : match classify_bool t with\n| bool_default => Error (msg \"not a boolean\")\n| _ => OK tt\nend = OK x) : classify_bool t <> bool_default.","conclusion":"classify_bool t <> bool_default","hypotheses":"(t : type) (x : unit) (H : match classify_bool t with\n| bool_default => Error (msg \"not a boolean\")\n| _ => OK tt\nend = OK x)","proofString":"destruct (classify_bool t); congruence."},{"statement":"forall (tl : list type) (el : exprlist) (x : unit),\ncheck_arguments el tl = OK x -> wt_arguments el tl.","conclusion":"forall (tl : list type) (el : exprlist) (x : unit),\ncheck_arguments el tl = OK x -> wt_arguments el tl","hypotheses":"","proofString":"induction tl; destruct el; simpl; intros; try discriminate.\nconstructor.\ndestruct strict eqn:S; try discriminate.\nconstructor; auto.\nmonadInv H.\nconstructor; eauto with ty."},{"statement":"(x : unit) (H : OK tt = OK x) : wt_arguments Enil nil.","conclusion":"wt_arguments Enil nil","hypotheses":"(x : unit) (H : OK tt = OK x)","proofString":"constructor."},{"statement":"(r1 : expr) (el : exprlist) (x : unit) (H : (if strict then Error (msg \"too many arguments\") else OK tt) = OK x) : wt_arguments (Econs r1 el) nil.","conclusion":"wt_arguments (Econs r1 el) nil","hypotheses":"(r1 : expr) (el : exprlist) (x : unit) (H : (if strict then Error (msg \"too many arguments\") else OK tt) = OK x)","proofString":"destruct strict eqn:S; try discriminate.\nconstructor; auto."},{"statement":"(r1 : expr) (el : exprlist) (x : unit) (S : strict = false) (H : OK tt = OK x) : wt_arguments (Econs r1 el) nil.","conclusion":"wt_arguments (Econs r1 el) nil","hypotheses":"(r1 : expr) (el : exprlist) (x : unit) (S : strict = false) (H : OK tt = OK x)","proofString":"constructor; auto."},{"statement":"(a : type) (tl : list type) (IHtl : forall (el0 : exprlist) (x0 : unit),\ncheck_arguments el0 tl = OK x0 -> wt_arguments el0 tl) (r1 : expr) (el : exprlist) (x : unit) (H : (do _ <- check_cast (typeof r1) a; check_arguments el tl) = OK x) : wt_arguments (Econs r1 el) (a :: tl).","conclusion":"wt_arguments (Econs r1 el) (a :: tl)","hypotheses":"(a : type) (tl : list type) (IHtl : forall (el0 : exprlist) (x0 : unit),\ncheck_arguments el0 tl = OK x0 -> wt_arguments el0 tl) (r1 : expr) (el : exprlist) (x : unit) (H : (do _ <- check_cast (typeof r1) a; check_arguments el tl) = OK x)","proofString":"monadInv H.\nconstructor; eauto with ty."},{"statement":"(a : type) (tl : list type) (IHtl : forall (el0 : exprlist) (x1 : unit),\ncheck_arguments el0 tl = OK x1 -> wt_arguments el0 tl) (r1 : expr) (el : exprlist) (x x0 : unit) (EQ : check_cast (typeof r1) a = OK x0) (EQ0 : check_arguments el tl = OK x) : wt_arguments (Econs r1 el) (a :: tl).","conclusion":"wt_arguments (Econs r1 el) (a :: tl)","hypotheses":"(a : type) (tl : list type) (IHtl : forall (el0 : exprlist) (x1 : unit),\ncheck_arguments el0 tl = OK x1 -> wt_arguments el0 tl) (r1 : expr) (el : exprlist) (x x0 : unit) (EQ : check_cast (typeof r1) a = OK x0) (EQ0 : check_arguments el tl = OK x)","proofString":"constructor; eauto with ty."},{"statement":"(a : expr) (x : unit) (H : match a with\n| Evar _ _ | Efield _ _ _ | Ederef _ _ | Eloc _ _ _ _ =>\n    Error (msg \"not a r-value\")\n| _ => OK tt\nend = OK x) : expr_kind a = RV.","conclusion":"expr_kind a = RV","hypotheses":"(a : expr) (x : unit) (H : match a with\n| Evar _ _ | Efield _ _ _ | Ederef _ _ | Eloc _ _ _ _ =>\n    Error (msg \"not a r-value\")\n| _ => OK tt\nend = OK x)","proofString":"destruct a; reflexivity || discriminate."},{"statement":"(a : expr) (x : unit) (H : match a with\n| Evar _ _ | Efield _ _ _ | Ederef _ _ | Eloc _ _ _ _ => OK tt\n| _ => Error (msg \"not a l-value\")\nend = OK x) : expr_kind a = LV.","conclusion":"expr_kind a = LV","hypotheses":"(a : expr) (x : unit) (H : match a with\n| Evar _ _ | Efield _ _ _ | Ederef _ _ | Eloc _ _ _ _ => OK tt\n| _ => Error (msg \"not a l-value\")\nend = OK x)","proofString":"destruct a; reflexivity || discriminate."},{"statement":"(t1 t2 : type) (H : classify_cast\n  match t1 with\n  | Tint I8 _ _ | Tint I16 _ _ | Tint IBool _ _ => Tint I32 Signed noattr\n  | Tarray t _ _ => Tpointer t noattr\n  | Tfunction _ _ _ => Tpointer t1 noattr\n  | _ => remove_attributes t1\n  end t2 <> cast_case_default) : classify_cast t1 t2 <> cast_case_default.","conclusion":"classify_cast t1 t2 <> cast_case_default","hypotheses":"(t1 t2 : type) (H : classify_cast\n  match t1 with\n  | Tint I8 _ _ | Tint I16 _ _ | Tint IBool _ _ => Tint I32 Signed noattr\n  | Tarray t _ _ => Tpointer t noattr\n  | Tfunction _ _ _ => Tpointer t1 noattr\n  | _ => remove_attributes t1\n  end t2 <> cast_case_default)","proofString":"destruct t1; auto.\nassert (classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->          classify_cast (Tint i s a) t2 <> cast_case_default).\nunfold classify_cast.\ndestruct t2; try congruence.\ndestruct f; congruence.\ndestruct Archi.ptr64; congruence.\ndestruct i; auto."},{"statement":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default) : classify_cast (Tint i s a) t2 <> cast_case_default.","conclusion":"classify_cast (Tint i s a) t2 <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default)","proofString":"assert (classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->          classify_cast (Tint i s a) t2 <> cast_case_default).\nunfold classify_cast.\ndestruct t2; try congruence.\ndestruct f; congruence.\ndestruct Archi.ptr64; congruence.\ndestruct i; auto."},{"statement":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default) : classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->\nclassify_cast (Tint i s a) t2 <> cast_case_default.","conclusion":"classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->\nclassify_cast (Tint i s a) t2 <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default)","proofString":"unfold classify_cast.\ndestruct t2; try congruence.\ndestruct f; congruence.\ndestruct Archi.ptr64; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default) : match t2 with\n| Tvoid => cast_case_void\n| Tint (I8 as sz2) si2 _ | Tint (I16 as sz2) si2 _ => cast_case_i2i sz2 si2\n| Tint (I32 as sz2) si2 _ =>\n    if Archi.ptr64 then cast_case_i2i sz2 si2 else cast_case_pointer\n| Tint IBool _ _ => cast_case_i2bool\n| Tlong _ _ => cast_case_i2l Signed\n| Tfloat F32 _ => cast_case_i2s Signed\n| Tfloat F64 _ => cast_case_i2f Signed\n| Tpointer _ _ =>\n    if Archi.ptr64 then cast_case_i2l Signed else cast_case_pointer\n| _ => cast_case_default\nend <> cast_case_default ->\nmatch t2 with\n| Tvoid => cast_case_void\n| Tint (I8 as sz2) si2 _ | Tint (I16 as sz2) si2 _ => cast_case_i2i sz2 si2\n| Tint (I32 as sz2) si2 _ =>\n    if Archi.ptr64 then cast_case_i2i sz2 si2 else cast_case_pointer\n| Tint IBool _ _ => cast_case_i2bool\n| Tlong _ _ => cast_case_i2l s\n| Tfloat F32 _ => cast_case_i2s s\n| Tfloat F64 _ => cast_case_i2f s\n| Tpointer _ _ => if Archi.ptr64 then cast_case_i2l s else cast_case_pointer\n| _ => cast_case_default\nend <> cast_case_default.","conclusion":"match t2 with\n| Tvoid => cast_case_void\n| Tint (I8 as sz2) si2 _ | Tint (I16 as sz2) si2 _ => cast_case_i2i sz2 si2\n| Tint (I32 as sz2) si2 _ =>\n    if Archi.ptr64 then cast_case_i2i sz2 si2 else cast_case_pointer\n| Tint IBool _ _ => cast_case_i2bool\n| Tlong _ _ => cast_case_i2l Signed\n| Tfloat F32 _ => cast_case_i2s Signed\n| Tfloat F64 _ => cast_case_i2f Signed\n| Tpointer _ _ =>\n    if Archi.ptr64 then cast_case_i2l Signed else cast_case_pointer\n| _ => cast_case_default\nend <> cast_case_default ->\nmatch t2 with\n| Tvoid => cast_case_void\n| Tint (I8 as sz2) si2 _ | Tint (I16 as sz2) si2 _ => cast_case_i2i sz2 si2\n| Tint (I32 as sz2) si2 _ =>\n    if Archi.ptr64 then cast_case_i2i sz2 si2 else cast_case_pointer\n| Tint IBool _ _ => cast_case_i2bool\n| Tlong _ _ => cast_case_i2l s\n| Tfloat F32 _ => cast_case_i2s s\n| Tfloat F64 _ => cast_case_i2f s\n| Tpointer _ _ => if Archi.ptr64 then cast_case_i2l s else cast_case_pointer\n| _ => cast_case_default\nend <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default)","proofString":"destruct t2; try congruence.\ndestruct f; congruence.\ndestruct Archi.ptr64; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (f : floatsize) (a0 : attr) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end (Tfloat f a0) <> cast_case_default) : match f with\n| F32 => cast_case_i2s Signed\n| F64 => cast_case_i2f Signed\nend <> cast_case_default ->\nmatch f with\n| F32 => cast_case_i2s s\n| F64 => cast_case_i2f s\nend <> cast_case_default.","conclusion":"match f with\n| F32 => cast_case_i2s Signed\n| F64 => cast_case_i2f Signed\nend <> cast_case_default ->\nmatch f with\n| F32 => cast_case_i2s s\n| F64 => cast_case_i2f s\nend <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (f : floatsize) (a0 : attr) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end (Tfloat f a0) <> cast_case_default)","proofString":"destruct f; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (a0 : attr) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end (Tpointer t2 a0) <> cast_case_default) : (if Archi.ptr64 then cast_case_i2l Signed else cast_case_pointer) <>\ncast_case_default ->\n(if Archi.ptr64 then cast_case_i2l s else cast_case_pointer) <>\ncast_case_default.","conclusion":"(if Archi.ptr64 then cast_case_i2l Signed else cast_case_pointer) <>\ncast_case_default ->\n(if Archi.ptr64 then cast_case_i2l s else cast_case_pointer) <>\ncast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (a0 : attr) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end (Tpointer t2 a0) <> cast_case_default)","proofString":"destruct Archi.ptr64; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default) (H0 : classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->\nclassify_cast (Tint i s a) t2 <> cast_case_default) : classify_cast (Tint i s a) t2 <> cast_case_default.","conclusion":"classify_cast (Tint i s a) t2 <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (t2 : type) (H : classify_cast\n  match i with\n  | I32 => remove_attributes (Tint i s a)\n  | _ => Tint I32 Signed noattr\n  end t2 <> cast_case_default) (H0 : classify_cast (Tint I32 Signed a) t2 <> cast_case_default ->\nclassify_cast (Tint i s a) t2 <> cast_case_default)","proofString":"destruct i; auto."},{"statement":"(ty : type) (H : match typeconv ty with\n| Tint _ _ _ => bool_case_i\n| Tlong _ _ => bool_case_l\n| Tfloat F32 _ => bool_case_s\n| Tfloat F64 _ => bool_case_f\n| Tpointer _ _ => if Archi.ptr64 then bool_case_l else bool_case_i\n| _ => bool_default\nend <> bool_default) : classify_cast ty type_bool <> cast_case_default.","conclusion":"classify_cast ty type_bool <> cast_case_default","hypotheses":"(ty : type) (H : match typeconv ty with\n| Tint _ _ _ => bool_case_i\n| Tlong _ _ => bool_case_l\n| Tfloat F32 _ => bool_case_s\n| Tfloat F64 _ => bool_case_f\n| Tpointer _ _ => if Archi.ptr64 then bool_case_l else bool_case_i\n| _ => bool_default\nend <> bool_default)","proofString":"destruct ty; simpl in *; try congruence;  try (destruct Archi.ptr64; congruence).\ndestruct f; congruence."},{"statement":"(f : floatsize) (a : attr) (H : match f with\n| F32 => bool_case_s\n| F64 => bool_case_f\nend <> bool_default) : match f with\n| F32 => cast_case_s2bool\n| F64 => cast_case_f2bool\nend <> cast_case_default.","conclusion":"match f with\n| F32 => cast_case_s2bool\n| F64 => cast_case_f2bool\nend <> cast_case_default","hypotheses":"(f : floatsize) (a : attr) (H : match f with\n| F32 => bool_case_s\n| F64 => bool_case_f\nend <> bool_default)","proofString":"destruct f; congruence."},{"statement":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) : match i2 with\n| I32 => if Archi.ptr64 then cast_case_i2i i2 s2 else cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default.","conclusion":"match i2 with\n| I32 => if Archi.ptr64 then cast_case_i2i i2 s2 else cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default","hypotheses":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr)","proofString":"destruct Archi.ptr64; [ | destruct (Ctypes.intsize_eq i2 I32)].\ndestruct i2; congruence.\nsubst i2; congruence.\ndestruct i2; congruence."},{"statement":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) : match i2 with\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default.","conclusion":"match i2 with\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default","hypotheses":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr)","proofString":"destruct i2; congruence."},{"statement":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) (e : i2 = I32) : match i2 with\n| I32 => cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default.","conclusion":"match i2 with\n| I32 => cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default","hypotheses":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) (e : i2 = I32)","proofString":"subst i2; congruence."},{"statement":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) (n : i2 <> I32) : match i2 with\n| I32 => cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default.","conclusion":"match i2 with\n| I32 => cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i2 s2\nend <> cast_case_default","hypotheses":"(i1 : intsize) (s1 : signedness) (a1 : attr) (i2 : intsize) (s2 : signedness) (a2 : attr) (n : i2 <> I32)","proofString":"destruct i2; congruence."},{"statement":"(t1 t2 t : type) (H : type_combine t1 t2 = OK t) (H0 : match t1 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H1 : match t2 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_combine t1 t2 = OK t) (H0 : match t1 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H1 : match t2 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend)","proofString":"unfold wt_cast; destruct t1; try discriminate; destruct t2; simpl in H; inv H.\nsimpl; split; congruence.\ndestruct (intsize_eq i i0 && signedness_eq s s0); inv H3.\nsplit; apply wt_cast_int.\ndestruct (signedness_eq s s0); inv H3.\nsimpl; split; try congruence; destruct Archi.ptr64; congruence.\ndestruct (floatsize_eq f f0); inv H3.\nsimpl; destruct f0; split; congruence.\nmonadInv H3.\nsimpl; split; congruence.\ncontradiction.\ncontradiction.\ndestruct (ident_eq i i0); inv H3.\nsimpl; split; congruence.\ndestruct (ident_eq i i0); inv H3.\nsimpl; split; congruence."},{"statement":"(H0 H1 : True) : classify_cast Tvoid Tvoid <> cast_case_default /\\\nclassify_cast Tvoid Tvoid <> cast_case_default.","conclusion":"classify_cast Tvoid Tvoid <> cast_case_default /\\\nclassify_cast Tvoid Tvoid <> cast_case_default","hypotheses":"(H0 H1 : True)","proofString":"simpl; split; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (i0 : intsize) (s0 : signedness) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if intsize_eq i i0 && signedness_eq s s0\n then OK (Tint i s (attr_combine a a0))\n else Error (msg \"incompatible int types\")) = OK t) : classify_cast (Tint i s a) t <> cast_case_default /\\\nclassify_cast (Tint i0 s0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tint i s a) t <> cast_case_default /\\\nclassify_cast (Tint i0 s0 a0) t <> cast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (i0 : intsize) (s0 : signedness) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if intsize_eq i i0 && signedness_eq s s0\n then OK (Tint i s (attr_combine a a0))\n else Error (msg \"incompatible int types\")) = OK t)","proofString":"destruct (intsize_eq i i0 && signedness_eq s s0); inv H3.\nsplit; apply wt_cast_int."},{"statement":"(i : intsize) (s : signedness) (a : attr) (i0 : intsize) (s0 : signedness) (a0 : attr) (H0 H1 : True) : classify_cast (Tint i s a) (Tint i s (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tint i0 s0 a0) (Tint i s (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tint i s a) (Tint i s (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tint i0 s0 a0) (Tint i s (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(i : intsize) (s : signedness) (a : attr) (i0 : intsize) (s0 : signedness) (a0 : attr) (H0 H1 : True)","proofString":"split; apply wt_cast_int."},{"statement":"(s : signedness) (a : attr) (s0 : signedness) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if signedness_eq s s0\n then OK (Tlong s (attr_combine a a0))\n else Error (msg \"incompatible long types\")) = OK t) : classify_cast (Tlong s a) t <> cast_case_default /\\\nclassify_cast (Tlong s0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tlong s a) t <> cast_case_default /\\\nclassify_cast (Tlong s0 a0) t <> cast_case_default","hypotheses":"(s : signedness) (a : attr) (s0 : signedness) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if signedness_eq s s0\n then OK (Tlong s (attr_combine a a0))\n else Error (msg \"incompatible long types\")) = OK t)","proofString":"destruct (signedness_eq s s0); inv H3.\nsimpl; split; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(a : attr) (s0 : signedness) (a0 : attr) (H0 H1 : True) : classify_cast (Tlong s0 a) (Tlong s0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tlong s0 a0) (Tlong s0 (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tlong s0 a) (Tlong s0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tlong s0 a0) (Tlong s0 (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(a : attr) (s0 : signedness) (a0 : attr) (H0 H1 : True)","proofString":"simpl; split; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(f : floatsize) (a : attr) (f0 : floatsize) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if floatsize_eq f f0\n then OK (Tfloat f (attr_combine a a0))\n else Error (msg \"incompatible float types\")) = OK t) : classify_cast (Tfloat f a) t <> cast_case_default /\\\nclassify_cast (Tfloat f0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tfloat f a) t <> cast_case_default /\\\nclassify_cast (Tfloat f0 a0) t <> cast_case_default","hypotheses":"(f : floatsize) (a : attr) (f0 : floatsize) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if floatsize_eq f f0\n then OK (Tfloat f (attr_combine a a0))\n else Error (msg \"incompatible float types\")) = OK t)","proofString":"destruct (floatsize_eq f f0); inv H3.\nsimpl; destruct f0; split; congruence."},{"statement":"(a : attr) (f0 : floatsize) (a0 : attr) (H0 H1 : True) : classify_cast (Tfloat f0 a) (Tfloat f0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tfloat f0 a0) (Tfloat f0 (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tfloat f0 a) (Tfloat f0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tfloat f0 a0) (Tfloat f0 (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(a : attr) (f0 : floatsize) (a0 : attr) (H0 H1 : True)","proofString":"simpl; destruct f0; split; congruence."},{"statement":"(t1 : type) (a : attr) (t2 : type) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (do t0 <- type_combine t1 t2; OK (Tpointer t0 (attr_combine a a0))) = OK t) : classify_cast (Tpointer t1 a) t <> cast_case_default /\\\nclassify_cast (Tpointer t2 a0) t <> cast_case_default.","conclusion":"classify_cast (Tpointer t1 a) t <> cast_case_default /\\\nclassify_cast (Tpointer t2 a0) t <> cast_case_default","hypotheses":"(t1 : type) (a : attr) (t2 : type) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (do t0 <- type_combine t1 t2; OK (Tpointer t0 (attr_combine a a0))) = OK t)","proofString":"monadInv H3.\nsimpl; split; congruence."},{"statement":"(t1 : type) (a : attr) (t2 : type) (a0 : attr) (H0 H1 : True) (x : type) (EQ : type_combine t1 t2 = OK x) : classify_cast (Tpointer t1 a) (Tpointer x (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tpointer t2 a0) (Tpointer x (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tpointer t1 a) (Tpointer x (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tpointer t2 a0) (Tpointer x (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(t1 : type) (a : attr) (t2 : type) (a0 : attr) (H0 H1 : True) (x : type) (EQ : type_combine t1 t2 = OK x)","proofString":"simpl; split; congruence."},{"statement":"(t1 : type) (z : Z) (a : attr) (t2 : type) (z0 : Z) (a0 : attr) (t : type) (H0 H1 : False) (H3 : (do t0 <- type_combine t1 t2;\n if zeq z z0\n then OK (Tarray t0 z (attr_combine a a0))\n else Error (msg \"incompatible array types\")) = OK t) : classify_cast (Tarray t1 z a) t <> cast_case_default /\\\nclassify_cast (Tarray t2 z0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tarray t1 z a) t <> cast_case_default /\\\nclassify_cast (Tarray t2 z0 a0) t <> cast_case_default","hypotheses":"(t1 : type) (z : Z) (a : attr) (t2 : type) (z0 : Z) (a0 : attr) (t : type) (H0 H1 : False) (H3 : (do t0 <- type_combine t1 t2;\n if zeq z z0\n then OK (Tarray t0 z (attr_combine a a0))\n else Error (msg \"incompatible array types\")) = OK t)","proofString":"contradiction."},{"statement":"(l : list type) (t1 : type) (c : calling_convention) (l0 : list type) (t2 : type) (c0 : calling_convention) (t : type) (H0 H1 : False) (H3 : (do res <- type_combine t1 t2;\n do args <-\n (if cc_unproto c\n  then OK l0\n  else\n   if cc_unproto c0\n   then OK l\n   else\n    (fix typelist_combine (tl1 tl2 : list type) {struct tl1} :\n         Errors.res (list type) :=\n       match tl1 with\n       | nil =>\n           match tl2 with\n           | nil => OK nil\n           | _ :: _ => Error (msg \"incompatible function types\")\n           end\n       | t0 :: tl0 =>\n           match tl2 with\n           | nil => Error (msg \"incompatible function types\")\n           | t3 :: tl3 =>\n               do t4 <- type_combine t0 t3;\n               do tl <- typelist_combine tl0 tl3; OK (t4 :: tl)\n           end\n       end) l l0); do cc <- callconv_combine c c0; OK (Tfunction args res cc)) =\nOK t) : classify_cast (Tfunction l t1 c) t <> cast_case_default /\\\nclassify_cast (Tfunction l0 t2 c0) t <> cast_case_default.","conclusion":"classify_cast (Tfunction l t1 c) t <> cast_case_default /\\\nclassify_cast (Tfunction l0 t2 c0) t <> cast_case_default","hypotheses":"(l : list type) (t1 : type) (c : calling_convention) (l0 : list type) (t2 : type) (c0 : calling_convention) (t : type) (H0 H1 : False) (H3 : (do res <- type_combine t1 t2;\n do args <-\n (if cc_unproto c\n  then OK l0\n  else\n   if cc_unproto c0\n   then OK l\n   else\n    (fix typelist_combine (tl1 tl2 : list type) {struct tl1} :\n         Errors.res (list type) :=\n       match tl1 with\n       | nil =>\n           match tl2 with\n           | nil => OK nil\n           | _ :: _ => Error (msg \"incompatible function types\")\n           end\n       | t0 :: tl0 =>\n           match tl2 with\n           | nil => Error (msg \"incompatible function types\")\n           | t3 :: tl3 =>\n               do t4 <- type_combine t0 t3;\n               do tl <- typelist_combine tl0 tl3; OK (t4 :: tl)\n           end\n       end) l l0); do cc <- callconv_combine c c0; OK (Tfunction args res cc)) =\nOK t)","proofString":"contradiction."},{"statement":"(i : ident) (a : attr) (i0 : ident) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if ident_eq i i0\n then OK (Tstruct i (attr_combine a a0))\n else Error (msg \"incompatible struct types\")) = OK t) : classify_cast (Tstruct i a) t <> cast_case_default /\\\nclassify_cast (Tstruct i0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tstruct i a) t <> cast_case_default /\\\nclassify_cast (Tstruct i0 a0) t <> cast_case_default","hypotheses":"(i : ident) (a : attr) (i0 : ident) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if ident_eq i i0\n then OK (Tstruct i (attr_combine a a0))\n else Error (msg \"incompatible struct types\")) = OK t)","proofString":"destruct (ident_eq i i0); inv H3.\nsimpl; split; congruence."},{"statement":"(a : attr) (i0 : ident) (a0 : attr) (H0 H1 : True) : classify_cast (Tstruct i0 a) (Tstruct i0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tstruct i0 a0) (Tstruct i0 (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tstruct i0 a) (Tstruct i0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tstruct i0 a0) (Tstruct i0 (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(a : attr) (i0 : ident) (a0 : attr) (H0 H1 : True)","proofString":"simpl; split; congruence."},{"statement":"(i : ident) (a : attr) (i0 : ident) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if ident_eq i i0\n then OK (Tunion i (attr_combine a a0))\n else Error (msg \"incompatible union types\")) = OK t) : classify_cast (Tunion i a) t <> cast_case_default /\\\nclassify_cast (Tunion i0 a0) t <> cast_case_default.","conclusion":"classify_cast (Tunion i a) t <> cast_case_default /\\\nclassify_cast (Tunion i0 a0) t <> cast_case_default","hypotheses":"(i : ident) (a : attr) (i0 : ident) (a0 : attr) (t : type) (H0 H1 : True) (H3 : (if ident_eq i i0\n then OK (Tunion i (attr_combine a a0))\n else Error (msg \"incompatible union types\")) = OK t)","proofString":"destruct (ident_eq i i0); inv H3.\nsimpl; split; congruence."},{"statement":"(a : attr) (i0 : ident) (a0 : attr) (H0 H1 : True) : classify_cast (Tunion i0 a) (Tunion i0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tunion i0 a0) (Tunion i0 (attr_combine a a0)) <>\ncast_case_default.","conclusion":"classify_cast (Tunion i0 a) (Tunion i0 (attr_combine a a0)) <>\ncast_case_default /\\\nclassify_cast (Tunion i0 a0) (Tunion i0 (attr_combine a a0)) <>\ncast_case_default","hypotheses":"(a : attr) (i0 : ident) (a0 : attr) (H0 H1 : True)","proofString":"simpl; split; congruence."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t)","proofString":"assert (A: forall x, match typeconv x with Tarray _ _ _ => False | Tfunction _ _ _ => False | _ => True end).\ndestruct x; simpl; auto.\ndestruct i; auto.\nassert (D: type_combine (typeconv t1) (typeconv t2) = OK t -> wt_cast t1 t /\\ wt_cast t2 t).\nintros.\napply type_combine_cast in H0.\ndestruct H0; split; apply typeconv_cast; auto.\napply A.\napply A.\nclear A.\nunfold type_conditional in H.\ndestruct (typeconv t1) eqn:T1; try discriminate;  destruct (typeconv t2) eqn:T2; inv H; eauto using D, binarith_type_cast.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend.","conclusion":"forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t)","proofString":"destruct x; simpl; auto.\ndestruct i; auto."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (i : intsize) (s : signedness) (a : attr) : match\n  match i with\n  | I32 => Tint i s noattr\n  | _ => Tint I32 Signed noattr\n  end\nwith\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend.","conclusion":"match\n  match i with\n  | I32 => Tint i s noattr\n  | _ => Tint I32 Signed noattr\n  end\nwith\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (i : intsize) (s : signedness) (a : attr)","proofString":"destruct i; auto."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend)","proofString":"assert (D: type_combine (typeconv t1) (typeconv t2) = OK t -> wt_cast t1 t /\\ wt_cast t2 t).\nintros.\napply type_combine_cast in H0.\ndestruct H0; split; apply typeconv_cast; auto.\napply A.\napply A.\nclear A.\nunfold type_conditional in H.\ndestruct (typeconv t1) eqn:T1; try discriminate;  destruct (typeconv t2) eqn:T2; inv H; eauto using D, binarith_type_cast.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t.","conclusion":"type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend)","proofString":"intros.\napply type_combine_cast in H0.\ndestruct H0; split; apply typeconv_cast; auto.\napply A.\napply A."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t)","proofString":"apply type_combine_cast in H0.\ndestruct H0; split; apply typeconv_cast; auto.\napply A.\napply A."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : wt_cast (typeconv t1) t /\\ wt_cast (typeconv t2) t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : wt_cast (typeconv t1) t /\\ wt_cast (typeconv t2) t)","proofString":"destruct H0; split; apply typeconv_cast; auto."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t) : match typeconv t1 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend.","conclusion":"match typeconv t1 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t)","proofString":"apply A."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t) : match typeconv t2 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend.","conclusion":"match typeconv t2 with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (H0 : type_combine (typeconv t1) (typeconv t2) = OK t)","proofString":"apply A."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (A : forall x : type,\nmatch typeconv x with\n| Tarray _ _ _ | Tfunction _ _ _ => False\n| _ => True\nend) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t)","proofString":"clear A.\nunfold type_conditional in H.\ndestruct (typeconv t1) eqn:T1; try discriminate;  destruct (typeconv t2) eqn:T2; inv H; eauto using D, binarith_type_cast.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : type_conditional t1 t2 = OK t) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t)","proofString":"unfold type_conditional in H.\ndestruct (typeconv t1) eqn:T1; try discriminate;  destruct (typeconv t2) eqn:T2; inv H; eauto using D, binarith_type_cast.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t : type) (H : match typeconv t1 with\n| Tvoid => type_combine Tvoid (typeconv t2)\n| Tint i s a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tint i s a) Tvoid\n    | Tpointer t0 _ => OK (Tpointer t0 noattr)\n    | Tarray t0 z a0 => type_combine (Tint i s a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tint i s a) (Tfunction l t0 c)\n    | Tstruct i0 a0 => type_combine (Tint i s a) (Tstruct i0 a0)\n    | Tunion i0 a0 => type_combine (Tint i s a) (Tunion i0 a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tlong s a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tlong s a) Tvoid\n    | Tpointer t0 a0 => type_combine (Tlong s a) (Tpointer t0 a0)\n    | Tarray t0 z a0 => type_combine (Tlong s a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tlong s a) (Tfunction l t0 c)\n    | Tstruct i a0 => type_combine (Tlong s a) (Tstruct i a0)\n    | Tunion i a0 => type_combine (Tlong s a) (Tunion i a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tfloat f a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tfloat f a) Tvoid\n    | Tpointer t0 a0 => type_combine (Tfloat f a) (Tpointer t0 a0)\n    | Tarray t0 z a0 => type_combine (Tfloat f a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tfloat f a) (Tfunction l t0 c)\n    | Tstruct i a0 => type_combine (Tfloat f a) (Tstruct i a0)\n    | Tunion i a0 => type_combine (Tfloat f a) (Tunion i a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tpointer t0 a1 =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tpointer t0 a1) Tvoid\n    | Tint _ _ _ => OK (Tpointer t0 noattr)\n    | Tlong s a => type_combine (Tpointer t0 a1) (Tlong s a)\n    | Tfloat f a => type_combine (Tpointer t0 a1) (Tfloat f a)\n    | Tpointer t3 _ =>\n        OK\n          (Tpointer\n             (if is_void t0 || is_void t3\n              then Tvoid\n              else\n               match type_combine t0 t3 with\n               | OK t4 => t4\n               | Error _ => Tvoid\n               end) noattr)\n    | Tarray t3 z a => type_combine (Tpointer t0 a1) (Tarray t3 z a)\n    | Tfunction l t3 c => type_combine (Tpointer t0 a1) (Tfunction l t3 c)\n    | Tstruct i a => type_combine (Tpointer t0 a1) (Tstruct i a)\n    | Tunion i a => type_combine (Tpointer t0 a1) (Tunion i a)\n    end\n| Tarray t0 z a => type_combine (Tarray t0 z a) (typeconv t2)\n| Tfunction l t0 c => type_combine (Tfunction l t0 c) (typeconv t2)\n| Tstruct i a => type_combine (Tstruct i a) (typeconv t2)\n| Tunion i a => type_combine (Tunion i a) (typeconv t2)\nend = OK t) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t) : wt_cast t1 t /\\ wt_cast t2 t.","conclusion":"wt_cast t1 t /\\ wt_cast t2 t","hypotheses":"(t1 t2 t : type) (H : match typeconv t1 with\n| Tvoid => type_combine Tvoid (typeconv t2)\n| Tint i s a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tint i s a) Tvoid\n    | Tpointer t0 _ => OK (Tpointer t0 noattr)\n    | Tarray t0 z a0 => type_combine (Tint i s a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tint i s a) (Tfunction l t0 c)\n    | Tstruct i0 a0 => type_combine (Tint i s a) (Tstruct i0 a0)\n    | Tunion i0 a0 => type_combine (Tint i s a) (Tunion i0 a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tlong s a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tlong s a) Tvoid\n    | Tpointer t0 a0 => type_combine (Tlong s a) (Tpointer t0 a0)\n    | Tarray t0 z a0 => type_combine (Tlong s a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tlong s a) (Tfunction l t0 c)\n    | Tstruct i a0 => type_combine (Tlong s a) (Tstruct i a0)\n    | Tunion i a0 => type_combine (Tlong s a) (Tunion i a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tfloat f a =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tfloat f a) Tvoid\n    | Tpointer t0 a0 => type_combine (Tfloat f a) (Tpointer t0 a0)\n    | Tarray t0 z a0 => type_combine (Tfloat f a) (Tarray t0 z a0)\n    | Tfunction l t0 c => type_combine (Tfloat f a) (Tfunction l t0 c)\n    | Tstruct i a0 => type_combine (Tfloat f a) (Tstruct i a0)\n    | Tunion i a0 => type_combine (Tfloat f a) (Tunion i a0)\n    | _ => binarith_type t1 t2 \"conditional expression\"\n    end\n| Tpointer t0 a1 =>\n    match typeconv t2 with\n    | Tvoid => type_combine (Tpointer t0 a1) Tvoid\n    | Tint _ _ _ => OK (Tpointer t0 noattr)\n    | Tlong s a => type_combine (Tpointer t0 a1) (Tlong s a)\n    | Tfloat f a => type_combine (Tpointer t0 a1) (Tfloat f a)\n    | Tpointer t3 _ =>\n        OK\n          (Tpointer\n             (if is_void t0 || is_void t3\n              then Tvoid\n              else\n               match type_combine t0 t3 with\n               | OK t4 => t4\n               | Error _ => Tvoid\n               end) noattr)\n    | Tarray t3 z a => type_combine (Tpointer t0 a1) (Tarray t3 z a)\n    | Tfunction l t3 c => type_combine (Tpointer t0 a1) (Tfunction l t3 c)\n    | Tstruct i a => type_combine (Tpointer t0 a1) (Tstruct i a)\n    | Tunion i a => type_combine (Tpointer t0 a1) (Tunion i a)\n    end\n| Tarray t0 z a => type_combine (Tarray t0 z a) (typeconv t2)\n| Tfunction l t0 c => type_combine (Tfunction l t0 c) (typeconv t2)\n| Tstruct i a => type_combine (Tstruct i a) (typeconv t2)\n| Tunion i a => type_combine (Tunion i a) (typeconv t2)\nend = OK t) (D : type_combine (typeconv t1) (typeconv t2) = OK t ->\nwt_cast t1 t /\\ wt_cast t2 t)","proofString":"destruct (typeconv t1) eqn:T1; try discriminate;  destruct (typeconv t2) eqn:T2; inv H; eauto using D, binarith_type_cast.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence.\nsplit; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : wt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr).","conclusion":"wt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)","hypotheses":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"split; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : classify_cast (typeconv t1) (Tpointer t0 noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t1) (Tpointer t0 noattr) <> cast_case_default","hypotheses":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"rewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : classify_cast (typeconv t2) (Tpointer t0 noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t2) (Tpointer t0 noattr) <> cast_case_default","hypotheses":"(t1 t2 : type) (i : intsize) (s : signedness) (a : attr) (T1 : typeconv t1 = Tint i s a) (t0 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t0 a0) (D : type_combine (Tint i s a) (Tpointer t0 a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"rewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : wt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr).","conclusion":"wt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"split; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : classify_cast (typeconv t1) (Tpointer t0 noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t1) (Tpointer t0 noattr) <> cast_case_default","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"rewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr)) : classify_cast (typeconv t2) (Tpointer t0 noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t2) (Tpointer t0 noattr) <> cast_case_default","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (i : intsize) (s : signedness) (a0 : attr) (T2 : typeconv t2 = Tint i s a0) (D : type_combine (Tpointer t0 a) (Tint i s a0) = OK (Tpointer t0 noattr) ->\nwt_cast t1 (Tpointer t0 noattr) /\\ wt_cast t2 (Tpointer t0 noattr))","proofString":"rewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr)) : wt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr).","conclusion":"wt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr)","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr))","proofString":"split; apply typeconv_cast; unfold wt_cast.\nrewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence.\nrewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr)) : classify_cast (typeconv t1)\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t1)\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) <> cast_case_default","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr))","proofString":"rewrite T1; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr)) : classify_cast (typeconv t2)\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) <> cast_case_default.","conclusion":"classify_cast (typeconv t2)\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) <> cast_case_default","hypotheses":"(t1 t2 t0 : type) (a : attr) (T1 : typeconv t1 = Tpointer t0 a) (t3 : type) (a0 : attr) (T2 : typeconv t2 = Tpointer t3 a0) (D : type_combine (Tpointer t0 a) (Tpointer t3 a0) =\nOK\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) ->\nwt_cast t1\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr) /\\\nwt_cast t2\n  (Tpointer\n     (if is_void t0 || is_void t3\n      then Tvoid\n      else match type_combine t0 t3 with\n           | OK t => t\n           | Error _ => Tvoid\n           end) noattr))","proofString":"rewrite T2; simpl; try congruence; destruct Archi.ptr64; congruence."},{"statement":"(a : expr) (x : unit) (H : match expr_kind a with\n| LV => wt_lvalue ce e a\n| RV => wt_rvalue ce e a\nend) (H0 : check_rval a = OK x) : wt_rvalue ce e a.","conclusion":"wt_rvalue ce e a","hypotheses":"(a : expr) (x : unit) (H : match expr_kind a with\n| LV => wt_lvalue ce e a\n| RV => wt_rvalue ce e a\nend) (H0 : check_rval a = OK x)","proofString":"erewrite check_rval_sound in H by eauto.\nauto."},{"statement":"(a : expr) (x : unit) (H : wt_rvalue ce e a) (H0 : check_rval a = OK x) : wt_rvalue ce e a.","conclusion":"wt_rvalue ce e a","hypotheses":"(a : expr) (x : unit) (H : wt_rvalue ce e a) (H0 : check_rval a = OK x)","proofString":"auto."},{"statement":"(a : expr) (x : unit) (H : match expr_kind a with\n| LV => wt_lvalue ce e a\n| RV => wt_rvalue ce e a\nend) (H0 : check_lval a = OK x) : wt_lvalue ce e a.","conclusion":"wt_lvalue ce e a","hypotheses":"(a : expr) (x : unit) (H : match expr_kind a with\n| LV => wt_lvalue ce e a\n| RV => wt_rvalue ce e a\nend) (H0 : check_lval a = OK x)","proofString":"erewrite check_lval_sound in H by eauto.\nauto."},{"statement":"(a : expr) (x : unit) (H : wt_lvalue ce e a) (H0 : check_lval a = OK x) : wt_lvalue ce e a.","conclusion":"wt_lvalue ce e a","hypotheses":"(a : expr) (x : unit) (H : wt_lvalue ce e a) (H0 : check_lval a = OK x)","proofString":"auto."},{"statement":"(x : ident) (a : expr) (H : match e ! x with\n| Some ty => OK (Evar x ty)\n| None => Error (MSG \"unbound variable \" :: CTX x :: nil)\nend = OK a) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(x : ident) (a : expr) (H : match e ! x with\n| Some ty => OK (Evar x ty)\n| None => Error (MSG \"unbound variable \" :: CTX x :: nil)\nend = OK a)","proofString":"destruct (e!x) as [ty|] eqn:E; inv H.\neauto with ty."},{"statement":"(x : ident) (ty : type) (E : e ! x = Some ty) : wt_expr ce e (Evar x ty).","conclusion":"wt_expr ce e (Evar x ty)","hypotheses":"(x : ident) (ty : type) (E : e ! x = Some ty)","proofString":"eauto with ty."},{"statement":"(r a : expr) (H : ederef r = OK a) (H0 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r a : expr) (H : ederef r = OK a) (H0 : wt_expr ce e r)","proofString":"monadInv H.\neauto with ty."},{"statement":"(r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : type) (EQ1 : type_deref (typeof r) = OK x0) : wt_expr ce e (Ederef r x0).","conclusion":"wt_expr ce e (Ederef r x0)","hypotheses":"(r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : type) (EQ1 : type_deref (typeof r) = OK x0)","proofString":"eauto with ty."},{"statement":"(r : expr) (f : ident) (a : expr) (H : efield ce r f = OK a) (H0 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r : expr) (f : ident) (a : expr) (H : efield ce r f = OK a) (H0 : wt_expr ce e r)","proofString":"monadInv H.\ndestruct (typeof r) eqn:TR; try discriminate;  destruct (ce!i) as [co|] eqn:CE; monadInv EQ0; eauto with ty."},{"statement":"(r : expr) (f : ident) (a : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (EQ0 : match typeof r with\n| Tstruct id a0 | Tunion id a0 =>\n    match ce ! id with\n    | Some co =>\n        do ty <- type_of_member a0 f (co_members co); OK (Efield r f ty)\n    | None => Error (MSG \"unbound composite \" :: CTX id :: nil)\n    end\n| _ =>\n    Error\n      (MSG \"argument of .\" :: CTX f :: MSG \" is not a struct or union\" :: nil)\nend = OK a) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r : expr) (f : ident) (a : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (EQ0 : match typeof r with\n| Tstruct id a0 | Tunion id a0 =>\n    match ce ! id with\n    | Some co =>\n        do ty <- type_of_member a0 f (co_members co); OK (Efield r f ty)\n    | None => Error (MSG \"unbound composite \" :: CTX id :: nil)\n    end\n| _ =>\n    Error\n      (MSG \"argument of .\" :: CTX f :: MSG \" is not a struct or union\" :: nil)\nend = OK a)","proofString":"destruct (typeof r) eqn:TR; try discriminate;  destruct (ce!i) as [co|] eqn:CE; monadInv EQ0; eauto with ty."},{"statement":"(n : int) (ty : type) : wt_expr ce e\n  (Eval (if Archi.ptr64 then Vlong (Int64.repr (Int.unsigned n)) else Vint n)\n     (Tpointer ty noattr)).","conclusion":"wt_expr ce e\n  (Eval (if Archi.ptr64 then Vlong (Int64.repr (Int.unsigned n)) else Vint n)\n     (Tpointer ty noattr))","hypotheses":"(n : int) (ty : type)","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(n : int64) (ty : type) : wt_expr ce e\n  (Eval (if Archi.ptr64 then Vlong n else Vint (Int64.loword n))\n     (Tpointer ty noattr)).","conclusion":"wt_expr ce e\n  (Eval (if Archi.ptr64 then Vlong n else Vint (Int64.loword n))\n     (Tpointer ty noattr))","hypotheses":"(n : int64) (ty : type)","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(l a : expr) (H : evalof l = OK a) (H0 : wt_expr ce e l) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(l a : expr) (H : evalof l = OK a) (H0 : wt_expr ce e l)","proofString":"monadInv H.\neauto with ty."},{"statement":"(l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x) : wt_expr ce e (Evalof l (typeof l)).","conclusion":"wt_expr ce e (Evalof l (typeof l))","hypotheses":"(l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x)","proofString":"eauto with ty."},{"statement":"(l a : expr) (H : eaddrof l = OK a) (H0 : wt_expr ce e l) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(l a : expr) (H : eaddrof l = OK a) (H0 : wt_expr ce e l)","proofString":"monadInv H.\neauto with ty."},{"statement":"(l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x) : wt_expr ce e (Eaddrof l (Tpointer (typeof l) noattr)).","conclusion":"wt_expr ce e (Eaddrof l (Tpointer (typeof l) noattr))","hypotheses":"(l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x)","proofString":"eauto with ty."},{"statement":"(op : unary_operation) (r a : expr) (H : eunop op r = OK a) (H0 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(op : unary_operation) (r a : expr) (H : eunop op r = OK a) (H0 : wt_expr ce e r)","proofString":"monadInv H.\neauto with ty."},{"statement":"(op : unary_operation) (r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : type) (EQ1 : type_unop op (typeof r) = OK x0) : wt_expr ce e (Eunop op r x0).","conclusion":"wt_expr ce e (Eunop op r x0)","hypotheses":"(op : unary_operation) (r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : type) (EQ1 : type_unop op (typeof r) = OK x0)","proofString":"eauto with ty."},{"statement":"(op : binary_operation) (r1 r2 a : expr) (H : ebinop op r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(op : binary_operation) (r1 r2 a : expr) (H : ebinop op r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2)","proofString":"monadInv H.\neauto with ty."},{"statement":"(op : binary_operation) (r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : type) (EQ0 : type_binop op (typeof r1) (typeof r2) = OK x1) : wt_expr ce e (Ebinop op r1 r2 x1).","conclusion":"wt_expr ce e (Ebinop op r1 r2 x1)","hypotheses":"(op : binary_operation) (r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : type) (EQ0 : type_binop op (typeof r1) (typeof r2) = OK x1)","proofString":"eauto with ty."},{"statement":"(ty : type) (r a : expr) (H : ecast ty r = OK a) (H0 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(ty : type) (r a : expr) (H : ecast ty r = OK a) (H0 : wt_expr ce e r)","proofString":"monadInv H.\neauto with ty."},{"statement":"(ty : type) (r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : unit) (EQ1 : check_cast (typeof r) ty = OK x0) : wt_expr ce e (Ecast r ty).","conclusion":"wt_expr ce e (Ecast r ty)","hypotheses":"(ty : type) (r : expr) (H0 : wt_expr ce e r) (x : unit) (EQ : check_rval r = OK x) (x0 : unit) (EQ1 : check_cast (typeof r) ty = OK x0)","proofString":"eauto with ty."},{"statement":"(r1 r2 a : expr) (H : eseqand r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 a : expr) (H : eseqand r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_bool (typeof r1) = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r2) = OK x2) : wt_expr ce e (Eseqand r1 r2 type_int32s).","conclusion":"wt_expr ce e (Eseqand r1 r2 type_int32s)","hypotheses":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_bool (typeof r1) = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r2) = OK x2)","proofString":"eauto 10 with ty."},{"statement":"(r1 r2 a : expr) (H : eseqor r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 a : expr) (H : eseqor r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_bool (typeof r1) = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r2) = OK x2) : wt_expr ce e (Eseqor r1 r2 type_int32s).","conclusion":"wt_expr ce e (Eseqor r1 r2 type_int32s)","hypotheses":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_bool (typeof r1) = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r2) = OK x2)","proofString":"eauto 10 with ty."},{"statement":"(r1 r2 r3 a : expr) (H : econdition r1 r2 r3 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 r3 a : expr) (H : econdition r1 r2 r3 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3)","proofString":"monadInv H.\napply type_conditional_cast in EQ3.\ndestruct EQ3.\neauto 10 with ty."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : type_conditional (typeof r2) (typeof r3) = OK x3) : wt_expr ce e (Econdition r1 r2 r3 x3).","conclusion":"wt_expr ce e (Econdition r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : type_conditional (typeof r2) (typeof r3) = OK x3)","proofString":"apply type_conditional_cast in EQ3.\ndestruct EQ3.\neauto 10 with ty."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : wt_cast (typeof r2) x3 /\\ wt_cast (typeof r3) x3) : wt_expr ce e (Econdition r1 r2 r3 x3).","conclusion":"wt_expr ce e (Econdition r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : wt_cast (typeof r2) x3 /\\ wt_cast (typeof r3) x3)","proofString":"destruct EQ3.\neauto 10 with ty."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : wt_expr ce e (Econdition r1 r2 r3 x3).","conclusion":"wt_expr ce e (Econdition r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"eauto 10 with ty."},{"statement":"(r1 r2 r3 : expr) (ty : type) (a : expr) (H : econdition' r1 r2 r3 ty = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 r3 : expr) (ty : type) (a : expr) (H : econdition' r1 r2 r3 ty = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(r1 r2 r3 : expr) (ty : type) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : unit) (EQ3 : check_cast (typeof r2) ty = OK x3) (x4 : unit) (EQ4 : check_cast (typeof r3) ty = OK x4) : wt_expr ce e (Econdition r1 r2 r3 ty).","conclusion":"wt_expr ce e (Econdition r1 r2 r3 ty)","hypotheses":"(r1 r2 r3 : expr) (ty : type) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : unit) (EQ3 : check_cast (typeof r2) ty = OK x3) (x4 : unit) (EQ4 : check_cast (typeof r3) ty = OK x4)","proofString":"eauto 10 with ty."},{"statement":"(l r a : expr) (H : eassign l r = OK a) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(l r a : expr) (H : eassign l r = OK a) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(l r : expr) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) (x : unit) (EQ : check_lval l = OK x) (x0 : unit) (EQ1 : check_rval r = OK x0) (x1 : unit) (EQ0 : check_cast (typeof r) (typeof l) = OK x1) : wt_expr ce e (Eassign l r (typeof l)).","conclusion":"wt_expr ce e (Eassign l r (typeof l))","hypotheses":"(l r : expr) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) (x : unit) (EQ : check_lval l = OK x) (x0 : unit) (EQ1 : check_rval r = OK x0) (x1 : unit) (EQ0 : check_cast (typeof r) (typeof l) = OK x1)","proofString":"eauto 10 with ty."},{"statement":"(op : binary_operation) (l r a : expr) (H : eassignop op l r = OK a) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(op : binary_operation) (l r a : expr) (H : eassignop op l r = OK a) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(op : binary_operation) (l r : expr) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) (x : unit) (EQ : check_lval l = OK x) (x0 : unit) (EQ1 : check_rval r = OK x0) (x1 : type) (EQ0 : type_binop op (typeof l) (typeof r) = OK x1) (x2 : unit) (EQ2 : check_cast x1 (typeof l) = OK x2) : wt_expr ce e (Eassignop op l r x1 (typeof l)).","conclusion":"wt_expr ce e (Eassignop op l r x1 (typeof l))","hypotheses":"(op : binary_operation) (l r : expr) (H0 : wt_expr ce e l) (H1 : wt_expr ce e r) (x : unit) (EQ : check_lval l = OK x) (x0 : unit) (EQ1 : check_rval r = OK x0) (x1 : type) (EQ0 : type_binop op (typeof l) (typeof r) = OK x1) (x2 : unit) (EQ2 : check_cast x1 (typeof l) = OK x2)","proofString":"eauto 10 with ty."},{"statement":"(id : incr_or_decr) (l a : expr) (H : epostincrdecr id l = OK a) (H0 : wt_expr ce e l) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(id : incr_or_decr) (l a : expr) (H : epostincrdecr id l = OK a) (H0 : wt_expr ce e l)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(id : incr_or_decr) (l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x) (x0 : type) (EQ1 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end (typeof l) type_int32s = OK x0) (x1 : unit) (EQ0 : check_cast (incrdecr_type (typeof l)) (typeof l) = OK x1) : wt_expr ce e (Epostincr id l (typeof l)).","conclusion":"wt_expr ce e (Epostincr id l (typeof l))","hypotheses":"(id : incr_or_decr) (l : expr) (H0 : wt_expr ce e l) (x : unit) (EQ : check_lval l = OK x) (x0 : type) (EQ1 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end (typeof l) type_int32s = OK x0) (x1 : unit) (EQ0 : check_cast (incrdecr_type (typeof l)) (typeof l) = OK x1)","proofString":"eauto 10 with ty."},{"statement":"(r1 r2 a : expr) (H : ecomma r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 a : expr) (H : ecomma r1 r2 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2)","proofString":"monadInv H.\neauto with ty."},{"statement":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) : wt_expr ce e (Ecomma r1 r2 (typeof r2)).","conclusion":"wt_expr ce e (Ecomma r1 r2 (typeof r2))","hypotheses":"(r1 r2 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0)","proofString":"eauto with ty."},{"statement":"(fn : expr) (args : exprlist) (a : expr) (H : ecall fn args = OK a) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(fn : expr) (args : exprlist) (a : expr) (H : ecall fn args = OK a) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args)","proofString":"monadInv H.\ndestruct (classify_fun (typeof fn)) eqn:CF; monadInv EQ2.\neconstructor; eauto with ty.\neapply check_arguments_sound; eauto."},{"statement":"(fn : expr) (args : exprlist) (a : expr) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (EQ2 : match classify_fun (typeof fn) with\n| fun_case_f tyargs tyres _ =>\n    do _ <- check_arguments args tyargs; OK (Ecall fn args tyres)\n| fun_default => Error (msg \"call: not a function\")\nend = OK a) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(fn : expr) (args : exprlist) (a : expr) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (EQ2 : match classify_fun (typeof fn) with\n| fun_case_f tyargs tyres _ =>\n    do _ <- check_arguments args tyargs; OK (Ecall fn args tyres)\n| fun_default => Error (msg \"call: not a function\")\nend = OK a)","proofString":"destruct (classify_fun (typeof fn)) eqn:CF; monadInv EQ2.\neconstructor; eauto with ty.\neapply check_arguments_sound; eauto."},{"statement":"(fn : expr) (args : exprlist) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (targs : list type) (tres : type) (cc : calling_convention) (CF : classify_fun (typeof fn) = fun_case_f targs tres cc) (x1 : unit) (EQ0 : check_arguments args targs = OK x1) : wt_expr ce e (Ecall fn args tres).","conclusion":"wt_expr ce e (Ecall fn args tres)","hypotheses":"(fn : expr) (args : exprlist) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (targs : list type) (tres : type) (cc : calling_convention) (CF : classify_fun (typeof fn) = fun_case_f targs tres cc) (x1 : unit) (EQ0 : check_arguments args targs = OK x1)","proofString":"econstructor; eauto with ty.\neapply check_arguments_sound; eauto."},{"statement":"(fn : expr) (args : exprlist) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (targs : list type) (tres : type) (cc : calling_convention) (CF : classify_fun (typeof fn) = fun_case_f targs tres cc) (x1 : unit) (EQ0 : check_arguments args targs = OK x1) : wt_arguments args targs.","conclusion":"wt_arguments args targs","hypotheses":"(fn : expr) (args : exprlist) (H0 : wt_expr ce e fn) (H1 : wt_exprlist ce e args) (x : unit) (EQ : check_rval fn = OK x) (x0 : unit) (EQ1 : check_rvals args = OK x0) (targs : list type) (tres : type) (cc : calling_convention) (CF : classify_fun (typeof fn) = fun_case_f targs tres cc) (x1 : unit) (EQ0 : check_arguments args targs = OK x1)","proofString":"eapply check_arguments_sound; eauto."},{"statement":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H : ebuiltin ef tyargs args tyres = OK a) (H0 : wt_exprlist ce e args) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H : ebuiltin ef tyargs args tyres = OK a) (H0 : wt_exprlist ce e args)","proofString":"monadInv H.\ndestruct (type_eq tyres Tvoid); simpl in EQ2; try discriminate.\ndestruct (xtype_eq (sig_res (ef_sig ef)) Xvoid); inv EQ2.\neconstructor; eauto.\neapply check_arguments_sound; eauto."},{"statement":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (EQ2 : (if type_eq tyres Tvoid && xtype_eq (sig_res (ef_sig ef)) Xvoid\n then OK (Ebuiltin ef tyargs args tyres)\n else Error (msg \"builtin: wrong type decoration\")) = \nOK a) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (EQ2 : (if type_eq tyres Tvoid && xtype_eq (sig_res (ef_sig ef)) Xvoid\n then OK (Ebuiltin ef tyargs args tyres)\n else Error (msg \"builtin: wrong type decoration\")) = \nOK a)","proofString":"destruct (type_eq tyres Tvoid); simpl in EQ2; try discriminate.\ndestruct (xtype_eq (sig_res (ef_sig ef)) Xvoid); inv EQ2.\neconstructor; eauto.\neapply check_arguments_sound; eauto."},{"statement":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e0 : tyres = Tvoid) (EQ2 : (if proj_sumbool (xtype_eq (sig_res (ef_sig ef)) Xvoid)\n then OK (Ebuiltin ef tyargs args tyres)\n else Error (msg \"builtin: wrong type decoration\")) = \nOK a) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(ef : external_function) (tyargs : list type) (args : exprlist) (tyres : type) (a : expr) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e0 : tyres = Tvoid) (EQ2 : (if proj_sumbool (xtype_eq (sig_res (ef_sig ef)) Xvoid)\n then OK (Ebuiltin ef tyargs args tyres)\n else Error (msg \"builtin: wrong type decoration\")) = \nOK a)","proofString":"destruct (xtype_eq (sig_res (ef_sig ef)) Xvoid); inv EQ2.\neconstructor; eauto.\neapply check_arguments_sound; eauto."},{"statement":"(ef : external_function) (tyargs : list type) (args : exprlist) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e1 : sig_res (ef_sig ef) = Xvoid) : wt_expr ce e (Ebuiltin ef tyargs args Tvoid).","conclusion":"wt_expr ce e (Ebuiltin ef tyargs args Tvoid)","hypotheses":"(ef : external_function) (tyargs : list type) (args : exprlist) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e1 : sig_res (ef_sig ef) = Xvoid)","proofString":"econstructor; eauto.\neapply check_arguments_sound; eauto."},{"statement":"(ef : external_function) (tyargs : list type) (args : exprlist) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e1 : sig_res (ef_sig ef) = Xvoid) : wt_arguments args tyargs.","conclusion":"wt_arguments args tyargs","hypotheses":"(ef : external_function) (tyargs : list type) (args : exprlist) (H0 : wt_exprlist ce e args) (x : unit) (EQ : check_rvals args = OK x) (x0 : unit) (EQ1 : check_arguments args tyargs = OK x0) (e1 : sig_res (ef_sig ef) = Xvoid)","proofString":"eapply check_arguments_sound; eauto."},{"statement":"(r1 r2 r3 a : expr) (H : eselection r1 r2 r3 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) : wt_expr ce e a.","conclusion":"wt_expr ce e a","hypotheses":"(r1 r2 r3 a : expr) (H : eselection r1 r2 r3 = OK a) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3)","proofString":"monadInv H.\napply type_conditional_cast in EQ3.\ndestruct EQ3.\neapply wt_Ebuiltin.\nrepeat (constructor; eauto with ty).\nrepeat (constructor; eauto with ty).\napply wt_bool_cast; eauto with ty.\nright; auto."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : type_conditional (typeof r2) (typeof r3) = OK x3) : wt_expr ce e (Eselection r1 r2 r3 x3).","conclusion":"wt_expr ce e (Eselection r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : type_conditional (typeof r2) (typeof r3) = OK x3)","proofString":"apply type_conditional_cast in EQ3.\ndestruct EQ3.\neapply wt_Ebuiltin.\nrepeat (constructor; eauto with ty).\nrepeat (constructor; eauto with ty).\napply wt_bool_cast; eauto with ty.\nright; auto."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : wt_cast (typeof r2) x3 /\\ wt_cast (typeof r3) x3) : wt_expr ce e (Eselection r1 r2 r3 x3).","conclusion":"wt_expr ce e (Eselection r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (EQ3 : wt_cast (typeof r2) x3 /\\ wt_cast (typeof r3) x3)","proofString":"destruct EQ3.\neapply wt_Ebuiltin.\nrepeat (constructor; eauto with ty).\nrepeat (constructor; eauto with ty).\napply wt_bool_cast; eauto with ty.\nright; auto."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : wt_expr ce e (Eselection r1 r2 r3 x3).","conclusion":"wt_expr ce e (Eselection r1 r2 r3 x3)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"eapply wt_Ebuiltin.\nrepeat (constructor; eauto with ty).\nrepeat (constructor; eauto with ty).\napply wt_bool_cast; eauto with ty.\nright; auto."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : wt_exprlist ce e (Econs r1 (Econs r2 (Econs r3 Enil))).","conclusion":"wt_exprlist ce e (Econs r1 (Econs r2 (Econs r3 Enil)))","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"repeat (constructor; eauto with ty)."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : wt_arguments (Econs r1 (Econs r2 (Econs r3 Enil)))\n  (type_bool :: x3 :: x3 :: nil).","conclusion":"wt_arguments (Econs r1 (Econs r2 (Econs r3 Enil)))\n  (type_bool :: x3 :: x3 :: nil)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"repeat (constructor; eauto with ty).\napply wt_bool_cast; eauto with ty."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : wt_cast (typeof r1) type_bool.","conclusion":"wt_cast (typeof r1) type_bool","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"apply wt_bool_cast; eauto with ty."},{"statement":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3) : x3 = Tvoid /\\\nsig_res\n  (ef_sig\n     (EF_builtin \"__builtin_sel\"\n        [Xint; inj_type (typ_of_type x3); inj_type (typ_of_type x3) --->\n        inj_type (typ_of_type x3)]%asttyp)) = Xvoid \\/\ntype_bool :: x3 :: x3 :: nil = type_bool :: x3 :: x3 :: nil /\\\n(let t := typ_of_type x3 in\n let x4 := inj_type t in\n let sg := [Xint; x4; x4 ---> x4]%asttyp in\n EF_builtin \"__builtin_sel\"\n   [Xint; inj_type (typ_of_type x3); inj_type (typ_of_type x3) --->\n   inj_type (typ_of_type x3)]%asttyp = EF_builtin \"__builtin_sel\" sg).","conclusion":"x3 = Tvoid /\\\nsig_res\n  (ef_sig\n     (EF_builtin \"__builtin_sel\"\n        [Xint; inj_type (typ_of_type x3); inj_type (typ_of_type x3) --->\n        inj_type (typ_of_type x3)]%asttyp)) = Xvoid \\/\ntype_bool :: x3 :: x3 :: nil = type_bool :: x3 :: x3 :: nil /\\\n(let t := typ_of_type x3 in\n let x4 := inj_type t in\n let sg := [Xint; x4; x4 ---> x4]%asttyp in\n EF_builtin \"__builtin_sel\"\n   [Xint; inj_type (typ_of_type x3); inj_type (typ_of_type x3) --->\n   inj_type (typ_of_type x3)]%asttyp = EF_builtin \"__builtin_sel\" sg)","hypotheses":"(r1 r2 r3 : expr) (H0 : wt_expr ce e r1) (H1 : wt_expr ce e r2) (H2 : wt_expr ce e r3) (x : unit) (EQ : check_rval r1 = OK x) (x0 : unit) (EQ1 : check_rval r2 = OK x0) (x1 : unit) (EQ0 : check_rval r3 = OK x1) (x2 : unit) (EQ2 : check_bool (typeof r1) = OK x2) (x3 : type) (H : wt_cast (typeof r2) x3) (H3 : wt_cast (typeof r3) x3)","proofString":"right; auto."},{"statement":"(a : expr) (s : statement) (H : sdo a = OK s) (H0 : wt_expr ce e a) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (s : statement) (H : sdo a = OK s) (H0 : wt_expr ce e a)","proofString":"monadInv H.\neauto with ty."},{"statement":"(a : expr) (H0 : wt_expr ce e a) (x : unit) (EQ : check_rval a = OK x) : wt_stmt ce e rt (Sdo a).","conclusion":"wt_stmt ce e rt (Sdo a)","hypotheses":"(a : expr) (H0 : wt_expr ce e a) (x : unit) (EQ : check_rval a = OK x)","proofString":"eauto with ty."},{"statement":"(a : expr) (s1 s2 s : statement) (H : sifthenelse a s1 s2 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (H2 : wt_stmt ce e rt s2) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (s1 s2 s : statement) (H : sifthenelse a s1 s2 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (H2 : wt_stmt ce e rt s2)","proofString":"monadInv H.\neauto with ty."},{"statement":"(a : expr) (s1 s2 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (H2 : wt_stmt ce e rt s2) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0) : wt_stmt ce e rt (Sifthenelse a s1 s2).","conclusion":"wt_stmt ce e rt (Sifthenelse a s1 s2)","hypotheses":"(a : expr) (s1 s2 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (H2 : wt_stmt ce e rt s2) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0)","proofString":"eauto with ty."},{"statement":"(a : expr) (s1 s : statement) (H : swhile a s1 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (s1 s : statement) (H : swhile a s1 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1)","proofString":"monadInv H.\neauto with ty."},{"statement":"(a : expr) (s1 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0) : wt_stmt ce e rt (Swhile a s1).","conclusion":"wt_stmt ce e rt (Swhile a s1)","hypotheses":"(a : expr) (s1 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0)","proofString":"eauto with ty."},{"statement":"(a : expr) (s1 s : statement) (H : sdowhile a s1 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (s1 s : statement) (H : sdowhile a s1 = OK s) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1)","proofString":"monadInv H.\neauto with ty."},{"statement":"(a : expr) (s1 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0) : wt_stmt ce e rt (Sdowhile a s1).","conclusion":"wt_stmt ce e rt (Sdowhile a s1)","hypotheses":"(a : expr) (s1 : statement) (H0 : wt_expr ce e a) (H1 : wt_stmt ce e rt s1) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0)","proofString":"eauto with ty."},{"statement":"(s1 : statement) (a : expr) (s2 s3 s : statement) (H : sfor s1 a s2 s3 = OK s) (H0 : wt_stmt ce e rt s1) (H1 : wt_expr ce e a) (H2 : wt_stmt ce e rt s2) (H3 : wt_stmt ce e rt s3) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(s1 : statement) (a : expr) (s2 s3 s : statement) (H : sfor s1 a s2 s3 = OK s) (H0 : wt_stmt ce e rt s1) (H1 : wt_expr ce e a) (H2 : wt_stmt ce e rt s2) (H3 : wt_stmt ce e rt s3)","proofString":"monadInv H.\neauto 10 with ty."},{"statement":"(s1 : statement) (a : expr) (s2 s3 : statement) (H0 : wt_stmt ce e rt s1) (H1 : wt_expr ce e a) (H2 : wt_stmt ce e rt s2) (H3 : wt_stmt ce e rt s3) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0) : wt_stmt ce e rt (Sfor s1 a s2 s3).","conclusion":"wt_stmt ce e rt (Sfor s1 a s2 s3)","hypotheses":"(s1 : statement) (a : expr) (s2 s3 : statement) (H0 : wt_stmt ce e rt s1) (H1 : wt_expr ce e a) (H2 : wt_stmt ce e rt s2) (H3 : wt_stmt ce e rt s3) (x : unit) (EQ : check_rval a = OK x) (x0 : unit) (EQ1 : check_bool (typeof a) = OK x0)","proofString":"eauto 10 with ty."},{"statement":"(a : expr) (s : statement) (H : sreturn rt a = OK s) (H0 : wt_expr ce e a) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (s : statement) (H : sreturn rt a = OK s) (H0 : wt_expr ce e a)","proofString":"monadInv H; eauto with ty."},{"statement":"(a : expr) (sl : labeled_statements) (s : statement) (H : sswitch a sl = OK s) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (sl : labeled_statements) (s : statement) (H : sswitch a sl = OK s) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl)","proofString":"monadInv H.\ndestruct (typeof a) eqn:TA; inv EQ0.\neauto with ty.\neapply wt_Sswitch with (sz := I32); eauto with ty."},{"statement":"(a : expr) (sl : labeled_statements) (s : statement) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (EQ0 : match typeof a with\n| Tint _ _ _ | Tlong _ _ => OK (Sswitch a sl)\n| _ => Error (msg \"wrong type for argument of switch\")\nend = OK s) : wt_stmt ce e rt s.","conclusion":"wt_stmt ce e rt s","hypotheses":"(a : expr) (sl : labeled_statements) (s : statement) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (EQ0 : match typeof a with\n| Tint _ _ _ | Tlong _ _ => OK (Sswitch a sl)\n| _ => Error (msg \"wrong type for argument of switch\")\nend = OK s)","proofString":"destruct (typeof a) eqn:TA; inv EQ0.\neauto with ty.\neapply wt_Sswitch with (sz := I32); eauto with ty."},{"statement":"(a : expr) (sl : labeled_statements) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (i : intsize) (s0 : signedness) (a0 : attr) (TA : typeof a = Tint i s0 a0) : wt_stmt ce e rt (Sswitch a sl).","conclusion":"wt_stmt ce e rt (Sswitch a sl)","hypotheses":"(a : expr) (sl : labeled_statements) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (i : intsize) (s0 : signedness) (a0 : attr) (TA : typeof a = Tint i s0 a0)","proofString":"eauto with ty."},{"statement":"(a : expr) (sl : labeled_statements) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (s0 : signedness) (a0 : attr) (TA : typeof a = Tlong s0 a0) : wt_stmt ce e rt (Sswitch a sl).","conclusion":"wt_stmt ce e rt (Sswitch a sl)","hypotheses":"(a : expr) (sl : labeled_statements) (H0 : wt_expr ce e a) (H1 : wt_lblstmts ce e rt sl) (x : unit) (EQ : check_rval a = OK x) (s0 : signedness) (a0 : attr) (TA : typeof a = Tlong s0 a0)","proofString":"eapply wt_Sswitch with (sz := I32); eauto with ty."},{"statement":"(ce : composite_env) (e : typenv) (f f' : function) (H : retype_function ce e f = OK f') : wt_function ce e f'.","conclusion":"wt_function ce e f'","hypotheses":"(ce : composite_env) (e : typenv) (f f' : function) (H : retype_function ce e f = OK f')","proofString":"monadInv H.\nconstructor; simpl.\neapply retype_stmt_sound; eauto."},{"statement":"(ce : composite_env) (e : typenv) (f : function) (x : statement) (EQ : retype_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f) = OK x) : wt_function ce e\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := fn_vars f;\n    fn_body := x\n  |}.","conclusion":"wt_function ce e\n  {|\n    fn_return := fn_return f;\n    fn_callconv := fn_callconv f;\n    fn_params := fn_params f;\n    fn_vars := fn_vars f;\n    fn_body := x\n  |}","hypotheses":"(ce : composite_env) (e : typenv) (f : function) (x : statement) (EQ : retype_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f) = OK x)","proofString":"constructor; simpl.\neapply retype_stmt_sound; eauto."},{"statement":"(ce : composite_env) (e : typenv) (f : function) (x : statement) (EQ : retype_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f) = OK x) : wt_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f)) \n  (fn_return f) x.","conclusion":"wt_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f)) \n  (fn_return f) x","hypotheses":"(ce : composite_env) (e : typenv) (f : function) (x : statement) (EQ : retype_stmt ce (bind_vars (bind_vars e (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f) = OK x)","proofString":"eapply retype_stmt_sound; eauto."},{"statement":"(ce : composite_env) (e : typenv) (fd fd' : fundef) (H : retype_fundef ce e fd = OK fd') : wt_fundef ce e fd'.","conclusion":"wt_fundef ce e fd'","hypotheses":"(ce : composite_env) (e : typenv) (fd fd' : fundef) (H : retype_fundef ce e fd = OK fd')","proofString":"destruct fd; monadInv H.\nconstructor; eapply retype_function_sound; eauto.\nconstructor; auto."},{"statement":"(ce : composite_env) (e : typenv) (f x : function) (EQ : retype_function ce e f = OK x) : wt_fundef ce e (Internal x).","conclusion":"wt_fundef ce e (Internal x)","hypotheses":"(ce : composite_env) (e : typenv) (f x : function) (EQ : retype_function ce e f = OK x)","proofString":"constructor; eapply retype_function_sound; eauto."},{"statement":"(ce : composite_env) (e : typenv) (e0 : external_function) (l : list type) (t : type) (c : calling_convention) (e1 : sig_res (ef_sig e0) = rettype_of_type t) : wt_fundef ce e (External e0 l t c).","conclusion":"wt_fundef ce e (External e0 l t c)","hypotheses":"(ce : composite_env) (e : typenv) (e0 : external_function) (l : list type) (t : type) (c : calling_convention) (e1 : sig_res (ef_sig e0) = rettype_of_type t)","proofString":"constructor; auto."},{"statement":"(p p' : program) (H : (do tp <-\n transform_partial_program\n   (retype_fundef (prog_comp_env p)\n      (bind_globdef (PTree.empty type) (prog_defs p))) p;\n OK\n   {|\n     prog_defs := AST.prog_defs tp;\n     prog_public := prog_public p;\n     prog_main := prog_main p;\n     prog_types := prog_types p;\n     prog_comp_env := prog_comp_env p;\n     prog_comp_env_eq := prog_comp_env_eq p\n   |}) = OK p') : wt_program p'.","conclusion":"wt_program p'","hypotheses":"(p p' : program) (H : (do tp <-\n transform_partial_program\n   (retype_fundef (prog_comp_env p)\n      (bind_globdef (PTree.empty type) (prog_defs p))) p;\n OK\n   {|\n     prog_defs := AST.prog_defs tp;\n     prog_public := prog_public p;\n     prog_main := prog_main p;\n     prog_types := prog_types p;\n     prog_comp_env := prog_comp_env p;\n     prog_comp_env_eq := prog_comp_env_eq p\n   |}) = OK p')","proofString":"monadInv H.\nrename x into tp.\nconstructor; simpl.\nset (ce := prog_comp_env p) in *.\nset (e := bind_globdef (PTree.empty type) (prog_defs p)) in *.\nset (e' := bind_globdef (PTree.empty type) (AST.prog_defs tp)) in *.\nassert (M: match_program (fun ctx f tf => retype_fundef ce e f = OK tf) eq p tp)  by (eapply match_transform_partial_program; eauto).\ndestruct M as (MATCH & _).\nsimpl in MATCH.\nassert (ENVS: e' = e).\nunfold e, e'.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto.\nrewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK x) : wt_program\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := prog_public p;\n    prog_main := prog_main p;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"wt_program\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := prog_public p;\n    prog_main := prog_main p;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : program) (x : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK x)","proofString":"rename x into tp.\nconstructor; simpl.\nset (ce := prog_comp_env p) in *.\nset (e := bind_globdef (PTree.empty type) (prog_defs p)) in *.\nset (e' := bind_globdef (PTree.empty type) (AST.prog_defs tp)) in *.\nassert (M: match_program (fun ctx f tf => retype_fundef ce e f = OK tf) eq p tp)  by (eapply match_transform_partial_program; eauto).\ndestruct M as (MATCH & _).\nsimpl in MATCH.\nassert (ENVS: e' = e).\nunfold e, e'.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto.\nrewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK tp) : wt_program\n  {|\n    prog_defs := AST.prog_defs tp;\n    prog_public := prog_public p;\n    prog_main := prog_main p;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"wt_program\n  {|\n    prog_defs := AST.prog_defs tp;\n    prog_public := prog_public p;\n    prog_main := prog_main p;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : program) (tp : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK tp)","proofString":"constructor; simpl.\nset (ce := prog_comp_env p) in *.\nset (e := bind_globdef (PTree.empty type) (prog_defs p)) in *.\nset (e' := bind_globdef (PTree.empty type) (AST.prog_defs tp)) in *.\nassert (M: match_program (fun ctx f tf => retype_fundef ce e f = OK tf) eq p tp)  by (eapply match_transform_partial_program; eauto).\ndestruct M as (MATCH & _).\nsimpl in MATCH.\nassert (ENVS: e' = e).\nunfold e, e'.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto.\nrewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK tp) : forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) ->\nwt_fundef (prog_comp_env p)\n  (bind_globdef (PTree.empty type) (AST.prog_defs tp)) fd.","conclusion":"forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) ->\nwt_fundef (prog_comp_env p)\n  (bind_globdef (PTree.empty type) (AST.prog_defs tp)) fd","hypotheses":"(p : program) (tp : AST.program fundef type) (EQ : transform_partial_program\n  (retype_fundef (prog_comp_env p)\n     (bind_globdef (PTree.empty type) (prog_defs p))) p = \nOK tp)","proofString":"set (ce := prog_comp_env p) in *.\nset (e := bind_globdef (PTree.empty type) (prog_defs p)) in *.\nset (e' := bind_globdef (PTree.empty type) (AST.prog_defs tp)) in *.\nassert (M: match_program (fun ctx f tf => retype_fundef ce e f = OK tf) eq p tp)  by (eapply match_transform_partial_program; eauto).\ndestruct M as (MATCH & _).\nsimpl in MATCH.\nassert (ENVS: e' = e).\nunfold e, e'.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto.\nrewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (EQ : transform_partial_program\n  (retype_fundef ce (bind_globdef (PTree.empty type) (prog_defs p))) p =\nOK tp) : forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) ->\nwt_fundef ce (bind_globdef (PTree.empty type) (AST.prog_defs tp)) fd.","conclusion":"forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) ->\nwt_fundef ce (bind_globdef (PTree.empty type) (AST.prog_defs tp)) fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (EQ : transform_partial_program\n  (retype_fundef ce (bind_globdef (PTree.empty type) (prog_defs p))) p =\nOK tp)","proofString":"set (e := bind_globdef (PTree.empty type) (prog_defs p)) in *.\nset (e' := bind_globdef (PTree.empty type) (AST.prog_defs tp)) in *.\nassert (M: match_program (fun ctx f tf => retype_fundef ce e f = OK tf) eq p tp)  by (eapply match_transform_partial_program; eauto).\ndestruct M as (MATCH & _).\nsimpl in MATCH.\nassert (ENVS: e' = e).\nunfold e, e'.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto.\nrewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) : bind_globdef (PTree.empty type) (AST.prog_defs tp) =\nbind_globdef (PTree.empty type) (prog_defs p).","conclusion":"bind_globdef (PTree.empty type) (AST.prog_defs tp) =\nbind_globdef (PTree.empty type) (prog_defs p)","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp))","proofString":"revert MATCH; generalize (prog_defs p) (AST.prog_defs tp) (PTree.empty type).\ninduction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) : forall (l : list (ident * globdef (Ctypes.fundef function) type))\n  (l0 : list (ident * globdef fundef type)) (t : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t l0 = bind_globdef t l.","conclusion":"forall (l : list (ident * globdef (Ctypes.fundef function) type))\n  (l0 : list (ident * globdef fundef type)) (t : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t l0 = bind_globdef t l","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv)","proofString":"induction l as [ | [id gd] l ]; intros l' t M; inv M.\nauto.\ndestruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (t : PTree.t type) : bind_globdef t nil = bind_globdef t nil.","conclusion":"bind_globdef t nil = bind_globdef t nil","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (t : PTree.t type)","proofString":"auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (id : ident) (gd : globdef (Ctypes.fundef function) type) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H1 : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p (id, gd) b1) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) : bind_globdef t (b1 :: bl) = bind_globdef t ((id, gd) :: l).","conclusion":"bind_globdef t (b1 :: bl) = bind_globdef t ((id, gd) :: l)","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (id : ident) (gd : globdef (Ctypes.fundef function) type) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H1 : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p (id, gd) b1) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl)","proofString":"destruct b1 as [id' gd']; destruct H1; simpl in *.\ninv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (id : ident) (gd : globdef (Ctypes.fundef function) type) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (gd' : globdef fundef type) (bl : list (ident * globdef fundef type)) (H : id = id') (H0 : match_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p gd gd') (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) : match gd' with\n| Gfun fd => bind_globdef (PTree.set id' (type_of_fundef fd) t) bl\n| Gvar v => bind_globdef (PTree.set id' (gvar_info v) t) bl\nend =\nmatch gd with\n| Gfun fd => bind_globdef (PTree.set id (type_of_fundef fd) t) l\n| Gvar v => bind_globdef (PTree.set id (gvar_info v) t) l\nend.","conclusion":"match gd' with\n| Gfun fd => bind_globdef (PTree.set id' (type_of_fundef fd) t) bl\n| Gvar v => bind_globdef (PTree.set id' (gvar_info v) t) bl\nend =\nmatch gd with\n| Gfun fd => bind_globdef (PTree.set id (type_of_fundef fd) t) l\n| Gvar v => bind_globdef (PTree.set id (gvar_info v) t) l\nend","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (id : ident) (gd : globdef (Ctypes.fundef function) type) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (gd' : globdef fundef type) (bl : list (ident * globdef fundef type)) (H : id = id') (H0 : match_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p gd gd') (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl)","proofString":"inv H0; simpl.\nreplace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto.\ninv H1.\nsimpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : retype_fundef ce e f1 = OK f2) : bind_globdef (PTree.set id' (type_of_fundef f2) t) bl =\nbind_globdef (PTree.set id' (type_of_fundef f1) t) l.","conclusion":"bind_globdef (PTree.set id' (type_of_fundef f2) t) bl =\nbind_globdef (PTree.set id' (type_of_fundef f1) t) l","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : retype_fundef ce e f1 = OK f2)","proofString":"replace (type_of_fundef f2) with (type_of_fundef f1); auto.\nunfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : retype_fundef ce e f1 = OK f2) : type_of_fundef f1 = type_of_fundef f2.","conclusion":"type_of_fundef f1 = type_of_fundef f2","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : retype_fundef ce e f1 = OK f2)","proofString":"unfold retype_fundef in H2.\ndestruct f1; monadInv H2; auto.\nmonadInv EQ0; auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : match f1 with\n| Internal f => do f' <- retype_function ce e f; OK (Internal f')\n| External ef _ res _ =>\n    assertion xtype_eq (sig_res (ef_sig ef)) (rettype_of_type res); OK f1\nend = OK f2) : type_of_fundef f1 = type_of_fundef f2.","conclusion":"type_of_fundef f1 = type_of_fundef f2","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f1 f2 : fundef) (H1 : linkorder ctx' p) (H2 : match f1 with\n| Internal f => do f' <- retype_function ce e f; OK (Internal f')\n| External ef _ res _ =>\n    assertion xtype_eq (sig_res (ef_sig ef)) (rettype_of_type res); OK f1\nend = OK f2)","proofString":"destruct f1; monadInv H2; auto.\nmonadInv EQ0; auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f0 tf : fundef) =>\n      retype_fundef ce e f0 = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f0 tf : fundef) =>\n      retype_fundef ce e f0 = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f : function) (H1 : linkorder ctx' p) (x : function) (EQ0 : retype_function ce e f = OK x) : type_of_fundef (Internal f) = type_of_fundef (Internal x).","conclusion":"type_of_fundef (Internal f) = type_of_fundef (Internal x)","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f0 tf : fundef) =>\n      retype_fundef ce e f0 = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f0 tf : fundef) =>\n      retype_fundef ce e f0 = OK tf) eq p) l bl) (ctx' : AST.program fundef type) (f : function) (H1 : linkorder ctx' p) (x : function) (EQ0 : retype_function ce e f = OK x)","proofString":"monadInv EQ0; auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (v1 v2 : globvar type) (H1 : match_globvar eq v1 v2) : bind_globdef (PTree.set id' (gvar_info v2) t) bl =\nbind_globdef (PTree.set id' (gvar_info v1) t) l.","conclusion":"bind_globdef (PTree.set id' (gvar_info v2) t) bl =\nbind_globdef (PTree.set id' (gvar_info v1) t) l","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (v1 v2 : globvar type) (H1 : match_globvar eq v1 v2)","proofString":"inv H1.\nsimpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (i2 : type) (init : list init_data) (ro vo : bool) : bind_globdef\n  (PTree.set id'\n     (gvar_info\n        {|\n          gvar_info := i2;\n          gvar_init := init;\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}) t) bl =\nbind_globdef\n  (PTree.set id'\n     (gvar_info\n        {|\n          gvar_info := i2;\n          gvar_init := init;\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}) t) l.","conclusion":"bind_globdef\n  (PTree.set id'\n     (gvar_info\n        {|\n          gvar_info := i2;\n          gvar_init := init;\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}) t) bl =\nbind_globdef\n  (PTree.set id'\n     (gvar_info\n        {|\n          gvar_info := i2;\n          gvar_init := init;\n          gvar_readonly := ro;\n          gvar_volatile := vo\n        |}) t) l","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (i2 : type) (init : list init_data) (ro vo : bool)","proofString":"simpl.\nauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (i2 : type) (init : list init_data) (ro vo : bool) : bind_globdef (PTree.set id' i2 t) bl = bind_globdef (PTree.set id' i2 t) l.","conclusion":"bind_globdef (PTree.set id' i2 t) bl = bind_globdef (PTree.set id' i2 t) l","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (l : list (ident * globdef (Ctypes.fundef function) type)) (IHl : forall (l0 : list (ident * globdef fundef type)) (t0 : PTree.t type),\nlist_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l l0 ->\nbind_globdef t0 l0 = bind_globdef t0 l) (t : PTree.t type) (id' : ident) (bl : list (ident * globdef fundef type)) (H3 : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) l bl) (i2 : type) (init : list init_data) (ro vo : bool)","proofString":"auto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e) : forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e' fd.","conclusion":"forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e' fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e)","proofString":"rewrite ENVS.\nintros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e) : forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e fd.","conclusion":"forall (id : ident) (fd : Ctypes.fundef function),\nIn (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e)","proofString":"intros id fd.\nrevert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) : In (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e fd.","conclusion":"In (id, Gfun fd) (AST.prog_defs tp) -> wt_fundef ce e fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) (prog_defs p) \n  (AST.prog_defs tp)) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function)","proofString":"revert MATCH; generalize (prog_defs p) (AST.prog_defs tp).\ninduction 1; simpl; intros.\ncontradiction.\ndestruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (H : False) : wt_fundef ce e fd.","conclusion":"wt_fundef ce e fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (H : False)","proofString":"contradiction."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (a1 : ident * globdef fundef type) (al : list (ident * globdef fundef type)) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p a1 b1) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) al bl) (IHMATCH : In (id, Gfun fd) bl -> wt_fundef ce e fd) (H0 : b1 = (id, Gfun fd) \\/ In (id, Gfun fd) bl) : wt_fundef ce e fd.","conclusion":"wt_fundef ce e fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (a1 : ident * globdef fundef type) (al : list (ident * globdef fundef type)) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p a1 b1) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) al bl) (IHMATCH : In (id, Gfun fd) bl -> wt_fundef ce e fd) (H0 : b1 = (id, Gfun fd) \\/ In (id, Gfun fd) bl)","proofString":"destruct H0; auto.\nsubst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (a1 : ident * globdef fundef type) (al : list (ident * globdef fundef type)) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p a1 b1) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) al bl) (IHMATCH : In (id, Gfun fd) bl -> wt_fundef ce e fd) (H0 : b1 = (id, Gfun fd)) : wt_fundef ce e fd.","conclusion":"wt_fundef ce e fd","hypotheses":"(p : program) (tp : AST.program fundef type) (ce : composite_env) (e : typenv) (EQ : transform_partial_program (retype_fundef ce e) p = OK tp) (e' : typenv) (ENVS : e' = e) (id : ident) (fd : Ctypes.fundef function) (a1 : ident * globdef fundef type) (al : list (ident * globdef fundef type)) (b1 : ident * globdef fundef type) (bl : list (ident * globdef fundef type)) (H : match_ident_globdef\n  (fun (_ : AST.program fundef type) (f tf : fundef) =>\n   retype_fundef ce e f = OK tf) eq p a1 b1) (MATCH : list_forall2\n  (match_ident_globdef\n     (fun (_ : AST.program fundef type) (f tf : fundef) =>\n      retype_fundef ce e f = OK tf) eq p) al bl) (IHMATCH : In (id, Gfun fd) bl -> wt_fundef ce e fd) (H0 : b1 = (id, Gfun fd))","proofString":"subst b1; inv H.\nsimpl in H1.\ninv H1.\neapply retype_fundef_sound; eauto."},{"statement":"(sz : intsize) (sg : signedness) (n : int) : wt_int (cast_int_int sz sg n) sz sg.","conclusion":"wt_int (cast_int_int sz sg n) sz sg","hypotheses":"(sz : intsize) (sg : signedness) (n : int)","proofString":"unfold cast_int_int.\ndestruct sz; simpl.\ndestruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia.\ndestruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia.\nauto.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(sz : intsize) (sg : signedness) (n : int) : wt_int\n  match sz with\n  | I8 =>\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end\n  | I16 =>\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end\n  | I32 => n\n  | IBool => if Int.eq n Int.zero then Int.zero else Int.one\n  end sz sg.","conclusion":"wt_int\n  match sz with\n  | I8 =>\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end\n  | I16 =>\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end\n  | I32 => n\n  | IBool => if Int.eq n Int.zero then Int.zero else Int.one\n  end sz sg","hypotheses":"(sz : intsize) (sg : signedness) (n : int)","proofString":"destruct sz; simpl.\ndestruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia.\ndestruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia.\nauto.\ndestruct (Int.eq n Int.zero); auto."},{"statement":"(sg : signedness) (n : int) : match sg with\n| Signed =>\n    Int.sign_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 8 n\n    | Unsigned => Int.zero_ext 8 n\n    end\n| Unsigned =>\n    Int.zero_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 8 n\n    | Unsigned => Int.zero_ext 8 n\n    end\nend.","conclusion":"match sg with\n| Signed =>\n    Int.sign_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 8 n\n    | Unsigned => Int.zero_ext 8 n\n    end\n| Unsigned =>\n    Int.zero_ext 8\n      match sg with\n      | Signed => Int.sign_ext 8 n\n      | Unsigned => Int.zero_ext 8 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 8 n\n    | Unsigned => Int.zero_ext 8 n\n    end\nend","hypotheses":"(sg : signedness) (n : int)","proofString":"destruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia."},{"statement":"(n : int) : Int.sign_ext 8 (Int.sign_ext 8 n) = Int.sign_ext 8 n.","conclusion":"Int.sign_ext 8 (Int.sign_ext 8 n) = Int.sign_ext 8 n","hypotheses":"(n : int)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(n : int) : Int.zero_ext 8 (Int.zero_ext 8 n) = Int.zero_ext 8 n.","conclusion":"Int.zero_ext 8 (Int.zero_ext 8 n) = Int.zero_ext 8 n","hypotheses":"(n : int)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(sg : signedness) (n : int) : match sg with\n| Signed =>\n    Int.sign_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 16 n\n    | Unsigned => Int.zero_ext 16 n\n    end\n| Unsigned =>\n    Int.zero_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 16 n\n    | Unsigned => Int.zero_ext 16 n\n    end\nend.","conclusion":"match sg with\n| Signed =>\n    Int.sign_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 16 n\n    | Unsigned => Int.zero_ext 16 n\n    end\n| Unsigned =>\n    Int.zero_ext 16\n      match sg with\n      | Signed => Int.sign_ext 16 n\n      | Unsigned => Int.zero_ext 16 n\n      end =\n    match sg with\n    | Signed => Int.sign_ext 16 n\n    | Unsigned => Int.zero_ext 16 n\n    end\nend","hypotheses":"(sg : signedness) (n : int)","proofString":"destruct sg.\napply Int.sign_ext_idem; lia.\napply Int.zero_ext_idem; lia."},{"statement":"(n : int) : Int.sign_ext 16 (Int.sign_ext 16 n) = Int.sign_ext 16 n.","conclusion":"Int.sign_ext 16 (Int.sign_ext 16 n) = Int.sign_ext 16 n","hypotheses":"(n : int)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(n : int) : Int.zero_ext 16 (Int.zero_ext 16 n) = Int.zero_ext 16 n.","conclusion":"Int.zero_ext 16 (Int.zero_ext 16 n) = Int.zero_ext 16 n","hypotheses":"(n : int)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(sg : signedness) (n : int) : True.","conclusion":"True","hypotheses":"(sg : signedness) (n : int)","proofString":"auto."},{"statement":"(sg : signedness) (n : int) : (if Int.eq n Int.zero then Int.zero else Int.one) = Int.zero \\/\n(if Int.eq n Int.zero then Int.zero else Int.one) = Int.one.","conclusion":"(if Int.eq n Int.zero then Int.zero else Int.one) = Int.zero \\/\n(if Int.eq n Int.zero then Int.zero else Int.one) = Int.one","hypotheses":"(sg : signedness) (n : int)","proofString":"destruct (Int.eq n Int.zero); auto."},{"statement":"(sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H : cast_int_int sz si n = n) : wt_int n sz si.","conclusion":"wt_int n sz si","hypotheses":"(sz : intsize) (si : signedness) (attr : Ctypes.attr) (n : int) (H : cast_int_int sz si n = n)","proofString":"rewrite <- H; apply pres_cast_int_int."},{"statement":"(m : mem) (v2 : val) (ty2 : type) (v1 : val) (ty1 : type) (H : wt_val v1 ty1) (H0 : sem_cast v1 ty1 ty2 m = Some v2) : wt_val v2 ty2.","conclusion":"wt_val v2 ty2","hypotheses":"(m : mem) (v2 : val) (ty2 : type) (v1 : val) (ty1 : type) (H : wt_val v1 ty1) (H0 : sem_cast v1 ty1 ty2 m = Some v2)","proofString":"apply wt_val_casted.\neapply cast_val_is_casted; eauto."},{"statement":"(m : mem) (v2 : val) (ty2 : type) (v1 : val) (ty1 : type) (H : wt_val v1 ty1) (H0 : sem_cast v1 ty1 ty2 m = Some v2) : val_casted v2 ty2.","conclusion":"val_casted v2 ty2","hypotheses":"(m : mem) (v2 : val) (ty2 : type) (v1 : val) (ty1 : type) (H : wt_val v1 ty1) (H0 : sem_cast v1 ty1 ty2 m = Some v2)","proofString":"eapply cast_val_is_casted; eauto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (ty' : type) (v1' : val) (CAST1 : sem_cast v1 ty1 ty' m = Some v1') (v2' : val) (CAST2 : sem_cast v2 ty2 ty' m = Some v2') (H3 : match classify_binarith ty1 ty2 with\n| bin_case_i sg =>\n    match v1' with\n    | Vint n1 => match v2' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match v1' with\n    | Vlong n1 =>\n        match v2' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match v1' with\n    | Vfloat n1 =>\n        match v2' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match v1' with\n    | Vsingle n1 =>\n        match v2' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H4 : match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (ty' : type) (v1' : val) (CAST1 : sem_cast v1 ty1 ty' m = Some v1') (v2' : val) (CAST2 : sem_cast v2 ty2 ty' m = Some v2') (H3 : match classify_binarith ty1 ty2 with\n| bin_case_i sg =>\n    match v1' with\n    | Vint n1 => match v2' with\n                 | Vint n2 => sem_int sg n1 n2\n                 | _ => None\n                 end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match v1' with\n    | Vlong n1 =>\n        match v2' with\n        | Vlong n2 => sem_long sg n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match v1' with\n    | Vfloat n1 =>\n        match v2' with\n        | Vfloat n2 => sem_float n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match v1' with\n    | Vsingle n1 =>\n        match v2' with\n        | Vsingle n2 => sem_single n1 n2\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (H4 : match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty)","proofString":"DestructCases.\nspecialize (H s i i0).\nrewrite H3 in H.\ndestruct v; auto with ty; contradiction.\nspecialize (H0 s i i0).\nrewrite H3 in H0.\ndestruct v; auto with ty; contradiction.\nspecialize (H1 f f0).\nrewrite H3 in H1.\ndestruct v; auto with ty; contradiction.\nspecialize (H2 f f0).\nrewrite H3 in H2.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (s : signedness) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (i : int) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (i0 : int) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v) : wt_val v (Tint I32 s noattr).","conclusion":"wt_val v (Tint I32 s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (s : signedness) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (i : int) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (i0 : int) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v)","proofString":"specialize (H s i i0).\nrewrite H3 in H.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (s : signedness) (i i0 : int) (H : match sem_int s i i0 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v) : wt_val v (Tint I32 s noattr).","conclusion":"wt_val v (Tint I32 s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (s : signedness) (i i0 : int) (H : match sem_int s i i0 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v)","proofString":"rewrite H3 in H.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (s : signedness) (i i0 : int) (H : match v with\n| Vundef | Vint _ => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v) : wt_val v (Tint I32 s noattr).","conclusion":"wt_val v (Tint I32 s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (s : signedness) (i i0 : int) (H : match v with\n| Vundef | Vint _ => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_i s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vint i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vint i0)) (H3 : sem_int s i i0 = Some v)","proofString":"destruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (s : signedness) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (i : int64) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (i0 : int64) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v) : wt_val v (Tlong s noattr).","conclusion":"wt_val v (Tlong s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (s : signedness) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (i : int64) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (i0 : int64) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v)","proofString":"specialize (H0 s i i0).\nrewrite H3 in H0.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (s : signedness) (i i0 : int64) (H0 : match sem_long s i i0 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v) : wt_val v (Tlong s noattr).","conclusion":"wt_val v (Tlong s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (s : signedness) (i i0 : int64) (H0 : match sem_long s i i0 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v)","proofString":"rewrite H3 in H0.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (s : signedness) (i i0 : int64) (H0 : match v with\n| Vundef | Vlong _ => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v) : wt_val v (Tlong s noattr).","conclusion":"wt_val v (Tlong s noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (s : signedness) (i i0 : int64) (H0 : match v with\n| Vundef | Vlong _ => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_l s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vlong i)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vlong i0)) (H3 : sem_long s i i0 = Some v)","proofString":"destruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (f : float) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (f0 : float) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v) : wt_val v (Tfloat F64 noattr).","conclusion":"wt_val v (Tfloat F64 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (f : float) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (f0 : float) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v)","proofString":"specialize (H1 f f0).\nrewrite H3 in H1.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (f f0 : float) (H1 : match sem_float f f0 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v) : wt_val v (Tfloat F64 noattr).","conclusion":"wt_val v (Tfloat F64 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (f f0 : float) (H1 : match sem_float f f0 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v)","proofString":"rewrite H3 in H1.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (f f0 : float) (H1 : match v with\n| Vundef | Vfloat _ => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v) : wt_val v (Tfloat F64 noattr).","conclusion":"wt_val v (Tfloat F64 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (f f0 : float) (H1 : match v with\n| Vundef | Vfloat _ => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_f) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vfloat f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vfloat f0)) (H3 : sem_float f f0 = Some v)","proofString":"destruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (f : float32) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (f0 : float32) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v) : wt_val v (Tfloat F32 noattr).","conclusion":"wt_val v (Tfloat F32 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (H2 : forall n1 n2 : float32,\nmatch sem_single n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (f : float32) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (f0 : float32) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v)","proofString":"specialize (H2 f f0).\nrewrite H3 in H2.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (f f0 : float32) (H2 : match sem_single f f0 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v) : wt_val v (Tfloat F32 noattr).","conclusion":"wt_val v (Tfloat F32 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (f f0 : float32) (H2 : match sem_single f f0 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v)","proofString":"rewrite H3 in H2.\ndestruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (f f0 : float32) (H2 : match v with\n| Vundef | Vsingle _ => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v) : wt_val v (Tfloat F32 noattr).","conclusion":"wt_val v (Tfloat F32 noattr)","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (sem_float : float -> float -> option val) (sem_single : float32 -> float32 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : forall n1 n2 : float,\nmatch sem_float n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend) (f f0 : float32) (H2 : match v with\n| Vundef | Vsingle _ => True\n| _ => False\nend) (Heqb : classify_binarith ty1 ty2 = bin_case_s) (ty' : type) (CAST1 : sem_cast v1 ty1 ty' m = Some (Vsingle f)) (CAST2 : sem_cast v2 ty2 ty' m = Some (Vsingle f0)) (H3 : sem_single f f0 = Some v)","proofString":"destruct v; auto with ty; contradiction."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty)","proofString":"eapply pres_sem_binarith with (msg := msg); eauto.\nsimpl; auto.\nsimpl; auto.\nunfold binarith_int_type, binarith_type in *.\ndestruct (classify_binarith ty1 ty2); congruence."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty) : forall n1 n2 : float,\nmatch (fun _ _ : float => None) n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend.","conclusion":"forall n1 n2 : float,\nmatch (fun _ _ : float => None) n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty)","proofString":"simpl; auto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty) : forall n1 n2 : float32,\nmatch (fun _ _ : float32 => None) n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend.","conclusion":"forall n1 n2 : float32,\nmatch (fun _ _ : float32 => None) n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty)","proofString":"simpl; auto."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty) : binarith_type ty1 ty2 msg = OK ty.","conclusion":"binarith_type ty1 ty2 msg = OK ty","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : binarith_int_type ty1 ty2 msg = OK ty)","proofString":"unfold binarith_int_type, binarith_type in *.\ndestruct (classify_binarith ty1 ty2); congruence."},{"statement":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| _ => Error (Errors.msg msg)\nend = OK ty) : match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty.","conclusion":"match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty","hypotheses":"(sem_int : signedness -> int -> int -> option val) (sem_long : signedness -> int64 -> int64 -> option val) (v1 : val) (ty1 : type) (v2 : val) (ty2 : type) (m : mem) (v : val) (ty : type) (msg : string) (H : forall (sg : signedness) (n1 n2 : int),\nmatch sem_int sg n1 n2 with\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend) (H0 : forall (sg : signedness) (n1 n2 : int64),\nmatch sem_long sg n1 n2 with\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend) (H1 : sem_binarith sem_int sem_long (fun _ _ : float => None)\n  (fun _ _ : float32 => None) v1 ty1 v2 ty2 m = Some v) (H2 : match classify_binarith ty1 ty2 with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| _ => Error (Errors.msg msg)\nend = OK ty)","proofString":"destruct (classify_binarith ty1 ty2); congruence."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (ty1 ty2 : type) (m : string) (ty : type) (v1 v2 v : val) (H : shift_op_type ty1 ty2 m = OK ty) (H0 : sem_shift sem_int sem_long v1 ty1 v2 ty2 = Some v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (ty1 ty2 : type) (m : string) (ty : type) (v1 v2 v : val) (H : shift_op_type ty1 ty2 m = OK ty) (H0 : sem_shift sem_int sem_long v1 ty1 v2 ty2 = Some v)","proofString":"unfold shift_op_type, sem_shift in *.\nDestructCases; auto with ty."},{"statement":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (ty1 ty2 : type) (m : string) (ty : type) (v1 v2 v : val) (H : match classify_shift ty1 ty2 with\n| shift_case_ii sg | shift_case_il sg => OK (Tint I32 sg noattr)\n| shift_case_ll sg | shift_case_li sg => OK (Tlong sg noattr)\n| shift_default => Error (msg m)\nend = OK ty) (H0 : match classify_shift ty1 ty2 with\n| shift_case_ii sg =>\n    match v1 with\n    | Vint n1 =>\n        match v2 with\n        | Vint n2 =>\n            if Int.ltu n2 Int.iwordsize\n            then Some (Vint (sem_int sg n1 n2))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_ll sg =>\n    match v1 with\n    | Vlong n1 =>\n        match v2 with\n        | Vlong n2 =>\n            if Int64.ltu n2 Int64.iwordsize\n            then Some (Vlong (sem_long sg n1 n2))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_il sg =>\n    match v1 with\n    | Vint n1 =>\n        match v2 with\n        | Vlong n2 =>\n            if Int64.ltu n2 (Int64.repr 32)\n            then Some (Vint (sem_int sg n1 (Int64.loword n2)))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_li sg =>\n    match v1 with\n    | Vlong n1 =>\n        match v2 with\n        | Vint n2 =>\n            if Int.ltu n2 Int64.iwordsize'\n            then Some (Vlong (sem_long sg n1 (Int64.repr (Int.unsigned n2))))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_default => None\nend = Some v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(sem_int : signedness -> int -> int -> int) (sem_long : signedness -> int64 -> int64 -> int64) (ty1 ty2 : type) (m : string) (ty : type) (v1 v2 v : val) (H : match classify_shift ty1 ty2 with\n| shift_case_ii sg | shift_case_il sg => OK (Tint I32 sg noattr)\n| shift_case_ll sg | shift_case_li sg => OK (Tlong sg noattr)\n| shift_default => Error (msg m)\nend = OK ty) (H0 : match classify_shift ty1 ty2 with\n| shift_case_ii sg =>\n    match v1 with\n    | Vint n1 =>\n        match v2 with\n        | Vint n2 =>\n            if Int.ltu n2 Int.iwordsize\n            then Some (Vint (sem_int sg n1 n2))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_ll sg =>\n    match v1 with\n    | Vlong n1 =>\n        match v2 with\n        | Vlong n2 =>\n            if Int64.ltu n2 Int64.iwordsize\n            then Some (Vlong (sem_long sg n1 n2))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_il sg =>\n    match v1 with\n    | Vint n1 =>\n        match v2 with\n        | Vlong n2 =>\n            if Int64.ltu n2 (Int64.repr 32)\n            then Some (Vint (sem_int sg n1 (Int64.loword n2)))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_case_li sg =>\n    match v1 with\n    | Vlong n1 =>\n        match v2 with\n        | Vint n2 =>\n            if Int.ltu n2 Int64.iwordsize'\n            then Some (Vlong (sem_long sg n1 (Int64.repr (Int.unsigned n2))))\n            else None\n        | _ => None\n        end\n    | _ => None\n    end\n| shift_default => None\nend = Some v)","proofString":"DestructCases; auto with ty."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v) : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr).","conclusion":"forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v)","proofString":"intros b; destruct b; constructor; exact I."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr).","conclusion":"forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr))","proofString":"intros ob EQ.\ndestruct ob as [b|]; inv EQ.\neauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (ob : option bool) (EQ : option_map Val.of_bool ob = Some v) : wt_val v (Tint I32 Signed noattr).","conclusion":"wt_val v (Tint I32 Signed noattr)","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (ob : option bool) (EQ : option_map Val.of_bool ob = Some v)","proofString":"destruct ob as [b|]; inv EQ.\neauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (b : bool) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some (Val.of_bool b)) (X : forall b0 : bool, wt_val (Val.of_bool b0) (Tint I32 Signed noattr)) : wt_val (Val.of_bool b) (Tint I32 Signed noattr).","conclusion":"wt_val (Val.of_bool b) (Tint I32 Signed noattr)","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (H : match classify_cmp ty1 ty2 with\n| cmp_default =>\n    match classify_binarith ty1 ty2 with\n    | bin_default => Error (Errors.msg msg)\n    | _ => OK (Tint I32 Signed noattr)\n    end\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (b : bool) (H0 : match classify_cmp ty1 ty2 with\n| cmp_case_pp => cmp_ptr m c v1 v2\n| cmp_case_pi si =>\n    match v2 with\n    | Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_ip si =>\n    match v1 with\n    | Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n    | _ => None\n    end\n| cmp_case_pl =>\n    match v2 with\n    | Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_case_lp =>\n    match v1 with\n    | Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n    | Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n    | _ => None\n    end\n| cmp_default =>\n    sem_binarith\n      (fun (sg : signedness) (n1 n2 : int) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int.cmp c n1 n2\n            | Unsigned => Int.cmpu c n1 n2\n            end))\n      (fun (sg : signedness) (n1 n2 : int64) =>\n       Some\n         (Val.of_bool\n            match sg with\n            | Signed => Int64.cmp c n1 n2\n            | Unsigned => Int64.cmpu c n1 n2\n            end))\n      (fun n1 n2 : float => Some (Val.of_bool (Float.cmp c n1 n2)))\n      (fun n1 n2 : float32 => Some (Val.of_bool (Float32.cmp c n1 n2))) v1\n      ty1 v2 ty2 m\nend = Some (Val.of_bool b)) (X : forall b0 : bool, wt_val (Val.of_bool b0) (Tint I32 Signed noattr))","proofString":"eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : cmp_ptr m c v1 v2 = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : cmp_ptr m c v1 v2 = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"inv H; eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (si : signedness) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v2 with\n| Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (si : signedness) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v2 with\n| Vint n2 => cmp_ptr m c v1 (Vptrofs (ptrofs_of_int si n2))\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"DestructCases; eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (si : signedness) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v1 with\n| Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (si : signedness) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v1 with\n| Vint n1 => cmp_ptr m c (Vptrofs (ptrofs_of_int si n1)) v2\n| Vptr _ _ => if Archi.ptr64 then None else cmp_ptr m c v1 v2\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"DestructCases; eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v2 with\n| Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v2 with\n| Vlong n2 => cmp_ptr m c v1 (Vptrofs (Ptrofs.of_int64 n2))\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"DestructCases; eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v1 with\n| Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : OK (Tint I32 Signed noattr) = OK ty) (H0 : match v1 with\n| Vlong n1 => cmp_ptr m c (Vptrofs (Ptrofs.of_int64 n1)) v2\n| Vptr _ _ => if Archi.ptr64 then cmp_ptr m c v1 v2 else None\n| _ => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"DestructCases; eauto."},{"statement":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_binarith ty1 ty2 with\n| bin_default => Error (Errors.msg msg)\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (ty' : type) (v1' v2' : val) (H0 : match classify_binarith ty1 ty2 with\n| bin_case_i sg =>\n    match v1' with\n    | Vint n1 =>\n        match v2' with\n        | Vint n2 =>\n            Some\n              (Val.of_bool\n                 match sg with\n                 | Signed => Int.cmp c n1 n2\n                 | Unsigned => Int.cmpu c n1 n2\n                 end)\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match v1' with\n    | Vlong n1 =>\n        match v2' with\n        | Vlong n2 =>\n            Some\n              (Val.of_bool\n                 match sg with\n                 | Signed => Int64.cmp c n1 n2\n                 | Unsigned => Int64.cmpu c n1 n2\n                 end)\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match v1' with\n    | Vfloat n1 =>\n        match v2' with\n        | Vfloat n2 => Some (Val.of_bool (Float.cmp c n1 n2))\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match v1' with\n    | Vsingle n1 =>\n        match v2' with\n        | Vsingle n2 => Some (Val.of_bool (Float32.cmp c n1 n2))\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr)) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty2 : type) (msg : string) (ty : type) (c : comparison) (v1 v2 : val) (m : mem) (v : val) (H : match classify_binarith ty1 ty2 with\n| bin_default => Error (Errors.msg msg)\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (ty' : type) (v1' v2' : val) (H0 : match classify_binarith ty1 ty2 with\n| bin_case_i sg =>\n    match v1' with\n    | Vint n1 =>\n        match v2' with\n        | Vint n2 =>\n            Some\n              (Val.of_bool\n                 match sg with\n                 | Signed => Int.cmp c n1 n2\n                 | Unsigned => Int.cmpu c n1 n2\n                 end)\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_l sg =>\n    match v1' with\n    | Vlong n1 =>\n        match v2' with\n        | Vlong n2 =>\n            Some\n              (Val.of_bool\n                 match sg with\n                 | Signed => Int64.cmp c n1 n2\n                 | Unsigned => Int64.cmpu c n1 n2\n                 end)\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_f =>\n    match v1' with\n    | Vfloat n1 =>\n        match v2' with\n        | Vfloat n2 => Some (Val.of_bool (Float.cmp c n1 n2))\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_case_s =>\n    match v1' with\n    | Vsingle n1 =>\n        match v2' with\n        | Vsingle n2 => Some (Val.of_bool (Float32.cmp c n1 n2))\n        | _ => None\n        end\n    | _ => None\n    end\n| bin_default => None\nend = Some v) (X : forall b : bool, wt_val (Val.of_bool b) (Tint I32 Signed noattr)) (Y : forall ob : option bool,\noption_map Val.of_bool ob = Some v -> wt_val v (Tint I32 Signed noattr))","proofString":"DestructCases; auto."},{"statement":"(ce : composite_env) (op : binary_operation) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : type_binop op ty1 ty2 = OK ty) (SEM : sem_binary_operation ce op v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (op : binary_operation) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : type_binop op ty1 ty2 = OK ty) (SEM : sem_binary_operation ce op v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"destruct op; simpl in TY; simpl in SEM.\nunfold sem_add, sem_add_ptr_int, sem_add_ptr_long in SEM; DestructCases; auto with ty.\neapply pres_sem_binarith; eauto; intros; exact I.\nunfold sem_sub in SEM; DestructCases; auto with ty.\nunfold ptrdiff_t, Vptrofs.\ndestruct Archi.ptr64; auto with ty.\neapply pres_sem_binarith; eauto; intros; exact I.\nunfold sem_mul in SEM.\neapply pres_sem_binarith; eauto; intros; exact I.\nunfold sem_div in SEM.\neapply pres_sem_binarith; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nunfold sem_mod in SEM.\neapply pres_sem_binarith_int; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nunfold sem_and in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I.\nunfold sem_or in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I.\nunfold sem_xor in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I.\nunfold sem_shl in SEM.\neapply pres_sem_shift; eauto.\nunfold sem_shr in SEM.\neapply pres_sem_shift; eauto.\neapply pres_sem_cmp; eauto.\neapply pres_sem_cmp; eauto.\neapply pres_sem_cmp; eauto.\neapply pres_sem_cmp; eauto.\neapply pres_sem_cmp; eauto.\neapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : match classify_add ty1 ty2 with\n| add_case_pi ty0 _ | add_case_pl ty0 | add_case_ip _ ty0 |\n  add_case_lp ty0 => OK (Tpointer ty0 noattr)\n| add_default => binarith_type ty1 ty2 \"operator +\"\nend = OK ty) (SEM : sem_add ce v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : match classify_add ty1 ty2 with\n| add_case_pi ty0 _ | add_case_pl ty0 | add_case_ip _ ty0 |\n  add_case_lp ty0 => OK (Tpointer ty0 noattr)\n| add_default => binarith_type ty1 ty2 \"operator +\"\nend = OK ty) (SEM : sem_add ce v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_add, sem_add_ptr_int, sem_add_ptr_long in SEM; DestructCases; auto with ty.\neapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (Heqc : classify_add ty1 ty2 = add_default) (TY : binarith_type ty1 ty2 \"operator +\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (Heqc : classify_add ty1 ty2 = add_default) (TY : binarith_type ty1 ty2 \"operator +\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.add n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.add n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.add n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.add n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : match classify_sub ty1 ty2 with\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty0 _ | sub_case_pl ty0 => OK (Tpointer ty0 noattr)\n| sub_default => binarith_type ty1 ty2 \"operator infix -\"\nend = OK ty) (SEM : sem_sub ce v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : match classify_sub ty1 ty2 with\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty0 _ | sub_case_pl ty0 => OK (Tpointer ty0 noattr)\n| sub_default => binarith_type ty1 ty2 \"operator infix -\"\nend = OK ty) (SEM : sem_sub ce v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_sub in SEM; DestructCases; auto with ty.\nunfold ptrdiff_t, Vptrofs.\ndestruct Archi.ptr64; auto with ty.\neapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 : type) (m : mem) (ty0 : type) (Heqc : classify_sub ty1 ty2 = sub_case_pp ty0) (i : ptrofs) (b0 : block) (i0 : ptrofs) (Heqs : eq_block b0 b0 = left eq_refl) (Heqb1 : zlt 0 (sizeof ce ty0) && zle (sizeof ce ty0) Ptrofs.max_signed = true) (WT1 : wt_val (Vptr b0 i) ty1) (WT2 : wt_val (Vptr b0 i0) ty2) : wt_val\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0))))\n  ptrdiff_t.","conclusion":"wt_val\n  (Vptrofs (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0))))\n  ptrdiff_t","hypotheses":"(ce : composite_env) (ty1 ty2 : type) (m : mem) (ty0 : type) (Heqc : classify_sub ty1 ty2 = sub_case_pp ty0) (i : ptrofs) (b0 : block) (i0 : ptrofs) (Heqs : eq_block b0 b0 = left eq_refl) (Heqb1 : zlt 0 (sizeof ce ty0) && zle (sizeof ce ty0) Ptrofs.max_signed = true) (WT1 : wt_val (Vptr b0 i) ty1) (WT2 : wt_val (Vptr b0 i0) ty2)","proofString":"unfold ptrdiff_t, Vptrofs.\ndestruct Archi.ptr64; auto with ty."},{"statement":"(ce : composite_env) (ty1 ty2 : type) (m : mem) (ty0 : type) (Heqc : classify_sub ty1 ty2 = sub_case_pp ty0) (i : ptrofs) (b0 : block) (i0 : ptrofs) (Heqs : eq_block b0 b0 = left eq_refl) (Heqb1 : zlt 0 (sizeof ce ty0) && zle (sizeof ce ty0) Ptrofs.max_signed = true) (WT1 : wt_val (Vptr b0 i) ty1) (WT2 : wt_val (Vptr b0 i0) ty2) : wt_val\n  (if Archi.ptr64\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0))))\n   else\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0)))))\n  (if Archi.ptr64 then Tlong Signed noattr else Tint I32 Signed noattr).","conclusion":"wt_val\n  (if Archi.ptr64\n   then\n    Vlong\n      (Ptrofs.to_int64\n         (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0))))\n   else\n    Vint\n      (Ptrofs.to_int\n         (Ptrofs.divs (Ptrofs.sub i i0) (Ptrofs.repr (sizeof ce ty0)))))\n  (if Archi.ptr64 then Tlong Signed noattr else Tint I32 Signed noattr)","hypotheses":"(ce : composite_env) (ty1 ty2 : type) (m : mem) (ty0 : type) (Heqc : classify_sub ty1 ty2 = sub_case_pp ty0) (i : ptrofs) (b0 : block) (i0 : ptrofs) (Heqs : eq_block b0 b0 = left eq_refl) (Heqb1 : zlt 0 (sizeof ce ty0) && zle (sizeof ce ty0) Ptrofs.max_signed = true) (WT1 : wt_val (Vptr b0 i) ty1) (WT2 : wt_val (Vptr b0 i0) ty2)","proofString":"destruct Archi.ptr64; auto with ty."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (Heqc : classify_sub ty1 ty2 = sub_default) (TY : binarith_type ty1 ty2 \"operator infix -\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (Heqc : classify_sub ty1 ty2 = sub_default) (TY : binarith_type ty1 ty2 \"operator infix -\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.sub n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.sub n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.sub n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.sub n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator infix *\" = OK ty) (SEM : sem_mul v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator infix *\" = OK ty) (SEM : sem_mul v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_mul in SEM.\neapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator infix *\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.mul n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.mul n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.mul n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.mul n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator infix *\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.mul n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.mul n1 n2)))\n  (fun n1 n2 : float => Some (Vfloat (Float.mul n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.mul n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_div v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_div v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_div in SEM.\neapply pres_sem_binarith; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n2 Int.zero\n        || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n       then None\n       else Some (Vint (Int.divs n1 n2))\n   | Unsigned =>\n       if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n2 Int64.zero\n        || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n           Int64.eq n2 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n1 n2))\n   | Unsigned =>\n       if Int64.eq n2 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n1 n2))\n   end) (fun n1 n2 : float => Some (Vfloat (Float.div n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.div n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n2 Int.zero\n        || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n       then None\n       else Some (Vint (Int.divs n1 n2))\n   | Unsigned =>\n       if Int.eq n2 Int.zero then None else Some (Vint (Int.divu n1 n2))\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n2 Int64.zero\n        || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n           Int64.eq n2 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n1 n2))\n   | Unsigned =>\n       if Int64.eq n2 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n1 n2))\n   end) (fun n1 n2 : float => Some (Vfloat (Float.div n1 n2)))\n  (fun n1 n2 : float32 => Some (Vsingle (Float32.div n1 n2))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int) : match\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend.","conclusion":"match\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int64) : match\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend.","conclusion":"match\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int64)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n0 n3 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg : signedness) (n0 n3 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (n1 n2 : float) : match (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3))) n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend.","conclusion":"match (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3))) n1 n2 with\n| Some Vundef | Some (Vfloat _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n0 n3 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg : signedness) (n0 n3 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (n1 n2 : float)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n0 n3 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg : signedness) (n0 n3 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (n1 n2 : float32) : match (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend.","conclusion":"match (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) n1 n2 with\n| Some Vundef | Some (Vsingle _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_type ty1 ty2 \"operator /\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n0 n3 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.divs n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.divu n0 n3))\n   end)\n  (fun (sg : signedness) (n0 n3 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.divs n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.divu n0 n3))\n   end) (fun n0 n3 : float => Some (Vfloat (Float.div n0 n3)))\n  (fun n0 n3 : float32 => Some (Vsingle (Float32.div n0 n3))) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (n1 n2 : float32)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_mod v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_mod v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_mod in SEM.\neapply pres_sem_binarith_int; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n2 Int.zero\n        || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n       then None\n       else Some (Vint (Int.mods n1 n2))\n   | Unsigned =>\n       if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n2 Int64.zero\n        || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n           Int64.eq n2 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n1 n2))\n   | Unsigned =>\n       if Int64.eq n2 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n1 n2))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed =>\n       if\n        Int.eq n2 Int.zero\n        || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone\n       then None\n       else Some (Vint (Int.mods n1 n2))\n   | Unsigned =>\n       if Int.eq n2 Int.zero then None else Some (Vint (Int.modu n1 n2))\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed =>\n       if\n        Int64.eq n2 Int64.zero\n        || Int64.eq n1 (Int64.repr Int64.min_signed) &&\n           Int64.eq n2 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n1 n2))\n   | Unsigned =>\n       if Int64.eq n2 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n1 n2))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith_int; eauto; intros.\nsimpl; DestructMatch; auto.\nsimpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int) : match\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend.","conclusion":"match\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vint _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int64) : match\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend.","conclusion":"match\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) sg n1 n2\nwith\n| Some Vundef | Some (Vlong _) | None => True\n| _ => False\nend","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator %\" = OK ty) (SEM : sem_binarith\n  (fun (sg0 : signedness) (n0 n3 : int) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int.eq n3 Int.zero\n        || Int.eq n0 (Int.repr Int.min_signed) && Int.eq n3 Int.mone\n       then None\n       else Some (Vint (Int.mods n0 n3))\n   | Unsigned =>\n       if Int.eq n3 Int.zero then None else Some (Vint (Int.modu n0 n3))\n   end)\n  (fun (sg0 : signedness) (n0 n3 : int64) =>\n   match sg0 with\n   | Signed =>\n       if\n        Int64.eq n3 Int64.zero\n        || Int64.eq n0 (Int64.repr Int64.min_signed) &&\n           Int64.eq n3 Int64.mone\n       then None\n       else Some (Vlong (Int64.mods n0 n3))\n   | Unsigned =>\n       if Int64.eq n3 Int64.zero\n       then None\n       else Some (Vlong (Int64.modu n0 n3))\n   end) (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) (sg : signedness) (n1 n2 : int64)","proofString":"simpl; DestructMatch; auto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator &\" = OK ty) (SEM : sem_and v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator &\" = OK ty) (SEM : sem_and v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_and in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator &\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.and n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.and n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator &\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.and n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.and n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator |\" = OK ty) (SEM : sem_or v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator |\" = OK ty) (SEM : sem_or v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_or in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator |\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.or n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.or n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator |\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.or n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.or n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator ^\" = OK ty) (SEM : sem_xor v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator ^\" = OK ty) (SEM : sem_xor v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_xor in SEM.\neapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator ^\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.xor n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.xor n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : binarith_int_type ty1 ty2 \"operator ^\" = OK ty) (SEM : sem_binarith\n  (fun (_ : signedness) (n1 n2 : int) => Some (Vint (Int.xor n1 n2)))\n  (fun (_ : signedness) (n1 n2 : int64) => Some (Vlong (Int64.xor n1 n2)))\n  (fun _ _ : float => None) (fun _ _ : float32 => None) v1 ty1 v2 ty2 m =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_binarith_int; eauto; intros; exact I."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator <<\" = OK ty) (SEM : sem_shl v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator <<\" = OK ty) (SEM : sem_shl v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_shl in SEM.\neapply pres_sem_shift; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator <<\" = OK ty) (SEM : sem_shift (fun (_ : signedness) (n1 n2 : int) => Int.shl n1 n2)\n  (fun (_ : signedness) (n1 n2 : int64) => Int64.shl n1 n2) v1 ty1 v2 ty2 =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator <<\" = OK ty) (SEM : sem_shift (fun (_ : signedness) (n1 n2 : int) => Int.shl n1 n2)\n  (fun (_ : signedness) (n1 n2 : int64) => Int64.shl n1 n2) v1 ty1 v2 ty2 =\nSome v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_shift; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator >>\" = OK ty) (SEM : sem_shr v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator >>\" = OK ty) (SEM : sem_shr v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"unfold sem_shr in SEM.\neapply pres_sem_shift; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator >>\" = OK ty) (SEM : sem_shift\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed => Int.shr n1 n2\n   | Unsigned => Int.shru n1 n2\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed => Int64.shr n1 n2\n   | Unsigned => Int64.shru n1 n2\n   end) v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : shift_op_type ty1 ty2 \"operator >>\" = OK ty) (SEM : sem_shift\n  (fun (sg : signedness) (n1 n2 : int) =>\n   match sg with\n   | Signed => Int.shr n1 n2\n   | Unsigned => Int.shru n1 n2\n   end)\n  (fun (sg : signedness) (n1 n2 : int64) =>\n   match sg with\n   | Signed => Int64.shr n1 n2\n   | Unsigned => Int64.shru n1 n2\n   end) v1 ty1 v2 ty2 = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_shift; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator ==\" = OK ty) (SEM : sem_cmp Ceq v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator ==\" = OK ty) (SEM : sem_cmp Ceq v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator !=\" = OK ty) (SEM : sem_cmp Cne v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator !=\" = OK ty) (SEM : sem_cmp Cne v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator <\" = OK ty) (SEM : sem_cmp Clt v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator <\" = OK ty) (SEM : sem_cmp Clt v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator >\" = OK ty) (SEM : sem_cmp Cgt v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator >\" = OK ty) (SEM : sem_cmp Cgt v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator <=\" = OK ty) (SEM : sem_cmp Cle v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator <=\" = OK ty) (SEM : sem_cmp Cle v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator >=\" = OK ty) (SEM : sem_cmp Cge v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ce : composite_env) (ty1 ty2 ty : type) (v1 v2 v : val) (m : mem) (TY : comparison_type ty1 ty2 \"operator >=\" = OK ty) (SEM : sem_cmp Cge v1 ty1 v2 ty2 m = Some v) (WT1 : wt_val v1 ty1) (WT2 : wt_val v2 ty2)","proofString":"eapply pres_sem_cmp; eauto."},{"statement":"(op : unary_operation) (ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : type_unop op ty1 = OK ty) (SEM : sem_unary_operation op v1 ty1 m = Some v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(op : unary_operation) (ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : type_unop op ty1 = OK ty) (SEM : sem_unary_operation op v1 ty1 m = Some v) (WT1 : wt_val v1 ty1)","proofString":"destruct op; simpl in TY; simpl in SEM.\nunfold sem_notbool in SEM.\nassert (A: ty = Tint I32 Signed noattr) by (destruct (classify_bool ty1); inv TY; auto).\nassert (B: exists b, v = Val.of_bool b).\ndestruct (bool_val v1 ty1 m); inv SEM.\nexists (negb b); auto.\ndestruct B as [b B].\nrewrite A, B.\ndestruct b; constructor; auto with ty.\nunfold sem_notint in SEM; DestructCases; auto with ty.\nunfold sem_neg in SEM; DestructCases; auto with ty.\nunfold sem_absfloat in SEM; DestructCases; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : sem_notbool v1 ty1 m = Some v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : sem_notbool v1 ty1 m = Some v) (WT1 : wt_val v1 ty1)","proofString":"unfold sem_notbool in SEM.\nassert (A: ty = Tint I32 Signed noattr) by (destruct (classify_bool ty1); inv TY; auto).\nassert (B: exists b, v = Val.of_bool b).\ndestruct (bool_val v1 ty1 m); inv SEM.\nexists (negb b); auto.\ndestruct B as [b B].\nrewrite A, B.\ndestruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1)","proofString":"assert (A: ty = Tint I32 Signed noattr) by (destruct (classify_bool ty1); inv TY; auto).\nassert (B: exists b, v = Val.of_bool b).\ndestruct (bool_val v1 ty1 m); inv SEM.\nexists (negb b); auto.\ndestruct B as [b B].\nrewrite A, B.\ndestruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr)","proofString":"assert (B: exists b, v = Val.of_bool b).\ndestruct (bool_val v1 ty1 m); inv SEM.\nexists (negb b); auto.\ndestruct B as [b B].\nrewrite A, B.\ndestruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) : exists b : bool, v = Val.of_bool b.","conclusion":"exists b : bool, v = Val.of_bool b","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr)","proofString":"destruct (bool_val v1 ty1 m); inv SEM.\nexists (negb b); auto."},{"statement":"(ty1 : type) (v1 : val) (m : mem) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK (Tint I32 Signed noattr)) (b : bool) (WT1 : wt_val v1 ty1) : exists b0 : bool, Val.of_bool (negb b) = Val.of_bool b0.","conclusion":"exists b0 : bool, Val.of_bool (negb b) = Val.of_bool b0","hypotheses":"(ty1 : type) (v1 : val) (m : mem) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK (Tint I32 Signed noattr)) (b : bool) (WT1 : wt_val v1 ty1)","proofString":"exists (negb b); auto."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (B : exists b : bool, v = Val.of_bool b) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b : bool => Val.of_bool (negb b)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (B : exists b : bool, v = Val.of_bool b)","proofString":"destruct B as [b B].\nrewrite A, B.\ndestruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (b : bool) (B : v = Val.of_bool b) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (b : bool) (B : v = Val.of_bool b)","proofString":"rewrite A, B.\ndestruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (b : bool) (B : v = Val.of_bool b) : wt_val (Val.of_bool b) (Tint I32 Signed noattr).","conclusion":"wt_val (Val.of_bool b) (Tint I32 Signed noattr)","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_bool ty1 with\n| bool_default => Error (msg \"operator !\")\n| _ => OK (Tint I32 Signed noattr)\nend = OK ty) (SEM : option_map (fun b0 : bool => Val.of_bool (negb b0)) (bool_val v1 ty1 m) =\nSome v) (WT1 : wt_val v1 ty1) (A : ty = Tint I32 Signed noattr) (b : bool) (B : v = Val.of_bool b)","proofString":"destruct b; constructor; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_notint ty1 with\n| notint_case_i sg => OK (Tint I32 sg noattr)\n| notint_case_l sg => OK (Tlong sg noattr)\n| notint_default => Error (msg \"operator ~\")\nend = OK ty) (SEM : sem_notint v1 ty1 = Some v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_notint ty1 with\n| notint_case_i sg => OK (Tint I32 sg noattr)\n| notint_case_l sg => OK (Tlong sg noattr)\n| notint_default => Error (msg \"operator ~\")\nend = OK ty) (SEM : sem_notint v1 ty1 = Some v) (WT1 : wt_val v1 ty1)","proofString":"unfold sem_notint in SEM; DestructCases; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_neg ty1 with\n| neg_case_i sg => OK (Tint I32 sg noattr)\n| neg_case_f => OK (Tfloat F64 noattr)\n| neg_case_s => OK (Tfloat F32 noattr)\n| neg_case_l sg => OK (Tlong sg noattr)\n| neg_default => Error (msg \"operator prefix -\")\nend = OK ty) (SEM : sem_neg v1 ty1 = Some v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_neg ty1 with\n| neg_case_i sg => OK (Tint I32 sg noattr)\n| neg_case_f => OK (Tfloat F64 noattr)\n| neg_case_s => OK (Tfloat F32 noattr)\n| neg_case_l sg => OK (Tlong sg noattr)\n| neg_default => Error (msg \"operator prefix -\")\nend = OK ty) (SEM : sem_neg v1 ty1 = Some v) (WT1 : wt_val v1 ty1)","proofString":"unfold sem_neg in SEM; DestructCases; auto with ty."},{"statement":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_neg ty1 with\n| neg_default => Error (msg \"operator __builtin_fabs\")\n| _ => OK (Tfloat F64 noattr)\nend = OK ty) (SEM : sem_absfloat v1 ty1 = Some v) (WT1 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ty1 ty : type) (v1 : val) (m : mem) (v : val) (TY : match classify_neg ty1 with\n| neg_default => Error (msg \"operator __builtin_fabs\")\n| _ => OK (Tfloat F64 noattr)\nend = OK ty) (SEM : sem_absfloat v1 ty1 = Some v) (WT1 : wt_val v1 ty1)","proofString":"unfold sem_absfloat in SEM; DestructCases; auto with ty."},{"statement":"forall (ty : type) (chunk : memory_chunk) (v : val),\nmatch ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk ->\nwt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty.","conclusion":"forall (ty : type) (chunk : memory_chunk) (v : val),\nmatch ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk ->\nwt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty","hypotheses":"","proofString":"remember Archi.ptr64 as ptr64.\nintros until v; intros AC.\ndestruct ty; simpl in AC; try discriminate AC.\ndestruct i; [destruct s|destruct s|idtac|idtac]; inv AC; simpl.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct v; auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto.\ninv AC.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct f; inv AC; destruct v; auto with ty.\ninv AC.\nunfold Mptr.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) : forall (ty : type) (chunk : memory_chunk) (v : val),\nmatch ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk ->\nwt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty.","conclusion":"forall (ty : type) (chunk : memory_chunk) (v : val),\nmatch ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk ->\nwt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64)","proofString":"intros until v; intros AC.\ndestruct ty; simpl in AC; try discriminate AC.\ndestruct i; [destruct s|destruct s|idtac|idtac]; inv AC; simpl.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct v; auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto.\ninv AC.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct f; inv AC; destruct v; auto with ty.\ninv AC.\nunfold Mptr.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (ty : type) (chunk : memory_chunk) (v : val) (AC : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk) : wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty.","conclusion":"wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end ty","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (ty : type) (chunk : memory_chunk) (v : val) (AC : match ty with\n| Tvoid => By_nothing\n| Tint I8 Signed _ => By_value Mint8signed\n| Tint I8 Unsigned _ => By_value Mint8unsigned\n| Tint I16 Signed _ => By_value Mint16signed\n| Tint I16 Unsigned _ => By_value Mint16unsigned\n| Tint I32 _ _ => By_value Mint32\n| Tint IBool _ _ => By_value Mbool\n| Tlong _ _ => By_value Mint64\n| Tfloat F32 _ => By_value Mfloat32\n| Tfloat F64 _ => By_value Mfloat64\n| Tpointer _ _ => By_value Mptr\n| Tarray _ _ _ | Tfunction _ _ _ => By_reference\n| _ => By_copy\nend = By_value chunk)","proofString":"destruct ty; simpl in AC; try discriminate AC.\ndestruct i; [destruct s|destruct s|idtac|idtac]; inv AC; simpl.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct v; auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto.\ninv AC.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct f; inv AC; destruct v; auto with ty.\ninv AC.\nunfold Mptr.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (i : intsize) (s : signedness) (a : attr) (chunk : memory_chunk) (v : val) (AC : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk) : wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tint i s a).","conclusion":"wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tint i s a)","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (i : intsize) (s : signedness) (a : attr) (chunk : memory_chunk) (v : val) (AC : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk)","proofString":"destruct i; [destruct s|destruct s|idtac|idtac]; inv AC; simpl.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty.\ndestruct v; auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(a : attr) (v : val) : wt_val match v with\n       | Vint n => Vint (Int.sign_ext 8 n)\n       | _ => Vundef\n       end (Tint I8 Signed a).","conclusion":"wt_val match v with\n       | Vint n => Vint (Int.sign_ext 8 n)\n       | _ => Vundef\n       end (Tint I8 Signed a)","hypotheses":"(a : attr) (v : val)","proofString":"destruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (i : int) : wt_val (Vint (Int.sign_ext 8 i)) (Tint I8 Signed a).","conclusion":"wt_val (Vint (Int.sign_ext 8 i)) (Tint I8 Signed a)","hypotheses":"(a : attr) (i : int)","proofString":"constructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (i : int) : Int.sign_ext 8 (Int.sign_ext 8 i) = Int.sign_ext 8 i.","conclusion":"Int.sign_ext 8 (Int.sign_ext 8 i) = Int.sign_ext 8 i","hypotheses":"(a : attr) (i : int)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (v : val) : wt_val match v with\n       | Vint n => Vint (Int.zero_ext 8 n)\n       | _ => Vundef\n       end (Tint I8 Unsigned a).","conclusion":"wt_val match v with\n       | Vint n => Vint (Int.zero_ext 8 n)\n       | _ => Vundef\n       end (Tint I8 Unsigned a)","hypotheses":"(a : attr) (v : val)","proofString":"destruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (i : int) : wt_val (Vint (Int.zero_ext 8 i)) (Tint I8 Unsigned a).","conclusion":"wt_val (Vint (Int.zero_ext 8 i)) (Tint I8 Unsigned a)","hypotheses":"(a : attr) (i : int)","proofString":"constructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (i : int) : Int.zero_ext 8 (Int.zero_ext 8 i) = Int.zero_ext 8 i.","conclusion":"Int.zero_ext 8 (Int.zero_ext 8 i) = Int.zero_ext 8 i","hypotheses":"(a : attr) (i : int)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (v : val) : wt_val match v with\n       | Vint n => Vint (Int.sign_ext 16 n)\n       | _ => Vundef\n       end (Tint I16 Signed a).","conclusion":"wt_val match v with\n       | Vint n => Vint (Int.sign_ext 16 n)\n       | _ => Vundef\n       end (Tint I16 Signed a)","hypotheses":"(a : attr) (v : val)","proofString":"destruct v; auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (i : int) : wt_val (Vint (Int.sign_ext 16 i)) (Tint I16 Signed a).","conclusion":"wt_val (Vint (Int.sign_ext 16 i)) (Tint I16 Signed a)","hypotheses":"(a : attr) (i : int)","proofString":"constructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (i : int) : Int.sign_ext 16 (Int.sign_ext 16 i) = Int.sign_ext 16 i.","conclusion":"Int.sign_ext 16 (Int.sign_ext 16 i) = Int.sign_ext 16 i","hypotheses":"(a : attr) (i : int)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (v : val) : wt_val match v with\n       | Vint n => Vint (Int.zero_ext 16 n)\n       | _ => Vundef\n       end (Tint I16 Unsigned a).","conclusion":"wt_val match v with\n       | Vint n => Vint (Int.zero_ext 16 n)\n       | _ => Vundef\n       end (Tint I16 Unsigned a)","hypotheses":"(a : attr) (v : val)","proofString":"destruct v; auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (i : int) : wt_val (Vint (Int.zero_ext 16 i)) (Tint I16 Unsigned a).","conclusion":"wt_val (Vint (Int.zero_ext 16 i)) (Tint I16 Unsigned a)","hypotheses":"(a : attr) (i : int)","proofString":"constructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (i : int) : Int.zero_ext 16 (Int.zero_ext 16 i) = Int.zero_ext 16 i.","conclusion":"Int.zero_ext 16 (Int.zero_ext 16 i) = Int.zero_ext 16 i","hypotheses":"(a : attr) (i : int)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(s : signedness) (a : attr) (v : val) : wt_val\n  match v with\n  | Vint n => Vint n\n  | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n  | _ => Vundef\n  end (Tint I32 s a).","conclusion":"wt_val\n  match v with\n  | Vint n => Vint n\n  | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n  | _ => Vundef\n  end (Tint I32 s a)","hypotheses":"(s : signedness) (a : attr) (v : val)","proofString":"destruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(s : signedness) (a : attr) (v : val) : wt_val\n  match v with\n  | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n  | _ => Vundef\n  end (Tint IBool s a).","conclusion":"wt_val\n  match v with\n  | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n  | _ => Vundef\n  end (Tint IBool s a)","hypotheses":"(s : signedness) (a : attr) (v : val)","proofString":"destruct v; auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(s : signedness) (a : attr) (i : int) : wt_val (Val.norm_bool (Vint (Int.zero_ext 8 i))) (Tint IBool s a).","conclusion":"wt_val (Val.norm_bool (Vint (Int.zero_ext 8 i))) (Tint IBool s a)","hypotheses":"(s : signedness) (a : attr) (i : int)","proofString":"destruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 i))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (s : signedness) (a : attr) (chunk : memory_chunk) (v : val) (AC : By_value Mint64 = By_value chunk) : wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tlong s a).","conclusion":"wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tlong s a)","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (s : signedness) (a : attr) (chunk : memory_chunk) (v : val) (AC : By_value Mint64 = By_value chunk)","proofString":"inv AC.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(s : signedness) (a : attr) (v : val) : wt_val\n  match v with\n  | Vlong n => Vlong n\n  | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n  | _ => Vundef\n  end (Tlong s a).","conclusion":"wt_val\n  match v with\n  | Vlong n => Vlong n\n  | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n  | _ => Vundef\n  end (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (v : val)","proofString":"destruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (f : floatsize) (a : attr) (chunk : memory_chunk) (v : val) (AC : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_value chunk) : wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f0 => Vsingle f0\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f0 => Vfloat f0\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tfloat f a).","conclusion":"wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f0 => Vsingle f0\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f0 => Vfloat f0\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tfloat f a)","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (f : floatsize) (a : attr) (chunk : memory_chunk) (v : val) (AC : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_value chunk)","proofString":"destruct f; inv AC; destruct v; auto with ty."},{"statement":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (ty : type) (a : attr) (chunk : memory_chunk) (v : val) (AC : By_value Mptr = By_value chunk) : wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a).","conclusion":"wt_val\n  match chunk with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a)","hypotheses":"(ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (ty : type) (a : attr) (chunk : memory_chunk) (v : val) (AC : By_value Mptr = By_value chunk)","proofString":"inv AC.\nunfold Mptr.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ty : type) (a : attr) (v : val) : wt_val\n  match Mptr with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a).","conclusion":"wt_val\n  match Mptr with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (v : val)","proofString":"unfold Mptr.\ndestruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ty : type) (a : attr) (v : val) : wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a).","conclusion":"wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mbool =>\n      match v with\n      | Vint n => Val.norm_bool (Vint (Int.zero_ext 8 n))\n      | _ => Vundef\n      end\n  | Mint8signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint8unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 8 n)\n      | _ => Vundef\n      end\n  | Mint16signed =>\n      match v with\n      | Vint n => Vint (Int.sign_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint16unsigned =>\n      match v with\n      | Vint n => Vint (Int.zero_ext 16 n)\n      | _ => Vundef\n      end\n  | Mint32 =>\n      match v with\n      | Vint n => Vint n\n      | Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs\n      | _ => Vundef\n      end\n  | Mint64 =>\n      match v with\n      | Vlong n => Vlong n\n      | Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef\n      | _ => Vundef\n      end\n  | Mfloat32 => match v with\n                | Vsingle f => Vsingle f\n                | _ => Vundef\n                end\n  | Mfloat64 => match v with\n                | Vfloat f => Vfloat f\n                | _ => Vundef\n                end\n  | Many32 =>\n      match v with\n      | Vint _ | Vsingle _ => v\n      | Vptr _ _ => if Archi.ptr64 then Vundef else v\n      | _ => Vundef\n      end\n  | Many64 => v\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (v : val)","proofString":"destruct Archi.ptr64 eqn:SF; destruct v; auto with ty."},{"statement":"(ty : type) (chunk : memory_chunk) (vl : list memval) (ACC : access_mode ty = By_value chunk) : wt_val (decode_val chunk vl) ty.","conclusion":"wt_val (decode_val chunk vl) ty","hypotheses":"(ty : type) (chunk : memory_chunk) (vl : list memval) (ACC : access_mode ty = By_value chunk)","proofString":"assert (LR: forall v, wt_val (Val.load_result chunk v) ty) by (eauto using wt_load_result).\ndestruct ty; simpl in ACC; try discriminate.\ndestruct i; [destruct s|destruct s|idtac|idtac]; inv ACC; unfold decode_val.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\ndestruct (proj_bytes vl); auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))) as [A | [A | A]]; rewrite A; constructor; red; auto.\ninv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\ndestruct f; inv ACC; unfold decode_val; destruct (proj_bytes vl); auto with ty.\ninv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (chunk : memory_chunk) (vl : list memval) (ACC : access_mode ty = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) ty) : wt_val (decode_val chunk vl) ty.","conclusion":"wt_val (decode_val chunk vl) ty","hypotheses":"(ty : type) (chunk : memory_chunk) (vl : list memval) (ACC : access_mode ty = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) ty)","proofString":"destruct ty; simpl in ACC; try discriminate.\ndestruct i; [destruct s|destruct s|idtac|idtac]; inv ACC; unfold decode_val.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\ndestruct (proj_bytes vl); auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))) as [A | [A | A]]; rewrite A; constructor; red; auto.\ninv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\ndestruct f; inv ACC; unfold decode_val; destruct (proj_bytes vl); auto with ty.\ninv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(i : intsize) (s : signedness) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tint i s a)) : wt_val (decode_val chunk vl) (Tint i s a).","conclusion":"wt_val (decode_val chunk vl) (Tint i s a)","hypotheses":"(i : intsize) (s : signedness) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tint i s a))","proofString":"destruct i; [destruct s|destruct s|idtac|idtac]; inv ACC; unfold decode_val.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia.\ndestruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\ndestruct (proj_bytes vl); auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I8 Signed a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I8 Signed a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a))","proofString":"destruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a)) (l : list byte) : wt_val (Vint (Int.sign_ext 8 (Int.repr (decode_int l)))) (Tint I8 Signed a).","conclusion":"wt_val (Vint (Int.sign_ext 8 (Int.repr (decode_int l)))) (Tint I8 Signed a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a)) (l : list byte)","proofString":"constructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a)) (l : list byte) : Int.sign_ext 8 (Int.sign_ext 8 (Int.repr (decode_int l))) =\nInt.sign_ext 8 (Int.repr (decode_int l)).","conclusion":"Int.sign_ext 8 (Int.sign_ext 8 (Int.repr (decode_int l))) =\nInt.sign_ext 8 (Int.repr (decode_int l))","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8signed v) (Tint I8 Signed a)) (l : list byte)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I8 Unsigned a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I8 Unsigned a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a))","proofString":"destruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a)) (l : list byte) : wt_val (Vint (Int.zero_ext 8 (Int.repr (decode_int l)))) (Tint I8 Unsigned a).","conclusion":"wt_val (Vint (Int.zero_ext 8 (Int.repr (decode_int l)))) (Tint I8 Unsigned a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a)) (l : list byte)","proofString":"constructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a)) (l : list byte) : Int.zero_ext 8 (Int.zero_ext 8 (Int.repr (decode_int l))) =\nInt.zero_ext 8 (Int.repr (decode_int l)).","conclusion":"Int.zero_ext 8 (Int.zero_ext 8 (Int.repr (decode_int l))) =\nInt.zero_ext 8 (Int.repr (decode_int l))","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint8unsigned v) (Tint I8 Unsigned a)) (l : list byte)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I16 Signed a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I16 Signed a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a))","proofString":"destruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a)) (l : list byte) : wt_val (Vint (Int.sign_ext 16 (Int.repr (decode_int l)))) (Tint I16 Signed a).","conclusion":"wt_val (Vint (Int.sign_ext 16 (Int.repr (decode_int l)))) (Tint I16 Signed a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a)) (l : list byte)","proofString":"constructor; red.\napply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a)) (l : list byte) : Int.sign_ext 16 (Int.sign_ext 16 (Int.repr (decode_int l))) =\nInt.sign_ext 16 (Int.repr (decode_int l)).","conclusion":"Int.sign_ext 16 (Int.sign_ext 16 (Int.repr (decode_int l))) =\nInt.sign_ext 16 (Int.repr (decode_int l))","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint16signed v) (Tint I16 Signed a)) (l : list byte)","proofString":"apply Int.sign_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I16 Unsigned a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | None => Vundef\n  end (Tint I16 Unsigned a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a))","proofString":"destruct (proj_bytes vl); auto with ty.\nconstructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a)) (l : list byte) : wt_val (Vint (Int.zero_ext 16 (Int.repr (decode_int l))))\n  (Tint I16 Unsigned a).","conclusion":"wt_val (Vint (Int.zero_ext 16 (Int.repr (decode_int l))))\n  (Tint I16 Unsigned a)","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a)) (l : list byte)","proofString":"constructor; red.\napply Int.zero_ext_idem; lia."},{"statement":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a)) (l : list byte) : Int.zero_ext 16 (Int.zero_ext 16 (Int.repr (decode_int l))) =\nInt.zero_ext 16 (Int.repr (decode_int l)).","conclusion":"Int.zero_ext 16 (Int.zero_ext 16 (Int.repr (decode_int l))) =\nInt.zero_ext 16 (Int.repr (decode_int l))","hypotheses":"(a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result Mint16unsigned v) (Tint I16 Unsigned a)) (l : list byte)","proofString":"apply Int.zero_ext_idem; lia."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result Mint32 (proj_value Q32 vl)\n  end (Tint I32 s a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result Mint32 (proj_value Q32 vl)\n  end (Tint I32 s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a))","proofString":"destruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a)) (l : list byte) : wt_val (Vint (Int.repr (decode_int l))) (Tint I32 s a).","conclusion":"wt_val (Vint (Int.repr (decode_int l))) (Tint I32 s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a)) (l : list byte)","proofString":"auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a)) : wt_val\n  (if Archi.ptr64 then Vundef else Val.load_result Mint32 (proj_value Q32 vl))\n  (Tint I32 s a).","conclusion":"wt_val\n  (if Archi.ptr64 then Vundef else Val.load_result Mint32 (proj_value Q32 vl))\n  (Tint I32 s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint32 v) (Tint I32 s a))","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mbool v) (Tint IBool s a)) : wt_val\n  match proj_bytes vl with\n  | Some bl =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | None => Vundef\n  end (Tint IBool s a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | None => Vundef\n  end (Tint IBool s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mbool v) (Tint IBool s a))","proofString":"destruct (proj_bytes vl); auto with ty.\ndestruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mbool v) (Tint IBool s a)) (l : list byte) : wt_val (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l)))))\n  (Tint IBool s a).","conclusion":"wt_val (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l)))))\n  (Tint IBool s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mbool v) (Tint IBool s a)) (l : list byte)","proofString":"destruct (Val.norm_bool_cases (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))) as [A | [A | A]]; rewrite A; constructor; red; auto."},{"statement":"(s : signedness) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : By_value Mint64 = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tlong s a)) : wt_val (decode_val chunk vl) (Tlong s a).","conclusion":"wt_val (decode_val chunk vl) (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : By_value Mint64 = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tlong s a))","proofString":"inv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a)) : wt_val (decode_val Mint64 vl) (Tlong s a).","conclusion":"wt_val (decode_val Mint64 vl) (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a))","proofString":"unfold decode_val.\ndestruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a)) : wt_val\n  match proj_bytes vl with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Val.load_result Mint64 (proj_value Q64 vl)\n      else Vundef\n  end (Tlong s a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Val.load_result Mint64 (proj_value Q64 vl)\n      else Vundef\n  end (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a))","proofString":"destruct (proj_bytes vl).\nauto with ty.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a)) (l : list byte) : wt_val (Vlong (Int64.repr (decode_int l))) (Tlong s a).","conclusion":"wt_val (Vlong (Int64.repr (decode_int l))) (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a)) (l : list byte)","proofString":"auto with ty."},{"statement":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a)) : wt_val\n  (if Archi.ptr64 then Val.load_result Mint64 (proj_value Q64 vl) else Vundef)\n  (Tlong s a).","conclusion":"wt_val\n  (if Archi.ptr64 then Val.load_result Mint64 (proj_value Q64 vl) else Vundef)\n  (Tlong s a)","hypotheses":"(s : signedness) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mint64 v) (Tlong s a))","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(f : floatsize) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tfloat f a)) : wt_val (decode_val chunk vl) (Tfloat f a).","conclusion":"wt_val (decode_val chunk vl) (Tfloat f a)","hypotheses":"(f : floatsize) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tfloat f a))","proofString":"destruct f; inv ACC; unfold decode_val; destruct (proj_bytes vl); auto with ty."},{"statement":"(ty : type) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : By_value Mptr = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tpointer ty a)) : wt_val (decode_val chunk vl) (Tpointer ty a).","conclusion":"wt_val (decode_val chunk vl) (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (chunk : memory_chunk) (vl : list memval) (ACC : By_value Mptr = By_value chunk) (LR : forall v : val, wt_val (Val.load_result chunk v) (Tpointer ty a))","proofString":"inv ACC.\nunfold decode_val.\ndestruct (proj_bytes vl).\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a)) : wt_val (decode_val Mptr vl) (Tpointer ty a).","conclusion":"wt_val (decode_val Mptr vl) (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a))","proofString":"unfold decode_val.\ndestruct (proj_bytes vl).\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a)) : wt_val\n  match proj_bytes vl with\n  | Some bl =>\n      match Mptr with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match Mptr with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result Mptr (proj_value Q32 vl)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result Mptr (proj_value Q64 vl)\n          else Vundef\n      | Many32 => Val.load_result Mptr (proj_value Q32 vl)\n      | Many64 => Val.load_result Mptr (proj_value Q64 vl)\n      | _ => Vundef\n      end\n  end (Tpointer ty a).","conclusion":"wt_val\n  match proj_bytes vl with\n  | Some bl =>\n      match Mptr with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match Mptr with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result Mptr (proj_value Q32 vl)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result Mptr (proj_value Q64 vl)\n          else Vundef\n      | Many32 => Val.load_result Mptr (proj_value Q32 vl)\n      | Many64 => Val.load_result Mptr (proj_value Q64 vl)\n      | _ => Vundef\n      end\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a))","proofString":"destruct (proj_bytes vl).\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty.\nunfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a)) (l : list byte) : wt_val\n  match Mptr with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l)))\n  | Mint32 => Vint (Int.repr (decode_int l))\n  | Mint64 => Vlong (Int64.repr (decode_int l))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l)))\n  | _ => Vundef\n  end (Tpointer ty a).","conclusion":"wt_val\n  match Mptr with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l)))\n  | Mint32 => Vint (Int.repr (decode_int l))\n  | Mint64 => Vlong (Int64.repr (decode_int l))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l)))\n  | _ => Vundef\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a)) (l : list byte)","proofString":"unfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result (if Archi.ptr64 then Mint64 else Mint32) v)\n  (Tpointer ty a)) (l : list byte) : wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l)))\n  | Mint32 => Vint (Int.repr (decode_int l))\n  | Mint64 => Vlong (Int64.repr (decode_int l))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l)))\n  | _ => Vundef\n  end (Tpointer ty a).","conclusion":"wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l)))\n  | Mint32 => Vint (Int.repr (decode_int l))\n  | Mint64 => Vlong (Int64.repr (decode_int l))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l)))\n  | _ => Vundef\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result (if Archi.ptr64 then Mint64 else Mint32) v)\n  (Tpointer ty a)) (l : list byte)","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a)) : wt_val\n  match Mptr with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result Mptr (proj_value Q32 vl)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result Mptr (proj_value Q64 vl)\n      else Vundef\n  | Many32 => Val.load_result Mptr (proj_value Q32 vl)\n  | Many64 => Val.load_result Mptr (proj_value Q64 vl)\n  | _ => Vundef\n  end (Tpointer ty a).","conclusion":"wt_val\n  match Mptr with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result Mptr (proj_value Q32 vl)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result Mptr (proj_value Q64 vl)\n      else Vundef\n  | Many32 => Val.load_result Mptr (proj_value Q32 vl)\n  | Many64 => Val.load_result Mptr (proj_value Q64 vl)\n  | _ => Vundef\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val, wt_val (Val.load_result Mptr v) (Tpointer ty a))","proofString":"unfold Mptr in *.\ndestruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result (if Archi.ptr64 then Mint64 else Mint32) v)\n  (Tpointer ty a)) : wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else\n       Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n         (proj_value Q32 vl)\n  | Mint64 =>\n      if Archi.ptr64\n      then\n       Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n         (proj_value Q64 vl)\n      else Vundef\n  | Many32 =>\n      Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n        (proj_value Q32 vl)\n  | Many64 =>\n      Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n        (proj_value Q64 vl)\n  | _ => Vundef\n  end (Tpointer ty a).","conclusion":"wt_val\n  match (if Archi.ptr64 then Mint64 else Mint32) with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else\n       Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n         (proj_value Q32 vl)\n  | Mint64 =>\n      if Archi.ptr64\n      then\n       Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n         (proj_value Q64 vl)\n      else Vundef\n  | Many32 =>\n      Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n        (proj_value Q32 vl)\n  | Many64 =>\n      Val.load_result (if Archi.ptr64 then Mint64 else Mint32)\n        (proj_value Q64 vl)\n  | _ => Vundef\n  end (Tpointer ty a)","hypotheses":"(ty : type) (a : attr) (vl : list memval) (LR : forall v : val,\nwt_val (Val.load_result (if Archi.ptr64 then Mint64 else Mint32) v)\n  (Tpointer ty a))","proofString":"destruct Archi.ptr64 eqn:SF; auto with ty."},{"statement":"(sz : intsize) (sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= bitsize_intsize sz) (H0 : sg1 = (if zlt width (bitsize_intsize sz) then Signed else sg)) : wt_int (bitfield_normalize sz sg width n) sz sg1.","conclusion":"wt_int (bitfield_normalize sz sg width n) sz sg1","hypotheses":"(sz : intsize) (sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= bitsize_intsize sz) (H0 : sg1 = (if zlt width (bitsize_intsize sz) then Signed else sg))","proofString":"destruct sz; cbn in *.\ndestruct sg.\nreplace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia.\nsubst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia.\ndestruct sg.\nreplace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia.\nsubst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia.\nauto.\nassert (width = 1) by lia.\nsubst width.\nassert (0 <= Int.unsigned (Int.zero_ext 1 n) < 2).\nrewrite Int.zero_ext_mod.\napply Z.mod_pos_bound.\nlia.\nsplit.\nlia.\nreflexivity.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 1 n)).\nset (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else sg)) : match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 sg width n) =\n    bitfield_normalize I8 sg width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 sg width n) =\n    bitfield_normalize I8 sg width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 sg width n) =\n    bitfield_normalize I8 sg width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 sg width n) =\n    bitfield_normalize I8 sg width n\nend","hypotheses":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else sg))","proofString":"destruct sg.\nreplace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia.\nsubst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Signed)) : match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 Signed width n) =\n    bitfield_normalize I8 Signed width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 Signed width n) =\n    bitfield_normalize I8 Signed width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 Signed width n) =\n    bitfield_normalize I8 Signed width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 Signed width n) =\n    bitfield_normalize I8 Signed width n\nend","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Signed))","proofString":"replace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Signed)) : Int.sign_ext 8 (bitfield_normalize I8 Signed width n) =\nbitfield_normalize I8 Signed width n.","conclusion":"Int.sign_ext 8 (bitfield_normalize I8 Signed width n) =\nbitfield_normalize I8 Signed width n","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Signed))","proofString":"apply Int.sign_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Unsigned)) : match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 Unsigned width n) =\n    bitfield_normalize I8 Unsigned width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 Unsigned width n) =\n    bitfield_normalize I8 Unsigned width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 8 (bitfield_normalize I8 Unsigned width n) =\n    bitfield_normalize I8 Unsigned width n\n| Unsigned =>\n    Int.zero_ext 8 (bitfield_normalize I8 Unsigned width n) =\n    bitfield_normalize I8 Unsigned width n\nend","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 8) (H0 : sg1 = (if zlt width 8 then Signed else Unsigned))","proofString":"subst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia."},{"statement":"(width : Z) (n : int) (H : 0 < width <= 8) (l : width < 8) : Int.sign_ext 8 (bitfield_normalize I8 Unsigned width n) =\nbitfield_normalize I8 Unsigned width n.","conclusion":"Int.sign_ext 8 (bitfield_normalize I8 Unsigned width n) =\nbitfield_normalize I8 Unsigned width n","hypotheses":"(width : Z) (n : int) (H : 0 < width <= 8) (l : width < 8)","proofString":"apply Int.sign_zero_ext_widen; lia."},{"statement":"(width : Z) (n : int) (H : 0 < width <= 8) (g : width >= 8) : Int.zero_ext 8 (bitfield_normalize I8 Unsigned width n) =\nbitfield_normalize I8 Unsigned width n.","conclusion":"Int.zero_ext 8 (bitfield_normalize I8 Unsigned width n) =\nbitfield_normalize I8 Unsigned width n","hypotheses":"(width : Z) (n : int) (H : 0 < width <= 8) (g : width >= 8)","proofString":"apply Int.zero_ext_widen; lia."},{"statement":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else sg)) : match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 sg width n) =\n    bitfield_normalize I16 sg width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 sg width n) =\n    bitfield_normalize I16 sg width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 sg width n) =\n    bitfield_normalize I16 sg width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 sg width n) =\n    bitfield_normalize I16 sg width n\nend","hypotheses":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else sg))","proofString":"destruct sg.\nreplace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia.\nsubst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Signed)) : match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 Signed width n) =\n    bitfield_normalize I16 Signed width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 Signed width n) =\n    bitfield_normalize I16 Signed width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 Signed width n) =\n    bitfield_normalize I16 Signed width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 Signed width n) =\n    bitfield_normalize I16 Signed width n\nend","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Signed))","proofString":"replace sg1 with Signed by (destruct zlt; auto).\napply Int.sign_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Signed)) : Int.sign_ext 16 (bitfield_normalize I16 Signed width n) =\nbitfield_normalize I16 Signed width n.","conclusion":"Int.sign_ext 16 (bitfield_normalize I16 Signed width n) =\nbitfield_normalize I16 Signed width n","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Signed))","proofString":"apply Int.sign_ext_widen; lia."},{"statement":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Unsigned)) : match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 Unsigned width n) =\n    bitfield_normalize I16 Unsigned width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 Unsigned width n) =\n    bitfield_normalize I16 Unsigned width n\nend.","conclusion":"match sg1 with\n| Signed =>\n    Int.sign_ext 16 (bitfield_normalize I16 Unsigned width n) =\n    bitfield_normalize I16 Unsigned width n\n| Unsigned =>\n    Int.zero_ext 16 (bitfield_normalize I16 Unsigned width n) =\n    bitfield_normalize I16 Unsigned width n\nend","hypotheses":"(width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 16) (H0 : sg1 = (if zlt width 16 then Signed else Unsigned))","proofString":"subst sg1; destruct zlt.\napply Int.sign_zero_ext_widen; lia.\napply Int.zero_ext_widen; lia."},{"statement":"(width : Z) (n : int) (H : 0 < width <= 16) (l : width < 16) : Int.sign_ext 16 (bitfield_normalize I16 Unsigned width n) =\nbitfield_normalize I16 Unsigned width n.","conclusion":"Int.sign_ext 16 (bitfield_normalize I16 Unsigned width n) =\nbitfield_normalize I16 Unsigned width n","hypotheses":"(width : Z) (n : int) (H : 0 < width <= 16) (l : width < 16)","proofString":"apply Int.sign_zero_ext_widen; lia."},{"statement":"(width : Z) (n : int) (H : 0 < width <= 16) (g : width >= 16) : Int.zero_ext 16 (bitfield_normalize I16 Unsigned width n) =\nbitfield_normalize I16 Unsigned width n.","conclusion":"Int.zero_ext 16 (bitfield_normalize I16 Unsigned width n) =\nbitfield_normalize I16 Unsigned width n","hypotheses":"(width : Z) (n : int) (H : 0 < width <= 16) (g : width >= 16)","proofString":"apply Int.zero_ext_widen; lia."},{"statement":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 32) (H0 : sg1 = (if zlt width 32 then Signed else sg)) : True.","conclusion":"True","hypotheses":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 32) (H0 : sg1 = (if zlt width 32 then Signed else sg))","proofString":"auto."},{"statement":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 1) (H0 : sg1 = (if zlt width 1 then Signed else sg)) : Int.zero_ext width n = Int.zero \\/ Int.zero_ext width n = Int.one.","conclusion":"Int.zero_ext width n = Int.zero \\/ Int.zero_ext width n = Int.one","hypotheses":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 1) (H0 : sg1 = (if zlt width 1 then Signed else sg))","proofString":"assert (width = 1) by lia.\nsubst width.\nassert (0 <= Int.unsigned (Int.zero_ext 1 n) < 2).\nrewrite Int.zero_ext_mod.\napply Z.mod_pos_bound.\nlia.\nsplit.\nlia.\nreflexivity.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 1 n)).\nset (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 1) (H0 : sg1 = (if zlt width 1 then Signed else sg)) (H1 : width = 1) : Int.zero_ext width n = Int.zero \\/ Int.zero_ext width n = Int.one.","conclusion":"Int.zero_ext width n = Int.zero \\/ Int.zero_ext width n = Int.one","hypotheses":"(sg : signedness) (width : Z) (sg1 : signedness) (n : int) (H : 0 < width <= 1) (H0 : sg1 = (if zlt width 1 then Signed else sg)) (H1 : width = 1)","proofString":"subst width.\nassert (0 <= Int.unsigned (Int.zero_ext 1 n) < 2).\nrewrite Int.zero_ext_mod.\napply Z.mod_pos_bound.\nlia.\nsplit.\nlia.\nreflexivity.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 1 n)).\nset (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : Int.zero_ext 1 n = Int.zero \\/ Int.zero_ext 1 n = Int.one.","conclusion":"Int.zero_ext 1 n = Int.zero \\/ Int.zero_ext 1 n = Int.one","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"assert (0 <= Int.unsigned (Int.zero_ext 1 n) < 2).\nrewrite Int.zero_ext_mod.\napply Z.mod_pos_bound.\nlia.\nsplit.\nlia.\nreflexivity.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 1 n)).\nset (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 0 <= Int.unsigned (Int.zero_ext 1 n) < 2.","conclusion":"0 <= Int.unsigned (Int.zero_ext 1 n) < 2","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"rewrite Int.zero_ext_mod.\napply Z.mod_pos_bound.\nlia.\nsplit.\nlia.\nreflexivity."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 0 <= Int.unsigned n mod two_p 1 < 2.","conclusion":"0 <= Int.unsigned n mod two_p 1 < 2","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"apply Z.mod_pos_bound.\nlia."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 0 < 2.","conclusion":"0 < 2","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"lia."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 0 <= 1 < Int.zwordsize.","conclusion":"0 <= 1 < Int.zwordsize","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"split.\nlia.\nreflexivity."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 0 <= 1.","conclusion":"0 <= 1","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"lia."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) : 1 < Int.zwordsize.","conclusion":"1 < Int.zwordsize","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1)","proofString":"reflexivity."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (H1 : 0 <= Int.unsigned (Int.zero_ext 1 n) < 2) : Int.zero_ext 1 n = Int.zero \\/ Int.zero_ext 1 n = Int.one.","conclusion":"Int.zero_ext 1 n = Int.zero \\/ Int.zero_ext 1 n = Int.one","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (H1 : 0 <= Int.unsigned (Int.zero_ext 1 n) < 2)","proofString":"rewrite <- (Int.repr_unsigned (Int.zero_ext 1 n)).\nset (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (H1 : 0 <= Int.unsigned (Int.zero_ext 1 n) < 2) : Int.repr (Int.unsigned (Int.zero_ext 1 n)) = Int.zero \\/\nInt.repr (Int.unsigned (Int.zero_ext 1 n)) = Int.one.","conclusion":"Int.repr (Int.unsigned (Int.zero_ext 1 n)) = Int.zero \\/\nInt.repr (Int.unsigned (Int.zero_ext 1 n)) = Int.one","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (H1 : 0 <= Int.unsigned (Int.zero_ext 1 n) < 2)","proofString":"set (i := Int.unsigned (Int.zero_ext 1 n)) in *.\nassert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (i : Z) (H1 : 0 <= i < 2) : Int.repr i = Int.zero \\/ Int.repr i = Int.one.","conclusion":"Int.repr i = Int.zero \\/ Int.repr i = Int.one","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (i : Z) (H1 : 0 <= i < 2)","proofString":"assert (i = 0 \\/ i = 1) by lia.\ndestruct H2 as [E|E]; rewrite E; auto."},{"statement":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (i : Z) (H1 : 0 <= i < 2) (H2 : i = 0 \\/ i = 1) : Int.repr i = Int.zero \\/ Int.repr i = Int.one.","conclusion":"Int.repr i = Int.zero \\/ Int.repr i = Int.one","hypotheses":"(sg sg1 : signedness) (n : int) (H0 : sg1 = (if zlt 1 1 then Signed else sg)) (H : 0 < 1 <= 1) (i : Z) (H1 : 0 <= i < 2) (H2 : i = 0 \\/ i = 1)","proofString":"destruct H2 as [E|E]; rewrite E; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"simpl in H1.\nexploit Mem.load_result; eauto.\nintros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"exploit Mem.load_result; eauto.\nintros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b) -> wt_val v ty.","conclusion":"v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b) -> wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"intros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (EQ : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b)) : wt_val\n  (decode_val chunk\n     (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n        (Mem.mem_contents m) !! b)) ty.","conclusion":"wt_val\n  (decode_val chunk\n     (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n        (Mem.mem_contents m) !! b)) ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (EQ : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b))","proofString":"apply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (t : trace) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H1 : volatile_load ge chunk m b ofs t v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (t : trace) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H1 : volatile_load ge chunk m b ofs t v)","proofString":"inv H1.\neapply wt_load_result; eauto.\nexploit Mem.load_result; eauto.\nintros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (id : ident) (ev : eventval) (v0 : val) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v0) : wt_val (Val.load_result chunk v0) ty.","conclusion":"wt_val (Val.load_result chunk v0) ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (id : ident) (ev : eventval) (v0 : val) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"eapply wt_load_result; eauto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"exploit Mem.load_result; eauto.\nintros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b) -> wt_val v ty.","conclusion":"v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b) -> wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"intros EQ; rewrite EQ.\napply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (EQ : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b)) : wt_val\n  (decode_val chunk\n     (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n        (Mem.mem_contents m) !! b)) ty.","conclusion":"wt_val\n  (decode_val chunk\n     (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n        (Mem.mem_contents m) !! b)) ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (chunk : memory_chunk) (v : val) (H : access_mode ty = By_value chunk) (H0 : type_is_volatile ty = true) (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (EQ : v =\ndecode_val chunk\n  (Mem.getN (size_chunk_nat chunk) (Ptrofs.unsigned ofs)\n     (Mem.mem_contents m) !! b))","proofString":"apply wt_decode_val; auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (H : access_mode ty = By_reference) : wt_val (Vptr b ofs) ty.","conclusion":"wt_val (Vptr b ofs) ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (H : access_mode ty = By_reference)","proofString":"destruct ty; simpl in H; try discriminate; auto with ty.\ndestruct i; destruct s; discriminate.\ndestruct f; discriminate."},{"statement":"(ge : genv) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_reference) : wt_val (Vptr b ofs) (Tint i s a).","conclusion":"wt_val (Vptr b ofs) (Tint i s a)","hypotheses":"(ge : genv) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_reference)","proofString":"destruct i; destruct s; discriminate."},{"statement":"(ge : genv) (f : floatsize) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_reference) : wt_val (Vptr b ofs) (Tfloat f a).","conclusion":"wt_val (Vptr b ofs) (Tfloat f a)","hypotheses":"(ge : genv) (f : floatsize) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_reference)","proofString":"destruct f; discriminate."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (H : access_mode ty = By_copy) : wt_val (Vptr b ofs) ty.","conclusion":"wt_val (Vptr b ofs) ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (H : access_mode ty = By_copy)","proofString":"destruct ty; simpl in H; try discriminate; auto with ty.\ndestruct i; destruct s; discriminate.\ndestruct f; discriminate."},{"statement":"(ge : genv) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_copy) : wt_val (Vptr b ofs) (Tint i s a).","conclusion":"wt_val (Vptr b ofs) (Tint i s a)","hypotheses":"(ge : genv) (i : intsize) (s : signedness) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match i with\n| I8 =>\n    match s with\n    | Signed => By_value Mint8signed\n    | Unsigned => By_value Mint8unsigned\n    end\n| I16 =>\n    match s with\n    | Signed => By_value Mint16signed\n    | Unsigned => By_value Mint16unsigned\n    end\n| I32 => By_value Mint32\n| IBool => By_value Mbool\nend = By_copy)","proofString":"destruct i; destruct s; discriminate."},{"statement":"(ge : genv) (f : floatsize) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_copy) : wt_val (Vptr b ofs) (Tfloat f a).","conclusion":"wt_val (Vptr b ofs) (Tfloat f a)","hypotheses":"(ge : genv) (f : floatsize) (a : attr) (m : mem) (b : block) (ofs : ptrofs) (H : match f with\n| F32 => By_value Mfloat32\n| F64 => By_value Mfloat64\nend = By_copy)","proofString":"destruct f; discriminate."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (H : load_bitfield ty sz sg pos width m (Vptr b ofs) v) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (H : load_bitfield ty sz sg pos width m (Vptr b ofs) v)","proofString":"inv H.\nconstructor.\napply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : wt_val (Vint (bitfield_extract sz sg pos width c))\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr).","conclusion":"wt_val (Vint (bitfield_extract sz sg pos width c))\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"constructor.\napply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : wt_int (bitfield_extract sz sg pos width c) sz\n  (if zlt width (bitsize_intsize sz) then Signed else sg).","conclusion":"wt_int (bitfield_extract sz sg pos width c) sz\n  (if zlt width (bitsize_intsize sz) then Signed else sg)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"apply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : 0 < width <= bitsize_intsize sz.","conclusion":"0 < width <= bitsize_intsize sz","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"lia."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) : (if zlt width (bitsize_intsize sz) then Signed else sg) =\n(if zlt width (bitsize_intsize sz) then Signed else sg).","conclusion":"(if zlt width (bitsize_intsize sz) then Signed else sg) =\n(if zlt width (bitsize_intsize sz) then Signed else sg)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (attr : Ctypes.attr) (c : int) (H0 : 0 <= pos) (H1 : 0 < width <= bitsize_intsize sz) (H2 : pos + width <= bitsize_carrier sz) (H4 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c))","proofString":"auto."},{"statement":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') (H0 : wt_val v ty) : wt_val v' ty.","conclusion":"wt_val v' ty","hypotheses":"(ge : genv) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') (H0 : wt_val v ty)","proofString":"inv H.\nconstructor.\napply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : wt_val (Vint (bitfield_normalize sz sg width n))\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr).","conclusion":"wt_val (Vint (bitfield_normalize sz sg width n))\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"constructor.\napply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : wt_int (bitfield_normalize sz sg width n) sz\n  (if zlt width (bitsize_intsize sz) then Signed else sg).","conclusion":"wt_int (bitfield_normalize sz sg width n) sz\n  (if zlt width (bitsize_intsize sz) then Signed else sg)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"apply wt_bitfield_normalize.\nlia.\nauto."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : 0 < width <= bitsize_intsize sz.","conclusion":"0 < width <= bitsize_intsize sz","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"lia."},{"statement":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') : (if zlt width (bitsize_intsize sz) then Signed else sg) =\n(if zlt width (bitsize_intsize sz) then Signed else sg).","conclusion":"(if zlt width (bitsize_intsize sz) then Signed else sg) =\n(if zlt width (bitsize_intsize sz) then Signed else sg)","hypotheses":"(ge : genv) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (attr : Ctypes.attr) (n : int) (H0 : wt_val (Vint n)\n  (Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr)) (c : int) (H1 : 0 <= pos) (H2 : 0 < width <= bitsize_intsize sz) (H3 : pos + width <= bitsize_carrier sz) (H5 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H6 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m')","proofString":"auto."},{"statement":"(t1 t2 : type) (H : classify_cast t1 t2 <> cast_case_default) : classify_cast t2 t2 <> cast_case_default.","conclusion":"classify_cast t2 t2 <> cast_case_default","hypotheses":"(t1 t2 : type) (H : classify_cast t1 t2 <> cast_case_default)","proofString":"destruct t2; simpl in *; try congruence.\napply (wt_cast_int i s a i s a).\ndestruct Archi.ptr64; congruence.\ndestruct f; congruence."},{"statement":"(t1 : type) (i : intsize) (s : signedness) (a : attr) (H : match t1 with\n| Tint _ _ _ =>\n    match i with\n    | I32 => if Archi.ptr64 then cast_case_i2i i s else cast_case_pointer\n    | IBool => cast_case_i2bool\n    | _ => cast_case_i2i i s\n    end\n| Tlong _ _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_l2bool else cast_case_l2i i s\n| Tfloat F32 _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_s2bool else cast_case_s2i i s\n| Tfloat F64 _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_f2bool else cast_case_f2i i s\n| Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ =>\n    if Archi.ptr64\n    then\n     if Ctypes.intsize_eq i IBool\n     then cast_case_l2bool\n     else cast_case_l2i i s\n    else\n     match i with\n     | I32 => cast_case_pointer\n     | IBool => cast_case_i2bool\n     | _ => cast_case_i2i i s\n     end\n| _ => cast_case_default\nend <> cast_case_default) : match i with\n| I32 => if Archi.ptr64 then cast_case_i2i i s else cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i s\nend <> cast_case_default.","conclusion":"match i with\n| I32 => if Archi.ptr64 then cast_case_i2i i s else cast_case_pointer\n| IBool => cast_case_i2bool\n| _ => cast_case_i2i i s\nend <> cast_case_default","hypotheses":"(t1 : type) (i : intsize) (s : signedness) (a : attr) (H : match t1 with\n| Tint _ _ _ =>\n    match i with\n    | I32 => if Archi.ptr64 then cast_case_i2i i s else cast_case_pointer\n    | IBool => cast_case_i2bool\n    | _ => cast_case_i2i i s\n    end\n| Tlong _ _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_l2bool else cast_case_l2i i s\n| Tfloat F32 _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_s2bool else cast_case_s2i i s\n| Tfloat F64 _ =>\n    if Ctypes.intsize_eq i IBool then cast_case_f2bool else cast_case_f2i i s\n| Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ =>\n    if Archi.ptr64\n    then\n     if Ctypes.intsize_eq i IBool\n     then cast_case_l2bool\n     else cast_case_l2i i s\n    else\n     match i with\n     | I32 => cast_case_pointer\n     | IBool => cast_case_i2bool\n     | _ => cast_case_i2i i s\n     end\n| _ => cast_case_default\nend <> cast_case_default)","proofString":"apply (wt_cast_int i s a i s a)."},{"statement":"(t1 : type) (s : signedness) (a : attr) (H : match t1 with\n| Tint _ si1 _ => cast_case_i2l si1\n| Tlong _ _ => if Archi.ptr64 then cast_case_pointer else cast_case_l2l\n| Tfloat F32 _ => cast_case_s2l s\n| Tfloat F64 _ => cast_case_f2l s\n| Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ =>\n    if Archi.ptr64 then cast_case_pointer else cast_case_i2l s\n| _ => cast_case_default\nend <> cast_case_default) : (if Archi.ptr64 then cast_case_pointer else cast_case_l2l) <>\ncast_case_default.","conclusion":"(if Archi.ptr64 then cast_case_pointer else cast_case_l2l) <>\ncast_case_default","hypotheses":"(t1 : type) (s : signedness) (a : attr) (H : match t1 with\n| Tint _ si1 _ => cast_case_i2l si1\n| Tlong _ _ => if Archi.ptr64 then cast_case_pointer else cast_case_l2l\n| Tfloat F32 _ => cast_case_s2l s\n| Tfloat F64 _ => cast_case_f2l s\n| Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ =>\n    if Archi.ptr64 then cast_case_pointer else cast_case_i2l s\n| _ => cast_case_default\nend <> cast_case_default)","proofString":"destruct Archi.ptr64; congruence."},{"statement":"(t1 : type) (f : floatsize) (a : attr) (H : match f with\n| F32 =>\n    match t1 with\n    | Tint _ si1 _ => cast_case_i2s si1\n    | Tlong si1 _ => cast_case_l2s si1\n    | Tfloat F32 _ => cast_case_s2s\n    | Tfloat F64 _ => cast_case_f2s\n    | _ => cast_case_default\n    end\n| F64 =>\n    match t1 with\n    | Tint _ si1 _ => cast_case_i2f si1\n    | Tlong si1 _ => cast_case_l2f si1\n    | Tfloat F32 _ => cast_case_s2f\n    | Tfloat F64 _ => cast_case_f2f\n    | _ => cast_case_default\n    end\nend <> cast_case_default) : match f with\n| F32 => match f with\n         | F32 => cast_case_s2s\n         | F64 => cast_case_f2s\n         end\n| F64 => match f with\n         | F32 => cast_case_s2f\n         | F64 => cast_case_f2f\n         end\nend <> cast_case_default.","conclusion":"match f with\n| F32 => match f with\n         | F32 => cast_case_s2s\n         | F64 => cast_case_f2s\n         end\n| F64 => match f with\n         | F32 => cast_case_s2f\n         | F64 => cast_case_f2f\n         end\nend <> cast_case_default","hypotheses":"(t1 : type) (f : floatsize) (a : attr) (H : match f with\n| F32 =>\n    match t1 with\n    | Tint _ si1 _ => cast_case_i2s si1\n    | Tlong si1 _ => cast_case_l2s si1\n    | Tfloat F32 _ => cast_case_s2s\n    | Tfloat F64 _ => cast_case_f2s\n    | _ => cast_case_default\n    end\n| F64 =>\n    match t1 with\n    | Tint _ si1 _ => cast_case_i2f si1\n    | Tlong si1 _ => cast_case_l2f si1\n    | Tfloat F32 _ => cast_case_s2f\n    | Tfloat F64 _ => cast_case_f2f\n    | _ => cast_case_default\n    end\nend <> cast_case_default)","proofString":"destruct f; congruence."},{"statement":"(ty1 : type) (msg : string) (ty2 : type) (H : binarith_type ty1 type_int32s msg = OK ty2) : ty2 = incrdecr_type ty1.","conclusion":"ty2 = incrdecr_type ty1","hypotheses":"(ty1 : type) (msg : string) (ty2 : type) (H : binarith_type ty1 type_int32s msg = OK ty2)","proofString":"unfold incrdecr_type.\nunfold binarith_type, classify_binarith in H; simpl in H.\ndestruct ty1; simpl; try congruence.\ndestruct i; destruct s; try congruence.\ndestruct s; congruence.\ndestruct f; congruence."},{"statement":"(ty1 : type) (msg : string) (ty2 : type) (H : binarith_type ty1 type_int32s msg = OK ty2) : ty2 =\nmatch typeconv ty1 with\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a => Tpointer ty a\n| _ => Tvoid\nend.","conclusion":"ty2 =\nmatch typeconv ty1 with\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a => Tpointer ty a\n| _ => Tvoid\nend","hypotheses":"(ty1 : type) (msg : string) (ty2 : type) (H : binarith_type ty1 type_int32s msg = OK ty2)","proofString":"unfold binarith_type, classify_binarith in H; simpl in H.\ndestruct ty1; simpl; try congruence.\ndestruct i; destruct s; try congruence.\ndestruct s; congruence.\ndestruct f; congruence."},{"statement":"(ty1 : type) (msg : string) (ty2 : type) (H : match\n  match ty1 with\n  | Tint I32 Unsigned _ => bin_case_i Unsigned\n  | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ | Tint IBool _ _ =>\n      bin_case_i Signed\n  | Tlong (Signed as sg) _ | Tlong (Unsigned as sg) _ => bin_case_l sg\n  | Tfloat F32 _ => bin_case_s\n  | Tfloat F64 _ => bin_case_f\n  | _ => bin_default\n  end\nwith\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2) : ty2 =\nmatch typeconv ty1 with\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a => Tpointer ty a\n| _ => Tvoid\nend.","conclusion":"ty2 =\nmatch typeconv ty1 with\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a => Tpointer ty a\n| _ => Tvoid\nend","hypotheses":"(ty1 : type) (msg : string) (ty2 : type) (H : match\n  match ty1 with\n  | Tint I32 Unsigned _ => bin_case_i Unsigned\n  | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ | Tint IBool _ _ =>\n      bin_case_i Signed\n  | Tlong (Signed as sg) _ | Tlong (Unsigned as sg) _ => bin_case_l sg\n  | Tfloat F32 _ => bin_case_s\n  | Tfloat F64 _ => bin_case_f\n  | _ => bin_default\n  end\nwith\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2)","proofString":"destruct ty1; simpl; try congruence.\ndestruct i; destruct s; try congruence.\ndestruct s; congruence.\ndestruct f; congruence."},{"statement":"(i : intsize) (s : signedness) (a : attr) (msg : string) (ty2 : type) (H : match\n  match i with\n  | I32 =>\n      match s with\n      | Signed => bin_case_i Signed\n      | Unsigned => bin_case_i Unsigned\n      end\n  | _ => bin_case_i Signed\n  end\nwith\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2) : ty2 =\nmatch\n  match i with\n  | I32 => Tint i s noattr\n  | _ => Tint I32 Signed noattr\n  end\nwith\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a0 => Tpointer ty a0\n| _ => Tvoid\nend.","conclusion":"ty2 =\nmatch\n  match i with\n  | I32 => Tint i s noattr\n  | _ => Tint I32 Signed noattr\n  end\nwith\n| Tint sz sg _ => Tint sz sg noattr\n| Tlong sg _ => Tlong sg noattr\n| Tfloat sz _ => Tfloat sz noattr\n| Tpointer ty a0 => Tpointer ty a0\n| _ => Tvoid\nend","hypotheses":"(i : intsize) (s : signedness) (a : attr) (msg : string) (ty2 : type) (H : match\n  match i with\n  | I32 =>\n      match s with\n      | Signed => bin_case_i Signed\n      | Unsigned => bin_case_i Unsigned\n      end\n  | _ => bin_case_i Signed\n  end\nwith\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2)","proofString":"destruct i; destruct s; try congruence."},{"statement":"(s : signedness) (a : attr) (msg : string) (ty2 : type) (H : match match s with\n      | Signed | _ => bin_case_l s\n      end with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2) : ty2 = Tlong s noattr.","conclusion":"ty2 = Tlong s noattr","hypotheses":"(s : signedness) (a : attr) (msg : string) (ty2 : type) (H : match match s with\n      | Signed | _ => bin_case_l s\n      end with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2)","proofString":"destruct s; congruence."},{"statement":"(f : floatsize) (a : attr) (msg : string) (ty2 : type) (H : match match f with\n      | F32 => bin_case_s\n      | F64 => bin_case_f\n      end with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2) : ty2 = Tfloat f noattr.","conclusion":"ty2 = Tfloat f noattr","hypotheses":"(f : floatsize) (a : attr) (msg : string) (ty2 : type) (H : match match f with\n      | F32 => bin_case_s\n      | F64 => bin_case_f\n      end with\n| bin_case_i sg => OK (Tint I32 sg noattr)\n| bin_case_l sg => OK (Tlong sg noattr)\n| bin_case_f => OK (Tfloat F64 noattr)\n| bin_case_s => OK (Tfloat F32 noattr)\n| bin_default => Error (Errors.msg msg)\nend = OK ty2)","proofString":"destruct f; congruence."},{"statement":"(ty1 ty2 : type) (H : match classify_add ty1 type_int32s with\n| add_case_pi ty _ | add_case_pl ty | add_case_ip _ ty | add_case_lp ty =>\n    OK (Tpointer ty noattr)\n| add_default => binarith_type ty1 type_int32s \"operator +\"\nend = OK ty2) : ty2 = incrdecr_type ty1.","conclusion":"ty2 = incrdecr_type ty1","hypotheses":"(ty1 ty2 : type) (H : match classify_add ty1 type_int32s with\n| add_case_pi ty _ | add_case_pl ty | add_case_ip _ ty | add_case_lp ty =>\n    OK (Tpointer ty noattr)\n| add_default => binarith_type ty1 type_int32s \"operator +\"\nend = OK ty2)","proofString":"unfold classify_add in H; destruct ty1; simpl in H;  try (eapply binarith_type_int32s; eauto; fail).\ndestruct i; eapply binarith_type_int32s; eauto.\ninv H; auto.\ninv H; auto.\ninv H; auto."},{"statement":"(i : intsize) (s : signedness) (a : attr) (ty2 : type) (H : match\n  match\n    match i with\n    | I32 => Tint i s noattr\n    | _ => Tint I32 Signed noattr\n    end\n  with\n  | Tpointer ty _ => add_case_pi ty Signed\n  | _ => add_default\n  end\nwith\n| add_case_pi ty _ | add_case_pl ty | add_case_ip _ ty | add_case_lp ty =>\n    OK (Tpointer ty noattr)\n| add_default => binarith_type (Tint i s a) type_int32s \"operator +\"\nend = OK ty2) : ty2 = incrdecr_type (Tint i s a).","conclusion":"ty2 = incrdecr_type (Tint i s a)","hypotheses":"(i : intsize) (s : signedness) (a : attr) (ty2 : type) (H : match\n  match\n    match i with\n    | I32 => Tint i s noattr\n    | _ => Tint I32 Signed noattr\n    end\n  with\n  | Tpointer ty _ => add_case_pi ty Signed\n  | _ => add_default\n  end\nwith\n| add_case_pi ty _ | add_case_pl ty | add_case_ip _ ty | add_case_lp ty =>\n    OK (Tpointer ty noattr)\n| add_default => binarith_type (Tint i s a) type_int32s \"operator +\"\nend = OK ty2)","proofString":"destruct i; eapply binarith_type_int32s; eauto."},{"statement":"(ty1 : type) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2) : ty2 = incrdecr_type (Tpointer ty1 a).","conclusion":"ty2 = incrdecr_type (Tpointer ty1 a)","hypotheses":"(ty1 : type) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(ty1 : type) (z : Z) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2) : ty2 = incrdecr_type (Tarray ty1 z a).","conclusion":"ty2 = incrdecr_type (Tarray ty1 z a)","hypotheses":"(ty1 : type) (z : Z) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(l : list type) (ty1 : type) (c : calling_convention) (ty2 : type) (H : OK (Tpointer (Tfunction l ty1 c) noattr) = OK ty2) : ty2 = incrdecr_type (Tfunction l ty1 c).","conclusion":"ty2 = incrdecr_type (Tfunction l ty1 c)","hypotheses":"(l : list type) (ty1 : type) (c : calling_convention) (ty2 : type) (H : OK (Tpointer (Tfunction l ty1 c) noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(ty1 ty2 : type) (H : match classify_sub ty1 type_int32s with\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty _ | sub_case_pl ty => OK (Tpointer ty noattr)\n| sub_default => binarith_type ty1 type_int32s \"operator infix -\"\nend = OK ty2) : ty2 = incrdecr_type ty1.","conclusion":"ty2 = incrdecr_type ty1","hypotheses":"(ty1 ty2 : type) (H : match classify_sub ty1 type_int32s with\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty _ | sub_case_pl ty => OK (Tpointer ty noattr)\n| sub_default => binarith_type ty1 type_int32s \"operator infix -\"\nend = OK ty2)","proofString":"unfold classify_sub in H; destruct ty1; simpl in H;  try (eapply binarith_type_int32s; eauto; fail).\ndestruct i; eapply binarith_type_int32s; eauto.\ninv H; auto.\ninv H; auto.\ninv H; auto."},{"statement":"(i : intsize) (s : signedness) (a : attr) (ty2 : type) (H : match\n  match\n    match i with\n    | I32 => Tint i s noattr\n    | _ => Tint I32 Signed noattr\n    end\n  with\n  | Tpointer ty _ => sub_case_pi ty Signed\n  | _ => sub_default\n  end\nwith\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty _ | sub_case_pl ty => OK (Tpointer ty noattr)\n| sub_default => binarith_type (Tint i s a) type_int32s \"operator infix -\"\nend = OK ty2) : ty2 = incrdecr_type (Tint i s a).","conclusion":"ty2 = incrdecr_type (Tint i s a)","hypotheses":"(i : intsize) (s : signedness) (a : attr) (ty2 : type) (H : match\n  match\n    match i with\n    | I32 => Tint i s noattr\n    | _ => Tint I32 Signed noattr\n    end\n  with\n  | Tpointer ty _ => sub_case_pi ty Signed\n  | _ => sub_default\n  end\nwith\n| sub_case_pp _ => OK ptrdiff_t\n| sub_case_pi ty _ | sub_case_pl ty => OK (Tpointer ty noattr)\n| sub_default => binarith_type (Tint i s a) type_int32s \"operator infix -\"\nend = OK ty2)","proofString":"destruct i; eapply binarith_type_int32s; eauto."},{"statement":"(ty1 : type) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2) : ty2 = incrdecr_type (Tpointer ty1 a).","conclusion":"ty2 = incrdecr_type (Tpointer ty1 a)","hypotheses":"(ty1 : type) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(ty1 : type) (z : Z) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2) : ty2 = incrdecr_type (Tarray ty1 z a).","conclusion":"ty2 = incrdecr_type (Tarray ty1 z a)","hypotheses":"(ty1 : type) (z : Z) (a : attr) (ty2 : type) (H : OK (Tpointer ty1 noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(l : list type) (ty1 : type) (c : calling_convention) (ty2 : type) (H : OK (Tpointer (Tfunction l ty1 c) noattr) = OK ty2) : ty2 = incrdecr_type (Tfunction l ty1 c).","conclusion":"ty2 = incrdecr_type (Tfunction l ty1 c)","hypotheses":"(l : list type) (ty1 : type) (c : calling_convention) (ty2 : type) (H : OK (Tpointer (Tfunction l ty1 c) noattr) = OK ty2)","proofString":"inv H; auto."},{"statement":"(v : val) (H : match v with\n| Vundef => True\n| _ => False\nend) : wt_val v Tvoid.","conclusion":"wt_val v Tvoid","hypotheses":"(v : val) (H : match v with\n| Vundef => True\n| _ => False\nend)","proofString":"destruct v; contradiction || constructor."},{"statement":"(v : val) (i : intsize) (s : signedness) (a : attr) (H : match\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Xint8signed\n      | Unsigned => Xint8unsigned\n      end\n  | I16 =>\n      match s with\n      | Signed => Xint16signed\n      | Unsigned => Xint16unsigned\n      end\n  | I32 => Xint\n  | IBool => Xbool\n  end\nwith\n| Xbool =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero \\/ n = Int.one\n    | _ => False\n    end\n| Xint8signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 8 n\n    | _ => False\n    end\n| Xint8unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 8 n\n    | _ => False\n    end\n| Xint16signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 16 n\n    | _ => False\n    end\n| Xint16unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 16 n\n    | _ => False\n    end\n| Xint =>\n    match v with\n    | Vundef | Vint _ => True\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => False\n    end\n| Xfloat => match v with\n            | Vundef | Vfloat _ => True\n            | _ => False\n            end\n| Xlong =>\n    match v with\n    | Vundef | Vlong _ => True\n    | Vptr _ _ => Archi.ptr64 = true\n    | _ => False\n    end\n| Xsingle => match v with\n             | Vundef | Vsingle _ => True\n             | _ => False\n             end\n| Xptr =>\n    match v with\n    | Vint _ => Archi.ptr64 = false\n    | Vlong _ => Archi.ptr64 = true\n    | Vfloat _ | Vsingle _ => False\n    | _ => True\n    end\n| Xany32 =>\n    match v with\n    | Vlong _ | Vfloat _ => False\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => True\n    end\n| Xany64 => True\n| Xvoid => match v with\n           | Vundef => True\n           | _ => False\n           end\nend) : wt_val v (Tint i s a).","conclusion":"wt_val v (Tint i s a)","hypotheses":"(v : val) (i : intsize) (s : signedness) (a : attr) (H : match\n  match i with\n  | I8 =>\n      match s with\n      | Signed => Xint8signed\n      | Unsigned => Xint8unsigned\n      end\n  | I16 =>\n      match s with\n      | Signed => Xint16signed\n      | Unsigned => Xint16unsigned\n      end\n  | I32 => Xint\n  | IBool => Xbool\n  end\nwith\n| Xbool =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero \\/ n = Int.one\n    | _ => False\n    end\n| Xint8signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 8 n\n    | _ => False\n    end\n| Xint8unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 8 n\n    | _ => False\n    end\n| Xint16signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 16 n\n    | _ => False\n    end\n| Xint16unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 16 n\n    | _ => False\n    end\n| Xint =>\n    match v with\n    | Vundef | Vint _ => True\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => False\n    end\n| Xfloat => match v with\n            | Vundef | Vfloat _ => True\n            | _ => False\n            end\n| Xlong =>\n    match v with\n    | Vundef | Vlong _ => True\n    | Vptr _ _ => Archi.ptr64 = true\n    | _ => False\n    end\n| Xsingle => match v with\n             | Vundef | Vsingle _ => True\n             | _ => False\n             end\n| Xptr =>\n    match v with\n    | Vint _ => Archi.ptr64 = false\n    | Vlong _ => Archi.ptr64 = true\n    | Vfloat _ | Vsingle _ => False\n    | _ => True\n    end\n| Xany32 =>\n    match v with\n    | Vlong _ | Vfloat _ => False\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => True\n    end\n| Xany64 => True\n| Xvoid => match v with\n           | Vundef => True\n           | _ => False\n           end\nend)","proofString":"destruct i; [destruct s | destruct s | | ]; destruct v; try contradiction;  constructor; unfold wt_int; auto."},{"statement":"(v : val) (s : signedness) (a : attr) (H : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend) : wt_val v (Tlong s a).","conclusion":"wt_val v (Tlong s a)","hypotheses":"(v : val) (s : signedness) (a : attr) (H : match v with\n| Vundef | Vlong _ => True\n| Vptr _ _ => Archi.ptr64 = true\n| _ => False\nend)","proofString":"destruct v; try contradiction; constructor; auto."},{"statement":"(v : val) (f : floatsize) (a : attr) (H : match match f with\n      | F32 => Xsingle\n      | F64 => Xfloat\n      end with\n| Xbool =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero \\/ n = Int.one\n    | _ => False\n    end\n| Xint8signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 8 n\n    | _ => False\n    end\n| Xint8unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 8 n\n    | _ => False\n    end\n| Xint16signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 16 n\n    | _ => False\n    end\n| Xint16unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 16 n\n    | _ => False\n    end\n| Xint =>\n    match v with\n    | Vundef | Vint _ => True\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => False\n    end\n| Xfloat => match v with\n            | Vundef | Vfloat _ => True\n            | _ => False\n            end\n| Xlong =>\n    match v with\n    | Vundef | Vlong _ => True\n    | Vptr _ _ => Archi.ptr64 = true\n    | _ => False\n    end\n| Xsingle => match v with\n             | Vundef | Vsingle _ => True\n             | _ => False\n             end\n| Xptr =>\n    match v with\n    | Vint _ => Archi.ptr64 = false\n    | Vlong _ => Archi.ptr64 = true\n    | Vfloat _ | Vsingle _ => False\n    | _ => True\n    end\n| Xany32 =>\n    match v with\n    | Vlong _ | Vfloat _ => False\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => True\n    end\n| Xany64 => True\n| Xvoid => match v with\n           | Vundef => True\n           | _ => False\n           end\nend) : wt_val v (Tfloat f a).","conclusion":"wt_val v (Tfloat f a)","hypotheses":"(v : val) (f : floatsize) (a : attr) (H : match match f with\n      | F32 => Xsingle\n      | F64 => Xfloat\n      end with\n| Xbool =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero \\/ n = Int.one\n    | _ => False\n    end\n| Xint8signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 8 n\n    | _ => False\n    end\n| Xint8unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 8 n\n    | _ => False\n    end\n| Xint16signed =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.sign_ext 16 n\n    | _ => False\n    end\n| Xint16unsigned =>\n    match v with\n    | Vundef => True\n    | Vint n => n = Int.zero_ext 16 n\n    | _ => False\n    end\n| Xint =>\n    match v with\n    | Vundef | Vint _ => True\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => False\n    end\n| Xfloat => match v with\n            | Vundef | Vfloat _ => True\n            | _ => False\n            end\n| Xlong =>\n    match v with\n    | Vundef | Vlong _ => True\n    | Vptr _ _ => Archi.ptr64 = true\n    | _ => False\n    end\n| Xsingle => match v with\n             | Vundef | Vsingle _ => True\n             | _ => False\n             end\n| Xptr =>\n    match v with\n    | Vint _ => Archi.ptr64 = false\n    | Vlong _ => Archi.ptr64 = true\n    | Vfloat _ | Vsingle _ => False\n    | _ => True\n    end\n| Xany32 =>\n    match v with\n    | Vlong _ | Vfloat _ => False\n    | Vptr _ _ => Archi.ptr64 = false\n    | _ => True\n    end\n| Xany64 => True\n| Xvoid => match v with\n           | Vundef => True\n           | _ => False\n           end\nend)","proofString":"destruct f; destruct v; try contradiction; constructor."},{"statement":"(v : val) (ty : type) (a : attr) (H : match v with\n| Vint _ => Archi.ptr64 = false\n| Vlong _ => Archi.ptr64 = true\n| Vfloat _ | Vsingle _ => False\n| _ => True\nend) : wt_val v (Tpointer ty a).","conclusion":"wt_val v (Tpointer ty a)","hypotheses":"(v : val) (ty : type) (a : attr) (H : match v with\n| Vint _ => Archi.ptr64 = false\n| Vlong _ => Archi.ptr64 = true\n| Vfloat _ | Vsingle _ => False\n| _ => True\nend)","proofString":"destruct v; try contradiction; constructor; auto."},{"statement":"(v : val) (ty : type) (z : Z) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend) : wt_val v (Tarray ty z a).","conclusion":"wt_val v (Tarray ty z a)","hypotheses":"(v : val) (ty : type) (z : Z) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend)","proofString":"destruct v; contradiction || constructor."},{"statement":"(v : val) (l : list type) (ty : type) (c : calling_convention) (H : match v with\n| Vundef => True\n| _ => False\nend) : wt_val v (Tfunction l ty c).","conclusion":"wt_val v (Tfunction l ty c)","hypotheses":"(v : val) (l : list type) (ty : type) (c : calling_convention) (H : match v with\n| Vundef => True\n| _ => False\nend)","proofString":"destruct v; contradiction || constructor."},{"statement":"(v : val) (i : ident) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend) : wt_val v (Tstruct i a).","conclusion":"wt_val v (Tstruct i a)","hypotheses":"(v : val) (i : ident) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend)","proofString":"destruct v; contradiction || constructor."},{"statement":"(v : val) (i : ident) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend) : wt_val v (Tunion i a).","conclusion":"wt_val v (Tunion i a)","hypotheses":"(v : val) (i : ident) (a : attr) (H : match v with\n| Vundef => True\n| _ => False\nend)","proofString":"destruct v; contradiction || constructor."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : typeof (Eloc b ofs bf ty) = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : typeof (Eloc b ofs bf ty) = ty)","proofString":"simpl in *.\nconstructor.\neapply wt_deref_loc; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : ty = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : ty = ty)","proofString":"constructor.\neapply wt_deref_loc; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : ty = ty) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (bf : bitfield) (ty : type) (m : mem) (t : trace) (v : val) (H : deref_loc ge ty m b ofs bf t v) (WT : wt_rvalue ge tenv (Evalof (Eloc b ofs bf ty) ty)) (l : expr) (H1 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H0 : l = Eloc b ofs bf ty) (H2 : ty = ty)","proofString":"eapply wt_deref_loc; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Eaddrof (Eloc b ofs Full ty1) ty)) (l : expr) (H0 : wt_lvalue ge tenv (Eloc b ofs Full ty1)) (H : l = Eloc b ofs Full ty1) (H1 : Tpointer (typeof (Eloc b ofs Full ty1)) noattr = ty) : wt_rvalue ge tenv\n  (Eval (Vptr b ofs) (Tpointer (typeof (Eloc b ofs Full ty1)) noattr)).","conclusion":"wt_rvalue ge tenv\n  (Eval (Vptr b ofs) (Tpointer (typeof (Eloc b ofs Full ty1)) noattr))","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Eaddrof (Eloc b ofs Full ty1) ty)) (l : expr) (H0 : wt_lvalue ge tenv (Eloc b ofs Full ty1)) (H : l = Eloc b ofs Full ty1) (H1 : Tpointer (typeof (Eloc b ofs Full ty1)) noattr = ty)","proofString":"constructor; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (op0 : unary_operation) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : type_unop op (typeof (Eval v1 ty1)) = OK ty) (H0 : op0 = op) (H1 : r = Eval v1 ty1) (H3 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (op0 : unary_operation) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : type_unop op (typeof (Eval v1 ty1)) = OK ty) (H0 : op0 = op) (H1 : r = Eval v1 ty1) (H3 : ty0 = ty)","proofString":"simpl in H4.\ninv H2.\nconstructor.\neapply pres_sem_unop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (op0 : unary_operation) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : type_unop op ty1 = OK ty) (H0 : op0 = op) (H1 : r = Eval v1 ty1) (H3 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (op0 : unary_operation) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : type_unop op ty1 = OK ty) (H0 : op0 = op) (H1 : r = Eval v1 ty1) (H3 : ty0 = ty)","proofString":"inv H2.\nconstructor.\neapply pres_sem_unop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (H4 : type_unop op ty1 = OK ty) (H6 : wt_val v1 ty1) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (H4 : type_unop op ty1 = OK ty) (H6 : wt_val v1 ty1)","proofString":"constructor.\neapply pres_sem_unop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (H4 : type_unop op ty1 = OK ty) (H6 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (tenv : typenv) (op : unary_operation) (v1 : val) (ty1 ty : type) (m : mem) (v : val) (H : sem_unary_operation op v1 ty1 m = Some v) (WT : wt_rvalue ge tenv (Eunop op (Eval v1 ty1) ty)) (H4 : type_unop op ty1 = OK ty) (H6 : wt_val v1 ty1)","proofString":"eapply pres_sem_unop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (op0 : binary_operation) (r1 r2 : expr) (ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op (typeof (Eval v1 ty1)) (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H1 : r1 = Eval v1 ty1) (H2 : r2 = Eval v2 ty2) (H4 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (op0 : binary_operation) (r1 r2 : expr) (ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op (typeof (Eval v1 ty1)) (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H1 : r1 = Eval v1 ty1) (H2 : r2 = Eval v2 ty2) (H4 : ty0 = ty)","proofString":"simpl in H6.\ninv H3.\ninv H5.\nconstructor.\neapply pres_sem_binop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (op0 : binary_operation) (r1 r2 : expr) (ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op ty1 ty2 = OK ty) (H0 : op0 = op) (H1 : r1 = Eval v1 ty1) (H2 : r2 = Eval v2 ty2) (H4 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (op0 : binary_operation) (r1 r2 : expr) (ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op ty1 ty2 = OK ty) (H0 : op0 = op) (H1 : r1 = Eval v1 ty1) (H2 : r2 = Eval v2 ty2) (H4 : ty0 = ty)","proofString":"inv H3.\ninv H5.\nconstructor.\neapply pres_sem_binop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1)","proofString":"inv H5.\nconstructor.\neapply pres_sem_binop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1) (H1 : wt_val v2 ty2) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1) (H1 : wt_val v2 ty2)","proofString":"constructor.\neapply pres_sem_binop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1) (H1 : wt_val v2 ty2) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (v1 : val) (ty1 : type) (v2 : val) (ty2 ty : type) (m : mem) (v : val) (H : sem_binary_operation ge op v1 ty1 v2 ty2 m = Some v) (WT : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)) (H6 : type_binop op ty1 ty2 = OK ty) (H8 : wt_val v1 ty1) (H1 : wt_val v2 ty2)","proofString":"eapply pres_sem_binop; eauto."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H0 : r = Eval v1 ty1) (H1 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (r : expr) (ty0 : type) (H2 : wt_rvalue ge tenv (Eval v1 ty1)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H0 : r = Eval v1 ty1) (H1 : ty0 = ty)","proofString":"inv H2.\nconstructor.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H5 : wt_val v1 ty1) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H5 : wt_val v1 ty1)","proofString":"constructor.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H5 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (v1 : val) (ty1 : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty m = Some v) (WT : wt_rvalue ge tenv (Ecast (Eval v1 ty1) ty)) (H3 : wt_cast (typeof (Eval v1 ty1)) ty) (H5 : wt_val v1 ty1)","proofString":"eapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"subst.\nconstructor.\nauto.\napply wt_bool_cast; auto.\nred; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"constructor.\nauto.\napply wt_bool_cast; auto.\nred; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_rvalue ge tenv r2.","conclusion":"wt_rvalue ge tenv r2","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_cast (typeof r2) type_bool.","conclusion":"wt_cast (typeof r2) type_bool","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"apply wt_bool_cast; auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : subtype type_bool (Tint I32 Signed noattr).","conclusion":"subtype type_bool (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"red; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (v : val) (H0 : wt_val v type_bool) : wt_val v (Tint I32 Signed noattr).","conclusion":"wt_val v (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (v : val) (H0 : wt_val v type_bool)","proofString":"inv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_rvalue ge tenv (Eval (Vint Int.zero) (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eval (Vint Int.zero) (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"constructor.\nauto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_val (Vint Int.zero) (Tint I32 Signed noattr).","conclusion":"wt_val (Vint Int.zero) (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqand (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_rvalue ge tenv (Eval (Vint Int.one) (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eval (Vint Int.one) (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"constructor.\nauto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_val (Vint Int.one) (Tint I32 Signed noattr).","conclusion":"wt_val (Vint Int.one) (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some true) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty) : wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 ty)) (r1 r0 : expr) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (H0 : r1 = Eval v1 ty1) (H1 : r0 = r2) (H2 : Tint I32 Signed noattr = ty)","proofString":"subst.\nconstructor.\nauto.\napply wt_bool_cast; auto.\nred; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr)).","conclusion":"wt_rvalue ge tenv (Eparen r2 type_bool (Tint I32 Signed noattr))","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"constructor.\nauto.\napply wt_bool_cast; auto.\nred; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_rvalue ge tenv r2.","conclusion":"wt_rvalue ge tenv r2","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : wt_cast (typeof r2) type_bool.","conclusion":"wt_cast (typeof r2) type_bool","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"apply wt_bool_cast; auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) : subtype type_bool (Tint I32 Signed noattr).","conclusion":"subtype type_bool (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2))","proofString":"red; intros.\ninv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (v : val) (H0 : wt_val v type_bool) : wt_val v (Tint I32 Signed noattr).","conclusion":"wt_val v (Tint I32 Signed noattr)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r2 : expr) (m : mem) (H : bool_val v1 ty1 m = Some false) (WT : wt_rvalue ge tenv (Eseqor (Eval v1 ty1) r2 (Tint I32 Signed noattr))) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_rvalue ge tenv r2) (H5 : wt_bool (typeof (Eval v1 ty1))) (H6 : wt_bool (typeof r2)) (v : val) (H0 : wt_val v type_bool)","proofString":"inv H0; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty) : wt_rvalue ge tenv (Eparen (if b then r1 else r2) ty ty).","conclusion":"wt_rvalue ge tenv (Eparen (if b then r1 else r2) ty ty)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty)","proofString":"constructor.\ndestruct b; auto.\ndestruct b; auto.\nred; auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty) : wt_rvalue ge tenv (if b then r1 else r2).","conclusion":"wt_rvalue ge tenv (if b then r1 else r2)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty)","proofString":"destruct b; auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty) : wt_cast (typeof (if b then r1 else r2)) ty.","conclusion":"wt_cast (typeof (if b then r1 else r2)) ty","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty)","proofString":"destruct b; auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty) : subtype ty ty.","conclusion":"subtype ty ty","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 : type) (r1 r2 : expr) (ty : type) (b : bool) (m : mem) (H : bool_val v1 ty1 m = Some b) (WT : wt_rvalue ge tenv (Econdition (Eval v1 ty1) r1 r2 ty)) (r0 r3 r4 : expr) (ty0 : type) (H4 : wt_rvalue ge tenv (Eval v1 ty1)) (H5 : wt_rvalue ge tenv r1) (H6 : wt_rvalue ge tenv r2) (H7 : wt_bool (typeof (Eval v1 ty1))) (H8 : wt_cast (typeof r1) ty) (H9 : wt_cast (typeof r2) ty) (H0 : r0 = Eval v1 ty1) (H1 : r3 = r1) (H2 : r4 = r2) (H3 : ty0 = ty)","proofString":"red; auto."},{"statement":"(ge : genv) (tenv : typenv) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Esizeof ty1 ty)) (ty0 : type) (H0 : ty0 = ty1) (H1 : size_t = ty) : wt_rvalue ge tenv (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) size_t).","conclusion":"wt_rvalue ge tenv (Eval (Vptrofs (Ptrofs.repr (sizeof ge ty1))) size_t)","hypotheses":"(ge : genv) (tenv : typenv) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Esizeof ty1 ty)) (ty0 : type) (H0 : ty0 = ty1) (H1 : size_t = ty)","proofString":"unfold size_t, Vptrofs; destruct Archi.ptr64; constructor; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Ealignof ty1 ty)) (ty0 : type) (H0 : ty0 = ty1) (H1 : size_t = ty) : wt_rvalue ge tenv (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) size_t).","conclusion":"wt_rvalue ge tenv (Eval (Vptrofs (Ptrofs.repr (alignof ge ty1))) size_t)","hypotheses":"(ge : genv) (tenv : typenv) (ty1 ty : type) (m : mem) (WT : wt_rvalue ge tenv (Ealignof ty1 ty)) (ty0 : type) (H0 : ty0 = ty1) (H1 : size_t = ty)","proofString":"unfold size_t, Vptrofs; destruct Archi.ptr64; constructor; auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv (Eval v' ty1).","conclusion":"wt_rvalue ge tenv (Eval v' ty1)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"inversion H5.\nconstructor.\neapply wt_assign_loc; eauto.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2) : wt_rvalue ge tenv (Eval v' ty1).","conclusion":"wt_rvalue ge tenv (Eval v' ty1)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2)","proofString":"constructor.\neapply wt_assign_loc; eauto.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2) : wt_val v' ty1.","conclusion":"wt_val v' ty1","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2)","proofString":"eapply wt_assign_loc; eauto.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2) : wt_val v ty1.","conclusion":"wt_val v ty1","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (v : val) (t : trace) (m' : mem) (v' : val) (H : sem_cast v2 ty2 ty1 m = Some v) (H0 : assign_loc ge ty1 m b ofs bf v t m' v') (WT : wt_rvalue ge tenv (Eassign (Eloc b ofs bf ty1) (Eval v2 ty2) ty1)) (l r : expr) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H5 : wt_rvalue ge tenv (Eval v2 ty2)) (H6 : wt_cast (typeof (Eval v2 ty2)) ty1) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : typeof (Eloc b ofs bf ty1) = ty1) (v0 : val) (ty : type) (H8 : wt_val v2 ty2) (H7 : v0 = v2) (H9 : ty = ty2)","proofString":"eapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) tyres ty1)) (op0 : binary_operation) (l r : expr) (ty : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK tyres) (H8 : wt_cast tyres ty1) (H0 : op0 = op) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : ty = tyres) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty1) (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres)\n     ty1).","conclusion":"wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty1) (Ebinop op (Eval v1 ty1) (Eval v2 ty2) tyres)\n     ty1)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 tyres : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) tyres ty1)) (op0 : binary_operation) (l r : expr) (ty : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK tyres) (H8 : wt_cast tyres ty1) (H0 : op0 = op) (H1 : l = Eloc b ofs bf ty1) (H2 : r = Eval v2 ty2) (H3 : ty = tyres) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"subst tyres l r.\nconstructor.\nauto.\nconstructor.\nconstructor.\neapply wt_deref_loc; eauto.\nauto.\nauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty1) (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty) ty1).","conclusion":"wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty1) (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty) ty1)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"constructor.\nauto.\nconstructor.\nconstructor.\neapply wt_deref_loc; eauto.\nauto.\nauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_lvalue ge tenv (Eloc b ofs bf ty1).","conclusion":"wt_lvalue ge tenv (Eloc b ofs bf ty1)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty).","conclusion":"wt_rvalue ge tenv (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"constructor.\nconstructor.\neapply wt_deref_loc; eauto.\nauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv (Eval v1 ty1).","conclusion":"wt_rvalue ge tenv (Eval v1 ty1)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"constructor.\neapply wt_deref_loc; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_val v1 ty1.","conclusion":"wt_val v1 ty1","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"eapply wt_deref_loc; eauto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_rvalue ge tenv (Eval v2 ty2).","conclusion":"wt_rvalue ge tenv (Eval v2 ty2)","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : type_binop op (typeof (Eval v1 ty1)) (typeof (Eval v2 ty2)) = OK ty.","conclusion":"type_binop op (typeof (Eval v1 ty1)) (typeof (Eval v2 ty2)) = OK ty","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1) : wt_cast (typeof (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty))\n  (typeof (Eloc b ofs bf ty1)).","conclusion":"wt_cast (typeof (Ebinop op (Eval v1 ty1) (Eval v2 ty2) ty))\n  (typeof (Eloc b ofs bf ty1))","hypotheses":"(ge : genv) (tenv : typenv) (op : binary_operation) (b : block) (ofs : ptrofs) (ty1 : type) (bf : bitfield) (v2 : val) (ty2 : type) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty1 m b ofs bf t v1) (ty : type) (WT : wt_rvalue ge tenv (Eassignop op (Eloc b ofs bf ty1) (Eval v2 ty2) ty ty1)) (op0 : binary_operation) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty1)) (H6 : wt_rvalue ge tenv (Eval v2 ty2)) (H8 : wt_cast ty ty1) (H7 : type_binop op ty1 (typeof (Eval v2 ty2)) = OK ty) (H0 : op0 = op) (H5 : typeof (Eloc b ofs bf ty1) = ty1)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (id0 : incr_or_decr) (l : expr) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H1 : id0 = id) (H2 : l = Eloc b ofs bf ty) (H3 : typeof (Eloc b ofs bf ty) = ty) : wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty).","conclusion":"wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (id0 : incr_or_decr) (l : expr) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H1 : id0 = id) (H2 : l = Eloc b ofs bf ty) (H3 : typeof (Eloc b ofs bf ty) = ty)","proofString":"simpl in *.\nsubst id0 l.\nexploit wt_deref_loc; eauto.\nintros WTV1.\nconstructor.\nconstructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto.\nconstructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (id0 : incr_or_decr) (l : expr) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H1 : id0 = id) (H2 : l = Eloc b ofs bf ty) (H3 : ty = ty) : wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty).","conclusion":"wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (id0 : incr_or_decr) (l : expr) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H1 : id0 = id) (H2 : l = Eloc b ofs bf ty) (H3 : ty = ty)","proofString":"subst id0 l.\nexploit wt_deref_loc; eauto.\nintros WTV1.\nconstructor.\nconstructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto.\nconstructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) : wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty).","conclusion":"wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty)","proofString":"exploit wt_deref_loc; eauto.\nintros WTV1.\nconstructor.\nconstructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto.\nconstructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) : wt_val v1 ty ->\nwt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty).","conclusion":"wt_val v1 ty ->\nwt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty)","proofString":"intros WTV1.\nconstructor.\nconstructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto.\nconstructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty).","conclusion":"wt_rvalue ge tenv\n  (Ecomma\n     (Eassign (Eloc b ofs bf ty)\n        (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n           (incrdecr_type ty)) ty) (Eval v1 ty) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor.\nconstructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto.\nconstructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty)\n     (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n        (incrdecr_type ty)) ty).","conclusion":"wt_rvalue ge tenv\n  (Eassign (Eloc b ofs bf ty)\n     (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n        (incrdecr_type ty)) ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor.\nauto.\nrewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto.\nsimpl; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_lvalue ge tenv (Eloc b ofs bf ty).","conclusion":"wt_lvalue ge tenv (Eloc b ofs bf ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv\n  (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type ty)).","conclusion":"wt_rvalue ge tenv\n  (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type ty))","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"rewrite <- H0 in H5.\nconstructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv\n  (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type ty)).","conclusion":"wt_rvalue ge tenv\n  (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n     (incrdecr_type ty))","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor.\nconstructor; auto.\nconstructor.\nconstructor.\nauto with ty.\nsubst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv (Eval v1 ty).","conclusion":"wt_rvalue ge tenv (Eval v1 ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv (Eval (Vint Int.one) type_int32s).","conclusion":"wt_rvalue ge tenv (Eval (Vint Int.one) type_int32s)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor.\nconstructor.\nauto with ty."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_val (Vint Int.one) type_int32s.","conclusion":"wt_val (Vint Int.one) type_int32s","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor.\nauto with ty."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_int Int.one I32 Signed.","conclusion":"wt_int Int.one I32 Signed","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop op (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty).","conclusion":"type_binop op (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop op ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"subst op.\ndestruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty).","conclusion":"type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"destruct id.\nerewrite <- type_add_int32s by eauto.\nauto.\nerewrite <- type_sub_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Incr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Oadd ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop Oadd (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty).","conclusion":"type_binop Oadd (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Incr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Oadd ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"erewrite <- type_add_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Incr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Oadd ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop Oadd (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK ty0.","conclusion":"type_binop Oadd (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK ty0","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Incr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Oadd ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Decr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Osub ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop Osub (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty).","conclusion":"type_binop Osub (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK (incrdecr_type ty)","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Decr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Osub ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"erewrite <- type_sub_int32s by eauto.\nauto."},{"statement":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Decr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Osub ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : type_binop Osub (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK ty0.","conclusion":"type_binop Osub (typeof (Eval v1 ty))\n  (typeof (Eval (Vint Int.one) type_int32s)) = OK ty0","hypotheses":"(ge : genv) (tenv : typenv) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (H : deref_loc ge ty m b ofs bf t v1) (WT : wt_rvalue ge tenv (Epostincr Decr (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop Osub ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_cast\n  (typeof\n     (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n        (incrdecr_type ty))) (typeof (Eloc b ofs bf ty)).","conclusion":"wt_cast\n  (typeof\n     (Ebinop op (Eval v1 ty) (Eval (Vint Int.one) type_int32s)\n        (incrdecr_type ty))) (typeof (Eloc b ofs bf ty))","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"simpl; auto."},{"statement":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty) : wt_rvalue ge tenv (Eval v1 ty).","conclusion":"wt_rvalue ge tenv (Eval v1 ty)","hypotheses":"(ge : genv) (tenv : typenv) (id : incr_or_decr) (b : block) (ofs : ptrofs) (ty : type) (bf : bitfield) (m : mem) (t : trace) (v1 : val) (op : binary_operation) (H : deref_loc ge ty m b ofs bf t v1) (H0 : op = match id with\n     | Incr => Oadd\n     | Decr => Osub\n     end) (WT : wt_rvalue ge tenv (Epostincr id (Eloc b ofs bf ty) ty)) (ty0 : type) (H4 : wt_lvalue ge tenv (Eloc b ofs bf ty)) (H5 : type_binop match id with\n           | Incr => Oadd\n           | Decr => Osub\n           end ty (Tint I32 Signed noattr) = OK ty0) (H6 : wt_cast (incrdecr_type ty) ty) (H3 : ty = ty) (WTV1 : wt_val v1 ty)","proofString":"constructor; auto."},{"statement":"(ge : genv) (tenv : typenv) (v : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : typeof r2 = ty) (WT : wt_rvalue ge tenv (Ecomma (Eval v ty1) r2 ty)) (r1 r0 : expr) (H2 : wt_rvalue ge tenv (Eval v ty1)) (H4 : wt_rvalue ge tenv r2) (H0 : r1 = Eval v ty1) (H1 : r0 = r2) (H3 : typeof r2 = ty) : wt_rvalue ge tenv r2.","conclusion":"wt_rvalue ge tenv r2","hypotheses":"(ge : genv) (tenv : typenv) (v : val) (ty1 : type) (r2 : expr) (ty : type) (m : mem) (H : typeof r2 = ty) (WT : wt_rvalue ge tenv (Ecomma (Eval v ty1) r2 ty)) (r1 r0 : expr) (H2 : wt_rvalue ge tenv (Eval v ty1)) (H4 : wt_rvalue ge tenv r2) (H0 : r1 = Eval v ty1) (H1 : r0 = r2) (H3 : typeof r2 = ty)","proofString":"auto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (r : expr) (tycast ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H0 : r = Eval v1 ty1) (H1 : tycast = ty2) (H2 : ty0 = ty) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (r : expr) (tycast ty0 : type) (H3 : wt_rvalue ge tenv (Eval v1 ty1)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H0 : r = Eval v1 ty1) (H1 : tycast = ty2) (H2 : ty0 = ty)","proofString":"inv H3.\nconstructor.\napply H5.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1) : wt_rvalue ge tenv (Eval v ty).","conclusion":"wt_rvalue ge tenv (Eval v ty)","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1)","proofString":"constructor.\napply H5.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1) : wt_val v ty.","conclusion":"wt_val v ty","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1)","proofString":"apply H5.\neapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1) : wt_val v ty2.","conclusion":"wt_val v ty2","hypotheses":"(ge : genv) (tenv : typenv) (v1 : val) (ty1 ty2 ty : type) (m : mem) (v : val) (H : sem_cast v1 ty1 ty2 m = Some v) (WT : wt_rvalue ge tenv (Eparen (Eval v1 ty1) ty2 ty)) (H4 : wt_cast (typeof (Eval v1 ty1)) ty2) (H5 : subtype ty2 ty) (H7 : wt_val v1 ty1)","proofString":"eapply pres_sem_cast; eauto."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (ef0 : external_function) (tyargs0 : list type) (rargs : exprlist) (ty0 : type) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (H7 : ty = Tvoid /\\ sig_res (ef_sig ef) = Xvoid \\/\ntyargs = type_bool :: ty :: ty :: nil /\\\n(let t0 := typ_of_type ty in\n let x := inj_type t0 in\n let sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg)) (H1 : ef0 = ef) (H2 : tyargs0 = tyargs) (H3 : rargs = el) (H5 : ty0 = ty) : wt_rvalue ge tenv (Eval vres ty).","conclusion":"wt_rvalue ge tenv (Eval vres ty)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (ef0 : external_function) (tyargs0 : list type) (rargs : exprlist) (ty0 : type) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (H7 : ty = Tvoid /\\ sig_res (ef_sig ef) = Xvoid \\/\ntyargs = type_bool :: ty :: ty :: nil /\\\n(let t0 := typ_of_type ty in\n let x := inj_type t0 in\n let sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg)) (H1 : ef0 = ef) (H2 : tyargs0 = tyargs) (H3 : rargs = el) (H5 : ty0 = ty)","proofString":"subst.\ndestruct H7 as [(A & B) | (A & B)].\nsubst ty.\nauto with ty.\nsimpl in B.\nset (T := typ_of_type ty) in *.\nset (X := inj_type T) in *.\nset (sg := [Xint; X; X ---> X]%asttyp) in *.\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select T))).\nunfold sg, X, T; destruct ty as   [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nsubst ef.\nred in H0.\nred in H0.\nrewrite LK in H0.\ninv H0.\ninv H.\ninv H8.\ninv H9.\ninv H10.\nsimpl in H1.\nassert (A: val_casted v1 type_bool) by (eapply cast_val_is_casted; eauto).\ninv A.\nset (v' := if Int.eq n Int.zero then v4 else v2) in *.\nconstructor.\ndestruct (type_eq ty Tvoid).\nsubst.\nconstructor.\ninv H1.\nassert (C: val_casted v' ty).\nunfold v'; destruct (Int.eq n Int.zero); eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' T = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\nrewrite EQ.\napply wt_val_casted; auto."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (H7 : ty = Tvoid /\\ sig_res (ef_sig ef) = Xvoid \\/\ntyargs = type_bool :: ty :: ty :: nil /\\\n(let t0 := typ_of_type ty in\n let x := inj_type t0 in\n let sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg)) : wt_rvalue ge tenv (Eval vres ty).","conclusion":"wt_rvalue ge tenv (Eval vres ty)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (H7 : ty = Tvoid /\\ sig_res (ef_sig ef) = Xvoid \\/\ntyargs = type_bool :: ty :: ty :: nil /\\\n(let t0 := typ_of_type ty in\n let x := inj_type t0 in\n let sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg))","proofString":"destruct H7 as [(A & B) | (A & B)].\nsubst ty.\nauto with ty.\nsimpl in B.\nset (T := typ_of_type ty) in *.\nset (X := inj_type T) in *.\nset (sg := [Xint; X; X ---> X]%asttyp) in *.\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select T))).\nunfold sg, X, T; destruct ty as   [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nsubst ef.\nred in H0.\nred in H0.\nrewrite LK in H0.\ninv H0.\ninv H.\ninv H8.\ninv H9.\ninv H10.\nsimpl in H1.\nassert (A: val_casted v1 type_bool) by (eapply cast_val_is_casted; eauto).\ninv A.\nset (v' := if Int.eq n Int.zero then v4 else v2) in *.\nconstructor.\ndestruct (type_eq ty Tvoid).\nsubst.\nconstructor.\ninv H1.\nassert (C: val_casted v' ty).\nunfold v'; destruct (Int.eq n Int.zero); eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' T = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\nrewrite EQ.\napply wt_val_casted; auto."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : ty = Tvoid) (B : sig_res (ef_sig ef) = Xvoid) : wt_rvalue ge tenv (Eval vres ty).","conclusion":"wt_rvalue ge tenv (Eval vres ty)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : ty = Tvoid) (B : sig_res (ef_sig ef) = Xvoid)","proofString":"subst ty.\nauto with ty."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el Tvoid)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (B : sig_res (ef_sig ef) = Xvoid) : wt_rvalue ge tenv (Eval vres Tvoid).","conclusion":"wt_rvalue ge tenv (Eval vres Tvoid)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el Tvoid)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (B : sig_res (ef_sig ef) = Xvoid)","proofString":"auto with ty."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : tyargs = type_bool :: ty :: ty :: nil) (B : let t0 := typ_of_type ty in\nlet x := inj_type t0 in\nlet sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg) : wt_rvalue ge tenv (Eval vres ty).","conclusion":"wt_rvalue ge tenv (Eval vres ty)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : tyargs = type_bool :: ty :: ty :: nil) (B : let t0 := typ_of_type ty in\nlet x := inj_type t0 in\nlet sg := [Xint; x; x ---> x]%asttyp in ef = EF_builtin \"__builtin_sel\" sg)","proofString":"simpl in B.\nset (T := typ_of_type ty) in *.\nset (X := inj_type T) in *.\nset (sg := [Xint; X; X ---> X]%asttyp) in *.\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select T))).\nunfold sg, X, T; destruct ty as   [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nsubst ef.\nred in H0.\nred in H0.\nrewrite LK in H0.\ninv H0.\ninv H.\ninv H8.\ninv H9.\ninv H10.\nsimpl in H1.\nassert (A: val_casted v1 type_bool) by (eapply cast_val_is_casted; eauto).\ninv A.\nset (v' := if Int.eq n Int.zero then v4 else v2) in *.\nconstructor.\ndestruct (type_eq ty Tvoid).\nsubst.\nconstructor.\ninv H1.\nassert (C: val_casted v' ty).\nunfold v'; destruct (Int.eq n Int.zero); eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' T = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\nrewrite EQ.\napply wt_val_casted; auto."},{"statement":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : tyargs = type_bool :: ty :: ty :: nil) (B : ef =\nEF_builtin \"__builtin_sel\"\n  [Xint; inj_type (typ_of_type ty); inj_type (typ_of_type ty) --->\n  inj_type (typ_of_type ty)]%asttyp) : wt_rvalue ge tenv (Eval vres ty).","conclusion":"wt_rvalue ge tenv (Eval vres ty)","hypotheses":"(ge : genv) (tenv : typenv) (ef : external_function) (tyargs : list type) (el : exprlist) (ty : type) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : cast_arguments m el tyargs vargs) (H0 : external_call ef ge vargs m t vres m') (WT : wt_rvalue ge tenv (Ebuiltin ef tyargs el ty)) (H4 : wt_exprlist ge tenv el) (H6 : wt_arguments el tyargs) (A : tyargs = type_bool :: ty :: ty :: nil) (B : ef =\nEF_builtin \"__builtin_sel\"\n  [Xint; inj_type (typ_of_type ty); inj_type (typ_of_type ty) --->\n  inj_type (typ_of_type ty)]%asttyp)","proofString":"set (T := typ_of_type ty) in *.\nset (X := inj_type T) in *.\nset (sg := [Xint; X; X ---> X]%asttyp) in *.\nassert (LK: lookup_builtin_function \"__builtin_sel\"%string sg = Some (BI_standard (BI_select T))).\nunfold sg, X, T; destruct ty as   [ | ? ? ? | ? | [] ? | ? ? | ? ? ? | ? ? ? | ? ? | ? ? ];    simpl; unfold Tptr; destruct Archi.ptr64; reflexivity.\nsubst ef.\nred in H0.\nred in H0.\nrewrite LK in H0.\ninv H0.\ninv H.\ninv H8.\ninv H9.\ninv H10.\nsimpl in H1.\nassert (A: val_casted v1 type_bool) by (eapply cast_val_is_casted; eauto).\ninv A.\nset (v' := if Int.eq n Int.zero then v4 else v2) in *.\nconstructor.\ndestruct (type_eq ty Tvoid).\nsubst.\nconstructor.\ninv H1.\nassert (C: val_casted v' ty).\nunfold v'; destruct (Int.eq n Int.zero); eapply cast_val_is_casted; eauto.\nassert (EQ: Val.normalize v' T = v').\napply Val.normalize_idem.\napply val_casted_has_type; auto.\nrewrite EQ.\napply wt_val_casted; auto."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (vres : val) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H1 : Some (Val.normalize v' T) = Some vres) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (e : ty = Tvoid) : wt_val vres ty.","conclusion":"wt_val vres ty","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (vres : val) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H1 : Some (Val.normalize v' T) = Some vres) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (e : ty = Tvoid)","proofString":"subst.\nconstructor."},{"statement":"(ge : genv) (tenv : typenv) (vres : val) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg)\n     (type_bool :: Tvoid :: Tvoid :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n     Tvoid)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: Tvoid :: Tvoid :: nil)) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H7 : sem_cast v3 ty2 Tvoid m' = Some v4) (H3 : sem_cast v0 ty1 Tvoid m' = Some v2) (H1 : Some (Val.normalize v' T) = Some vres) (H2 : cast_int_int IBool Signed n = n) : wt_val vres Tvoid.","conclusion":"wt_val vres Tvoid","hypotheses":"(ge : genv) (tenv : typenv) (vres : val) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg)\n     (type_bool :: Tvoid :: Tvoid :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n     Tvoid)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: Tvoid :: Tvoid :: nil)) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H7 : sem_cast v3 ty2 Tvoid m' = Some v4) (H3 : sem_cast v0 ty1 Tvoid m' = Some v2) (H1 : Some (Val.normalize v' T) = Some vres) (H2 : cast_int_int IBool Signed n = n)","proofString":"constructor."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (n0 : ty <> Tvoid) (C : val_casted v' ty) (EQ : Val.normalize v' T = v') : wt_val (Val.normalize v' T) ty.","conclusion":"wt_val (Val.normalize v' T) ty","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (n0 : ty <> Tvoid) (C : val_casted v' ty) (EQ : Val.normalize v' T = v')","proofString":"rewrite EQ.\napply wt_val_casted; auto."},{"statement":"(ge : genv) (tenv : typenv) (ty : type) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (n0 : ty <> Tvoid) (C : val_casted v' ty) (EQ : Val.normalize v' T = v') : wt_val v' ty.","conclusion":"wt_val v' ty","hypotheses":"(ge : genv) (tenv : typenv) (ty : type) (m' : mem) (T : typ) (X : xtype) (sg : signature) (v : val) (ty0 : type) (v0 : val) (ty1 : type) (v3 : val) (ty2 : type) (WT : wt_rvalue ge tenv\n  (Ebuiltin (EF_builtin \"__builtin_sel\" sg) (type_bool :: ty :: ty :: nil)\n     (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil))) ty)) (H4 : wt_exprlist ge tenv\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))) (H6 : wt_arguments\n  (Econs (Eval v ty0) (Econs (Eval v0 ty1) (Econs (Eval v3 ty2) Enil)))\n  (type_bool :: ty :: ty :: nil)) (LK : lookup_builtin_function \"__builtin_sel\" sg = Some (BI_standard (BI_select T))) (v2 v4 : val) (n : int) (H5 : sem_cast v ty0 type_bool m' = Some (Vint n)) (v' : val) (H3 : sem_cast v0 ty1 ty m' = Some v2) (H7 : sem_cast v3 ty2 ty m' = Some v4) (H2 : cast_int_int IBool Signed n = n) (n0 : ty <> Tvoid) (C : val_casted v' ty) (EQ : Val.normalize v' T = v')","proofString":"apply wt_val_casted; auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (tyl : list type) (H0 : wt_arguments (Econs (C a) el) tyl) : wt_arguments (Econs (C a') el) tyl.","conclusion":"wt_arguments (Econs (C a') el) tyl","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (tyl : list type) (H0 : wt_arguments (Econs (C a) el) tyl)","proofString":"inv H0.\nconstructor; auto.\nrewrite (typeof_context _ _ _ H); auto.\nconstructor; auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof (C a)) ty) (H5 : wt_arguments el tyl0) : wt_arguments (Econs (C a') el) (ty :: tyl0).","conclusion":"wt_arguments (Econs (C a') el) (ty :: tyl0)","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof (C a)) ty) (H5 : wt_arguments el tyl0)","proofString":"constructor; auto.\nrewrite (typeof_context _ _ _ H); auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof (C a)) ty) (H5 : wt_arguments el tyl0) : wt_cast (typeof (C a')) ty.","conclusion":"wt_cast (typeof (C a')) ty","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof (C a)) ty) (H5 : wt_arguments el tyl0)","proofString":"rewrite (typeof_context _ _ _ H); auto."},{"statement":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H4 : strict = false) : wt_arguments (Econs (C a') el) nil.","conclusion":"wt_arguments (Econs (C a') el) nil","hypotheses":"(k : kind) (C : expr -> expr) (el : exprlist) (H : context k RV C) (H4 : strict = false)","proofString":"constructor; auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl0 : list type, wt_arguments (C a) tyl0 -> wt_arguments (C a') tyl0) (tyl : list type) (H0 : wt_arguments (Econs e1 (C a)) tyl) : wt_arguments (Econs e1 (C a')) tyl.","conclusion":"wt_arguments (Econs e1 (C a')) tyl","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl0 : list type, wt_arguments (C a) tyl0 -> wt_arguments (C a') tyl0) (tyl : list type) (H0 : wt_arguments (Econs e1 (C a)) tyl)","proofString":"inv H0.\nconstructor; auto.\nconstructor; auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl : list type, wt_arguments (C a) tyl -> wt_arguments (C a') tyl) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof e1) ty) (H5 : wt_arguments (C a) tyl0) : wt_arguments (Econs e1 (C a')) (ty :: tyl0).","conclusion":"wt_arguments (Econs e1 (C a')) (ty :: tyl0)","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl : list type, wt_arguments (C a) tyl -> wt_arguments (C a') tyl) (ty : type) (tyl0 : list type) (H3 : wt_cast (typeof e1) ty) (H5 : wt_arguments (C a) tyl0)","proofString":"constructor; auto."},{"statement":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl : list type, wt_arguments (C a) tyl -> wt_arguments (C a') tyl) (H4 : strict = false) : wt_arguments (Econs e1 (C a')) nil.","conclusion":"wt_arguments (Econs e1 (C a')) nil","hypotheses":"(k : kind) (C : expr -> exprlist) (e1 : expr) (H : contextlist k C) (IHcontextlist : forall tyl : list type, wt_arguments (C a) tyl -> wt_arguments (C a') tyl) (H4 : strict = false)","proofString":"constructor; auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) : wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end.","conclusion":"wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl)","proofString":"assert (A: wt_lblstmts ce e rt (select_switch_default sl)).\nrevert sl H.\ninduction 1; simpl; intros.\nconstructor.\ndestruct case.\nauto.\nconstructor; auto.\nassert (B: forall sl', select_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl').\nrevert H.\ngeneralize sl.\ninduction 1; simpl; intros.\ndiscriminate.\ndestruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto.\ndestruct (select_switch_case n sl); auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) : wt_lblstmts ce e rt (select_switch_default sl).","conclusion":"wt_lblstmts ce e rt (select_switch_default sl)","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl)","proofString":"revert sl H.\ninduction 1; simpl; intros.\nconstructor.\ndestruct case.\nauto.\nconstructor; auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) : forall sl : labeled_statements,\nwt_lblstmts ce e rt sl -> wt_lblstmts ce e rt (select_switch_default sl).","conclusion":"forall sl : labeled_statements,\nwt_lblstmts ce e rt sl -> wt_lblstmts ce e rt (select_switch_default sl)","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type)","proofString":"induction 1; simpl; intros.\nconstructor.\ndestruct case.\nauto.\nconstructor; auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) : wt_lblstmts ce e rt LSnil.","conclusion":"wt_lblstmts ce e rt LSnil","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type)","proofString":"constructor."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls)) : wt_lblstmts ce e rt\n  match case with\n  | Some _ => select_switch_default ls\n  | None => LScons case s ls\n  end.","conclusion":"wt_lblstmts ce e rt\n  match case with\n  | Some _ => select_switch_default ls\n  | None => LScons case s ls\n  end","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls))","proofString":"destruct case.\nauto.\nconstructor; auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls)) : wt_lblstmts ce e rt (select_switch_default ls).","conclusion":"wt_lblstmts ce e rt (select_switch_default ls)","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls))","proofString":"auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls)) : wt_lblstmts ce e rt (LScons None s ls).","conclusion":"wt_lblstmts ce e rt (LScons None s ls)","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_lblstmts ce e rt (select_switch_default ls))","proofString":"constructor; auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl)) : wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end.","conclusion":"wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl))","proofString":"assert (B: forall sl', select_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl').\nrevert H.\ngeneralize sl.\ninduction 1; simpl; intros.\ndiscriminate.\ndestruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto.\ndestruct (select_switch_case n sl); auto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl)) : forall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl'.","conclusion":"forall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl))","proofString":"revert H.\ngeneralize sl.\ninduction 1; simpl; intros.\ndiscriminate.\ndestruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) : wt_lblstmts ce e rt sl ->\nforall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl'.","conclusion":"wt_lblstmts ce e rt sl ->\nforall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl))","proofString":"generalize sl.\ninduction 1; simpl; intros.\ndiscriminate.\ndestruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) : forall sl0 : labeled_statements,\nwt_lblstmts ce e rt sl0 ->\nforall sl' : labeled_statements,\nselect_switch_case n sl0 = Some sl' -> wt_lblstmts ce e rt sl'.","conclusion":"forall sl0 : labeled_statements,\nwt_lblstmts ce e rt sl0 ->\nforall sl' : labeled_statements,\nselect_switch_case n sl0 = Some sl' -> wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl))","proofString":"induction 1; simpl; intros.\ndiscriminate.\ndestruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (sl' : labeled_statements) (H : None = Some sl') : wt_lblstmts ce e rt sl'.","conclusion":"wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (sl' : labeled_statements) (H : None = Some sl')","proofString":"discriminate."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (H1 : match case with\n| Some c =>\n    if zeq c n then Some (LScons case s ls) else select_switch_case n ls\n| None => select_switch_case n ls\nend = Some sl') : wt_lblstmts ce e rt sl'.","conclusion":"wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (H1 : match case with\n| Some c =>\n    if zeq c n then Some (LScons case s ls) else select_switch_case n ls\n| None => select_switch_case n ls\nend = Some sl')","proofString":"destruct case; eauto.\ndestruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (H1 : (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls) =\nSome sl') : wt_lblstmts ce e rt sl'.","conclusion":"wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (H1 : (if zeq z n then Some (LScons (Some z) s ls) else select_switch_case n ls) =\nSome sl')","proofString":"destruct (zeq z n); eauto.\ninv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (e0 : z = n) (H1 : Some (LScons (Some z) s ls) = Some sl') : wt_lblstmts ce e rt sl'.","conclusion":"wt_lblstmts ce e rt sl'","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (z : Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl'0 : labeled_statements,\nselect_switch_case n ls = Some sl'0 -> wt_lblstmts ce e rt sl'0) (sl' : labeled_statements) (e0 : z = n) (H1 : Some (LScons (Some z) s ls) = Some sl')","proofString":"inv H1.\neconstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl' : labeled_statements,\nselect_switch_case n ls = Some sl' -> wt_lblstmts ce e rt sl') : wt_lblstmts ce e rt (LScons (Some n) s ls).","conclusion":"wt_lblstmts ce e rt (LScons (Some n) s ls)","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (A : wt_lblstmts ce e rt (select_switch_default sl)) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : forall sl' : labeled_statements,\nselect_switch_case n ls = Some sl' -> wt_lblstmts ce e rt sl')","proofString":"econstructor; eauto."},{"statement":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl)) (B : forall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl') : wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end.","conclusion":"wt_lblstmts ce e rt\n  match select_switch_case n sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end","hypotheses":"(n : Z) (ce : composite_env) (e : typenv) (rt : type) (sl : labeled_statements) (H : wt_lblstmts ce e rt sl) (A : wt_lblstmts ce e rt (select_switch_default sl)) (B : forall sl' : labeled_statements,\nselect_switch_case n sl = Some sl' -> wt_lblstmts ce e rt sl')","proofString":"destruct (select_switch_case n sl); auto."},{"statement":"(ce : composite_env) (e : typenv) (rt : type) : wt_stmt ce e rt Sskip.","conclusion":"wt_stmt ce e rt Sskip","hypotheses":"(ce : composite_env) (e : typenv) (rt : type)","proofString":"constructor."},{"statement":"(ce : composite_env) (e : typenv) (rt : type) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_stmt ce e rt (seq_of_labeled_statement ls)) : wt_stmt ce e rt (Ssequence s (seq_of_labeled_statement ls)).","conclusion":"wt_stmt ce e rt (Ssequence s (seq_of_labeled_statement ls))","hypotheses":"(ce : composite_env) (e : typenv) (rt : type) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt ce e rt s) (H0 : wt_lblstmts ce e rt ls) (IHwt_lblstmts : wt_stmt ce e rt (seq_of_labeled_statement ls))","proofString":"constructor; auto."},{"statement":"(te : typenv) (f : function) (k : cont) (H : is_call_cont k) (H0 : wt_stmt_cont te f k) : wt_call_cont k (fn_return f).","conclusion":"wt_call_cont k (fn_return f)","hypotheses":"(te : typenv) (f : function) (k : cont) (H : is_call_cont k) (H0 : wt_stmt_cont te f k)","proofString":"inv H0; simpl in H; try contradiction.\nconstructor.\nauto."},{"statement":"(te : typenv) (f : function) (H : True) : wt_call_cont Kstop (fn_return f).","conclusion":"wt_call_cont Kstop (fn_return f)","hypotheses":"(te : typenv) (f : function) (H : True)","proofString":"constructor."},{"statement":"(te : typenv) (f f' : function) (e : env) (C : expr -> expr) (k0 : cont) (H : True) (H1 : wt_call_cont (Kcall f' e C (fn_return f) k0) (fn_return f)) : wt_call_cont (Kcall f' e C (fn_return f) k0) (fn_return f).","conclusion":"wt_call_cont (Kcall f' e C (fn_return f) k0) (fn_return f)","hypotheses":"(te : typenv) (f f' : function) (e : env) (C : expr -> expr) (k0 : cont) (H : True) (H1 : wt_call_cont (Kcall f' e C (fn_return f) k0) (fn_return f))","proofString":"auto."},{"statement":"(te : typenv) (f : function) (k : cont) (H : wt_call_cont k (fn_return f)) : wt_stmt_cont te f k.","conclusion":"wt_stmt_cont te f k","hypotheses":"(te : typenv) (f : function) (k : cont) (H : wt_call_cont k (fn_return f))","proofString":"inversion H; subst.\nconstructor.\nconstructor; auto."},{"statement":"(te : typenv) (f : function) (H : wt_call_cont Kstop (fn_return f)) : wt_stmt_cont te f Kstop.","conclusion":"wt_stmt_cont te f Kstop","hypotheses":"(te : typenv) (f : function) (H : wt_call_cont Kstop (fn_return f))","proofString":"constructor."},{"statement":"(te : typenv) (f f0 : function) (e : env) (C : expr -> expr) (k0 : cont) (H : wt_call_cont (Kcall f0 e C (fn_return f) k0) (fn_return f)) (te0 : typenv) (H0 : wt_expr_cont te0 f0 k0) (H1 : wt_stmt ge te0 (fn_return f0) (fn_body f0)) (H2 : forall v : val,\nwt_val v (fn_return f) -> wt_rvalue ge te0 (C (Eval v (fn_return f)))) : wt_stmt_cont te f (Kcall f0 e C (fn_return f) k0).","conclusion":"wt_stmt_cont te f (Kcall f0 e C (fn_return f) k0)","hypotheses":"(te : typenv) (f f0 : function) (e : env) (C : expr -> expr) (k0 : cont) (H : wt_call_cont (Kcall f0 e C (fn_return f) k0) (fn_return f)) (te0 : typenv) (H0 : wt_expr_cont te0 f0 k0) (H1 : wt_stmt ge te0 (fn_return f0) (fn_body f0)) (H2 : forall v : val,\nwt_val v (fn_return f) -> wt_rvalue ge te0 (C (Eval v (fn_return f))))","proofString":"constructor; auto."},{"statement":"(te : typenv) (f : function) : wt_call_cont Kstop (fn_return f).","conclusion":"wt_call_cont Kstop (fn_return f)","hypotheses":"(te : typenv) (f : function)","proofString":"constructor."},{"statement":"(te : typenv) (f f' : function) (e : env) (C : expr -> expr) (ty : type) (k : cont) (H : wt_call_cont (Kcall f' e C ty k) ty) (H0 : ty = fn_return f) : wt_call_cont (Kcall f' e C ty k) (fn_return f).","conclusion":"wt_call_cont (Kcall f' e C ty k) (fn_return f)","hypotheses":"(te : typenv) (f f' : function) (e : env) (C : expr -> expr) (ty : type) (k : cont) (H : wt_call_cont (Kcall f' e C ty k) ty) (H0 : ty = fn_return f)","proofString":"congruence."},{"statement":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd) : wt_fundef ge gtenv fd.","conclusion":"wt_fundef ge gtenv fd","hypotheses":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd)","proofString":"apply Genv.find_funct_prop with (p := prog) (v := v); auto.\nintros.\ninv WTPROG.\napply H1 with id; auto."},{"statement":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd) : forall (id : ident) (f : Ctypes.fundef function),\nIn (id, Gfun f) (AST.prog_defs prog) -> wt_fundef ge gtenv f.","conclusion":"forall (id : ident) (f : Ctypes.fundef function),\nIn (id, Gfun f) (AST.prog_defs prog) -> wt_fundef ge gtenv f","hypotheses":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd)","proofString":"intros.\ninv WTPROG.\napply H1 with id; auto."},{"statement":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd) (id : ident) (f : Ctypes.fundef function) (H0 : In (id, Gfun f) (AST.prog_defs prog)) : wt_fundef ge gtenv f.","conclusion":"wt_fundef ge gtenv f","hypotheses":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd) (id : ident) (f : Ctypes.fundef function) (H0 : In (id, Gfun f) (AST.prog_defs prog))","proofString":"inv WTPROG.\napply H1 with id; auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) : forall (k : cont) (s' : statement) (k' : cont),\nfind_label lbl s0 k = Some (s', k') ->\nwt_stmt_cont e f k -> wt_stmt ge e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"forall (k : cont) (s' : statement) (k' : cont),\nfind_label lbl s0 k = Some (s', k') ->\nwt_stmt_cont e f k -> wt_stmt ge e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0)","proofString":"pattern s0.\napply (wt_stmt_ind2 ge e f.(fn_return) _    (fun ls => wt_lblstmts ge e f.(fn_return) ls ->           forall k s' k',           find_label_ls lbl ls k = Some (s', k') ->           wt_stmt_cont e f k ->           wt_stmt ge e f.(fn_return) s' /\\ wt_stmt_cont e f k'));  simpl; intros; try discriminate.\ndestruct (find_label lbl s1 (Kseq s2 k)) as [[sx kx] | ] eqn:F.\ninv H3.\neauto with ty.\neauto with ty.\ndestruct (find_label lbl s1 k) as [[sx kx] | ] eqn:F.\ninv H5.\neauto with ty.\neauto with ty.\neauto with ty.\neauto with ty.\ndestruct (find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k)) as [[sx kx] | ] eqn:F.\ninv H7.\neauto with ty.\ndestruct (find_label lbl s3 (Kfor3 r s2 s3 k)) as [[sx kx] | ] eqn:F2.\ninv H7.\neauto with ty.\neauto with ty.\neauto with ty.\ndestruct (ident_eq lbl lbl0).\ninv H1.\nauto.\neauto.\ndestruct (find_label lbl s (Kseq (seq_of_labeled_statement ls) k)) as [[sx kx] | ] eqn:F.\ninv H4.\neapply H0; eauto.\nconstructor.\nauto.\napply wt_seq_of_ls; auto.\neauto.\nassumption."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) : (fun s : statement =>\n forall (k : cont) (s' : statement) (k' : cont),\n find_label lbl s k = Some (s', k') ->\n wt_stmt_cont e f k -> wt_stmt ge e (fn_return f) s' /\\ wt_stmt_cont e f k')\n  s0.","conclusion":"(fun s : statement =>\n forall (k : cont) (s' : statement) (k' : cont),\n find_label lbl s k = Some (s', k') ->\n wt_stmt_cont e f k -> wt_stmt ge e (fn_return f) s' /\\ wt_stmt_cont e f k')\n  s0","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0)","proofString":"apply (wt_stmt_ind2 ge e f.(fn_return) _    (fun ls => wt_lblstmts ge e f.(fn_return) ls ->           forall k s' k',           find_label_ls lbl ls k = Some (s', k') ->           wt_stmt_cont e f k ->           wt_stmt ge e f.(fn_return) s' /\\ wt_stmt_cont e f k'));  simpl; intros; try discriminate.\ndestruct (find_label lbl s1 (Kseq s2 k)) as [[sx kx] | ] eqn:F.\ninv H3.\neauto with ty.\neauto with ty.\ndestruct (find_label lbl s1 k) as [[sx kx] | ] eqn:F.\ninv H5.\neauto with ty.\neauto with ty.\neauto with ty.\neauto with ty.\ndestruct (find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k)) as [[sx kx] | ] eqn:F.\ninv H7.\neauto with ty.\ndestruct (find_label lbl s3 (Kfor3 r s2 s3 k)) as [[sx kx] | ] eqn:F2.\ninv H7.\neauto with ty.\neauto with ty.\neauto with ty.\ndestruct (ident_eq lbl lbl0).\ninv H1.\nauto.\neauto.\ndestruct (find_label lbl s (Kseq (seq_of_labeled_statement ls) k)) as [[sx kx] | ] eqn:F.\ninv H4.\neapply H0; eauto.\nconstructor.\nauto.\napply wt_seq_of_ls; auto.\neauto.\nassumption."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H3 : match find_label lbl s1 (Kseq s2 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H3 : match find_label lbl s1 (Kseq s2 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"destruct (find_label lbl s1 (Kseq s2 k)) as [[sx kx] | ] eqn:F.\ninv H3.\neauto with ty.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 (Kseq s2 k) = Some (sx, kx)) (H3 : Some (sx, kx) = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 (Kseq s2 k) = Some (sx, kx)) (H3 : Some (sx, kx) = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"inv H3.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq s2 k) = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq s2 k) = None) (H3 : find_label lbl s2 k = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 s2 : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H2 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq s2 k) = None) (H3 : find_label lbl s2 k = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H5 : match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k')) (H6 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H5 : match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = Some (s', k')) (H6 : wt_stmt_cont e f k)","proofString":"destruct (find_label lbl s1 k) as [[sx kx] | ] eqn:F.\ninv H5.\neauto with ty.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 k = Some (sx, kx)) (H5 : Some (sx, kx) = Some (s', k')) (H6 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 k = Some (sx, kx)) (H5 : Some (sx, kx) = Some (s', k')) (H6 : wt_stmt_cont e f k)","proofString":"inv H5.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 k = Some (s', k')) (H6 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 k = Some (s', k')) (H6 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 k = None) (H5 : find_label lbl s2 k = Some (s', k')) (H6 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s1 s2 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 k = None) (H5 : find_label lbl s2 k = Some (s', k')) (H6 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H3 : find_label lbl s (Kwhile2 r s k) = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H3 : find_label lbl s (Kwhile2 r s k) = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H3 : find_label lbl s (Kdowhile1 r s k) = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (s : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H3 : find_label lbl s (Kdowhile1 r s k) = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H7 : match find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) with\n| Some sk => Some sk\n| None =>\n    match find_label lbl s3 (Kfor3 r s2 s3 k) with\n    | Some sk => Some sk\n    | None => find_label lbl s2 (Kfor4 r s2 s3 k)\n    end\nend = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (H7 : match find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) with\n| Some sk => Some sk\n| None =>\n    match find_label lbl s3 (Kfor3 r s2 s3 k) with\n    | Some sk => Some sk\n    | None => find_label lbl s2 (Kfor4 r s2 s3 k)\n    end\nend = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"destruct (find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k)) as [[sx kx] | ] eqn:F.\ninv H7.\neauto with ty.\ndestruct (find_label lbl s3 (Kfor3 r s2 s3 k)) as [[sx kx] | ] eqn:F2.\ninv H7.\neauto with ty.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = Some (sx, kx)) (H7 : Some (sx, kx) = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = Some (sx, kx)) (H7 : Some (sx, kx) = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"inv H7.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (H7 : match find_label lbl s3 (Kfor3 r s2 s3 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 (Kfor4 r s2 s3 k)\nend = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (H7 : match find_label lbl s3 (Kfor3 r s2 s3 k) with\n| Some sk => Some sk\n| None => find_label lbl s2 (Kfor4 r s2 s3 k)\nend = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"destruct (find_label lbl s3 (Kfor3 r s2 s3 k)) as [[sx kx] | ] eqn:F2.\ninv H7.\neauto with ty.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (sx : statement) (kx : cont) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = Some (sx, kx)) (H7 : Some (sx, kx) = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (sx : statement) (kx : cont) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = Some (sx, kx)) (H7 : Some (sx, kx) = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"inv H7.\neauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = None) (H7 : find_label lbl s2 (Kfor4 r s2 s3 k) = Some (s', k')) (H8 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (s1 : statement) (r : expr) (s2 s3 : statement) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : wt_stmt (prog_comp_env prog) e (fn_return f) s1) (H1 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s1 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H2 : wt_stmt (prog_comp_env prog) e (fn_return f) s2) (H3 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s2 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H4 : wt_stmt (prog_comp_env prog) e (fn_return f) s3) (H5 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s3 k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H6 : wt_bool (typeof r)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s1 (Kseq (Sfor Sskip r s2 s3) k) = None) (F2 : find_label lbl s3 (Kfor3 r s2 s3 k) = None) (H7 : find_label lbl s2 (Kfor4 r s2 s3 k) = Some (s', k')) (H8 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (ls : labeled_statements) (sg : signedness) (sz : intsize) (a : attr) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : typeof r = Tint sz sg a \\/ typeof r = Tlong sg a) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H3 : find_label_ls lbl ls (Kswitch2 k) = Some (s', k')) (H4 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (r : expr) (ls : labeled_statements) (sg : signedness) (sz : intsize) (a : attr) (H : wt_rvalue (prog_comp_env prog) e r) (H0 : typeof r = Tint sz sg a \\/ typeof r = Tlong sg a) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H3 : find_label_ls lbl ls (Kswitch2 k) = Some (s', k')) (H4 : wt_stmt_cont e f k)","proofString":"eauto with ty."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H1 : (if ident_eq lbl lbl0 then Some (s, k) else find_label lbl s k) =\nSome (s', k')) (H2 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (H1 : (if ident_eq lbl lbl0 then Some (s, k) else find_label lbl s k) =\nSome (s', k')) (H2 : wt_stmt_cont e f k)","proofString":"destruct (ident_eq lbl lbl0).\ninv H1.\nauto.\neauto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (e0 : lbl = lbl0) (H1 : Some (s, k) = Some (s', k')) (H2 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (e0 : lbl = lbl0) (H1 : Some (s, k) = Some (s', k')) (H2 : wt_stmt_cont e f k)","proofString":"inv H1.\nauto."},{"statement":"(e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s' : statement) (H0 : forall (k : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl0 s' k = Some (s'0, k'0) ->\nwt_stmt_cont e f k ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s') (k' : cont) (H2 : wt_stmt_cont e f k') : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s' : statement) (H0 : forall (k : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl0 s' k = Some (s'0, k'0) ->\nwt_stmt_cont e f k ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s') (k' : cont) (H2 : wt_stmt_cont e f k')","proofString":"auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (n : lbl <> lbl0) (H1 : find_label lbl s k = Some (s', k')) (H2 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (lbl0 : label) (s : statement) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (k : cont) (s' : statement) (k' : cont) (n : lbl <> lbl0) (H1 : find_label lbl s k = Some (s', k')) (H2 : wt_stmt_cont e f k)","proofString":"eauto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (H4 : match find_label lbl s (Kseq (seq_of_labeled_statement ls) k) with\n| Some sk => Some sk\n| None => find_label_ls lbl ls k\nend = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (H4 : match find_label lbl s (Kseq (seq_of_labeled_statement ls) k) with\n| Some sk => Some sk\n| None => find_label_ls lbl ls k\nend = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"destruct (find_label lbl s (Kseq (seq_of_labeled_statement ls) k)) as [[sx kx] | ] eqn:F.\ninv H4.\neapply H0; eauto.\nconstructor.\nauto.\napply wt_seq_of_ls; auto.\neauto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (sx, kx)) (H4 : Some (sx, kx) = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (sx : statement) (kx : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (sx, kx)) (H4 : Some (sx, kx) = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"inv H4.\neapply H0; eauto.\nconstructor.\nauto.\napply wt_seq_of_ls; auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"eapply H0; eauto.\nconstructor.\nauto.\napply wt_seq_of_ls; auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt_cont e f (Kseq (seq_of_labeled_statement ls) k).","conclusion":"wt_stmt_cont e f (Kseq (seq_of_labeled_statement ls) k)","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"constructor.\nauto.\napply wt_seq_of_ls; auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt_cont e f k.","conclusion":"wt_stmt_cont e f k","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt ge e (fn_return f) (seq_of_labeled_statement ls).","conclusion":"wt_stmt ge e (fn_return f) (seq_of_labeled_statement ls)","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"apply wt_seq_of_ls; auto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = None) (H4 : find_label_ls lbl ls k = Some (s', k')) (H5 : wt_stmt_cont e f k) : wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s' /\\ wt_stmt_cont e f k'","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) (case : option Z) (s : statement) (ls : labeled_statements) (H : wt_stmt (prog_comp_env prog) e (fn_return f) s) (H0 : forall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label lbl s k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H1 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls) (H2 : wt_lblstmts (prog_comp_env prog) e (fn_return f) ls ->\nforall (k0 : cont) (s'0 : statement) (k'0 : cont),\nfind_label_ls lbl ls k0 = Some (s'0, k'0) ->\nwt_stmt_cont e f k0 ->\nwt_stmt (prog_comp_env prog) e (fn_return f) s'0 /\\ wt_stmt_cont e f k'0) (H3 : wt_lblstmts (prog_comp_env prog) e (fn_return f) (LScons case s ls)) (k : cont) (s' : statement) (k' : cont) (F : find_label lbl s (Kseq (seq_of_labeled_statement ls) k) = None) (H4 : find_label_ls lbl ls k = Some (s', k')) (H5 : wt_stmt_cont e f k)","proofString":"eauto."},{"statement":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0) : wt_stmt (prog_comp_env prog) e (fn_return f) s0.","conclusion":"wt_stmt (prog_comp_env prog) e (fn_return f) s0","hypotheses":"(lbl : label) (e : typenv) (f : function) (s0 : statement) (WTS0 : wt_stmt ge e (fn_return f) s0)","proofString":"assumption."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_state (ExprState f (C a') k e m').","conclusion":"wt_state (ExprState f (C a') k e m')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"econstructor; eauto.\nchange (wt_expr_kind ge te RV (C a')).\neapply wt_context with (a := a); eauto.\neapply lred_same_type; eauto.\neapply wt_lred; eauto.\nchange (wt_expr_kind ge te LV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_rvalue ge te (C a').","conclusion":"wt_rvalue ge te (C a')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"change (wt_expr_kind ge te RV (C a')).\neapply wt_context with (a := a); eauto.\neapply lred_same_type; eauto.\neapply wt_lred; eauto.\nchange (wt_expr_kind ge te LV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te RV (C a').","conclusion":"wt_expr_kind ge te RV (C a')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_context with (a := a); eauto.\neapply lred_same_type; eauto.\neapply wt_lred; eauto.\nchange (wt_expr_kind ge te LV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : typeof a' = typeof a.","conclusion":"typeof a' = typeof a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply lred_same_type; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te LV a'.","conclusion":"wt_expr_kind ge te LV a'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_lred; eauto.\nchange (wt_expr_kind ge te LV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_lvalue ge te a.","conclusion":"wt_lvalue ge te a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"change (wt_expr_kind ge te LV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te LV a.","conclusion":"wt_expr_kind ge te LV a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (a' : expr) (m' : mem) (H : lred ge e a m a' m') (H0 : context LV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_state (ExprState f (C a') k e m').","conclusion":"wt_state (ExprState f (C a') k e m')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"econstructor; eauto.\nchange (wt_expr_kind ge te RV (C a')).\neapply wt_context with (a := a); eauto.\neapply rred_same_type; eauto.\neapply wt_rred; eauto.\nchange (wt_expr_kind ge te RV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_rvalue ge te (C a').","conclusion":"wt_rvalue ge te (C a')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"change (wt_expr_kind ge te RV (C a')).\neapply wt_context with (a := a); eauto.\neapply rred_same_type; eauto.\neapply wt_rred; eauto.\nchange (wt_expr_kind ge te RV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te RV (C a').","conclusion":"wt_expr_kind ge te RV (C a')","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_context with (a := a); eauto.\neapply rred_same_type; eauto.\neapply wt_rred; eauto.\nchange (wt_expr_kind ge te RV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : typeof a' = typeof a.","conclusion":"typeof a' = typeof a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply rred_same_type; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te RV a'.","conclusion":"wt_expr_kind ge te RV a'","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_rred; eauto.\nchange (wt_expr_kind ge te RV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_rvalue ge te a.","conclusion":"wt_rvalue ge te a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"change (wt_expr_kind ge te RV a).\neapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_expr_kind ge te RV a.","conclusion":"wt_expr_kind ge te RV a","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (t : trace) (a' : expr) (m' : mem) (H : rred ge a m t a' m') (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"eapply wt_subexpr; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"assert (A: wt_expr_kind ge te RV a) by (eapply wt_subexpr; eauto).\nsimpl in A.\ninv H.\ninv A.\nsimpl in H9; rewrite H4 in H9; inv H9.\nassert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) (A : wt_expr_kind ge te RV a) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) (A : wt_expr_kind ge te RV a)","proofString":"simpl in A.\ninv H.\ninv A.\nsimpl in H9; rewrite H4 in H9; inv H9.\nassert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) (A : wt_rvalue (prog_comp_env prog) te a) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H : callred ge a m fd vargs ty) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) (A : wt_rvalue (prog_comp_env prog) te a)","proofString":"inv H.\ninv A.\nsimpl in H9; rewrite H4 in H9; inv H9.\nassert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (A : wt_rvalue (prog_comp_env prog) te (Ecall (Eval vf tyf) el ty)) (tyargs : list type) (tyres : type) (cconv : calling_convention) (H1 : Genv.find_funct ge vf = Some fd) (H2 : cast_arguments m el tyargs vargs) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H4 : classify_fun tyf = fun_case_f tyargs tyres cconv) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (A : wt_rvalue (prog_comp_env prog) te (Ecall (Eval vf tyf) el ty)) (tyargs : list type) (tyres : type) (cconv : calling_convention) (H1 : Genv.find_funct ge vf = Some fd) (H2 : cast_arguments m el tyargs vargs) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H4 : classify_fun tyf = fun_case_f tyargs tyres cconv)","proofString":"inv A.\nsimpl in H9; rewrite H4 in H9; inv H9.\nassert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (tyargs : list type) (tyres : type) (cconv : calling_convention) (H1 : Genv.find_funct ge vf = Some fd) (H2 : cast_arguments m el tyargs vargs) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H4 : classify_fun tyf = fun_case_f tyargs tyres cconv) (tyargs0 : list type) (cconv0 : calling_convention) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H9 : classify_fun (typeof (Eval vf tyf)) = fun_case_f tyargs0 ty cconv0) (H10 : wt_arguments el tyargs0) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (tyargs : list type) (tyres : type) (cconv : calling_convention) (H1 : Genv.find_funct ge vf = Some fd) (H2 : cast_arguments m el tyargs vargs) (H3 : type_of_fundef fd = Tfunction tyargs tyres cconv) (H4 : classify_fun tyf = fun_case_f tyargs tyres cconv) (tyargs0 : list type) (cconv0 : calling_convention) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H9 : classify_fun (typeof (Eval vf tyf)) = fun_case_f tyargs0 ty cconv0) (H10 : wt_arguments el tyargs0)","proofString":"simpl in H9; rewrite H4 in H9; inv H9.\nassert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0)","proofString":"assert (fundef_return fd = ty).\ndestruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence.\neconstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) : fundef_return fd = ty.","conclusion":"fundef_return fd = ty","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0)","proofString":"destruct fd; simpl in *.\nunfold type_of_function in H3.\ncongruence.\ncongruence."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (f0 : function) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (Internal f0)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_function f0 = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) : fn_return f0 = ty.","conclusion":"fn_return f0 = ty","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (f0 : function) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (Internal f0)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_function f0 = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0)","proofString":"unfold type_of_function in H3.\ncongruence."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (f0 : function) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (Internal f0)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : Tfunction (type_of_params (fn_params f0)) (fn_return f0) (fn_callconv f0) =\nTfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) : fn_return f0 = ty.","conclusion":"fn_return f0 = ty","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (f0 : function) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (Internal f0)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : Tfunction (type_of_params (fn_params f0)) (fn_return f0) (fn_callconv f0) =\nTfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0)","proofString":"congruence."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (e0 : external_function) (l : list type) (t : type) (c : calling_convention) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (External e0 l t c)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : Tfunction l t c = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) : t = ty.","conclusion":"t = ty","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (e0 : external_function) (l : list type) (t : type) (c : calling_convention) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt (prog_comp_env prog) te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue (prog_comp_env prog) te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct (Genv.globalenv prog) vf = Some (External e0 l t c)) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : Tfunction l t c = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0)","proofString":"congruence."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) : wt_state (Callstate fd vargs (Kcall f e C ty k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall f e C ty k) m)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty)","proofString":"econstructor.\nrewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto.\neapply wt_find_funct; eauto.\neauto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) : wt_call_cont (Kcall f e C ty k) (fundef_return fd).","conclusion":"wt_call_cont (Kcall f e C ty k) (fundef_return fd)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty)","proofString":"rewrite H.\neconstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) : wt_call_cont (Kcall f e C ty k) ty.","conclusion":"wt_call_cont (Kcall f e C ty k) ty","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty)","proofString":"econstructor; eauto.\nintros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) : forall v : val, wt_val v ty -> wt_rvalue ge te (C (Eval v ty)).","conclusion":"forall v : val, wt_val v ty -> wt_rvalue ge te (C (Eval v ty))","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty)","proofString":"intros.\nchange (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty) : wt_rvalue ge te (C (Eval v ty)).","conclusion":"wt_rvalue ge te (C (Eval v ty))","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty)","proofString":"change (wt_expr_kind ge te RV (C (Eval v ty))).\neapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty) : wt_expr_kind ge te RV (C (Eval v ty)).","conclusion":"wt_expr_kind ge te RV (C (Eval v ty))","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty)","proofString":"eapply wt_context with (a := Ecall (Eval vf tyf) el ty); eauto.\nred; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty) : wt_expr_kind ge te RV (Eval v ty).","conclusion":"wt_expr_kind ge te RV (Eval v ty)","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) (v : val) (H5 : wt_val v ty)","proofString":"red; constructor; auto."},{"statement":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty) : wt_fundef ge gtenv fd.","conclusion":"wt_fundef ge gtenv fd","hypotheses":"(C : expr -> expr) (f : function) (k : cont) (e : env) (m : mem) (fd : fundef) (vargs : list val) (ty : type) (H0 : context RV RV C) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (vf : val) (tyf : type) (el : exprlist) (WTE : wt_rvalue ge te (C (Ecall (Eval vf tyf) el ty))) (H1 : Genv.find_funct ge vf = Some fd) (tyargs0 : list type) (cconv0 : calling_convention) (H4 : classify_fun tyf = fun_case_f tyargs0 ty cconv0) (H3 : type_of_fundef fd = Tfunction tyargs0 ty cconv0) (H2 : cast_arguments m el tyargs0 vargs) (H7 : wt_rvalue (prog_comp_env prog) te (Eval vf tyf)) (H8 : wt_exprlist (prog_comp_env prog) te el) (H10 : wt_arguments el tyargs0) (H : fundef_return fd = ty)","proofString":"eapply wt_find_funct; eauto."},{"statement":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : context K RV C) (H0 : ~ imm_safe ge e K a m) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a)) : wt_state Stuckstate.","conclusion":"wt_state Stuckstate","hypotheses":"(C : expr -> expr) (f : function) (a : expr) (k : cont) (e : env) (m : mem) (K : kind) (H : context K RV C) (H0 : ~ imm_safe ge e K a m) (te : typenv) (WTK : wt_expr_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (C a))","proofString":"constructor."},{"statement":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sdo x)) : wt_state (ExprState f x (Kdo k) e m).","conclusion":"wt_state (ExprState f x (Kdo k) e m)","hypotheses":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sdo x))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_expr_cont te f (Kdo k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (v : val) (ty : type) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_expr_cont te f (Kdo k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Ssequence s1 s2)) : wt_state (State f s1 (Kseq s2 k) e m).","conclusion":"wt_state (State f s1 (Kseq s2 k) e m)","hypotheses":"(f : function) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Ssequence s1 s2))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip) : wt_state (State f s k e m).","conclusion":"wt_state (State f s k e m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Scontinue) : wt_state (State f Scontinue k e m).","conclusion":"wt_state (State f Scontinue k e m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Scontinue)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak) : wt_state (State f Sbreak k e m).","conclusion":"wt_state (State f Sbreak k e m)","hypotheses":"(f : function) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kseq s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sifthenelse a s1 s2)) : wt_state (ExprState f a (Kifthenelse s1 s2 k) e m).","conclusion":"wt_state (ExprState f a (Kifthenelse s1 s2 k) e m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sifthenelse a s1 s2))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (te : typenv) (WTK : wt_expr_cont te f (Kifthenelse s1 s2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f (if b then s1 else s2) k e m).","conclusion":"wt_state (State f (if b then s1 else s2) k e m)","hypotheses":"(f : function) (v : val) (ty : type) (s1 s2 : statement) (k : cont) (e : env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (te : typenv) (WTK : wt_expr_cont te f (Kifthenelse s1 s2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; destruct b; eauto with ty."},{"statement":"(f : function) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Swhile x s)) : wt_state (ExprState f x (Kwhile1 x s k) e m).","conclusion":"wt_state (ExprState f x (Kwhile1 x s k) e m)","hypotheses":"(f : function) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Swhile x s))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kwhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kwhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kwhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f s (Kwhile2 x s k) e m).","conclusion":"wt_state (State f s (Kwhile2 x s k) e m)","hypotheses":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kwhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (s0 : statement) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : s0 = Sskip \\/ s0 = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kwhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) s0) : wt_state (State f (Swhile x s) k e m).","conclusion":"wt_state (State f (Swhile x s) k e m)","hypotheses":"(f : function) (s0 : statement) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : s0 = Sskip \\/ s0 = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kwhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) s0)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kwhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kwhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sdowhile a s)) : wt_state (State f s (Kdowhile1 a s k) e m).","conclusion":"wt_state (State f s (Kdowhile1 a s k) e m)","hypotheses":"(f : function) (a : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sdowhile a s))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (s0 : statement) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : s0 = Sskip \\/ s0 = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kdowhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) s0) : wt_state (ExprState f x (Kdowhile2 x s k) e m).","conclusion":"wt_state (ExprState f x (Kdowhile2 x s k) e m)","hypotheses":"(f : function) (s0 : statement) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : s0 = Sskip \\/ s0 = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kdowhile1 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) s0)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kdowhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kdowhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kdowhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f (Sdowhile x s) k e m).","conclusion":"wt_state (State f (Sdowhile x s) k e m)","hypotheses":"(f : function) (v : val) (ty : type) (x : expr) (s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kdowhile2 x s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kdowhile1 a s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (a : expr) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kdowhile1 a s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a1 : statement) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : a1 <> Sskip) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sfor a1 a2 a3 s)) : wt_state (State f a1 (Kseq (Sfor Sskip a2 a3 s) k) e m).","conclusion":"wt_state (State f a1 (Kseq (Sfor Sskip a2 a3 s) k) e m)","hypotheses":"(f : function) (a1 : statement) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : a1 <> Sskip) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sfor a1 a2 a3 s))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sfor Sskip a2 a3 s)) : wt_state (ExprState f a2 (Kfor2 a2 a3 s k) e m).","conclusion":"wt_state (ExprState f a2 (Kfor2 a2 a3 s k) e m)","hypotheses":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sfor Sskip a2 a3 s))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kfor2 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (v : val) (ty : type) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some false) (te : typenv) (WTK : wt_expr_cont te f (Kfor2 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (v : val) (ty : type) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kfor2 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state (State f s (Kfor3 a2 a3 s k) e m).","conclusion":"wt_state (State f s (Kfor3 a2 a3 s k) e m)","hypotheses":"(f : function) (v : val) (ty : type) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : bool_val v ty m = Some true) (te : typenv) (WTK : wt_expr_cont te f (Kfor2 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (x : statement) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : x = Sskip \\/ x = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kfor3 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) x) : wt_state (State f a3 (Kfor4 a2 a3 s k) e m).","conclusion":"wt_state (State f a3 (Kfor4 a2 a3 s k) e m)","hypotheses":"(f : function) (x : statement) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (H : x = Sskip \\/ x = Scontinue) (te : typenv) (WTK : wt_stmt_cont te f (Kfor3 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) x)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kfor3 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kfor3 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sbreak)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kfor4 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip) : wt_state (State f (Sfor Sskip a2 a3 s) k e m).","conclusion":"wt_state (State f (Sfor Sskip a2 a3 s) k e m)","hypotheses":"(f : function) (a2 : expr) (a3 s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kfor4 a2 a3 s k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (k : cont) (e : env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sreturn None)) : wt_state (Returnstate Vundef (call_cont k) m').","conclusion":"wt_state (Returnstate Vundef (call_cont k) m')","hypotheses":"(f : function) (k : cont) (e : env) (m m' : mem) (H : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sreturn None))","proofString":"econstructor.\neapply call_cont_wt; eauto.\nconstructor."},{"statement":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sreturn (Some x))) : wt_state (ExprState f x (Kreturn k) e m).","conclusion":"wt_state (ExprState f x (Kreturn k) e m)","hypotheses":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sreturn (Some x)))","proofString":"inv WTS.\neauto with ty."},{"statement":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (H0 : wt_rvalue ge te x) (H1 : wt_cast (typeof x) (fn_return f)) : wt_state (ExprState f x (Kreturn k) e m).","conclusion":"wt_state (ExprState f x (Kreturn k) e m)","hypotheses":"(f : function) (x : expr) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (H0 : wt_rvalue ge te x) (H1 : wt_cast (typeof x) (fn_return f))","proofString":"eauto with ty."},{"statement":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_expr_cont te f (Kreturn k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v1 ty)) : wt_state (Returnstate v2 (call_cont k) m').","conclusion":"wt_state (Returnstate v2 (call_cont k) m')","hypotheses":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_expr_cont te f (Kreturn k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v1 ty))","proofString":"inv WTK.\neconstructor.\neapply call_cont_wt; eauto.\ninv WTE.\neapply pres_sem_cast; eauto."},{"statement":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v1 ty)) (H4 : wt_stmt_cont te f k) : wt_state (Returnstate v2 (call_cont k) m').","conclusion":"wt_state (Returnstate v2 (call_cont k) m')","hypotheses":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v1 ty)) (H4 : wt_stmt_cont te f k)","proofString":"econstructor.\neapply call_cont_wt; eauto.\ninv WTE.\neapply pres_sem_cast; eauto."},{"statement":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (H4 : wt_stmt_cont te f k) (H2 : wt_val v1 ty) : wt_val v2 (fn_return f).","conclusion":"wt_val v2 (fn_return f)","hypotheses":"(f : function) (v1 : val) (ty : type) (k : cont) (e : env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (fn_return f) m = Some v2) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (H4 : wt_stmt_cont te f k) (H2 : wt_val v1 ty)","proofString":"eapply pres_sem_cast; eauto."},{"statement":"(f : function) (k : cont) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip) : wt_state (Returnstate Vundef k m').","conclusion":"wt_state (Returnstate Vundef k m')","hypotheses":"(f : function) (k : cont) (e : env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free_list m (blocks_of_env ge e) = Some m') (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Sskip)","proofString":"econstructor.\neapply is_wt_call_cont; eauto.\nconstructor."},{"statement":"(f : function) (x : expr) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sswitch x sl)) : wt_state (ExprState f x (Kswitch1 sl k) e m).","conclusion":"wt_state (ExprState f x (Kswitch1 sl k) e m)","hypotheses":"(f : function) (x : expr) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sswitch x sl))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTK : wt_expr_cont te f (Kswitch1 sl k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) : wt_state\n  (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch2 k) e m).","conclusion":"wt_state\n  (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch2 k) e m)","hypotheses":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTK : wt_expr_cont te f (Kswitch1 sl k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty))","proofString":"inv WTK.\neconstructor; eauto with ty.\napply wt_seq_of_ls.\napply wt_select_switch; auto."},{"statement":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl) : wt_state\n  (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch2 k) e m).","conclusion":"wt_state\n  (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch2 k) e m)","hypotheses":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl)","proofString":"econstructor; eauto with ty.\napply wt_seq_of_ls.\napply wt_select_switch; auto."},{"statement":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl) : wt_stmt ge te (fn_return f) (seq_of_labeled_statement (select_switch n sl)).","conclusion":"wt_stmt ge te (fn_return f) (seq_of_labeled_statement (select_switch n sl))","hypotheses":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl)","proofString":"apply wt_seq_of_ls.\napply wt_select_switch; auto."},{"statement":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl) : wt_lblstmts ge te (fn_return f) (select_switch n sl).","conclusion":"wt_lblstmts ge te (fn_return f) (select_switch n sl)","hypotheses":"(f : function) (ty : type) (sl : labeled_statements) (k : cont) (e : env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (te : typenv) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTE : wt_rvalue ge te (Eval v ty)) (H4 : wt_stmt_cont te f k) (H5 : wt_lblstmts ge te (fn_return f) sl)","proofString":"apply wt_select_switch; auto."},{"statement":"(f : function) (x : statement) (k : cont) (e : env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (te : typenv) (WTK : wt_stmt_cont te f (Kswitch2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) x) : wt_state (State f Sskip k e m).","conclusion":"wt_state (State f Sskip k e m)","hypotheses":"(f : function) (x : statement) (k : cont) (e : env) (m : mem) (H : x = Sskip \\/ x = Sbreak) (te : typenv) (WTK : wt_stmt_cont te f (Kswitch2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) x)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kswitch2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Scontinue) : wt_state (State f Scontinue k e m).","conclusion":"wt_state (State f Scontinue k e m)","hypotheses":"(f : function) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f (Kswitch2 k)) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) Scontinue)","proofString":"inv WTK; eauto with ty."},{"statement":"(f : function) (lbl : label) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Slabel lbl s)) : wt_state (State f s k e m).","conclusion":"wt_state (State f s k e m)","hypotheses":"(f : function) (lbl : label) (s : statement) (k : cont) (e : env) (m : mem) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Slabel lbl s))","proofString":"inv WTS; eauto with ty."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sgoto lbl)) : wt_state (State f s' k' e m).","conclusion":"wt_state (State f s' k' e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sgoto lbl))","proofString":"exploit wt_find_label.\neexact WTB.\neauto.\neapply call_cont_wt'; eauto.\nintros [A B].\neauto with ty."},{"statement":"(f : function) (lbl : label) (k : cont) (e : env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sgoto lbl)) (A : wt_stmt ge te (fn_return f) s') (B : wt_stmt_cont te f k') : wt_state (State f s' k' e m).","conclusion":"wt_state (State f s' k' e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (e : env) (m : mem) (s' : statement) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (te : typenv) (WTK : wt_stmt_cont te f k) (WTB : wt_stmt ge te (fn_return f) (fn_body f)) (WTS : wt_stmt ge te (fn_return f) (Sgoto lbl)) (A : wt_stmt ge te (fn_return f) s') (B : wt_stmt_cont te f k')","proofString":"eauto with ty."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (WTFD : wt_fundef ge gtenv (Internal f)) (FIND : Genv.find_funct ge b = Some (Internal f)) : wt_state (State f (fn_body f) k e m2).","conclusion":"wt_state (State f (fn_body f) k e m2)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (WTFD : wt_fundef ge gtenv (Internal f)) (FIND : Genv.find_funct ge b = Some (Internal f))","proofString":"inv WTFD.\ninv H3.\neconstructor; eauto.\napply wt_call_cont_stmt_cont; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H3 : wt_function ge gtenv f) : wt_state (State f (fn_body f) k e m2).","conclusion":"wt_state (State f (fn_body f) k e m2)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H3 : wt_function ge gtenv f)","proofString":"inv H3.\neconstructor; eauto.\napply wt_call_cont_stmt_cont; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H2 : wt_stmt ge (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f)) : wt_state (State f (fn_body f) k e m2).","conclusion":"wt_state (State f (fn_body f) k e m2)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H2 : wt_stmt ge (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f))","proofString":"econstructor; eauto.\napply wt_call_cont_stmt_cont; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H2 : wt_stmt ge (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f)) : wt_stmt_cont (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f)) f k.","conclusion":"wt_stmt_cont (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f)) f k","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (e : env) (m1 m2 : mem) (H : list_norepet (var_names (fn_params f) ++ var_names (fn_vars f))) (H0 : alloc_variables ge empty_env m (fn_params f ++ fn_vars f) e m1) (H1 : bind_parameters ge e m1 (fn_params f) vargs m2) (b : val) (WTK : wt_call_cont k (fundef_return (Internal f))) (FIND : Genv.find_funct ge b = Some (Internal f)) (H2 : wt_stmt ge (bind_vars (bind_vars gtenv (fn_params f)) (fn_vars f))\n  (fn_return f) (fn_body f))","proofString":"apply wt_call_cont_stmt_cont; auto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (WTFD : wt_fundef ge gtenv (External ef targs tres cc)) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) : wt_state (Returnstate vres k m').","conclusion":"wt_state (Returnstate vres k m')","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (WTFD : wt_fundef ge gtenv (External ef targs tres cc)) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc))","proofString":"inv WTFD.\neconstructor; eauto.\napply has_rettype_wt_val.\nsimpl; rewrite <- H1.\neapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres) : wt_state (Returnstate vres k m').","conclusion":"wt_state (Returnstate vres k m')","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres)","proofString":"econstructor; eauto.\napply has_rettype_wt_val.\nsimpl; rewrite <- H1.\neapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres) : wt_val vres (fundef_return (External ef targs tres cc)).","conclusion":"wt_val vres (fundef_return (External ef targs tres cc))","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres)","proofString":"apply has_rettype_wt_val.\nsimpl; rewrite <- H1.\neapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres) : Val.has_rettype vres\n  (rettype_of_type (fundef_return (External ef targs tres cc))).","conclusion":"Val.has_rettype vres\n  (rettype_of_type (fundef_return (External ef targs tres cc)))","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres)","proofString":"simpl; rewrite <- H1.\neapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres) : Val.has_rettype vres (sig_res (ef_sig ef)).","conclusion":"Val.has_rettype vres (sig_res (ef_sig ef))","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (b : val) (WTK : wt_call_cont k (fundef_return (External ef targs tres cc))) (FIND : Genv.find_funct ge b = Some (External ef targs tres cc)) (H1 : sig_res (ef_sig ef) = rettype_of_type tres)","proofString":"eapply external_call_well_typed_gen; eauto."},{"statement":"(v : val) (f : function) (e : env) (C : expr -> expr) (ty : type) (k : cont) (m : mem) (ty0 : type) (WTK : wt_call_cont (Kcall f e C ty k) ty0) (VAL : wt_val v ty0) : wt_state (ExprState f (C (Eval v ty)) k e m).","conclusion":"wt_state (ExprState f (C (Eval v ty)) k e m)","hypotheses":"(v : val) (f : function) (e : env) (C : expr -> expr) (ty : type) (k : cont) (m : mem) (ty0 : type) (WTK : wt_call_cont (Kcall f e C ty k) ty0) (VAL : wt_val v ty0)","proofString":"inv WTK.\neauto with ty."},{"statement":"(v : val) (f : function) (e : env) (C : expr -> expr) (k : cont) (m : mem) (ty0 : type) (VAL : wt_val v ty0) (te : typenv) (H5 : wt_expr_cont te f k) (H6 : wt_stmt ge te (fn_return f) (fn_body f)) (H7 : forall v0 : val, wt_val v0 ty0 -> wt_rvalue ge te (C (Eval v0 ty0))) : wt_state (ExprState f (C (Eval v ty0)) k e m).","conclusion":"wt_state (ExprState f (C (Eval v ty0)) k e m)","hypotheses":"(v : val) (f : function) (e : env) (C : expr -> expr) (k : cont) (m : mem) (ty0 : type) (VAL : wt_val v ty0) (te : typenv) (H5 : wt_expr_cont te f k) (H6 : wt_stmt ge te (fn_return f) (fn_body f)) (H7 : forall v0 : val, wt_val v0 ty0 -> wt_rvalue ge te (C (Eval v0 ty0)))","proofString":"eauto with ty."},{"statement":"(S : state) (t : trace) (S' : state) (H : step ge S t S') (H0 : wt_state S) : wt_state S'.","conclusion":"wt_state S'","hypotheses":"(S : state) (t : trace) (S' : state) (H : step ge S t S') (H0 : wt_state S)","proofString":"destruct H.\neapply preservation_estep; eauto.\neapply preservation_sstep; eauto."},{"statement":"(S : state) (t : trace) (S' : state) (H : estep ge S t S') (H0 : wt_state S) : wt_state S'.","conclusion":"wt_state S'","hypotheses":"(S : state) (t : trace) (S' : state) (H : estep ge S t S') (H0 : wt_state S)","proofString":"eapply preservation_estep; eauto."},{"statement":"(S : state) (t : trace) (S' : state) (H : sstep ge S t S') (H0 : wt_state S) : wt_state S'.","conclusion":"wt_state S'","hypotheses":"(S : state) (t : trace) (S' : state) (H : sstep ge S t S') (H0 : wt_state S)","proofString":"eapply preservation_sstep; eauto."},{"statement":"(S : state) (H : initial_state prog S) : wt_state S.","conclusion":"wt_state S","hypotheses":"(S : state) (H : initial_state prog S)","proofString":"inv H.\neconstructor.\nconstructor.\napply Genv.find_funct_ptr_prop with (p := prog) (b := b); auto.\nintros.\ninv WTPROG.\napply H4 with id; auto.\ninstantiate (1 := (Vptr b Ptrofs.zero)).\nrewrite Genv.find_funct_find_funct_ptr.\nauto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) : wt_call_cont Kstop (fundef_return f).","conclusion":"wt_call_cont Kstop (fundef_return f)","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default)","proofString":"constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) : forall (id : ident) (f0 : Ctypes.fundef function),\nIn (id, Gfun f0) (AST.prog_defs prog) -> wt_fundef ge gtenv f0.","conclusion":"forall (id : ident) (f0 : Ctypes.fundef function),\nIn (id, Gfun f0) (AST.prog_defs prog) -> wt_fundef ge gtenv f0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default)","proofString":"intros.\ninv WTPROG.\napply H4 with id; auto."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (id : ident) (f0 : Ctypes.fundef function) (H : In (id, Gfun f0) (AST.prog_defs prog)) : wt_fundef ge gtenv f0.","conclusion":"wt_fundef ge gtenv f0","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : type_of_fundef f = Tfunction nil type_int32s cc_default) (id : ident) (f0 : Ctypes.fundef function) (H : In (id, Gfun f0) (AST.prog_defs prog))","proofString":"inv WTPROG.\napply H4 with id; auto."},{"statement":"forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n.","conclusion":"forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n","hypotheses":"","proofString":"unfold wt_int; intros.\ndestruct sz; [destruct sg | destruct sg | | ];    simpl; auto.\ndestruct H; subst n; auto."},{"statement":"(n : int) (sz : intsize) (sg : signedness) (H : match sz with\n| I8 =>\n    match sg with\n    | Signed => Int.sign_ext 8 n = n\n    | Unsigned => Int.zero_ext 8 n = n\n    end\n| I16 =>\n    match sg with\n    | Signed => Int.sign_ext 16 n = n\n    | Unsigned => Int.zero_ext 16 n = n\n    end\n| I32 => True\n| IBool => n = Int.zero \\/ n = Int.one\nend) : cast_int_int sz sg n = n.","conclusion":"cast_int_int sz sg n = n","hypotheses":"(n : int) (sz : intsize) (sg : signedness) (H : match sz with\n| I8 =>\n    match sg with\n    | Signed => Int.sign_ext 8 n = n\n    | Unsigned => Int.zero_ext 8 n = n\n    end\n| I16 =>\n    match sg with\n    | Signed => Int.sign_ext 16 n = n\n    | Unsigned => Int.zero_ext 16 n = n\n    end\n| I32 => True\n| IBool => n = Int.zero \\/ n = Int.one\nend)","proofString":"destruct sz; [destruct sg | destruct sg | | ];    simpl; auto.\ndestruct H; subst n; auto."},{"statement":"(n : int) (sg : signedness) (H : n = Int.zero \\/ n = Int.one) : (if Int.eq n Int.zero then Int.zero else Int.one) = n.","conclusion":"(if Int.eq n Int.zero then Int.zero else Int.one) = n","hypotheses":"(n : int) (sg : signedness) (H : n = Int.zero \\/ n = Int.one)","proofString":"destruct H; subst n; auto."},{"statement":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n) : forall (v : val) (t1 t2 : type) (m : mem),\nwt_val v t2 -> sem_cast v t1 t2 m = Some v \\/ sem_cast v t1 t2 m = None.","conclusion":"forall (v : val) (t1 t2 : type) (m : mem),\nwt_val v t2 -> sem_cast v t1 t2 m = Some v \\/ sem_cast v t1 t2 m = None","hypotheses":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n)","proofString":"assert (BOOL: forall n sg, wt_int n IBool sg -> (if Int.eq n Int.zero then Int.zero else Int.one) = n).\nintros.\ndestruct H; subst n; auto.\nLtac DestructCast :=    auto;    match goal with    | [ |- match match ?x with _ => _ end with _ => _ end = _ \\/ _] => destruct x; DestructCast    | [ |- match ?x with _ => _ end = _ \\/ _ ] => destruct x; DestructCast    | _ => idtac    end.\nintros.\nunfold sem_cast, classify_cast; inv H; DestructCast;  try discriminate;  erewrite ? INT, ? BOOL; eauto."},{"statement":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n) : forall (n : int) (sg : signedness),\nwt_int n IBool sg -> (if Int.eq n Int.zero then Int.zero else Int.one) = n.","conclusion":"forall (n : int) (sg : signedness),\nwt_int n IBool sg -> (if Int.eq n Int.zero then Int.zero else Int.one) = n","hypotheses":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n)","proofString":"intros.\ndestruct H; subst n; auto."},{"statement":"(INT : forall (n0 : int) (sz : intsize) (sg0 : signedness),\nwt_int n0 sz sg0 -> cast_int_int sz sg0 n0 = n0) (n : int) (sg : signedness) (H : wt_int n IBool sg) : (if Int.eq n Int.zero then Int.zero else Int.one) = n.","conclusion":"(if Int.eq n Int.zero then Int.zero else Int.one) = n","hypotheses":"(INT : forall (n0 : int) (sz : intsize) (sg0 : signedness),\nwt_int n0 sz sg0 -> cast_int_int sz sg0 n0 = n0) (n : int) (sg : signedness) (H : wt_int n IBool sg)","proofString":"destruct H; subst n; auto."},{"statement":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n) (BOOL : forall (n : int) (sg : signedness),\nwt_int n IBool sg -> (if Int.eq n Int.zero then Int.zero else Int.one) = n) : forall (v : val) (t1 t2 : type) (m : mem),\nwt_val v t2 -> sem_cast v t1 t2 m = Some v \\/ sem_cast v t1 t2 m = None.","conclusion":"forall (v : val) (t1 t2 : type) (m : mem),\nwt_val v t2 -> sem_cast v t1 t2 m = Some v \\/ sem_cast v t1 t2 m = None","hypotheses":"(INT : forall (n : int) (sz : intsize) (sg : signedness),\nwt_int n sz sg -> cast_int_int sz sg n = n) (BOOL : forall (n : int) (sg : signedness),\nwt_int n IBool sg -> (if Int.eq n Int.zero then Int.zero else Int.one) = n)","proofString":"Ltac DestructCast :=    auto;    match goal with    | [ |- match match ?x with _ => _ end with _ => _ end = _ \\/ _] => destruct x; DestructCast    | [ |- match ?x with _ => _ end = _ \\/ _ ] => destruct x; DestructCast    | _ => idtac    end.\nintros.\nunfold sem_cast, classify_cast; inv H; DestructCast;  try discriminate;  erewrite ? INT, ? BOOL; eauto."},{"statement":"(v : val) (t1 t2 : type) (m : mem) (v' : val) (H : sem_cast v t1 t2 m = Some v') (H0 : wt_val v t2) : v' = v.","conclusion":"v' = v","hypotheses":"(v : val) (t1 t2 : type) (m : mem) (v' : val) (H : sem_cast v t1 t2 m = Some v') (H0 : wt_val v t2)","proofString":"destruct (sem_cast_already_typed v t1 t2 m H0); congruence."}]}