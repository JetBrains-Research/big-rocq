{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/SelectOpproof.v","fileSamples":[{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrsymbol id ofs) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","proofString":"unfold addrsymbol.\nTrivialExists."},{"statement":"(le : letenv) (id : ident) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) Enil) v /\\\n  Val.lessdef (Genv.symbol_address ge id ofs) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (addrstack ofs) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","proofString":"unfold addrstack.\nTrivialExists."},{"statement":"(le : letenv) (ofs : ptrofs) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddrstack ofs) Enil) v /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      match addimm_match a with\n      | addimm_case1 m0 => Eop (Ointconst (Int.add n m0)) Enil\n      | addimm_case2 m0 t => Eop (Oaddimm (Int.add n m0)) (t ::: Enil)\n      | addimm_default e0 => Eop (Oaddimm n) (e0 ::: Enil)\n      end) v /\\ Val.lessdef (Val.add x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero; auto.\ncase (addimm_match a); intros; InvEval; simpl; TrivialExists; simpl.\nrewrite Int.add_commut.\nauto.\nsubst x.\nrewrite Val.add_assoc.\nrewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint n)) v.","proofString":"subst n.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v.","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.add x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : Val.lessdef (Val.add x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.add_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.add i Int.zero)) (Vint i).","proofString":"rewrite Int.add_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match addimm_match a with\n    | addimm_case1 m0 => Eop (Ointconst (Int.add n m0)) Enil\n    | addimm_case2 m0 t => Eop (Oaddimm (Int.add n m0)) (t ::: Enil)\n    | addimm_default e0 => Eop (Oaddimm n) (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.add x (Vint n)) v.","proofString":"case (addimm_match a); intros; InvEval; simpl; TrivialExists; simpl.\nrewrite Int.add_commut.\nauto.\nsubst x.\nrewrite Val.add_assoc.\nrewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) : Some (Vint (Int.add n m0)) = Some (Vint (Int.add m0 n)).","proofString":"rewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) : Some (Vint (Int.add m0 n)) = Some (Vint (Int.add m0 n)).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (m0 : int) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1) (H0 : Val.add v1 (Vint m0) = x) : Some (Val.add v1 (Vint (Int.add n m0))) = Some (Val.add x (Vint n)).","proofString":"subst x.\nrewrite Val.add_assoc.\nrewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : Some (Val.add v1 (Vint (Int.add n m0))) =\nSome (Val.add (Val.add v1 (Vint m0)) (Vint n)).","proofString":"rewrite Val.add_assoc.\nrewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : Some (Val.add v1 (Vint (Int.add n m0))) =\nSome (Val.add v1 (Val.add (Vint m0) (Vint n))).","proofString":"rewrite Int.add_commut.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (m0 : int) (t : expr) (v1 : val) (H3 : eval_expr ge sp e m le t v1) : Some (Val.add v1 (Vint (Int.add m0 n))) =\nSome (Val.add v1 (Val.add (Vint m0) (Vint n))).","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (add a b) v /\\ Val.lessdef (Val.add x y) v.","proofString":"unfold add; case (add_match a b); intros; InvEval; subst.\nrewrite Val.add_commut.\napply eval_addimm; auto.\napply eval_addimm; auto.\nreplace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))     with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut.\nreplace (Val.add (Val.add v1 (Vint n1)) y)     with (Val.add (Val.add v1 y) (Vint n1)).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_commut.\nrewrite <- Val.add_assoc.\napply eval_addimm.\nEvalOp.\nrewrite Val.add_commut.\nTrivialExists.\nTrivialExists.\nrewrite Val.add_commut.\nTrivialExists.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 t2) v /\\\n  Val.lessdef (Val.add (Vint n1) y) v.","proofString":"rewrite Val.add_commut.\napply eval_addimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 t2) v /\\\n  Val.lessdef (Val.add y (Vint n1)) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm n2 t1) v /\\\n  Val.lessdef (Val.add x (Vint n2)) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.add n1 n2) (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v.","proofString":"replace (Val.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)))     with (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.add n1 n2) (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2))) v.","proofString":"apply eval_addimm.\nEvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : eval_expr ge sp e m le (Eop Oadd (t1 ::: t2 ::: Enil)) (Val.add v1 v0).","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add (Val.add v1 v0) (Val.add (Vint n1) (Vint n2)) =\nVal.add (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2)).","proofString":"repeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add v1 (Val.add v0 (Val.add (Vint n1) (Vint n2))) =\nVal.add v1 (Val.add (Vint n1) (Val.add v0 (Vint n2))).","proofString":"decEq.\napply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : Val.add v0 (Val.add (Vint n1) (Vint n2)) =\nVal.add (Vint n1) (Val.add v0 (Vint n2)).","proofString":"apply Val.add_permut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 (Vint n1)) y) v.","proofString":"replace (Val.add (Val.add v1 (Vint n1)) y)     with (Val.add (Val.add v1 y) (Vint n1)).\napply eval_addimm.\nEvalOp.\nrepeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add v1 y) (Vint n1)) v.","proofString":"apply eval_addimm.\nEvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop Oadd (t1 ::: t2 ::: Enil)) (Val.add v1 y).","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.add (Val.add v1 y) (Vint n1) = Val.add (Val.add v1 (Vint n1)) y.","proofString":"repeat rewrite Val.add_assoc.\ndecEq.\napply Val.add_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.add v1 (Val.add y (Vint n1)) = Val.add v1 (Val.add (Vint n1) y).","proofString":"decEq.\napply Val.add_commut."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Val.add y (Vint n1) = Val.add (Vint n1) y.","proofString":"apply Val.add_commut."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n2 (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add x (Val.add v1 (Vint n2))) v.","proofString":"rewrite <- Val.add_assoc.\napply eval_addimm.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n2 (Eop Oadd (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.add x v1) (Vint n2)) v.","proofString":"apply eval_addimm.\nEvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : eval_expr ge sp e m le (Eop Oadd (t1 ::: t2 ::: Enil)) (Val.add x v1).","proofString":"EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.add (eval_shift s v1 a0) y) v.","proofString":"rewrite Val.add_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.add y (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oaddshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.add x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omuladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 v0) y) v.","proofString":"rewrite Val.add_commut.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 t3 : expr) (H0 : eval_expr ge sp e m le t3 y) (v1 v0 : val) (H3 : eval_expr ge sp e m le t1 v1) (H4 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omuladd (t3 ::: t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.add y (Val.mul v1 v0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omuladd (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.add x (Val.mul v1 v0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oadd (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.add x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match negint_match a with\n    | negint_case1 n => Eop (Ointconst (Int.neg n)) Enil\n    | negint_case2 s a0 t1 => Eop (Onegshift s a0) (t1 ::: Enil)\n    | negint_default e0 => Eop Oneg (e0 ::: Enil)\n    end v /\\ Val.lessdef (Val.sub Vzero x) v.","proofString":"case (negint_match a); intros; InvEval; subst.\nTrivialExists.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.neg n)) Enil) v /\\\n  Val.lessdef (Val.sub Vzero (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (s : shift) (a0 : amount32) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Onegshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.sub Vzero (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Oneg (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.sub Vzero x) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.sub x (Vint n2)) v.","proofString":"rewrite Val.sub_add_opp.\napply eval_addimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.neg n2) t1) v /\\\n  Val.lessdef (Val.add x (Vint (Int.neg n2))) v.","proofString":"apply eval_addimm; auto."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) (Val.add v0 (Vint n2))) v.","proofString":"rewrite Val.sub_add_l.\nrewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 (Val.add v0 (Vint n2))) (Vint n1)) v.","proofString":"rewrite Val.sub_add_r.\nrewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.add (Val.sub v1 v0) (Vint (Int.neg n2))) (Vint n1)) v.","proofString":"rewrite Val.add_assoc.\nsimpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef\n    (Val.add (Val.sub v1 v0) (Val.add (Vint (Int.neg n2)) (Vint n1))) v.","proofString":"simpl.\nrewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add (Int.neg n2) n1))) v.","proofString":"rewrite Int.add_commut.\nrewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.add n1 (Int.neg n2)))) v.","proofString":"rewrite <- Int.sub_add_opp.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (n1 : int) (t1 : expr) (n2 : int) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.sub n1 n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 v0) (Vint (Int.sub n1 n2))) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub (Val.add v1 (Vint n1)) y) v.","proofString":"rewrite Val.sub_add_l.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm n1 (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub v1 y) (Vint n1)) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.sub x (Val.add v1 (Vint n2))) v.","proofString":"rewrite Val.sub_add_r.\napply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (addimm (Int.neg n2) (Eop Osub (t1 ::: t2 ::: Enil))) v /\\\n  Val.lessdef (Val.add (Val.sub x v1) (Vint (Int.neg n2))) v.","proofString":"apply eval_addimm; EvalOp."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osubshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.sub x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 t3 : expr) (H : eval_expr ge sp e m le t1 x) (v1 v0 : val) (H3 : eval_expr ge sp e m le t2 v1) (H4 : eval_expr ge sp e m le t3 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Omulsub (t1 ::: t2 ::: t3 ::: Enil)) v /\\\n  Val.lessdef (Val.sub x (Val.mul v1 v0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Osub (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.sub x y) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int.iwordsize)\n      then Eop Oshl (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shlimm_match a with\n       | shlimm_case1 n1 => Eop (Ointconst (Int.shl n1 n)) Enil\n       | shlimm_case2 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int.iwordsize\n           then shlimm_base t1 (Int.add a0 n)\n           else shlimm_base a n\n       | shlimm_case3 s t1 => Eop (Oshlzext s (mk_amount32 n)) (t1 ::: Enil)\n       | shlimm_case4 s t1 => Eop (Oshlsext s (mk_amount32 n)) (t1 ::: Enil)\n       | shlimm_case5 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int.iwordsize\n           then Eop (Oshlzext s (mk_amount32 (Int.add a0 n))) (t1 ::: Enil)\n           else shlimm_base a n\n       | shlimm_case6 s a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int.iwordsize\n           then Eop (Oshlsext s (mk_amount32 (Int.add a0 n))) (t1 ::: Enil)\n           else shlimm_base a n\n       | shlimm_default e1 => shlimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shl x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int.iwordsize) eqn:L]; simpl.\nintros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto.\ndestruct (shlimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shlimm_base; auto.\nEvalOp.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\neconstructor; eauto using eval_shlimm_base.\nintros; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint n)) v.","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shl x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shl x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.shl_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shl i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shl_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shlimm_match a with\n    | shlimm_case1 n1 => Eop (Ointconst (Int.shl n1 n)) Enil\n    | shlimm_case2 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int.iwordsize\n        then shlimm_base t1 (Int.add a0 n)\n        else shlimm_base a n\n    | shlimm_case3 s t1 => Eop (Oshlzext s (mk_amount32 n)) (t1 ::: Enil)\n    | shlimm_case4 s t1 => Eop (Oshlsext s (mk_amount32 n)) (t1 ::: Enil)\n    | shlimm_case5 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int.iwordsize\n        then Eop (Oshlzext s (mk_amount32 (Int.add a0 n))) (t1 ::: Enil)\n        else shlimm_base a n\n    | shlimm_case6 s a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int.iwordsize\n        then Eop (Oshlsext s (mk_amount32 (Int.add a0 n))) (t1 ::: Enil)\n        else shlimm_base a n\n    | shlimm_default e1 => shlimm_base e1 n\n    end v /\\ Val.lessdef (Val.shl x (Vint n)) v.","proofString":"destruct (shlimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shlimm_base; auto.\nEvalOp.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto.\neconstructor; eauto using eval_shlimm_base."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.shl n1 n)) Enil) v /\\\n  Val.lessdef (Val.shl (Vint n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_operation ge sp (Ointconst (Int.shl n1 n)) nil m =\nSome (Val.shl (Vint n1) (Vint n)).","proofString":"simpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int.iwordsize\n     then shlimm_base t1 (Int.add a n)\n     else shlimm_base (Eop (Oshift Slsl a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shl (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"destruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le (shlimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shl (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\neapply eval_shlimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef\n  (Val.shl (if Int.ltu a Int.iwordsize then Vint (Int.shl i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shl i (Int.add a n))\n   else Vundef).","proofString":"rewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl (Int.shl i a) n) else Vundef)\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shl i (Int.add a n))\n   else Vundef).","proofString":"rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef (Vint (Int.shl (Int.shl i a) n)) (Vint (Int.shl i (Int.add a n))).","proofString":"rewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shlimm_base (Eop (Oshift Slsl a) (t1 ::: Enil)) n)\n    v /\\ Val.lessdef (Val.shl (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split; [|eauto].\napply eval_shlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : eval_expr ge sp e m le (shlimm_base (Eop (Oshift Slsl a) (t1 ::: Enil)) n)\n  (Val.shl (Val.shl v1 (Vint a)) (Vint n)).","proofString":"apply eval_shlimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : eval_expr ge sp e m le (Eop (Oshift Slsl a) (t1 ::: Enil))\n  (Val.shl v1 (Vint a)).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshlzext s (mk_amount32 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shl (Val.zero_ext s v1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Oshlzext s (mk_amount32 n)) (v1 :: nil) m =\nSome (Val.shl (Val.zero_ext s v1) (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some (Val.shl (Val.zero_ext s v1) (Vint (mk_amount32 n))) =\nSome (Val.shl (Val.zero_ext s v1) (Vint n)).","proofString":"rewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshlsext s (mk_amount32 n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shl (Val.sign_ext s v1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Oshlsext s (mk_amount32 n)) (v1 :: nil) m =\nSome (Val.shl (Val.sign_ext s v1) (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some (Val.shl (Val.sign_ext s v1) (Vint (mk_amount32 n))) =\nSome (Val.shl (Val.sign_ext s v1) (Vint n)).","proofString":"rewrite mk_amount32_eq; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int.iwordsize\n     then Eop (Oshlzext s (mk_amount32 (Int.add a n))) (t1 ::: Enil)\n     else shlimm_base (Eop (Oshlzext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)) v.","proofString":"destruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshlzext s (mk_amount32 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : eval_operation ge sp (Oshlzext s (mk_amount32 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Some (Val.shl (Val.zero_ext s v1) (Vint (mk_amount32 (Int.add a n)))) =\nSome (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)).","proofString":"rewrite mk_amount32_eq by auto.\ndestruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Some (Val.shl (Val.zero_ext s v1) (Vint (Int.add a n))) =\nSome (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)).","proofString":"destruct (Val.zero_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) (i : int) : Some\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shl i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shl (if Int.ltu a Int.iwordsize then Vint (Int.shl i a) else Vundef)\n     (Vint n)).","proofString":"rewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) (i : int) : Some (Vint (Int.shl i (Int.add a n))) = Some (Vint (Int.shl (Int.shl i a) n)).","proofString":"rewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shlimm_base (Eop (Oshlzext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.zero_ext s v1) (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int.iwordsize\n     then Eop (Oshlsext s (mk_amount32 (Int.add a n))) (t1 ::: Enil)\n     else shlimm_base (Eop (Oshlsext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)) v.","proofString":"destruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\nTrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range.\neconstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshlsext s (mk_amount32 (Int.add a n))) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : eval_operation ge sp (Oshlsext s (mk_amount32 (Int.add a n))) (v1 :: nil) m =\nSome (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Some (Val.shl (Val.sign_ext s v1) (Vint (mk_amount32 (Int.add a n)))) =\nSome (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)).","proofString":"rewrite mk_amount32_eq by auto.\ndestruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Some (Val.shl (Val.sign_ext s v1) (Vint (Int.add a n))) =\nSome (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)).","proofString":"destruct (Val.sign_ext s v1); simpl; auto.\nrewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) (i : int) : Some\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shl i (Int.add a n))\n   else Vundef) =\nSome\n  (Val.shl (if Int.ltu a Int.iwordsize then Vint (Int.shl i a) else Vundef)\n     (Vint n)).","proofString":"rewrite a32_range; simpl; rewrite L, L2.\nrewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) (i : int) : Some (Vint (Int.shl i (Int.add a n))) = Some (Vint (Int.shl (Int.shl i a) n)).","proofString":"rewrite Int.shl_shl; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shlimm_base (Eop (Oshlsext s a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shl (Val.shl (Val.sign_ext s v1) (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\neapply eval_shlimm_base; eauto.\nEvalOp; simpl; eauto.\nauto."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x) : exists v : val,\n  eval_expr ge sp e m le (shlimm_base e1 n) v /\\\n  Val.lessdef (Val.shl x (Vint n)) v.","proofString":"econstructor; eauto using eval_shlimm_base."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = false) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshl (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shl x (Vint n)) v.","proofString":"intros; TrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : eval_operation ge sp (Oshift Slsr (mk_amount32 n)) (x :: nil) m =\nSome (Val.shru x (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : Some (Val.shru x (Vint (mk_amount32 n))) = Some (Val.shru x (Vint n)).","proofString":"rewrite mk_amount32_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : Some (Val.shru x (Vint n)) = Some (Val.shru x (Vint n)).","proofString":"auto."},{"statement":"(y z : int) (H : Int.ltu y Int.iwordsize = true) (H0 : Int.ltu z Int.iwordsize = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.ltu (Int.sub z y) Int.iwordsize = true.","proofString":"unfold Int.ltu; apply zlt_true.\nrewrite Int.unsigned_repr_wordsize.\napply Int.ltu_iwordsize_inv in H.\napply Int.ltu_iwordsize_inv in H0.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(y z : int) (H : Int.ltu y Int.iwordsize = true) (H0 : Int.ltu z Int.iwordsize = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.unsigned Int.iwordsize.","proofString":"rewrite Int.unsigned_repr_wordsize.\napply Int.ltu_iwordsize_inv in H.\napply Int.ltu_iwordsize_inv in H0.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(y z : int) (H : Int.ltu y Int.iwordsize = true) (H0 : Int.ltu z Int.iwordsize = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.zwordsize.","proofString":"apply Int.ltu_iwordsize_inv in H.\napply Int.ltu_iwordsize_inv in H0.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.zwordsize) (H0 : Int.ltu z Int.iwordsize = true) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.zwordsize.","proofString":"apply Int.ltu_iwordsize_inv in H0.\nunfold Int.sub; rewrite Int.unsigned_repr.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.zwordsize) (H0 : 0 <= Int.unsigned z < Int.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned (Int.sub z y) < Int.zwordsize.","proofString":"unfold Int.sub; rewrite Int.unsigned_repr.\nlia.\ngeneralize Int.wordsize_max_unsigned; lia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.zwordsize) (H0 : 0 <= Int.unsigned z < Int.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : Int.unsigned z - Int.unsigned y < Int.zwordsize.","proofString":"lia."},{"statement":"(y z : int) (H : 0 <= Int.unsigned y < Int.zwordsize) (H0 : 0 <= Int.unsigned z < Int.zwordsize) (H1 : Int.unsigned y <= Int.unsigned z) : 0 <= Int.unsigned z - Int.unsigned y <= Int.max_unsigned.","proofString":"generalize Int.wordsize_max_unsigned; lia."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : eval_operation ge sp (Oshift Sasr (mk_amount32 n)) (x :: nil) m =\nSome (Val.shr x (Vint n)).","proofString":"simpl.\nrewrite mk_amount32_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : Some (Val.shr x (Vint (mk_amount32 n))) = Some (Val.shr x (Vint n)).","proofString":"rewrite mk_amount32_eq by auto.\nauto."},{"statement":"(le : letenv) (a : expr) (n : int) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.ltu n Int.iwordsize = true) : Some (Val.shr x (Vint n)) = Some (Val.shr x (Vint n)).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if negb (Int.ltu n Int.iwordsize)\n      then Eop Oshr (a ::: Eop (Ointconst n) Enil ::: Enil)\n      else\n       match shrimm_match a with\n       | shrimm_case1 n1 => Eop (Ointconst (Int.shr n1 n)) Enil\n       | shrimm_case2 a0 t1 =>\n           if Int.ltu n a0\n           then\n            Eop\n              (Oshlsext (Int.zwordsize - Int.unsigned a0)\n                 (mk_amount32 (Int.sub a0 n))) (t1 ::: Enil)\n           else\n            Eop\n              (Osextshr (mk_amount32 (Int.sub n a0))\n                 (Int.zwordsize - Int.unsigned n)) \n              (t1 ::: Enil)\n       | shrimm_case3 a0 t1 =>\n           if Int.ltu (Int.add a0 n) Int.iwordsize\n           then shrimm_base t1 (Int.add a0 n)\n           else shrimm_base a n\n       | shrimm_case4 s t1 =>\n           if zlt (Int.unsigned n) s && zlt s Int.zwordsize\n           then\n            Eop (Osextshr (mk_amount32 n) (s - Int.unsigned n)) (t1 ::: Enil)\n           else shrimm_base a n\n       | shrimm_default e1 => shrimm_base e1 n\n       end) v /\\ Val.lessdef (Val.shr x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero; [| destruct (Int.ltu n Int.iwordsize) eqn:L]; simpl.\nintros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto.\ndestruct (shrimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shrimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp.\ndestruct (zlt (Int.unsigned n) s && zlt s Int.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount32_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp.\neconstructor; eauto using eval_shrimm_base.\nintros; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint n)) v.","proofString":"intros; subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.shr x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.shr x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.shr_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef\n  (if Int.ltu Int.zero Int.iwordsize\n   then Vint (Int.shr i Int.zero)\n   else Vundef) (Vint i).","proofString":"rewrite Int.shr_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match shrimm_match a with\n    | shrimm_case1 n1 => Eop (Ointconst (Int.shr n1 n)) Enil\n    | shrimm_case2 a0 t1 =>\n        if Int.ltu n a0\n        then\n         Eop\n           (Oshlsext (Int.zwordsize - Int.unsigned a0)\n              (mk_amount32 (Int.sub a0 n))) (t1 ::: Enil)\n        else\n         Eop\n           (Osextshr (mk_amount32 (Int.sub n a0))\n              (Int.zwordsize - Int.unsigned n)) (t1 ::: Enil)\n    | shrimm_case3 a0 t1 =>\n        if Int.ltu (Int.add a0 n) Int.iwordsize\n        then shrimm_base t1 (Int.add a0 n)\n        else shrimm_base a n\n    | shrimm_case4 s t1 =>\n        if zlt (Int.unsigned n) s && zlt s Int.zwordsize\n        then\n         Eop (Osextshr (mk_amount32 n) (s - Int.unsigned n)) (t1 ::: Enil)\n        else shrimm_base a n\n    | shrimm_default e1 => shrimm_base e1 n\n    end v /\\ Val.lessdef (Val.shr x (Vint n)) v.","proofString":"destruct (shrimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl; rewrite L; auto.\ndestruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto.\ndestruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shrimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp.\ndestruct (zlt (Int.unsigned n) s && zlt s Int.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount32_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp.\neconstructor; eauto using eval_shrimm_base."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.shr n1 n)) Enil) v /\\\n  Val.lessdef (Val.shr (Vint n1) (Vint n)) v.","proofString":"TrivialExists.\nsimpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (n1 : int) : eval_operation ge sp (Ointconst (Int.shr n1 n)) nil m =\nSome (Val.shr (Vint n1) (Vint n)).","proofString":"simpl; rewrite L; auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu n a\n     then\n      Eop\n        (Oshlsext (Int.zwordsize - Int.unsigned a)\n           (mk_amount32 (Int.sub a n))) (t1 ::: Enil)\n     else\n      Eop\n        (Osextshr (mk_amount32 (Int.sub n a))\n           (Int.zwordsize - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"destruct (Int.ltu n a) eqn:L2.\nassert (L3: Int.ltu (Int.sub a n) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto.\nassert (L3: Int.ltu (Int.sub n a) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshlsext (Int.zwordsize - Int.unsigned a) (mk_amount32 (Int.sub a n)))\n       (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"assert (L3: Int.ltu (Int.sub a n) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\napply Int.ltu_inv in L2.\nlia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : Int.ltu (Int.sub a n) Int.iwordsize = true.","proofString":"apply sub_shift_amount; auto using a32_range.\napply Int.ltu_inv in L2.\nlia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) : Int.unsigned n <= Int.unsigned a.","proofString":"apply Int.ltu_inv in L2.\nlia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : 0 <= Int.unsigned n < Int.unsigned a) : Int.unsigned n <= Int.unsigned a.","proofString":"lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Oshlsext (Int.zwordsize - Int.unsigned a) (mk_amount32 (Int.sub a n)))\n       (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : Val.lessdef\n  (Val.shr (if Int.ltu a Int.iwordsize then Vint (Int.shl i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (mk_amount32 (Int.sub a n)) Int.iwordsize\n   then\n    Vint\n      (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i)\n         (mk_amount32 (Int.sub a n)))\n   else Vundef).","proofString":"rewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : Val.lessdef (Val.shr (Vint (Int.shl i a)) (Vint n))\n  (Vint\n     (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i) (Int.sub a n))).","proofString":"simpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr (Int.shl i a) n) else Vundef)\n  (Vint\n     (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i) (Int.sub a n))).","proofString":"rewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : Val.lessdef (Vint (Int.shr (Int.shl i a) n))\n  (Vint\n     (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i) (Int.sub a n))).","proofString":"rewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = true) (L3 : Int.ltu (Int.sub a n) Int.iwordsize = true) : Val.lessdef\n  (Vint\n     (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i) (Int.sub a n)))\n  (Vint\n     (Int.shl (Int.sign_ext (Int.zwordsize - Int.unsigned a) i) (Int.sub a n))).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshr (mk_amount32 (Int.sub n a)) (Int.zwordsize - Int.unsigned n))\n       (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"assert (L3: Int.ltu (Int.sub n a) Int.iwordsize = true).\napply sub_shift_amount; auto using a32_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : Int.ltu (Int.sub n a) Int.iwordsize = true.","proofString":"apply sub_shift_amount; auto using a32_range.\nunfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) : Int.unsigned a <= Int.unsigned n.","proofString":"unfold Int.ltu in L2.\ndestruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : (if zlt (Int.unsigned n) (Int.unsigned a) then true else false) = false) : Int.unsigned a <= Int.unsigned n.","proofString":"destruct zlt in L2; discriminate || lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop\n       (Osextshr (mk_amount32 (Int.sub n a)) (Int.zwordsize - Int.unsigned n))\n       (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.shl v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : Val.lessdef\n  (Val.shr (if Int.ltu a Int.iwordsize then Vint (Int.shl i a) else Vundef)\n     (Vint n))\n  (Val.sign_ext (Int.zwordsize - Int.unsigned n)\n     (if Int.ltu (mk_amount32 (Int.sub n a)) Int.iwordsize\n      then Vint (Int.shr i (mk_amount32 (Int.sub n a)))\n      else Vundef)).","proofString":"rewrite mk_amount32_eq, L3, a32_range by auto.\nsimpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : Val.lessdef (Val.shr (Vint (Int.shl i a)) (Vint n))\n  (Val.sign_ext (Int.zwordsize - Int.unsigned n)\n     (Vint (Int.shr i (Int.sub n a)))).","proofString":"simpl.\nrewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr (Int.shl i a) n) else Vundef)\n  (Vint\n     (Int.sign_ext (Int.zwordsize - Int.unsigned n) (Int.shr i (Int.sub n a)))).","proofString":"rewrite L.\nrewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : Val.lessdef (Vint (Int.shr (Int.shl i a) n))\n  (Vint\n     (Int.sign_ext (Int.zwordsize - Int.unsigned n) (Int.shr i (Int.sub n a)))).","proofString":"rewrite Int.shr_shl, L2 by auto using a32_range.\nauto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu n a = false) (L3 : Int.ltu (Int.sub n a) Int.iwordsize = true) : Val.lessdef\n  (Vint\n     (Int.sign_ext (Int.zwordsize - Int.unsigned n) (Int.shr i (Int.sub n a))))\n  (Vint\n     (Int.sign_ext (Int.zwordsize - Int.unsigned n) (Int.shr i (Int.sub n a)))).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.ltu (Int.add a n) Int.iwordsize\n     then shrimm_base t1 (Int.add a n)\n     else shrimm_base (Eop (Oshift Sasr a) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shr (Val.shr v1 (Vint a)) (Vint n)) v.","proofString":"destruct (Int.ltu (Int.add a n) Int.iwordsize) eqn:L2.\neconstructor; split.\neapply eval_shrimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : exists v : val,\n  eval_expr ge sp e m le (shrimm_base t1 (Int.add a n)) v /\\\n  Val.lessdef (Val.shr (Val.shr v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split.\neapply eval_shrimm_base; eauto.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef\n  (Val.shr (if Int.ltu a Int.iwordsize then Vint (Int.shr i a) else Vundef)\n     (Vint n))\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shr i (Int.add a n))\n   else Vundef).","proofString":"rewrite a32_range; simpl.\nrewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr (Int.shr i a) n) else Vundef)\n  (if Int.ltu (Int.add a n) Int.iwordsize\n   then Vint (Int.shr i (Int.add a n))\n   else Vundef).","proofString":"rewrite L, L2.\nrewrite Int.shr_shr; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (L2 : Int.ltu (Int.add a n) Int.iwordsize = true) : Val.lessdef (Vint (Int.shr (Int.shr i a) n)) (Vint (Int.shr i (Int.add a n))).","proofString":"rewrite Int.shr_shr; auto using a32_range."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shrimm_base (Eop (Oshift Sasr a) (t1 ::: Enil)) n)\n    v /\\ Val.lessdef (Val.shr (Val.shr v1 (Vint a)) (Vint n)) v.","proofString":"econstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : eval_expr ge sp e m le (shrimm_base (Eop (Oshift Sasr a) (t1 ::: Enil)) n)\n  (Val.shr (Val.shr v1 (Vint a)) (Vint n)).","proofString":"apply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (a : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (L2 : Int.ltu (Int.add a n) Int.iwordsize = false) : eval_expr ge sp e m le (Eop (Oshift Sasr a) (t1 ::: Enil))\n  (Val.shr v1 (Vint a)).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned n) s && zlt s Int.zwordsize\n     then Eop (Osextshr (mk_amount32 n) (s - Int.unsigned n)) (t1 ::: Enil)\n     else shrimm_base (Eop (Osext s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shr (Val.sign_ext s v1) (Vint n)) v.","proofString":"destruct (zlt (Int.unsigned n) s && zlt s Int.zwordsize) eqn:E.\nInvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount32_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia.\neconstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int.zwordsize = true) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshr (mk_amount32 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.sign_ext s v1) (Vint n)) v.","proofString":"InvBooleans.\neconstructor; split.\nEvalOp.\nrewrite mk_amount32_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int.zwordsize) (H0 : Int.unsigned n < s) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osextshr (mk_amount32 n) (s - Int.unsigned n)) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.shr (Val.sign_ext s v1) (Vint n)) v.","proofString":"econstructor; split.\nEvalOp.\nrewrite mk_amount32_eq by auto.\ndestruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (H1 : s < Int.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef (Val.shr (Val.sign_ext s v1) (Vint n))\n  (Val.sign_ext (s - Int.unsigned n) (Val.shr v1 (Vint n))).","proofString":"destruct v1; simpl; auto.\nrewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (H1 : s < Int.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef\n  (if Int.ltu n Int.iwordsize\n   then Vint (Int.shr (Int.sign_ext s i) n)\n   else Vundef)\n  (Val.sign_ext (s - Int.unsigned n)\n     (if Int.ltu n Int.iwordsize then Vint (Int.shr i n) else Vundef)).","proofString":"rewrite ! L; simpl.\nset (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (H1 : s < Int.zwordsize) (H0 : Int.unsigned n < s) : Val.lessdef (Vint (Int.shr (Int.sign_ext s i) n))\n  (Vint (Int.sign_ext (s - Int.unsigned n) (Int.shr i n))).","proofString":"set (s' := s - Int.unsigned n).\nreplace s with (s' + Int.unsigned n) by (unfold s'; lia).\nrewrite Int.shr_sign_ext.\nauto.\nunfold s'; lia.\nunfold s'; lia."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (H1 : s < Int.zwordsize) (H0 : Int.unsigned n < s) (s' : Z) : Val.lessdef (Vint (Int.sign_ext s' (Int.shr i n)))\n  (Vint (Int.sign_ext s' (Int.shr i n))).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int.zwordsize = false) : exists v : val,\n  eval_expr ge sp e m le (shrimm_base (Eop (Osext s) (t1 ::: Enil)) n) v /\\\n  Val.lessdef (Val.shr (Val.sign_ext s v1) (Vint n)) v.","proofString":"econstructor; split; [|eauto].\napply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int.zwordsize = false) : eval_expr ge sp e m le (shrimm_base (Eop (Osext s) (t1 ::: Enil)) n)\n  (Val.shr (Val.sign_ext s v1) (Vint n)).","proofString":"apply eval_shrimm_base; auto.\nEvalOp."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (s : Z) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (E : zlt (Int.unsigned n) s && zlt s Int.zwordsize = false) : eval_expr ge sp e m le (Eop (Osext s) (t1 ::: Enil)) (Val.sign_ext s v1).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = true) (e1 : expr) (H0 : eval_expr ge sp e m le e1 x) : exists v : val,\n  eval_expr ge sp e m le (shrimm_base e1 n) v /\\\n  Val.lessdef (Val.shr x (Vint n)) v.","proofString":"econstructor; eauto using eval_shrimm_base."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (L : Int.ltu n Int.iwordsize = false) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop Oshr (a ::: Eop (Ointconst n) Enil ::: Enil)) v /\\\n  Val.lessdef (Val.shr x (Vint n)) v.","proofString":"intros; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.one_bits n with\n    | nil => Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)\n    | i :: nil => shlimm a i\n    | i :: j :: nil =>\n        Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"assert (DFL: exists v, eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\ Val.lessdef (Val.mul x (Vint n)) v).\nrewrite Val.mul_commut; TrivialExists.\ngeneralize (Int.one_bits_decomp n); generalize (Int.one_bits_range n);  destruct (Int.one_bits n) as [ | i [ | j []]]; intros P Q.\napply DFL.\nreplace (Val.mul x (Vint n)) with (Val.shl x (Vint i)).\napply eval_shlimm; auto.\nsimpl in Q.\nrewrite <- Val.shl_mul, Q, Int.add_zero.\nsimpl.\nrewrite P by auto with coqlib.\nauto.\nexploit (eval_shlimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shlimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto.\napply DFL."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"rewrite Val.mul_commut; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) : exists v : val,\n  eval_expr ge sp e m le\n    match Int.one_bits n with\n    | nil => Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)\n    | i :: nil => shlimm a i\n    | i :: j :: nil =>\n        Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))\n    | i :: j :: _ :: _ => Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"generalize (Int.one_bits_decomp n); generalize (Int.one_bits_range n);  destruct (Int.one_bits n) as [ | i [ | j []]]; intros P Q.\napply DFL.\nreplace (Val.mul x (Vint n)) with (Val.shl x (Vint i)).\napply eval_shlimm; auto.\nsimpl in Q.\nrewrite <- Val.shl_mul, Q, Int.add_zero.\nsimpl.\nrewrite P by auto with coqlib.\nauto.\nexploit (eval_shlimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shlimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto.\napply DFL."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (P : forall i : int, In i nil -> Int.ltu i Int.iwordsize = true) (Q : n = Int.int_of_one_bits nil) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"apply DFL."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: nil)) : exists v : val,\n  eval_expr ge sp e m le (shlimm a i) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"replace (Val.mul x (Vint n)) with (Val.shl x (Vint i)).\napply eval_shlimm; auto.\nsimpl in Q.\nrewrite <- Val.shl_mul, Q, Int.add_zero.\nsimpl.\nrewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: nil)) : exists v : val,\n  eval_expr ge sp e m le (shlimm a i) v /\\ Val.lessdef (Val.shl x (Vint i)) v.","proofString":"apply eval_shlimm; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: nil)) : Val.shl x (Vint i) = Val.mul x (Vint n).","proofString":"simpl in Q.\nrewrite <- Val.shl_mul, Q, Int.add_zero.\nsimpl.\nrewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) Int.zero) : Val.shl x (Vint i) = Val.mul x (Vint n).","proofString":"rewrite <- Val.shl_mul, Q, Int.add_zero.\nsimpl.\nrewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) Int.zero) : Val.mul x (Val.shl Vone (Vint i)) = Val.mul x (Vint (Int.shl Int.one i)).","proofString":"simpl.\nrewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) Int.zero) : Val.mul x\n  (if Int.ltu i Int.iwordsize then Vint (Int.shl Int.one i) else Vundef) =\nVal.mul x (Vint (Int.shl Int.one i)).","proofString":"rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i : int) (P : forall i0 : int, In i0 (i :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) Int.zero) : Val.mul x (Vint (Int.shl Int.one i)) = Val.mul x (Vint (Int.shl Int.one i)).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exploit (eval_shlimm i (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v1 [A1 B1]].\nexploit (eval_shlimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) : eval_expr ge sp e m (x :: le) (Eletvar 0) x.","proofString":"constructor; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) : (exists v : val,\n   eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v /\\\n   Val.lessdef (Val.shl x (Vint i)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros [v1 [A1 B1]].\nexploit (eval_shlimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exploit (eval_shlimm j (x :: le) (Eletvar 0) x).\nconstructor; auto.\nintros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) : eval_expr ge sp e m (x :: le) (Eletvar 0) x.","proofString":"constructor; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) : (exists v : val,\n   eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v /\\\n   Val.lessdef (Val.shl x (Vint j)) v) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros [v2 [A2 B2]].\nexploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exploit (eval_add (x :: le)).\neexact A1.\neexact A2.\nintros [v [A B]].\nexists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : exists v0 : val,\n  eval_expr ge sp e m le\n    (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v0 /\\\n  Val.lessdef (Val.mul x (Vint n)) v0.","proofString":"exists v; split.\neconstructor; eauto.\nsimpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : eval_expr ge sp e m le\n  (Elet a (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j))) v.","proofString":"econstructor; eauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: nil)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef (Val.mul x (Vint n)) v.","proofString":"simpl in Q.\nrewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef (Val.mul x (Vint n)) v.","proofString":"rewrite Q, Int.add_zero.\nreplace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef\n  (Val.mul x (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))) v.","proofString":"replace (Vint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)))     with (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j))).\nrewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto.\nsimpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef\n  (Val.mul x (Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j)))) v.","proofString":"rewrite Val.mul_add_distr_r.\nrepeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef\n  (Val.add (Val.mul x (Val.shl Vone (Vint i)))\n     (Val.mul x (Val.shl Vone (Vint j)))) v.","proofString":"repeat rewrite Val.shl_mul.\neapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef (Val.add (Val.shl x (Vint i)) (Val.shl x (Vint j))) v.","proofString":"eapply Val.lessdef_trans; [|eauto].\napply Val.add_lessdef; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.lessdef (Val.add (Val.shl x (Vint i)) (Val.shl x (Vint j)))\n  (Val.add v1 v2).","proofString":"apply Val.add_lessdef; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.add (Val.shl Vone (Vint i)) (Val.shl Vone (Vint j)) =\nVint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)).","proofString":"simpl.\nrepeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.add\n  (if Int.ltu i Int.iwordsize then Vint (Int.shl Int.one i) else Vundef)\n  (if Int.ltu j Int.iwordsize then Vint (Int.shl Int.one j) else Vundef) =\nVint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)).","proofString":"repeat rewrite P by auto with coqlib.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v0 : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil))\n    v0 /\\ Val.lessdef (Val.mul x (Vint n)) v0) (i j : int) (P : forall i0 : int, In i0 (i :: j :: nil) -> Int.ltu i0 Int.iwordsize = true) (Q : n = Int.add (Int.shl Int.one i) (Int.add (Int.shl Int.one j) Int.zero)) (v1 : val) (A1 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) i) v1) (B1 : Val.lessdef (Val.shl x (Vint i)) v1) (v2 : val) (A2 : eval_expr ge sp e m (x :: le) (shlimm (Eletvar 0) j) v2) (B2 : Val.lessdef (Val.shl x (Vint j)) v2) (v : val) (A : eval_expr ge sp e m (x :: le)\n  (add (shlimm (Eletvar 0) i) (shlimm (Eletvar 0) j)) v) (B : Val.lessdef (Val.add v1 v2) v) : Val.add (Vint (Int.shl Int.one i)) (Vint (Int.shl Int.one j)) =\nVint (Int.add (Int.shl Int.one i) (Int.shl Int.one j)).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (DFL : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v) (i j i0 : int) (l : list int) (P : forall i1 : int, In i1 (i :: j :: i0 :: l) -> Int.ltu i1 Int.iwordsize = true) (Q : n = Int.int_of_one_bits (i :: j :: i0 :: l)) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (Eop (Ointconst n) Enil ::: a ::: Enil)) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"apply DFL."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then Eop (Ointconst Int.zero) Enil\n     else\n      if Int.eq n Int.one\n      then a\n      else\n       match mulimm_match a with\n       | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n       | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n       | mulimm_default e2 => mulimm_base n e2\n       end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) (Vint Int.zero).","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint Int.zero).","proofString":"subst n.\nrewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.mul_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.zero) (Vint Int.zero).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.one\n     then a\n     else\n      match mulimm_match a with\n      | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n      | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n      | mulimm_default e2 => mulimm_base n e2\n      end) v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.one.\nintros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto.\ncase (mulimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"intros.\nexists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.mul x (Vint n)) x.","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.one) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i n)) (Vint i).","proofString":"subst n.\nrewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.mul i Int.one)) (Vint i).","proofString":"rewrite Int.mul_one.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.one <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match mulimm_match a with\n    | mulimm_case1 n2 => Eop (Ointconst (Int.mul n n2)) Enil\n    | mulimm_case2 n2 t2 => addimm (Int.mul n n2) (mulimm_base n t2)\n    | mulimm_default e2 => mulimm_base n e2\n    end v /\\ Val.lessdef (Val.mul x (Vint n)) v.","proofString":"case (mulimm_match a); intros; InvEval; subst.\nTrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto.\nrewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto.\napply eval_mulimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.mul n n2)) Enil) v /\\\n  Val.lessdef (Val.mul (Vint n2) (Vint n)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : eval_operation ge sp (Ointconst (Int.mul n n2)) nil m =\nSome (Val.mul (Vint n2) (Vint n)).","proofString":"simpl.\nrewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) : Some (Vint (Int.mul n n2)) = Some (Vint (Int.mul n2 n)).","proofString":"rewrite Int.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.mul (Val.add v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.mul_add_distr_l.\nexploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exploit eval_mulimm_base; eauto.\ninstantiate (1 := n).\nintros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : (exists v : val,\n   eval_expr ge sp e m le (mulimm_base n t2) v /\\\n   Val.lessdef (Val.mul v1 (Vint n)) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"intros [v' [A1 B1]].\nexploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exploit (eval_addimm (Int.mul n n2) le (mulimm_base n t2) v').\nauto.\nintros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : eval_expr ge sp e m le (mulimm_base n t2) v'.","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') : (exists v : val,\n   eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n   Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v) ->\nexists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"intros [v'' [A2 B2]].\nexists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : exists v : val,\n  eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v /\\\n  Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v.","proofString":"exists v''; split; auto.\neapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (H : n <> Int.zero) (H0 : n <> Int.one) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) (v' : val) (A1 : eval_expr ge sp e m le (mulimm_base n t2) v') (B1 : Val.lessdef (Val.mul v1 (Vint n)) v') (v'' : val) (A2 : eval_expr ge sp e m le (addimm (Int.mul n n2) (mulimm_base n t2)) v'') (B2 : Val.lessdef (Val.add v' (Vint (Int.mul n n2))) v'') : Val.lessdef (Val.add (Val.mul v1 (Vint n)) (Val.mul (Vint n2) (Vint n))) v''.","proofString":"eapply Val.lessdef_trans.\neapply Val.add_lessdef; eauto.\nrewrite Val.mul_commut; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.one) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm_base n e2) v /\\\n  Val.lessdef (Val.mul x (Vint n)) v.","proofString":"apply eval_mulimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul (Vint n1) y) v.","proofString":"rewrite Val.mul_commut.\napply eval_mulimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (mulimm n1 t2) v /\\\n  Val.lessdef (Val.mul y (Vint n1)) v.","proofString":"apply eval_mulimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (mulimm n2 t1) v /\\\n  Val.lessdef (Val.mul x (Vint n2)) v.","proofString":"apply eval_mulimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Omul (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.mul x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Olowlong\n       (Eop (Oshiftl Sasr (mk_amount64 (Int.repr 32)))\n          (Eop Omull\n             (Eop (Oextend Xsgn32 (mk_amount64 Int.zero)) (a ::: Enil)\n              ::: Eop (Oextend Xsgn32 (mk_amount64 Int.zero)) (b ::: Enil)\n                  ::: Enil) ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.mulhs x y) v.","proofString":"econstructor; split.\nEvalOp.\nunfold eval_shiftl, eval_extend.\nrewrite ! mk_amount64_eq by auto.\ndestruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : Val.lessdef (Val.mulhs x y)\n  (Val.loword\n     (Val.shrl\n        (Val.mull (Val.shll (Val.longofint x) (Vint (mk_amount64 Int.zero)))\n           (Val.shll (Val.longofint y) (Vint (mk_amount64 Int.zero))))\n        (Vint (mk_amount64 (Int.repr 32))))).","proofString":"rewrite ! mk_amount64_eq by auto.\ndestruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : Val.lessdef (Val.mulhs x y)\n  (Val.loword\n     (Val.shrl\n        (Val.mull (Val.shll (Val.longofint x) (Vint Int.zero))\n           (Val.shll (Val.longofint y) (Vint Int.zero))) \n        (Vint (Int.repr 32)))).","proofString":"destruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b y) : Val.lessdef match y with\n            | Vint n2 => Vint (Int.mulhs i n2)\n            | _ => Vundef\n            end\n  (Val.loword\n     (Val.shrl\n        (Val.mull\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.signed i)) Int.zero)\n            else Vundef) (Val.shll (Val.longofint y) (Vint Int.zero)))\n        (Vint (Int.repr 32)))).","proofString":"destruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhs i i0))\n  (Val.loword\n     (Val.shrl\n        (Val.mull\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.signed i)) Int.zero)\n            else Vundef)\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.signed i0)) Int.zero)\n            else Vundef)) (Vint (Int.repr 32)))).","proofString":"change (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhs i i0))\n  (Val.loword\n     (if Int.ltu (Int.repr 32) Int64.iwordsize'\n      then\n       Vlong\n         (Int64.shr'\n            (Int64.mul (Int64.shl' (Int64.repr (Int.signed i)) Int.zero)\n               (Int64.shl' (Int64.repr (Int.signed i0)) Int.zero))\n            (Int.repr 32))\n      else Vundef)).","proofString":"rewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhs i i0))\n  (Val.loword\n     (if Int.ltu (Int.repr 32) Int64.iwordsize'\n      then\n       Vlong\n         (Int64.shr'\n            (Int64.mul (Int64.repr (Int.signed i))\n               (Int64.repr (Int.signed i0))) (Int.repr 32))\n      else Vundef)).","proofString":"change (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhs i i0))\n  (Vint\n     (Int64.loword\n        (Int64.shr'\n           (Int64.mul (Int64.repr (Int.signed i))\n              (Int64.repr (Int.signed i0))) (Int.repr 32)))).","proofString":"apply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Vint (Int.mulhs i i0) =\nVint\n  (Int64.loword\n     (Int64.shr'\n        (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n        (Int.repr 32))).","proofString":"f_equal.\ntransitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.mulhs i i0 =\nInt64.loword\n  (Int64.shr'\n     (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n     (Int.repr 32)).","proofString":"transitivity (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)).\nunfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.mulhs i i0 = Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32).","proofString":"unfold Int.mulhs; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.signed i * Int.signed i0 / Int.modulus =\nZ.shiftr (Int.signed i * Int.signed i0) 32.","proofString":"rewrite Zshiftr_div_two_p by lia.\nreflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.signed i * Int.signed i0 / Int.modulus =\nInt.signed i * Int.signed i0 / two_p 32.","proofString":"reflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32) =\nInt64.loword\n  (Int64.shr'\n     (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n     (Int.repr 32)).","proofString":"apply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < Int.zwordsize) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shr'\n        (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n        (Int.repr 32))) n.","proofString":"change Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shr'\n        (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n        (Int.repr 32))) n.","proofString":"assert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shr'\n        (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n        (Int.repr 32))) n.","proofString":"rewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt64.testbit\n  (Int64.shr'\n     (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n     (Int.repr 32)) n.","proofString":"rewrite Int64.bits_shr' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n  (if zlt (n + Int.unsigned (Int.repr 32)) Int64.zwordsize\n   then n + Int.unsigned (Int.repr 32)\n   else Int64.zwordsize - 1).","proofString":"change (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n  (if zlt (n + 32) Int64.zwordsize then n + 32 else Int64.zwordsize - 1).","proofString":"change Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n  (if zlt (n + 32) 64 then n + 32 else 64 - 1).","proofString":"rewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.signed i * Int.signed i0) 32)) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n  (n + 32).","proofString":"rewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.signed i * Int.signed i0) 32) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.signed i)) (Int64.repr (Int.signed i0)))\n  (n + 32).","proofString":"unfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.signed i * Int.signed i0) 32) n =\nInt64.testbit\n  (Int64.repr\n     (Int64.unsigned (Int64.repr (Int.signed i)) *\n      Int64.unsigned (Int64.repr (Int.signed i0)))) \n  (n + 32).","proofString":"rewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.signed i * Int.signed i0) 32) n =\nZ.testbit\n  (Int64.unsigned (Int64.repr (Int.signed i)) *\n   Int64.unsigned (Int64.repr (Int.signed i0))) (n + 32).","proofString":"transitivity (Z.testbit (Int.signed i * Int.signed i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.signed i * Int.signed i0) 32) n =\nZ.testbit (Int.signed i * Int.signed i0) (n + 32).","proofString":"rewrite Z.shiftr_spec by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Int.signed i * Int.signed i0) (n + 32) =\nZ.testbit (Int.signed i * Int.signed i0) (n + 32).","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Int.signed i * Int.signed i0) (n + 32) =\nZ.testbit\n  (Int64.unsigned (Int64.repr (Int.signed i)) *\n   Int64.unsigned (Int64.repr (Int.signed i0))) (n + 32).","proofString":"apply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int64.eqm (Int.signed i * Int.signed i0)\n  (Int64.unsigned (Int64.repr (Int.signed i)) *\n   Int64.unsigned (Int64.repr (Int.signed i0))).","proofString":"apply Int64.eqm_mult; apply Int64.eqm_unsigned_repr."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : 0 <= n + 32 < Int64.zwordsize.","proofString":"change Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop Olowlong\n       (Eop (Oshiftl Slsr (mk_amount64 (Int.repr 32)))\n          (Eop Omull\n             (Eop (Oextend Xuns32 (mk_amount64 Int.zero)) (a ::: Enil)\n              ::: Eop (Oextend Xuns32 (mk_amount64 Int.zero)) (b ::: Enil)\n                  ::: Enil) ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.mulhu x y) v.","proofString":"econstructor; split.\nEvalOp.\nunfold eval_shiftl, eval_extend.\nrewrite ! mk_amount64_eq by auto.\ndestruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : Val.lessdef (Val.mulhu x y)\n  (Val.loword\n     (Val.shrlu\n        (Val.mull (Val.shll (Val.longofintu x) (Vint (mk_amount64 Int.zero)))\n           (Val.shll (Val.longofintu y) (Vint (mk_amount64 Int.zero))))\n        (Vint (mk_amount64 (Int.repr 32))))).","proofString":"rewrite ! mk_amount64_eq by auto.\ndestruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : Val.lessdef (Val.mulhu x y)\n  (Val.loword\n     (Val.shrlu\n        (Val.mull (Val.shll (Val.longofintu x) (Vint Int.zero))\n           (Val.shll (Val.longofintu y) (Vint Int.zero)))\n        (Vint (Int.repr 32)))).","proofString":"destruct x; simpl; auto.\ndestruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (y : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b y) : Val.lessdef match y with\n            | Vint n2 => Vint (Int.mulhu i n2)\n            | _ => Vundef\n            end\n  (Val.loword\n     (Val.shrlu\n        (Val.mull\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.unsigned i)) Int.zero)\n            else Vundef) (Val.shll (Val.longofintu y) (Vint Int.zero)))\n        (Vint (Int.repr 32)))).","proofString":"destruct y; simpl; auto.\nchange (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhu i i0))\n  (Val.loword\n     (Val.shrlu\n        (Val.mull\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.unsigned i)) Int.zero)\n            else Vundef)\n           (if Int.ltu Int.zero Int64.iwordsize'\n            then Vlong (Int64.shl' (Int64.repr (Int.unsigned i0)) Int.zero)\n            else Vundef)) (Vint (Int.repr 32)))).","proofString":"change (Int.ltu Int.zero Int64.iwordsize') with true; simpl.\nrewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhu i i0))\n  (Val.loword\n     (if Int.ltu (Int.repr 32) Int64.iwordsize'\n      then\n       Vlong\n         (Int64.shru'\n            (Int64.mul (Int64.shl' (Int64.repr (Int.unsigned i)) Int.zero)\n               (Int64.shl' (Int64.repr (Int.unsigned i0)) Int.zero))\n            (Int.repr 32))\n      else Vundef)).","proofString":"rewrite ! Int64.shl'_zero.\nchange (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhu i i0))\n  (Val.loword\n     (if Int.ltu (Int.repr 32) Int64.iwordsize'\n      then\n       Vlong\n         (Int64.shru'\n            (Int64.mul (Int64.repr (Int.unsigned i))\n               (Int64.repr (Int.unsigned i0))) (Int.repr 32))\n      else Vundef)).","proofString":"change (Int.ltu (Int.repr 32) Int64.iwordsize') with true; simpl.\napply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Val.lessdef (Vint (Int.mulhu i i0))\n  (Vint\n     (Int64.loword\n        (Int64.shru'\n           (Int64.mul (Int64.repr (Int.unsigned i))\n              (Int64.repr (Int.unsigned i0))) (Int.repr 32)))).","proofString":"apply Val.lessdef_same.\nf_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Vint (Int.mulhu i i0) =\nVint\n  (Int64.loword\n     (Int64.shru'\n        (Int64.mul (Int64.repr (Int.unsigned i))\n           (Int64.repr (Int.unsigned i0))) (Int.repr 32))).","proofString":"f_equal.\ntransitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.mulhu i i0 =\nInt64.loword\n  (Int64.shru'\n     (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n     (Int.repr 32)).","proofString":"transitivity (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)).\nunfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity.\napply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.mulhu i i0 = Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32).","proofString":"unfold Int.mulhu; f_equal.\nrewrite Zshiftr_div_two_p by lia.\nreflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.unsigned i * Int.unsigned i0 / Int.modulus =\nZ.shiftr (Int.unsigned i * Int.unsigned i0) 32.","proofString":"rewrite Zshiftr_div_two_p by lia.\nreflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.unsigned i * Int.unsigned i0 / Int.modulus =\nInt.unsigned i * Int.unsigned i0 / two_p 32.","proofString":"reflexivity."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) : Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32) =\nInt64.loword\n  (Int64.shru'\n     (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n     (Int.repr 32)).","proofString":"apply Int.same_bits_eq; intros n N.\nchange Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < Int.zwordsize) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shru'\n        (Int64.mul (Int64.repr (Int.unsigned i))\n           (Int64.repr (Int.unsigned i0))) (Int.repr 32))) n.","proofString":"change Int.zwordsize with 32 in *.\nassert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shru'\n        (Int64.mul (Int64.repr (Int.unsigned i))\n           (Int64.repr (Int.unsigned i0))) (Int.repr 32))) n.","proofString":"assert (N1: 0 <= n < 64) by lia.\nrewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\nInt.testbit\n  (Int64.loword\n     (Int64.shru'\n        (Int64.mul (Int64.repr (Int.unsigned i))\n           (Int64.repr (Int.unsigned i0))) (Int.repr 32))) n.","proofString":"rewrite Int64.bits_loword by auto.\nrewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\nInt64.testbit\n  (Int64.shru'\n     (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n     (Int.repr 32)) n.","proofString":"rewrite Int64.bits_shru' by auto.\nchange (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\n(if zlt (n + Int.unsigned (Int.repr 32)) Int64.zwordsize\n then\n  Int64.testbit\n    (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n    (n + Int.unsigned (Int.repr 32))\n else false).","proofString":"change (Int.unsigned (Int.repr 32)) with 32.\nchange Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\n(if zlt (n + 32) Int64.zwordsize\n then\n  Int64.testbit\n    (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n    (n + 32)\n else false).","proofString":"change Int64.zwordsize with 64.\nrewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\n(if zlt (n + 32) 64\n then\n  Int64.testbit\n    (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n    (n + 32)\n else false).","proofString":"rewrite zlt_true by lia.\nrewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int.testbit (Int.repr (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32)) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n  (n + 32).","proofString":"rewrite Int.testbit_repr by auto.\nunfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32) n =\nInt64.testbit\n  (Int64.mul (Int64.repr (Int.unsigned i)) (Int64.repr (Int.unsigned i0)))\n  (n + 32).","proofString":"unfold Int64.mul.\nrewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32) n =\nInt64.testbit\n  (Int64.repr\n     (Int64.unsigned (Int64.repr (Int.unsigned i)) *\n      Int64.unsigned (Int64.repr (Int.unsigned i0)))) \n  (n + 32).","proofString":"rewrite Int64.testbit_repr by (change Int64.zwordsize with 64; lia).\ntransitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32) n =\nZ.testbit\n  (Int64.unsigned (Int64.repr (Int.unsigned i)) *\n   Int64.unsigned (Int64.repr (Int.unsigned i0))) \n  (n + 32).","proofString":"transitivity (Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32)).\nrewrite Z.shiftr_spec by lia.\nauto.\napply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Z.shiftr (Int.unsigned i * Int.unsigned i0) 32) n =\nZ.testbit (Int.unsigned i * Int.unsigned i0) (n + 32).","proofString":"rewrite Z.shiftr_spec by lia.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32) =\nZ.testbit (Int.unsigned i * Int.unsigned i0) (n + 32).","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Z.testbit (Int.unsigned i * Int.unsigned i0) (n + 32) =\nZ.testbit\n  (Int64.unsigned (Int64.repr (Int.unsigned i)) *\n   Int64.unsigned (Int64.repr (Int.unsigned i0))) \n  (n + 32).","proofString":"apply Int64.same_bits_eqm.\napply Int64.eqm_mult; apply Int64.eqm_unsigned_repr.\nchange Int64.zwordsize with 64; lia."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : Int64.eqm (Int.unsigned i * Int.unsigned i0)\n  (Int64.unsigned (Int64.repr (Int.unsigned i)) *\n   Int64.unsigned (Int64.repr (Int.unsigned i0))).","proofString":"apply Int64.eqm_mult; apply Int64.eqm_unsigned_repr."},{"statement":"(le : letenv) (a : expr) (i : int) (b : expr) (i0 : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : eval_expr ge sp e m le b (Vint i0)) (n : Z) (N : 0 <= n < 32) (N1 : 0 <= n < 64) : 0 <= n + 32 < Int64.zwordsize.","proofString":"change Int64.zwordsize with 64; lia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.zero_ext sz n)) Enil) v /\\\n  Val.lessdef (Val.zero_ext sz (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ozextshr a0 sz) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext sz (Val.shru v1 (Vint a0))) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned a0) sz\n     then Eop (Oshlzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)\n     else Eop (Ozext sz) (Eop (Oshift Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"destruct (zlt (Int.unsigned a0) sz).\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_zero_ext by lia.\nf_equal.\nlia.\nTrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (l : Int.unsigned a0 < sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshlzext (sz - Int.unsigned a0) a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Val.lessdef\n  (Val.zero_ext sz\n     (if Int.ltu a0 Int.iwordsize then Vint (Int.shl i a0) else Vundef))\n  (if Int.ltu a0 Int.iwordsize\n   then Vint (Int.shl (Int.zero_ext (sz - Int.unsigned a0) i) a0)\n   else Vundef).","proofString":"rewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Val.lessdef (Vint (Int.zero_ext sz (Int.shl i a0)))\n  (Vint (Int.shl (Int.zero_ext (sz - Int.unsigned a0) i) a0)).","proofString":"apply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Vint (Int.zero_ext sz (Int.shl i a0)) =\nVint (Int.shl (Int.zero_ext (sz - Int.unsigned a0) i) a0).","proofString":"f_equal.\nrewrite Int.shl_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Int.zero_ext sz (Int.shl i a0) =\nInt.shl (Int.zero_ext (sz - Int.unsigned a0) i) a0.","proofString":"rewrite Int.shl_zero_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Int.zero_ext sz (Int.shl i a0) =\nInt.zero_ext (sz - Int.unsigned a0 + Int.unsigned a0) (Int.shl i a0).","proofString":"f_equal.\nlia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : sz = sz - Int.unsigned a0 + Int.unsigned a0.","proofString":"lia."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (g : Int.unsigned a0 >= sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ozext sz) (Eop (Oshift Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 <= sz) (le : letenv) (a : expr) (x : val) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ozext sz) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.zero_ext sz x) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.sign_ext sz n)) Enil) v /\\\n  Val.lessdef (Val.sign_ext sz (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osextshr a0 sz) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.sign_ext sz (Val.shr v1 (Vint a0))) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zlt (Int.unsigned a0) sz\n     then Eop (Oshlsext (sz - Int.unsigned a0) a0) (t1 ::: Enil)\n     else Eop (Osext sz) (Eop (Oshift Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.sign_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"destruct (zlt (Int.unsigned a0) sz).\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_sign_ext by lia.\nf_equal.\nlia.\nTrivialExists."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (l : Int.unsigned a0 < sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oshlsext (sz - Int.unsigned a0) a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.sign_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto.\nrewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_sign_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Val.lessdef\n  (Val.sign_ext sz\n     (if Int.ltu a0 Int.iwordsize then Vint (Int.shl i a0) else Vundef))\n  (if Int.ltu a0 Int.iwordsize\n   then Vint (Int.shl (Int.sign_ext (sz - Int.unsigned a0) i) a0)\n   else Vundef).","proofString":"rewrite a32_range; simpl.\napply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_sign_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Val.lessdef (Vint (Int.sign_ext sz (Int.shl i a0)))\n  (Vint (Int.shl (Int.sign_ext (sz - Int.unsigned a0) i) a0)).","proofString":"apply Val.lessdef_same.\nf_equal.\nrewrite Int.shl_sign_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Vint (Int.sign_ext sz (Int.shl i a0)) =\nVint (Int.shl (Int.sign_ext (sz - Int.unsigned a0) i) a0).","proofString":"f_equal.\nrewrite Int.shl_sign_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Int.sign_ext sz (Int.shl i a0) =\nInt.shl (Int.sign_ext (sz - Int.unsigned a0) i) a0.","proofString":"rewrite Int.shl_sign_ext by lia.\nf_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : Int.sign_ext sz (Int.shl i a0) =\nInt.sign_ext (sz - Int.unsigned a0 + Int.unsigned a0) (Int.shl i a0).","proofString":"f_equal.\nlia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (i : int) (H3 : eval_expr ge sp e m le t1 (Vint i)) (l : Int.unsigned a0 < sz) : sz = sz - Int.unsigned a0 + Int.unsigned a0.","proofString":"lia."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (a0 : amount32) (t1 : expr) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) (g : Int.unsigned a0 >= sz) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Osext sz) (Eop (Oshift Slsl a0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (Val.sign_ext sz (Val.shl v1 (Vint a0))) v.","proofString":"TrivialExists."},{"statement":"(sz : Z) (H : 0 < sz) (le : letenv) (a : expr) (x : val) (e0 : expr) (H0 : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osext sz) (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.sign_ext sz x) v.","proofString":"TrivialExists."},{"statement":"forall v : val, Val.lessdef (Val.notint (Val.notint v)) v.","proofString":"destruct v; auto.\nsimpl; rewrite Int.not_involutive; auto."},{"statement":"(i : int) : Val.lessdef (Val.notint (Val.notint (Vint i))) (Vint i).","proofString":"simpl; rewrite Int.not_involutive; auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) : unary_constructor_sound notint Val.notint.","proofString":"unfold notint; red; intros until x; case (notint_match a); intros; InvEval; subst.\nTrivialExists.\nTrivialExists.\nexists v1; auto.\nexists (eval_shift s v1 a0); split; auto.\nEvalOp.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int.not_and_or_not, Int.not_involutive, Int.or_commut.\nauto.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int.not_or_and_not, Int.not_involutive, Int.and_commut.\nauto.\neconstructor; split.\nEvalOp.\nrewrite ! Val.not_xor, Val.xor_assoc; auto.\neconstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int.not; rewrite ! Int.xor_assoc, Int.xor_idem, Int.xor_zero.\nauto.\nTrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (n : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.not n)) Enil) v /\\\n  Val.lessdef (Val.notint (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount32) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Onotshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le t1 v /\\ Val.lessdef (Val.notint (Val.notint v1)) v.","proofString":"exists v1; auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount32) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift s a0) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (Val.notint (eval_shift s v1 a0))) v.","proofString":"exists (eval_shift s v1 a0); split; auto.\nEvalOp."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (s : shift) (a0 : amount32) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : eval_expr ge sp e m le (Eop (Oshift s a0) (t1 ::: Enil)) (eval_shift s v1 a0).","proofString":"EvalOp."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oorn (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (Val.and v1 (Val.notint v0))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int.not_and_or_not, Int.not_involutive, Int.or_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.not (Int.and i (Int.not i0))))\n  (Vint (Int.or i0 (Int.not i))).","proofString":"rewrite Int.not_and_or_not, Int.not_involutive, Int.or_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.or i0 (Int.not i))) (Vint (Int.or i0 (Int.not i))).","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (Val.or v1 (Val.notint v0))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nrewrite Int.not_or_and_not, Int.not_involutive, Int.and_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.not (Int.or i (Int.not i0))))\n  (Vint (Int.and i0 (Int.not i))).","proofString":"rewrite Int.not_or_and_not, Int.not_involutive, Int.and_commut.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.and i0 (Int.not i))) (Vint (Int.and i0 (Int.not i))).","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqv (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (Val.xor v1 v0)) v.","proofString":"econstructor; split.\nEvalOp.\nrewrite ! Val.not_xor, Val.xor_assoc; auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (v1 v0 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le (Eop Oxor (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.notint (Val.xor v1 (Val.notint v0))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v1; simpl; auto; destruct v0; simpl; auto.\nunfold Int.not; rewrite ! Int.xor_assoc, Int.xor_idem, Int.xor_zero.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.not (Int.xor i (Int.not i0)))) (Vint (Int.xor i i0)).","proofString":"unfold Int.not; rewrite ! Int.xor_assoc, Int.xor_idem, Int.xor_zero.\nauto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a t1 t2 : expr) (i i0 : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) (H3 : eval_expr ge sp e m le t2 (Vint i0)) : Val.lessdef (Vint (Int.xor i i0)) (Vint (Int.xor i i0)).","proofString":"auto."},{"statement":"(INV : forall v : val, Val.lessdef (Val.notint (Val.notint v)) v) (le : letenv) (a : expr) (x : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) : exists v : val,\n  eval_expr ge sp e m le (Eop Onot (e0 ::: Enil)) v /\\\n  Val.lessdef (Val.notint x) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (andimm_base n a) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"unfold andimm_base.\npredSpec Int.eq Int.eq_spec n Int.zero.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.and_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (Z_is_power2m1 (Int.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then Eop (Ointconst Int.zero) Enil\n     else\n      if Int.eq n Int.mone\n      then a\n      else\n       match Z_is_power2m1 (Int.unsigned n) with\n       | Some s => zero_ext s a\n       | None => Eop (Oandimm n) (a ::: Enil)\n       end) v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.and_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (Z_is_power2m1 (Int.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.and_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.and x (Vint n)) (Vint Int.zero).","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.and_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : n = Int.zero) : Val.lessdef (Vint (Int.and i n)) (Vint Int.zero).","proofString":"subst n.\nrewrite Int.and_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.and i Int.zero)) (Vint Int.zero).","proofString":"rewrite Int.and_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.zero) (Vint Int.zero).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone\n     then a\n     else\n      match Z_is_power2m1 (Int.unsigned n) with\n      | Some s => zero_ext s a\n      | None => Eop (Oandimm n) (a ::: Enil)\n      end) v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone.\nexists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int.and_mone; auto.\ndestruct (Z_is_power2m1 (Int.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n = Int.mone) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"exists x; split; auto.\nsubst.\ndestruct x; simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n = Int.mone) : Val.lessdef (Val.and x (Vint n)) x.","proofString":"subst.\ndestruct x; simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.mone <> Int.zero) : Val.lessdef (Val.and x (Vint Int.mone)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.and_mone; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : Int.mone <> Int.zero) : Val.lessdef (Vint (Int.and i Int.mone)) (Vint i).","proofString":"rewrite Int.and_mone; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) : exists v : val,\n  eval_expr ge sp e m le\n    match Z_is_power2m1 (Int.unsigned n) with\n    | Some s => zero_ext s a\n    | None => Eop (Oandimm n) (a ::: Enil)\n    end v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"destruct (Z_is_power2m1 (Int.unsigned n)) as [s|] eqn:P.\nassert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (s : Z) (P : Z_is_power2m1 (Int.unsigned n) = Some s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext s a) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"assert (0 <= s) by (eapply Z_is_power2m1_nonneg; eauto).\nrewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (s : Z) (P : Z_is_power2m1 (Int.unsigned n) = Some s) (H2 : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext s a) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"rewrite <- (Int.repr_unsigned n), (Z_is_power2m1_sound _ _ P), <- Val.zero_ext_and by auto.\napply eval_zero_ext; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (s : Z) (P : Z_is_power2m1 (Int.unsigned n) = Some s) (H2 : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le (zero_ext s a) v /\\ Val.lessdef (Val.zero_ext s x) v.","proofString":"apply eval_zero_ext; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) (P : Z_is_power2m1 (Int.unsigned n) = None) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (andimm n a) v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"unfold andimm.\ncase (andimm_match a); intros; InvEval; subst.\nrewrite Int.and_commut; TrivialExists.\nrewrite Val.and_assoc, Int.and_commut.\napply eval_andimm_base; auto.\ndestruct (zle 0 s).\nrewrite Val.zero_ext_and, Val.and_assoc, Int.and_commut by auto.\napply eval_andimm_base; auto.\napply eval_andimm_base.\nEvalOp.\napply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match andimm_match a with\n    | andimm_case1 n2 => Eop (Ointconst (Int.and n n2)) Enil\n    | andimm_case2 n2 t2 => andimm_base (Int.and n n2) t2\n    | andimm_case3 s t2 =>\n        if zle 0 s\n        then andimm_base (Int.and n (Int.repr (two_p s - 1))) t2\n        else andimm_base n a\n    | andimm_default e2 => andimm_base n e2\n    end v /\\ Val.lessdef (Val.and x (Vint n)) v.","proofString":"case (andimm_match a); intros; InvEval; subst.\nrewrite Int.and_commut; TrivialExists.\nrewrite Val.and_assoc, Int.and_commut.\napply eval_andimm_base; auto.\ndestruct (zle 0 s).\nrewrite Val.zero_ext_and, Val.and_assoc, Int.and_commut by auto.\napply eval_andimm_base; auto.\napply eval_andimm_base.\nEvalOp.\napply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.and n n2)) Enil) v /\\\n  Val.lessdef (Val.and (Vint n2) (Vint n)) v.","proofString":"rewrite Int.and_commut; TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (andimm_base (Int.and n n2) t2) v /\\\n  Val.lessdef (Val.and (Val.and v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.and_assoc, Int.and_commut.\napply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (andimm_base (Int.and n2 n) t2) v /\\\n  Val.lessdef (Val.and v1 (Val.and (Vint n2) (Vint n))) v.","proofString":"apply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if zle 0 s\n     then andimm_base (Int.and n (Int.repr (two_p s - 1))) t2\n     else andimm_base n (Eop (Ozext s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.and (Val.zero_ext s v1) (Vint n)) v.","proofString":"destruct (zle 0 s).\nrewrite Val.zero_ext_and, Val.and_assoc, Int.and_commut by auto.\napply eval_andimm_base; auto.\napply eval_andimm_base.\nEvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le\n    (andimm_base (Int.and n (Int.repr (two_p s - 1))) t2) v /\\\n  Val.lessdef (Val.and (Val.zero_ext s v1) (Vint n)) v.","proofString":"rewrite Val.zero_ext_and, Val.and_assoc, Int.and_commut by auto.\napply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (l : 0 <= s) : exists v : val,\n  eval_expr ge sp e m le\n    (andimm_base (Int.and (Int.repr (two_p s - 1)) n) t2) v /\\\n  Val.lessdef (Val.and v1 (Val.and (Vint (Int.repr (two_p s - 1))) (Vint n)))\n    v.","proofString":"apply eval_andimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s) : exists v : val,\n  eval_expr ge sp e m le (andimm_base n (Eop (Ozext s) (t2 ::: Enil))) v /\\\n  Val.lessdef (Val.and (Val.zero_ext s v1) (Vint n)) v.","proofString":"apply eval_andimm_base.\nEvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (s : Z) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) (g : 0 > s) : eval_expr ge sp e m le (Eop (Ozext s) (t2 ::: Enil)) (Val.zero_ext s v1).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (andimm_base n e2) v /\\\n  Val.lessdef (Val.and x (Vint n)) v.","proofString":"apply eval_andimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (andimm n1 t2) v /\\\n  Val.lessdef (Val.and (Vint n1) y) v.","proofString":"rewrite Val.and_commut; apply eval_andimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (andimm n2 t1) v /\\\n  Val.lessdef (Val.and x (Vint n2)) v.","proofString":"apply eval_andimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and (Val.notint v1) y) v.","proofString":"rewrite Val.and_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Obic (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x (Val.notint v1)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Obicshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and (Val.notint (eval_shift s v1 a0)) y) v.","proofString":"rewrite Val.and_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Obicshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x (Val.notint (eval_shift s v1 a0))) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.and (eval_shift s v1 a0) y) v.","proofString":"rewrite Val.and_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oandshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oand (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.and x y) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (orimm n a) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"unfold orimm.\npredSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval; subst.\nrewrite Int.or_commut; TrivialExists.\nrewrite Val.or_assoc, Int.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.eq n Int.mone\n      then Eop (Ointconst Int.mone) Enil\n      else\n       match orimm_match a with\n       | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n       | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n       | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n       end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval; subst.\nrewrite Int.or_commut; TrivialExists.\nrewrite Val.or_assoc, Int.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"intros.\nsubst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n = Int.zero) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"subst.\nexists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.or x (Vint Int.zero)) v.","proofString":"exists x; split; auto.\ndestruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H0 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint Int.zero)) x.","proofString":"destruct x; simpl; auto.\nrewrite Int.or_zero; auto."},{"statement":"(le : letenv) (a : expr) (i : int) (H0 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.zero)) (Vint i).","proofString":"rewrite Int.or_zero; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone\n     then Eop (Ointconst Int.mone) Enil\n     else\n      match orimm_match a with\n      | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n      | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n      | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n      end) v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone.\nintros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto.\ndestruct (orimm_match a); intros; InvEval; subst.\nrewrite Int.or_commut; TrivialExists.\nrewrite Val.or_assoc, Int.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"intros.\nexists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"exists (Vint Int.mone); split.\nEvalOp.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : eval_expr ge sp e m le (Eop (Ointconst Int.mone) Enil) (Vint Int.mone).","proofString":"EvalOp."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a x) : Val.lessdef (Val.or x (Vint n)) (Vint Int.mone).","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : n <> Int.zero) (H0 : n = Int.mone) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i n)) (Vint Int.mone).","proofString":"subst n.\nrewrite Int.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.or i Int.mone)) (Vint Int.mone).","proofString":"rewrite Int.or_mone.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : Int.mone <> Int.zero) (H1 : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint Int.mone) (Vint Int.mone).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match orimm_match a with\n    | orimm_case1 n2 => Eop (Ointconst (Int.or n n2)) Enil\n    | orimm_case2 n2 t2 => Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)\n    | orimm_default e2 => Eop (Oorimm n) (e2 ::: Enil)\n    end v /\\ Val.lessdef (Val.or x (Vint n)) v.","proofString":"destruct (orimm_match a); intros; InvEval; subst.\nrewrite Int.or_commut; TrivialExists.\nrewrite Val.or_assoc, Int.or_commut; TrivialExists.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.or n n2)) Enil) v /\\\n  Val.lessdef (Val.or (Vint n2) (Vint n)) v.","proofString":"rewrite Int.or_commut; TrivialExists."},{"statement":"(n : int) (le : letenv) (H : n <> Int.zero) (H0 : n <> Int.mone) (n2 : int) (t2 : expr) (v1 : val) (H4 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm (Int.or n n2)) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.or v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.or_assoc, Int.or_commut; TrivialExists."},{"statement":"(n : int) (le : letenv) (x : val) (H : n <> Int.zero) (H0 : n <> Int.mone) (e2 : expr) (H1 : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorimm n) (e2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(a1 a2 : expr) (le : letenv) (v1 v2 : val) (H : same_expr_pure a1 a2 = true) (H0 : eval_expr ge sp e m le a1 v1) (H1 : eval_expr ge sp e m le a2 v2) : a1 = a2 /\\ v1 = v2.","proofString":"destruct a1; try discriminate.\ndestruct a2; try discriminate.\nsimpl in H; destruct (ident_eq i i0); inv H.\nsplit.\nauto.\ninv H0; inv H1; congruence."},{"statement":"(i : ident) (a2 : expr) (le : letenv) (v1 v2 : val) (H : same_expr_pure (Evar i) a2 = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le a2 v2) : Evar i = a2 /\\ v1 = v2.","proofString":"destruct a2; try discriminate.\nsimpl in H; destruct (ident_eq i i0); inv H.\nsplit.\nauto.\ninv H0; inv H1; congruence."},{"statement":"(i i0 : ident) (le : letenv) (v1 v2 : val) (H : same_expr_pure (Evar i) (Evar i0) = true) (H0 : eval_expr ge sp e m le (Evar i) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : Evar i = Evar i0 /\\ v1 = v2.","proofString":"simpl in H; destruct (ident_eq i i0); inv H.\nsplit.\nauto.\ninv H0; inv H1; congruence."},{"statement":"(i0 : ident) (le : letenv) (v1 v2 : val) (H0 : eval_expr ge sp e m le (Evar i0) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : Evar i0 = Evar i0 /\\ v1 = v2.","proofString":"split.\nauto.\ninv H0; inv H1; congruence."},{"statement":"(i0 : ident) (le : letenv) (v1 v2 : val) (H0 : eval_expr ge sp e m le (Evar i0) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : Evar i0 = Evar i0.","proofString":"auto."},{"statement":"(i0 : ident) (le : letenv) (v1 v2 : val) (H0 : eval_expr ge sp e m le (Evar i0) v1) (H1 : eval_expr ge sp e m le (Evar i0) v2) : v1 = v2.","proofString":"inv H0; inv H1; congruence."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orimm n1 t2) v /\\\n  Val.lessdef (Val.or (Vint n1) y) v.","proofString":"rewrite Val.or_commut.\napply eval_orimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (orimm n1 t2) v /\\\n  Val.lessdef (Val.or y (Vint n1)) v.","proofString":"apply eval_orimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (orimm n2 t1) v /\\\n  Val.lessdef (Val.or x (Vint n2)) v.","proofString":"apply eval_orimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oorn (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.notint v1) y) v.","proofString":"rewrite Val.or_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oorn (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Val.notint v1)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oornshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.notint (eval_shift s v1 a0)) y) v.","proofString":"rewrite Val.or_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oornshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (Val.notint (eval_shift s v1 a0))) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a1 a2) Int.iwordsize && same_expr_pure t1 t2\n     then Eop (Oshift Sror a2) (t2 ::: Enil)\n     else\n      Eop (Oorshift Slsr a2)\n        (Eop (Oshift Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"destruct (Int.eq (Int.add a1 a2) Int.iwordsize && same_expr_pure t1 t2) eqn:?.\nInvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int.iwordsize && same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"InvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a1 a2) Int.iwordsize = true) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"apply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"exploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) : t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"subst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a2) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v0 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef\n  (Val.or (if Int.ltu a1 Int.iwordsize then Vint (Int.shl i a1) else Vundef)\n     (if Int.ltu a2 Int.iwordsize then Vint (Int.shru i a2) else Vundef))\n  (Vint (Int.ror i a2)).","proofString":"rewrite ! a32_range.\nsimpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Val.or (Vint (Int.shl i a1)) (Vint (Int.shru i a2)))\n  (Vint (Int.ror i a2)).","proofString":"simpl.\nrewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a1 a2 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Vint (Int.or (Int.shl i a1) (Int.shru i a2)))\n  (Vint (Int.ror i a2)).","proofString":"rewrite <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a1 a2) Int.iwordsize && same_expr_pure t1 t2 = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorshift Slsr a2)\n       (Eop (Oshift Slsl a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shl v1 (Vint a1)) (Val.shru v0 (Vint a2))) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq (Int.add a2 a1) Int.iwordsize && same_expr_pure t1 t2\n     then Eop (Oshift Sror a1) (t1 ::: Enil)\n     else\n      Eop (Oorshift Slsl a2)\n        (Eop (Oshift Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"destruct (Int.eq (Int.add a2 a1) Int.iwordsize && same_expr_pure t1 t2) eqn:?.\nInvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range.\nTrivialExists."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int.iwordsize && same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"InvBooleans.\napply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.eq (Int.add a2 a1) Int.iwordsize = true) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"apply Int.same_if_eq in H.\nexploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"exploit eval_same_expr; eauto.\nintros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) : t1 = t2 /\\ v1 = v0 ->\nexists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"intros [EQ1 EQ2].\nsubst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t1 t2 = true) (EQ1 : t1 = t2) (EQ2 : v1 = v0) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"subst.\neconstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (v0 : val) (H2 H3 : eval_expr ge sp e m le t2 v0) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshift Sror a1) (t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v0 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"econstructor; split.\nEvalOp.\ndestruct v0; simpl; auto.\nrewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef\n  (Val.or (if Int.ltu a1 Int.iwordsize then Vint (Int.shru i a1) else Vundef)\n     (if Int.ltu a2 Int.iwordsize then Vint (Int.shl i a2) else Vundef))\n  (Vint (Int.ror i a1)).","proofString":"rewrite ! a32_range.\nsimpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Val.or (Vint (Int.shru i a1)) (Vint (Int.shl i a2)))\n  (Vint (Int.ror i a1)).","proofString":"simpl.\nrewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 a2 : amount32) (t2 : expr) (i : int) (H2 H3 : eval_expr ge sp e m le t2 (Vint i)) (H : Int.add a2 a1 = Int.iwordsize) (H0 : same_expr_pure t2 t2 = true) : Val.lessdef (Vint (Int.or (Int.shru i a1) (Int.shl i a2)))\n  (Vint (Int.ror i a1)).","proofString":"rewrite Int.or_commut, <- Int.or_ror; auto using a32_range."},{"statement":"(le : letenv) (a b : expr) (a1 : amount32) (t1 : expr) (a2 : amount32) (t2 : expr) (v0 v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H3 : eval_expr ge sp e m le t2 v0) (Heqb0 : Int.eq (Int.add a2 a1) Int.iwordsize && same_expr_pure t1 t2 = false) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Oorshift Slsl a2)\n       (Eop (Oshift Slsr a1) (t1 ::: Enil) ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or (Val.shru v1 (Vint a1)) (Val.shl v0 (Vint a2))) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.or (eval_shift s v1 a0) y) v.","proofString":"rewrite Val.or_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oorshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oor (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.or x y) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (xorimm_base n a) v /\\\n  Val.lessdef (Val.xor x (Vint n)) v.","proofString":"unfold xorimm_base.\npredSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.xor_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nsubst n.\nrewrite <- Val.not_xor.\napply eval_notint; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero\n     then a\n     else\n      if Int.eq n Int.mone then notint a else Eop (Oxorimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nintros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.xor_zero.\nauto.\npredSpec Int.eq Int.eq_spec n Int.mone.\nsubst n.\nrewrite <- Val.not_xor.\napply eval_notint; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xor x (Vint n)) v.","proofString":"intros.\nexists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.xor_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.xor x (Vint n)) v.","proofString":"exists x; split.\nauto.\ndestruct x; simpl; auto.\nsubst n.\nrewrite Int.xor_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : eval_expr ge sp e m le a x.","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n = Int.zero) : Val.lessdef (Val.xor x (Vint n)) x.","proofString":"destruct x; simpl; auto.\nsubst n.\nrewrite Int.xor_zero.\nauto."},{"statement":"(n : int) (le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) (H0 : n = Int.zero) : Val.lessdef (Vint (Int.xor i n)) (Vint i).","proofString":"subst n.\nrewrite Int.xor_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.xor i Int.zero)) (Vint i).","proofString":"rewrite Int.xor_zero.\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","proofString":"auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.mone then notint a else Eop (Oxorimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (Vint n)) v.","proofString":"predSpec Int.eq Int.eq_spec n Int.mone.\nsubst n.\nrewrite <- Val.not_xor.\napply eval_notint; auto.\nTrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n = Int.mone) : exists v : val,\n  eval_expr ge sp e m le (notint a) v /\\ Val.lessdef (Val.xor x (Vint n)) v.","proofString":"subst n.\nrewrite <- Val.not_xor.\napply eval_notint; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.mone <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (notint a) v /\\\n  Val.lessdef (Val.xor x (Vint Int.mone)) v.","proofString":"rewrite <- Val.not_xor.\napply eval_notint; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : Int.mone <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (notint a) v /\\ Val.lessdef (Val.notint x) v.","proofString":"apply eval_notint; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) (H : eval_expr ge sp e m le a x) (H0 : n <> Int.zero) (H1 : n <> Int.mone) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorimm n) (a ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (Vint n)) v.","proofString":"TrivialExists."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (xorimm n a) v /\\ Val.lessdef (Val.xor x (Vint n)) v.","proofString":"unfold xorimm.\ndestruct (xorimm_match a); intros; InvEval; subst.\nrewrite Int.xor_commut; TrivialExists.\nrewrite Val.xor_assoc; simpl.\nrewrite (Int.xor_commut n2).\napply eval_xorimm_base; auto.\napply eval_xorimm_base; auto."},{"statement":"(n : int) (le : letenv) (a : expr) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le\n    match xorimm_match a with\n    | xorimm_case1 n2 => Eop (Ointconst (Int.xor n n2)) Enil\n    | xorimm_case2 n2 t2 => xorimm_base (Int.xor n n2) t2\n    | xorimm_default e2 => xorimm_base n e2\n    end v /\\ Val.lessdef (Val.xor x (Vint n)) v.","proofString":"destruct (xorimm_match a); intros; InvEval; subst.\nrewrite Int.xor_commut; TrivialExists.\nrewrite Val.xor_assoc; simpl.\nrewrite (Int.xor_commut n2).\napply eval_xorimm_base; auto.\napply eval_xorimm_base; auto."},{"statement":"(n : int) (le : letenv) (n2 : int) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst (Int.xor n n2)) Enil) v /\\\n  Val.lessdef (Val.xor (Vint n2) (Vint n)) v.","proofString":"rewrite Int.xor_commut; TrivialExists."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorimm_base (Int.xor n n2) t2) v /\\\n  Val.lessdef (Val.xor (Val.xor v1 (Vint n2)) (Vint n)) v.","proofString":"rewrite Val.xor_assoc; simpl.\nrewrite (Int.xor_commut n2).\napply eval_xorimm_base; auto."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorimm_base (Int.xor n n2) t2) v /\\\n  Val.lessdef (Val.xor v1 (Vint (Int.xor n2 n))) v.","proofString":"rewrite (Int.xor_commut n2).\napply eval_xorimm_base; auto."},{"statement":"(n : int) (le : letenv) (n2 : int) (t2 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (xorimm_base (Int.xor n n2) t2) v /\\\n  Val.lessdef (Val.xor v1 (Vint (Int.xor n n2))) v.","proofString":"apply eval_xorimm_base; auto."},{"statement":"(n : int) (le : letenv) (x : val) (e2 : expr) (H : eval_expr ge sp e m le e2 x) : exists v : val,\n  eval_expr ge sp e m le (xorimm_base n e2) v /\\\n  Val.lessdef (Val.xor x (Vint n)) v.","proofString":"apply eval_xorimm_base; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (xorimm n1 t2) v /\\\n  Val.lessdef (Val.xor (Vint n1) y) v.","proofString":"rewrite Val.xor_commut; apply eval_xorimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (xorimm n2 t1) v /\\\n  Val.lessdef (Val.xor x (Vint n2)) v.","proofString":"apply eval_xorimm; auto."},{"statement":"(le : letenv) (a b : expr) (y : val) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqv (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xor (Val.notint v1) y) v.","proofString":"rewrite Val.xor_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop Oeqv (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (Val.notint v1)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xor (Val.notint (eval_shift s v1 a0)) y) v.","proofString":"rewrite Val.xor_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oeqvshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (Val.notint (eval_shift s v1 a0))) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorshift s a0) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.xor (eval_shift s v1 a0) y) v.","proofString":"rewrite Val.xor_commut; TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oxorshift s a0) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.xor x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oxor (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.xor x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odiv (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"exploit Val.mods_divs; eauto.\nintros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) : (exists v : val, Val.divs x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odiv (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"intros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a b : expr) (x y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.mods x y = Some z) (q : val) (A : Val.divs x y = Some q) (B : z = Val.sub x (Val.mul q y)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odiv (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"subst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul q y))) (A : Val.divs x y = Some q) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odiv (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.sub x (Val.mul q y)) v.","proofString":"TrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul q y))) (A : Val.divs x y = Some q) : eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omulsub\n           (Eletvar 1\n            ::: Eop Odiv (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.sub x (Val.mul q y)).","proofString":"repeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a b : expr) (x y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.mods x y = Some (Val.sub x (Val.mul q y))) (A : Val.divs x y = Some q) : eval_operation ge sp Odiv (x :: y :: nil) m = Some q.","proofString":"exact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odivu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"exploit Val.modu_divu; eauto.\nintros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) : (exists v : val, Val.divu x y = Some v /\\ z = Val.sub x (Val.mul v y)) ->\nexists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odivu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"intros (q & A & B).\nsubst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y z : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (H1 : Val.modu x y = Some z) (q : val) (A : Val.divu x y = Some q) (B : z = Val.sub x (Val.mul q y)) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odivu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\ \n  Val.lessdef z v.","proofString":"subst z.\nTrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul q y))) (A : Val.divu x y = Some q) : exists v : val,\n  eval_expr ge sp e m le\n    (Elet a\n       (Elet (lift b)\n          (Eop Omulsub\n             (Eletvar 1\n              ::: Eop Odivu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                  ::: Eletvar 0 ::: Enil)))) v /\\\n  Val.lessdef (Val.sub x (Val.mul q y)) v.","proofString":"TrivialExists.\nrepeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul q y))) (A : Val.divu x y = Some q) : eval_expr ge sp e m le\n  (Elet a\n     (Elet (lift b)\n        (Eop Omulsub\n           (Eletvar 1\n            ::: Eop Odivu (Eletvar 1 ::: Eletvar 0 ::: Enil)\n                ::: Eletvar 0 ::: Enil)))) (Val.sub x (Val.mul q y)).","proofString":"repeat (econstructor; eauto with evalexpr).\nexact A."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) (q : val) (H1 : Val.modu x y = Some (Val.sub x (Val.mul q y))) (A : Val.divu x y = Some q) : eval_operation ge sp Odivu (x :: y :: nil) m = Some q.","proofString":"exact A."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n Int.zero then a else Eop (Oshrximm n) (a ::: Enil)) v /\\\n  Val.lessdef z v.","proofString":"predSpec Int.eq Int.eq_spec n Int.zero.\nsubst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 31)) with true in H0; inv H0.\nrewrite Int.shrx_zero by (compute; auto).\nauto.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n = Int.zero) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"subst n.\nexists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 31)) with true in H0; inv H0.\nrewrite Int.shrx_zero by (compute; auto).\nauto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : exists v : val, eval_expr ge sp e m le a v /\\ Val.lessdef z v.","proofString":"exists x; split; auto.\ndestruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 31)) with true in H0; inv H0.\nrewrite Int.shrx_zero by (compute; auto).\nauto."},{"statement":"(le : letenv) (a : expr) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint Int.zero) = Some z) : Val.lessdef z x.","proofString":"destruct x; simpl in H0; try discriminate.\nchange (Int.ltu Int.zero (Int.repr 31)) with true in H0; inv H0.\nrewrite Int.shrx_zero by (compute; auto).\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (z : val) (H : eval_expr ge sp e m le a (Vint i)) (H0 : (if Int.ltu Int.zero (Int.repr 31)\n then Some (Vint (Int.shrx i Int.zero))\n else None) = Some z) : Val.lessdef z (Vint i).","proofString":"change (Int.ltu Int.zero (Int.repr 31)) with true in H0; inv H0.\nrewrite Int.shrx_zero by (compute; auto).\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint (Int.shrx i Int.zero)) (Vint i).","proofString":"rewrite Int.shrx_zero by (compute; auto).\nauto."},{"statement":"(le : letenv) (a : expr) (i : int) (H : eval_expr ge sp e m le a (Vint i)) : Val.lessdef (Vint i) (Vint i).","proofString":"auto."},{"statement":"(le : letenv) (a : expr) (n : int) (x z : val) (H : eval_expr ge sp e m le a x) (H0 : Val.shrx x (Vint n) = Some z) (H1 : n <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Oshrximm n) (a ::: Enil)) v /\\ Val.lessdef z v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\ Val.lessdef (Val.shl x y) v.","proofString":"InvEval.\napply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shlimm a n2) v /\\\n  Val.lessdef (Val.shl x (Vint n2)) v.","proofString":"apply eval_shlimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshl (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shl x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\ Val.lessdef (Val.shr x y) v.","proofString":"InvEval.\napply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shrimm a n2) v /\\\n  Val.lessdef (Val.shr x (Vint n2)) v.","proofString":"apply eval_shrimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshr (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shr x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (n2 : int) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le (Eop (Ointconst n2) Enil) y) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\ Val.lessdef (Val.shru x y) v.","proofString":"InvEval.\napply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (n2 : int) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (shruimm a n2) v /\\\n  Val.lessdef (Val.shru x (Vint n2)) v.","proofString":"apply eval_shruimm; auto."},{"statement":"(le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e2 : expr) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop Oshru (a ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.shru x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) : eval_expr ge sp e m le a x ->\nexists v : val,\n  eval_expr ge sp e m le (compimm default intsem c a n2) v /\\\n  Val.lessdef (sem c x (Vint n2)) v.","proofString":"unfold compimm; case (compimm_match c a); intros; InvEval; subst.\nrewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto.\ninv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto.\npredSpec Int.eq Int.eq_spec n2 Int.zero.\nsubst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto.\nTrivialExists.\nsimpl.\nrewrite sem_default.\nauto.\npredSpec Int.eq Int.eq_spec n2 Int.zero.\nsubst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto.\nTrivialExists.\nsimpl.\nrewrite sem_default.\nauto.\nTrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (sem c0 (Vint n1) (Vint n2)) v.","proofString":"rewrite sem_int.\nTrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) Enil) v /\\\n  Val.lessdef (Val.of_bool (intsem c0 n1 n2)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : eval_operation ge sp\n  (Ointconst (if intsem c0 n1 n2 then Int.one else Int.zero)) nil m =\nSome (Val.of_bool (intsem c0 n1 n2)).","proofString":"simpl.\ndestruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : comparison) (n1 : int) : Some (Vint (if intsem c0 n1 n2 then Int.one else Int.zero)) =\nSome (Val.of_bool (intsem c0 n1 n2)).","proofString":"destruct (intsem c0 n1 n2); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq x (Vint n2)) v.","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp (negate_condition c0)) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp c0) el\n      else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.zero)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Ceq Vundef (Vint Int.zero)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp c0) el\n     else Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Ceq (if b then Vtrue else Vfalse) (Vint Int.one)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","proofString":"destruct b; simpl; rewrite sem_eq; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Ceq Vundef (Vint Int.one)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) v /\\\n  Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"exists (Vint Int.zero); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) (Vint Int.zero).","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.zero).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.zero).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Ceq (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.zero).","proofString":"destruct b; rewrite sem_eq; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Ceq Vundef (Vint n2)) (Vint Int.zero).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (H : eval_expr ge sp e m le (Eop (Ocmp c0) el) x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"inv H.\nsimpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : eval_operation ge sp (Ocmp c0) vl m = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"simpl in H5.\ninv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (H5 : Some (Val.of_optbool (eval_condition c0 vl m)) = Some x) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne x (Vint n2)) v.","proofString":"inv H5.\ndestruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.zero\n     then Eop (Ocmp c0) el\n     else\n      if Int.eq_dec n2 Int.one\n      then Eop (Ocmp (negate_condition c0)) el\n      else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.zero).\nsubst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\ndestruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (e0 : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp c0) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)) v.","proofString":"TrivialExists.\nsimpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : eval_operation ge sp (Ocmp c0) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"simpl.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some (Val.of_optbool (eval_condition c0 vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.zero)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.zero)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (b : bool) : Some (if b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.zero)).","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) : Some Vundef = Some (sem Cne Vundef (Vint Int.zero)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq_dec n2 Int.one\n     then Eop (Ocmp (negate_condition c0)) el\n     else Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"destruct (Int.eq_dec n2 Int.one).\nsubst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto.\nexists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (e0 : n2 = Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"subst n2.\nTrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (negate_condition c0)) el) v /\\\n  Val.lessdef\n    (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : eval_operation ge sp (Ocmp (negate_condition c0)) vl m =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"simpl.\nrewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (eval_condition (negate_condition c0) vl m)) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"rewrite eval_negate_condition.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some (Val.of_optbool (option_map negb (eval_condition c0 vl m))) =\nSome (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint Int.one)).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vtrue else Vfalse) =\nSome (sem Cne (if b then Vtrue else Vfalse) (Vint Int.one)).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) (b : bool) : Some (if negb b then Vint Int.one else Vint Int.zero) =\nSome (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint Int.one)).","proofString":"destruct b; simpl; rewrite sem_ne; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : Int.one <> Int.zero) : Some Vundef = Some (sem Cne Vundef (Vint Int.one)).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) v /\\\n  Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2)) v.","proofString":"exists (Vint Int.one); split.\nEvalOp.\ndestruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : eval_expr ge sp e m le (Eop (Ointconst Int.one) Enil) (Vint Int.one).","proofString":"EvalOp."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne (Val.of_optbool (eval_condition c0 vl m)) (Vint n2))\n  (Vint Int.one).","proofString":"destruct (eval_condition c0 vl m); simpl.\nunfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto.\nrewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vtrue else Vfalse) (Vint n2)) (Vint Int.one).","proofString":"unfold Vtrue, Vfalse.\ndestruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) (b : bool) : Val.lessdef (sem Cne (if b then Vint Int.one else Vint Int.zero) (Vint n2))\n  (Vint Int.one).","proofString":"destruct b; rewrite sem_ne; rewrite Int.eq_false; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (c0 : condition) (el : exprlist) (vl : list val) (H3 : eval_exprlist ge sp e m le el vl) (n : n2 <> Int.zero) (n0 : n2 <> Int.one) : Val.lessdef (sem Cne Vundef (Vint n2)) (Vint Int.one).","proofString":"rewrite sem_undef; auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then Eop (Ocmp (Cmaskzero m0)) (t1 ::: Enil)\n     else\n      Eop (Ocmp (default Ceq n2)) (Eop (Oandimm m0) (t1 ::: Enil) ::: Enil))\n    v /\\ Val.lessdef (sem Ceq (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"predSpec Int.eq Int.eq_spec n2 Int.zero.\nsubst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto.\nTrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Cmaskzero m0)) (t1 ::: Enil)) v /\\\n  Val.lessdef (sem Ceq (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"subst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Cmaskzero m0)) (t1 ::: Enil)) v /\\\n  Val.lessdef (sem Ceq (Val.and v1 (Vint m0)) (Vint Int.zero)) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.lessdef (sem Ceq (Val.and v1 (Vint m0)) (Vint Int.zero))\n  (Val.of_optbool (Val.cmp_bool Ceq (Val.and v1 (Vint m0)) (Vint Int.zero))).","proofString":"destruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) : Val.lessdef (sem Ceq (Vint (Int.and i m0)) (Vint Int.zero))\n  (if Int.eq (Int.and i m0) Int.zero then Vtrue else Vfalse).","proofString":"rewrite sem_eq.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) : Val.lessdef (Val.of_bool (Int.eq (Int.and i m0) Int.zero))\n  (if Int.eq (Int.and i m0) Int.zero then Vtrue else Vfalse).","proofString":"destruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (default Ceq n2)) (Eop (Oandimm m0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (sem Ceq (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : eval_operation ge sp (Ocmp (default Ceq n2)) (Val.and v1 (Vint m0) :: nil) m =\nSome (sem Ceq (Val.and v1 (Vint m0)) (Vint n2)).","proofString":"simpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : Some\n  (Val.of_optbool\n     (eval_condition (default Ceq n2) (Val.and v1 (Vint m0) :: nil) m)) =\nSome (sem Ceq (Val.and v1 (Vint m0)) (Vint n2)).","proofString":"rewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : Some\n  (Val.of_optbool\n     (eval_condition (default Ceq n2) (Val.and v1 (Vint m0) :: nil) m)) =\nSome\n  (Val.of_optbool\n     (eval_condition (default Ceq n2) (Val.and v1 (Vint m0) :: nil) m)).","proofString":"auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (if Int.eq n2 Int.zero\n     then Eop (Ocmp (Cmasknotzero m0)) (t1 ::: Enil)\n     else\n      Eop (Ocmp (default Cne n2)) (Eop (Oandimm m0) (t1 ::: Enil) ::: Enil))\n    v /\\ Val.lessdef (sem Cne (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"predSpec Int.eq Int.eq_spec n2 Int.zero.\nsubst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto.\nTrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 = Int.zero) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Cmasknotzero m0)) (t1 ::: Enil)) v /\\\n  Val.lessdef (sem Cne (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"subst n2.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Cmasknotzero m0)) (t1 ::: Enil)) v /\\\n  Val.lessdef (sem Cne (Val.and v1 (Vint m0)) (Vint Int.zero)) v.","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) : Val.lessdef (sem Cne (Val.and v1 (Vint m0)) (Vint Int.zero))\n  (Val.of_optbool (Val.cmp_bool Cne (Val.and v1 (Vint m0)) (Vint Int.zero))).","proofString":"destruct v1; simpl; try (rewrite sem_undef; auto).\nrewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) : Val.lessdef (sem Cne (Vint (Int.and i m0)) (Vint Int.zero))\n  (if negb (Int.eq (Int.and i m0) Int.zero) then Vtrue else Vfalse).","proofString":"rewrite sem_ne.\ndestruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (m0 : int) (t1 : expr) (i : int) (H2 : eval_expr ge sp e m le t1 (Vint i)) : Val.lessdef (Val.of_bool (negb (Int.eq (Int.and i m0) Int.zero)))\n  (if negb (Int.eq (Int.and i m0) Int.zero) then Vtrue else Vfalse).","proofString":"destruct (Int.eq (Int.and i m0) Int.zero); auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (default Cne n2)) (Eop (Oandimm m0) (t1 ::: Enil) ::: Enil)) v /\\\n  Val.lessdef (sem Cne (Val.and v1 (Vint m0)) (Vint n2)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : eval_operation ge sp (Ocmp (default Cne n2)) (Val.and v1 (Vint m0) :: nil) m =\nSome (sem Cne (Val.and v1 (Vint m0)) (Vint n2)).","proofString":"simpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : Some\n  (Val.of_optbool\n     (eval_condition (default Cne n2) (Val.and v1 (Vint m0) :: nil) m)) =\nSome (sem Cne (Val.and v1 (Vint m0)) (Vint n2)).","proofString":"rewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 m0 : int) (t1 : expr) (v1 : val) (H2 : eval_expr ge sp e m le t1 v1) (H : n2 <> Int.zero) : Some\n  (Val.of_optbool\n     (eval_condition (default Cne n2) (Val.and v1 (Vint m0) :: nil) m)) =\nSome\n  (Val.of_optbool\n     (eval_condition (default Cne n2) (Val.and v1 (Vint m0) :: nil) m)).","proofString":"auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (e1 : expr) (H : eval_expr ge sp e m le e1 x) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (default c0 n2)) (e1 ::: Enil)) v /\\\n  Val.lessdef (sem c0 x (Vint n2)) v.","proofString":"TrivialExists.\nsimpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (e1 : expr) (H : eval_expr ge sp e m le e1 x) : eval_operation ge sp (Ocmp (default c0 n2)) (x :: nil) m =\nSome (sem c0 x (Vint n2)).","proofString":"simpl.\nrewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (e1 : expr) (H : eval_expr ge sp e m le e1 x) : Some (Val.of_optbool (eval_condition (default c0 n2) (x :: nil) m)) =\nSome (sem c0 x (Vint n2)).","proofString":"rewrite sem_default.\nauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (c0 : comparison) (e1 : expr) (H : eval_expr ge sp e m le e1 x) : Some (Val.of_optbool (eval_condition (default c0 n2) (x :: nil) m)) =\nSome (Val.of_optbool (eval_condition (default c0 n2) (x :: nil) m)).","proofString":"auto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem c (Vint n2) x) v.","proofString":"rewrite <- sem_swap.\neapply eval_compimm; eauto."},{"statement":"(le : letenv) (c : comparison) (a : expr) (n2 : int) (x : val) (H : eval_expr ge sp e m le a x) : exists v : val,\n  eval_expr ge sp e m le (compimm default intsem (swap_comparison c) a n2) v /\\\n  Val.lessdef (sem (swap_comparison c) x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (comp c a b) v /\\ Val.lessdef (Val.cmp c x y) v.","proofString":"unfold comp; case (comp_match a b); intros; InvEval; subst.\neapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto.\neapply eval_compimm; eauto.\nTrivialExists.\nsimpl.\nrewrite Val.swap_cmp_bool.\nauto.\nTrivialExists.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp (swap_comparison c) t2 n1)\n    v /\\ Val.lessdef (Val.cmp c (Vint n1) y) v.","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","proofString":"intros.\nunfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmp (swap_comparison c0) x y0 = Val.cmp c0 y0 x.","proofString":"unfold Val.cmp.\nrewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool (Val.cmp_bool (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmp_bool c0 y0 x).","proofString":"rewrite Val.swap_cmp_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompimm Int.cmp c t1 n2) v /\\\n  Val.lessdef (Val.cmp c x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (Ccompshift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil)) v /\\\n  Val.lessdef (Val.cmp c (eval_shift s v1 a0) y) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Val.swap_cmp_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Ocmp (Ccompshift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m = Some (Val.cmp c (eval_shift s v1 a0) y).","proofString":"simpl.\nrewrite Val.swap_cmp_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool (Val.cmp_bool (swap_comparison c) y (eval_shift s v1 a0))) =\nSome (Val.cmp c (eval_shift s v1 a0) y).","proofString":"rewrite Val.swap_cmp_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some (Val.of_optbool (Val.cmp_bool c (eval_shift s v1 a0) y)) =\nSome (Val.cmp c (eval_shift s v1 a0) y).","proofString":"auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (Ccompshift c s a0)) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.cmp c x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccomp c)) (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.cmp c x y) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) : eval_expr ge sp e m le a x ->\neval_expr ge sp e m le b y ->\nexists v : val,\n  eval_expr ge sp e m le (compu c a b) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x y) v.","proofString":"unfold compu; case (compu_match a b); intros; InvEval; subst.\neapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto.\neapply eval_compimm; eauto.\nTrivialExists.\nsimpl.\nrewrite Val.swap_cmpu_bool.\nauto.\nTrivialExists.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : exists v : val,\n  eval_expr ge sp e m le\n    (compimm Ccompuimm Int.cmpu (swap_comparison c) t2 n1) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c (Vint n1) y) v.","proofString":"eapply eval_compimm_swap; eauto.\nintros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) : forall (c0 : comparison) (x y0 : val),\nVal.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","proofString":"intros.\nunfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.cmpu (Mem.valid_pointer m) (swap_comparison c0) x y0 =\nVal.cmpu (Mem.valid_pointer m) c0 y0 x.","proofString":"unfold Val.cmpu.\nrewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (n1 : int) (t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (c0 : comparison) (x y0 : val) : Val.of_optbool\n  (Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c0) x y0) =\nVal.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) c0 y0 x).","proofString":"rewrite Val.swap_cmpu_bool; auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (n2 : int) (H : eval_expr ge sp e m le t1 x) : exists v : val,\n  eval_expr ge sp e m le (compimm Ccompuimm Int.cmpu c t1 n2) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x (Vint n2)) v.","proofString":"eapply eval_compimm; eauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (Ccompushift (swap_comparison c) s a0)) (t2 ::: t1 ::: Enil))\n    v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c (eval_shift s v1 a0) y) v.","proofString":"TrivialExists.\nsimpl.\nrewrite Val.swap_cmpu_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : eval_operation ge sp (Ocmp (Ccompushift (swap_comparison c) s a0))\n  (y :: v1 :: nil) m =\nSome (Val.cmpu (Mem.valid_pointer m) c (eval_shift s v1 a0) y).","proofString":"simpl.\nrewrite Val.swap_cmpu_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) (swap_comparison c) y\n        (eval_shift s v1 a0))) =\nSome (Val.cmpu (Mem.valid_pointer m) c (eval_shift s v1 a0) y).","proofString":"rewrite Val.swap_cmpu_bool.\nauto."},{"statement":"(c : comparison) (le : letenv) (a b : expr) (y : val) (s : shift) (a0 : amount32) (t1 t2 : expr) (H0 : eval_expr ge sp e m le t2 y) (v1 : val) (H3 : eval_expr ge sp e m le t1 v1) : Some\n  (Val.of_optbool\n     (Val.cmpu_bool (Mem.valid_pointer m) c (eval_shift s v1 a0) y)) =\nSome (Val.cmpu (Mem.valid_pointer m) c (eval_shift s v1 a0) y).","proofString":"auto."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b t1 : expr) (s : shift) (a0 : amount32) (t2 : expr) (H : eval_expr ge sp e m le t1 x) (v1 : val) (H3 : eval_expr ge sp e m le t2 v1) : exists v : val,\n  eval_expr ge sp e m le\n    (Eop (Ocmp (Ccompushift c s a0)) (t1 ::: t2 ::: Enil)) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x (eval_shift s v1 a0)) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (e1 e2 : expr) (H : eval_expr ge sp e m le e1 x) (H0 : eval_expr ge sp e m le e2 y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompu c)) (e1 ::: e2 ::: Enil)) v /\\\n  Val.lessdef (Val.cmpu (Mem.valid_pointer m) c x y) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (compf c a b) v /\\ Val.lessdef (Val.cmpf c x y) v.","proofString":"unfold compf.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompf c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpf c x y) v.","proofString":"TrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (compfs c a b) v /\\ Val.lessdef (Val.cmpfs c x y) v.","proofString":"unfold compfs.\nTrivialExists."},{"statement":"(c : comparison) (le : letenv) (a : expr) (x : val) (b : expr) (y : val) (H : eval_expr ge sp e m le a x) (H0 : eval_expr ge sp e m le b y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ocmp (Ccompfs c)) (a ::: b ::: Enil)) v /\\\n  Val.lessdef (Val.cmpfs c x y) v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.floatofint x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match floatofint_match a with\n    | floatofint_case1 n => Eop (Ofloatconst (Float.of_int n)) Enil\n    | floatofint_default e0 => Eop Ofloatofint (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (floatofint_match a); intros; InvEval.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.floatofint (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_int n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.floatofint x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofint (e0 ::: Enil)) v /\\ Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.floatofintu x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match floatofintu_match a with\n    | floatofintu_case1 n => Eop (Ofloatconst (Float.of_intu n)) Enil\n    | floatofintu_default e0 => Eop Ofloatofintu (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (floatofintu_match a); intros; InvEval.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.floatofintu (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Ofloatconst (Float.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.floatofintu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Ofloatofintu (e0 ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.singleofint x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match singleofint_match a with\n    | singleofint_case1 n => Eop (Osingleconst (Float32.of_int n)) Enil\n    | singleofint_default e0 => Eop Osingleofint (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (singleofint_match a); intros; InvEval.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.singleofint (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osingleconst (Float32.of_int n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.singleofint x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleofint (e0 ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) : eval_expr ge sp e m le a x ->\nVal.singleofintu x = Some y ->\nexists v : val,\n  eval_expr ge sp e m le\n    match singleofintu_match a with\n    | singleofintu_case1 n => Eop (Osingleconst (Float32.of_intu n)) Enil\n    | singleofintu_default e0 => Eop Osingleofintu (e0 ::: Enil)\n    end v /\\ Val.lessdef y v.","proofString":"case (singleofintu_match a); intros; InvEval.\nTrivialExists.\nTrivialExists."},{"statement":"(le : letenv) (a : expr) (y : val) (n : int) (H0 : Val.singleofintu (Vint n) = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osingleconst (Float32.of_intu n)) Enil) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (a : expr) (x y : val) (e0 : expr) (H : eval_expr ge sp e m le e0 x) (H0 : Val.singleofintu x = Some y) : exists v : val,\n  eval_expr ge sp e m le (Eop Osingleofintu (e0 ::: Enil)) v /\\\n  Val.lessdef y v.","proofString":"TrivialExists."},{"statement":"(le : letenv) (ty : typ) (cond : condition) (al : exprlist) (vl : list val) (a1 : expr) (v1 : val) (a2 : expr) (v2 : val) (a : expr) (b : bool) (H : (if match ty with\n    | Tany32 | Tany64 => false\n    | _ => true\n    end\n then Some (Eop (Osel cond ty) (a1 ::: a2 ::: al))\n else None) = Some a) (H0 : eval_exprlist ge sp e m le al vl) (H1 : eval_expr ge sp e m le a1 v1) (H2 : eval_expr ge sp e m le a2 v2) (H3 : eval_condition cond vl m = Some b) : exists v : val,\n  eval_expr ge sp e m le a v /\\ Val.lessdef (Val.select (Some b) v1 v2 ty) v.","proofString":"destruct (match ty with Tint | Tlong | Tfloat | Tsingle => true | _ => false end); inv H.\nrewrite <- H3; TrivialExists."},{"statement":"(le : letenv) (ty : typ) (cond : condition) (al : exprlist) (vl : list val) (a1 : expr) (v1 : val) (a2 : expr) (v2 : val) (b : bool) (H0 : eval_exprlist ge sp e m le al vl) (H1 : eval_expr ge sp e m le a1 v1) (H2 : eval_expr ge sp e m le a2 v2) (H3 : eval_condition cond vl m = Some b) : exists v : val,\n  eval_expr ge sp e m le (Eop (Osel cond ty) (a1 ::: a2 ::: al)) v /\\\n  Val.lessdef (Val.select (Some b) v1 v2 ty) v.","proofString":"rewrite <- H3; TrivialExists."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (v : val) : forall (b : block) (ofs : ptrofs),\neval_expr ge sp e m le a v ->\nv = Vptr b ofs ->\nlet (mode, args) := addressing chunk a in\nexists vl : list val,\n  eval_exprlist ge sp e m le args vl /\\\n  eval_addressing ge sp mode vl = Some v.","proofString":"unfold addressing; case (addressing_match a); intros; InvEval.\neconstructor; split.\nEvalOp.\nsimpl; auto.\ndestruct (symbol_is_relocatable id).\nexists (Genv.symbol_address ge id Ptrofs.zero :: nil); split.\nconstructor.\nEvalOp.\nconstructor.\nsimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto.\neconstructor; split.\nEvalOp.\nsimpl; auto.\neconstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; try discriminate.\nrewrite <- H; auto.\neconstructor; split.\nEvalOp.\nsimpl.\ncongruence.\neconstructor; split.\nEvalOp.\nsimpl.\ncongruence.\neconstructor; split.\nEvalOp.\nsimpl.\ncongruence.\neconstructor; split.\nEvalOp.\nsimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : ptrofs) (b : block) (ofs : ptrofs) (H0 : Val.offset_ptr sp n = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le Enil vl /\\\n  eval_addressing ge sp (Ainstack n) vl = Some (Val.offset_ptr sp n).","proofString":"econstructor; split.\nEvalOp.\nsimpl; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : let (mode, args) :=\n  if symbol_is_relocatable id\n  then\n   (Aindexed (Ptrofs.to_int64 ofs),\n    Eop (Oaddrsymbol id Ptrofs.zero) Enil ::: Enil)\n  else (Aglobal id ofs, Enil) in\nexists vl : list val,\n  eval_exprlist ge sp e m le args vl /\\\n  eval_addressing ge sp mode vl = Some (Genv.symbol_address ge id ofs).","proofString":"destruct (symbol_is_relocatable id).\nexists (Genv.symbol_address ge id Ptrofs.zero :: nil); split.\nconstructor.\nEvalOp.\nconstructor.\nsimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto.\neconstructor; split.\nEvalOp.\nsimpl; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : exists vl : list val,\n  eval_exprlist ge sp e m le (Eop (Oaddrsymbol id Ptrofs.zero) Enil ::: Enil)\n    vl /\\\n  eval_addressing ge sp (Aindexed (Ptrofs.to_int64 ofs)) vl =\n  Some (Genv.symbol_address ge id ofs).","proofString":"exists (Genv.symbol_address ge id Ptrofs.zero :: nil); split.\nconstructor.\nEvalOp.\nconstructor.\nsimpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : eval_exprlist ge sp e m le (Eop (Oaddrsymbol id Ptrofs.zero) Enil ::: Enil)\n  (Genv.symbol_address ge id Ptrofs.zero :: nil).","proofString":"constructor.\nEvalOp.\nconstructor."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : eval_expr ge sp e m le (Eop (Oaddrsymbol id Ptrofs.zero) Enil)\n  (Genv.symbol_address ge id Ptrofs.zero).","proofString":"EvalOp."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : eval_exprlist ge sp e m le Enil nil.","proofString":"constructor."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : eval_addressing ge sp (Aindexed (Ptrofs.to_int64 ofs))\n  (Genv.symbol_address ge id Ptrofs.zero :: nil) =\nSome (Genv.symbol_address ge id ofs).","proofString":"simpl.\nrewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : Some\n  (Val.addl (Genv.symbol_address ge id Ptrofs.zero)\n     (Vlong (Ptrofs.to_int64 ofs))) = Some (Genv.symbol_address ge id ofs).","proofString":"rewrite <- Genv.shift_symbol_address_64 by auto.\nrewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : Some\n  (Genv.symbol_address ge id\n     (Ptrofs.add Ptrofs.zero (Ptrofs.of_int64 (Ptrofs.to_int64 ofs)))) =\nSome (Genv.symbol_address ge id ofs).","proofString":"rewrite Ptrofs.of_int64_to_int64, Ptrofs.add_zero_l by auto.\nauto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : Some (Genv.symbol_address ge id ofs) = Some (Genv.symbol_address ge id ofs).","proofString":"auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (id : ident) (ofs : ptrofs) (b : block) (ofs0 : ptrofs) (H0 : Genv.symbol_address ge id ofs = Vptr b ofs0) : exists vl : list val,\n  eval_exprlist ge sp e m le Enil vl /\\\n  eval_addressing ge sp (Aglobal id ofs) vl =\n  Some (Genv.symbol_address ge id ofs).","proofString":"econstructor; split.\nEvalOp.\nsimpl; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le e1 v1) (H : Val.addl v1 (Vlong n) = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le (e1 ::: Enil) vl /\\\n  eval_addressing ge sp (Aindexed n) vl = Some (Vptr b ofs).","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ndestruct v1; try discriminate.\nrewrite <- H; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (v1 : val) (H2 : eval_expr ge sp e m le e1 v1) (H : Val.addl v1 (Vlong n) = Vptr b ofs) : Some (Val.addl v1 (Vlong n)) = Some (Vptr b ofs).","proofString":"destruct v1; try discriminate.\nrewrite <- H; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (n : int64) (e1 : expr) (b : block) (ofs : ptrofs) (b0 : block) (i : ptrofs) (H2 : eval_expr ge sp e m le e1 (Vptr b0 i)) (H : Val.addl (Vptr b0 i) (Vlong n) = Vptr b ofs) : Some (Val.addl (Vptr b0 i) (Vlong n)) = Some (Vptr b ofs).","proofString":"rewrite <- H; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (a0 : amount64) (e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 (Val.shll v0 (Vint a0)) = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le (e1 ::: e2 ::: Enil) vl /\\\n  eval_addressing ge sp (Aindexed2shift a0) vl = Some (Vptr b ofs).","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ncongruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (a0 : amount64) (e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 (Val.shll v0 (Vint a0)) = Vptr b ofs) : Some (Val.addl v1 (Val.shll v0 (Vint a0))) = Some (Vptr b ofs).","proofString":"congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (x : extension) (a0 : amount64) (e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 (eval_extend x v0 a0) = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le (e1 ::: e2 ::: Enil) vl /\\\n  eval_addressing ge sp (Aindexed2ext x a0) vl = Some (Vptr b ofs).","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ncongruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (x : extension) (a0 : amount64) (e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 (eval_extend x v0 a0) = Vptr b ofs) : Some (Val.addl v1 (eval_extend x v0 a0)) = Some (Vptr b ofs).","proofString":"congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 v0 = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le (e1 ::: e2 ::: Enil) vl /\\\n  eval_addressing ge sp Aindexed2 vl = Some (Vptr b ofs).","proofString":"econstructor; split.\nEvalOp.\nsimpl.\ncongruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a e1 e2 : expr) (b : block) (ofs : ptrofs) (v1 v0 : val) (H2 : eval_expr ge sp e m le e1 v1) (H3 : eval_expr ge sp e m le e2 v0) (H : Val.addl v1 v0 = Vptr b ofs) : Some (Val.addl v1 v0) = Some (Vptr b ofs).","proofString":"congruence."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (v : val) (e0 : expr) (b : block) (ofs : ptrofs) (H : eval_expr ge sp e m le e0 v) (H0 : v = Vptr b ofs) : exists vl : list val,\n  eval_exprlist ge sp e m le (e0 ::: Enil) vl /\\\n  eval_addressing ge sp (Aindexed Int64.zero) vl = Some v.","proofString":"econstructor; split.\nEvalOp.\nsimpl.\nrewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (v : val) (e0 : expr) (b : block) (ofs : ptrofs) (H : eval_expr ge sp e m le e0 v) (H0 : v = Vptr b ofs) : Some (Val.addl v (Vlong Int64.zero)) = Some v.","proofString":"rewrite H0.\nsimpl.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (v : val) (e0 : expr) (b : block) (ofs : ptrofs) (H : eval_expr ge sp e m le e0 v) (H0 : v = Vptr b ofs) : Some (Val.addl (Vptr b ofs) (Vlong Int64.zero)) = Some (Vptr b ofs).","proofString":"simpl.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(le : letenv) (chunk : memory_chunk) (a : expr) (v : val) (e0 : expr) (b : block) (ofs : ptrofs) (H : eval_expr ge sp e m le e0 v) (H0 : v = Vptr b ofs) : Some (Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 Int64.zero))) =\nSome (Vptr b ofs).","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(a : expr) (v : val) : eval_expr ge sp e m nil a v -> eval_builtin_arg ge sp e m (builtin_arg a) v.","proofString":"unfold builtin_arg; case (builtin_arg_match a); intros; InvEval.\nconstructor.\nconstructor.\nconstructor.\nconstructor.\ninv H.\nInvEval.\nsimpl in H6.\ninv H6.\nconstructor; auto.\nsubst v.\nrepeat constructor; auto.\nconstructor; auto."},{"statement":"(a : expr) (n : int) : eval_builtin_arg ge sp e m (BA_int n) (Vint n).","proofString":"constructor."},{"statement":"(a : expr) (n : int64) : eval_builtin_arg ge sp e m (BA_long n) (Vlong n).","proofString":"constructor."},{"statement":"(a : expr) (id : ident) (ofs : ptrofs) : eval_builtin_arg ge sp e m (BA_addrglobal id ofs)\n  (Genv.symbol_address ge id ofs).","proofString":"constructor."},{"statement":"(a : expr) (ofs : ptrofs) : eval_builtin_arg ge sp e m (BA_addrstack ofs) (Val.offset_ptr sp ofs).","proofString":"constructor."},{"statement":"(a : expr) (v : val) (chunk : memory_chunk) (ofs : ptrofs) (H : eval_expr ge sp e m nil (Eload chunk (Ainstack ofs) Enil) v) : eval_builtin_arg ge sp e m (BA_loadstack chunk ofs) v.","proofString":"inv H.\nInvEval.\nsimpl in H6.\ninv H6.\nconstructor; auto."},{"statement":"(a : expr) (v : val) (chunk : memory_chunk) (ofs : ptrofs) (vl : list val) (vaddr : val) (H4 : eval_exprlist ge sp e m nil Enil vl) (H6 : Op.eval_addressing ge sp (Ainstack ofs) vl = Some vaddr) (H7 : Mem.loadv chunk m vaddr = Some v) : eval_builtin_arg ge sp e m (BA_loadstack chunk ofs) v.","proofString":"InvEval.\nsimpl in H6.\ninv H6.\nconstructor; auto."},{"statement":"(a : expr) (v : val) (chunk : memory_chunk) (ofs : ptrofs) (vaddr : val) (H6 : Op.eval_addressing ge sp (Ainstack ofs) nil = Some vaddr) (H7 : Mem.loadv chunk m vaddr = Some v) : eval_builtin_arg ge sp e m (BA_loadstack chunk ofs) v.","proofString":"simpl in H6.\ninv H6.\nconstructor; auto."},{"statement":"(a : expr) (v : val) (chunk : memory_chunk) (ofs : ptrofs) (vaddr : val) (H6 : Some (Val.offset_ptr sp ofs) = Some vaddr) (H7 : Mem.loadv chunk m vaddr = Some v) : eval_builtin_arg ge sp e m (BA_loadstack chunk ofs) v.","proofString":"inv H6.\nconstructor; auto."},{"statement":"(a : expr) (v : val) (chunk : memory_chunk) (ofs : ptrofs) (H7 : Mem.loadv chunk m (Val.offset_ptr sp ofs) = Some v) : eval_builtin_arg ge sp e m (BA_loadstack chunk ofs) v.","proofString":"constructor; auto."},{"statement":"(a : expr) (v : val) (n : int64) (e1 : expr) (v1 : val) (H2 : eval_expr ge sp e m nil e1 v1) (H : Val.addl v1 (Vlong n) = v) : eval_builtin_arg ge sp e m (BA_addptr (BA e1) (BA_long n)) v.","proofString":"subst v.\nrepeat constructor; auto."},{"statement":"(a : expr) (n : int64) (e1 : expr) (v1 : val) (H2 : eval_expr ge sp e m nil e1 v1) : eval_builtin_arg ge sp e m (BA_addptr (BA e1) (BA_long n))\n  (Val.addl v1 (Vlong n)).","proofString":"repeat constructor; auto."},{"statement":"(a : expr) (v : val) (e0 : expr) (H : eval_expr ge sp e m nil e0 v) : eval_builtin_arg ge sp e m (BA e0) v.","proofString":"constructor; auto."},{"statement":"(bf : Builtins1.platform_builtin) (al : exprlist) (a : expr) (vl : list val) (v : val) (le : letenv) (H : platform_builtin bf al = Some a) (H0 : eval_exprlist ge sp e m le al vl) (H1 : platform_builtin_sem bf vl = Some v) : exists v' : val, eval_expr ge sp e m le a v' /\\ Val.lessdef v v'.","proofString":"discriminate."}]}