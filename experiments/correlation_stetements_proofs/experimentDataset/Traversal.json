[{"statement":"Lemma itrav_step_mon_ext e\n        (C1 I1 C2 I2 C' I': actid -> Prop)\n        (STEP: itrav_step e (mkTC C1 I1) (mkTC C2 I2)):\n          (itrav_step e)^?\n                        (mkTC (C1 ∪₁ C') (I1 ∪₁ I'))\n                        (mkTC (C2 ∪₁ C') (I2 ∪₁ I')).","proof":"red in STEP.\ndesf; simpl in *.\n{\ndestruct (classic (C' e)).\n{\nleft.\nf_equal; apply set_extensionality;                (rewrite COVEQ || rewrite ISSEQ); basic_solver.\n}\nright.\nred.\nleft.\nsplits; simpl.\n{\nintros [? | ?]; done.\n}\n{\neapply traversal_mon; [.. | apply COV]; simpl; basic_solver.\n}\nall: (rewrite COVEQ || rewrite ISSEQ); basic_solver.\n}\ndestruct (classic (I' e)).\n{\nleft.\nf_equal; apply set_extensionality;              (rewrite COVEQ || rewrite ISSEQ); basic_solver.\n}\nright.\nred.\nright.\nsplits; simpl.\n{\nintros [? | ?]; done.\n}\n{\neapply traversal_mon; [| | apply ISS]; simpl; basic_solver.\n}\nall: (rewrite COVEQ || rewrite ISSEQ); basic_solver.\n"},{"statement":"Lemma itrav_step_mon_ext_equiv e \n        (C1 I1 C2 I2 C' I' Cu1 Iu1 Cu2 Iu2: actid -> Prop)\n        (STEP: itrav_step e {| covered := C1; issued := I1 |}\n                            {| covered := C2; issued := I2 |})\n        (EQC1: Cu1 ≡₁ C1 ∪₁ C') (EQI1: Iu1 ≡₁ I1 ∪₁ I')\n        (EQC2: Cu2 ≡₁ C2 ∪₁ C') (EQI2: Iu2 ≡₁ I2 ∪₁ I'):\n    (itrav_step e)^? (mkTC Cu1 Iu1) (mkTC Cu2 Iu2).","proof":"forward eapply itrav_step_mon_ext with (C' := C') (I' := I') as STEP'; eauto.\ndestruct STEP'.\n{\nleft.\napply same_tc_extensionality.\nrewrite EQC1, EQC2, EQI1, EQI2.\ninversion H.\nrewrite H1, H2.\nreflexivity.\n}\nright.\neapply itrav_step_more; [done| .. | by apply H].\nall: red; split; simpl; auto.\n"},{"statement":"Lemma itrav_step_mon_ext_cover e\n        (C I C' I': actid -> Prop)\n        (STEP: itrav_step e (mkTC C I) (mkTC (C ∪₁ eq e) I))\n        (NEW: set_disjoint (C ∪₁ C') (eq e)):\n    itrav_step e (mkTC (C ∪₁ C') (I ∪₁ I'))\n                 (mkTC (C ∪₁ C' ∪₁ eq e) (I ∪₁ I')).","proof":"forward eapply itrav_step_mon_ext with (C' := C') (I' := I') as STEP'; eauto.\nred in STEP.\ndesf; simpl in *.\n2: {\ndestruct (NEW e); auto.\nleft.\napply COVEQ.\nbasic_solver.\n}\ndestruct STEP'.\n{\ninversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver.\n}\nrewrite set_unionA, set_unionC with (s := C'), <- set_unionA.\nauto.\n"},{"statement":"Lemma itrav_step_mon_ext_issue e\n        (C I C' I': actid -> Prop)\n        (STEP: itrav_step e (mkTC C I) (mkTC C (I ∪₁ eq e)))\n        (NEW: set_disjoint (I ∪₁ I') (eq e)):\n          itrav_step e (mkTC (C ∪₁ C') (I ∪₁ I'))\n                       (mkTC (C ∪₁ C') (I ∪₁ I' ∪₁ eq e)).","proof":"forward eapply itrav_step_mon_ext with (C' := C') (I' := I') as STEP'; eauto.\nred in STEP.\ndesf; simpl in *.\n{\ndestruct (NEW e); auto.\nleft.\napply ISSEQ.\nbasic_solver.\n}\ndestruct STEP'.\n{\ninversion H.\ndestruct (NEW e); auto.\nrewrite H1.\nbasic_solver.\n}\nrewrite set_unionA, set_unionC with (s := I'), <- set_unionA.\nauto.\n"},{"statement":"Lemma step_mon C C' (T : trav_step C C') :\n  covered C ⊆₁ covered C' /\\ issued C ⊆₁ issued C'.","proof":"destruct T as [e [STEP | STEP]]; auto.\nunnw; unfolder in *; basic_solver 21.\nunnw; unfolder in *; basic_solver 21.\n"},{"statement":"Lemma trav_step_coherence (C C' : trav_config) (T : trav_step C C')\n        (H : tc_coherent G sc C):\n    tc_coherent G sc C'.","proof":"assert (coverable G sc C ⊆₁ coverable G sc C' /\\ issuable G sc C ⊆₁ issuable G sc C').\nby apply traversal_mon; apply step_mon; eauto.\ndestruct T as [e [STEP | STEP]]; auto; unnw; desf.\n- unfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nunfolder in *; basic_solver 12.\n- unfold tc_coherent in *; splits; desf.\nunfolder in *; basic_solver 12.\nrewrite STEP1, <- H0; basic_solver 21.\nrewrite STEP2, <- H1; basic_solver 21.\n"},{"statement":"Lemma trav_coherence (C C' : trav_config) (T : traverse C C')\n        (H : tc_coherent G sc C):\n    tc_coherent G sc C'.","proof":"apply clos_trans_tn1 in T.\ninduction T; eapply trav_step_coherence; eauto.\n"},{"statement":"Lemma init_trav_coherent : tc_coherent G sc init_trav.","proof":"unfold init_trav.\nred; splits; ins.\n{\nunfold coverable; ins.\nrepeat (splits; try apply set_subset_inter_r).\nbasic_solver.\nrewrite no_sb_to_init; unfold dom_cond; basic_solver.\ngeneralize (init_w WF); basic_solver 12.\n}\nunfold issuable; ins.\nrepeat (splits; try apply set_subset_inter_r).\n{\nbasic_solver.\n}\n{\ngeneralize (init_w WF); basic_solver 12.\n}\n{\nrewrite fwbob_in_bob, bob_in_sb, no_sb_to_init; unfold dom_cond; basic_solver.\n}\neapply dom_cond_in with (r' := fun _ _ => False).\nrewrite id_inter.\nrewrite ct_end, !seqA.\narewrite ((ar G sc ∪ rf ⨾ ppo ∩ same_loc) ⨾ ⦗Init⦘ ⊆ ∅₂).\n{\nby apply no_ar_rf_ppo_loc_to_init.\n}\nbasic_solver.\n"},{"statement":"Lemma exists_next P e \n        (ACTS : E e)\n        (N_COV : ~ P e) :\n    exists e', sb^? e' e /\\ next G P e'.","proof":"generalize dependent e.\nset (Q e := E e -> ~ P e ->                exists e' : actid, sb^? e' e /\\ next G P e').\napply (@well_founded_ind _ sb (wf_sb G) Q).\nins; subst Q; simpls.\ndestruct (classic (exists e', sb e' x /\\ ~ P e')) as        [[e' [H' COV]]| H']; ins.\n{\nassert (E e') as ACTS.\n{\napply seq_eqv_l in H'; desf.\n}\nspecialize (H e' H' ACTS COV).\ndestruct H as [z [X Y]].\nexists z; split; auto.\nright.\nred in X; desf.\neapply sb_trans; eauto.\n}\nexists x; splits; [by left|]; red; splits; auto.\nunfolder; splits; eauto.\nunfold dom_cond; unfolder.\nins; desc; subst.\ndestruct (classic (P x0)); auto.\nexfalso; apply H'; vauto.\n"},{"statement":"Lemma exists_trav_step T (TCCOH : tc_coherent G sc T)\n        e (N_FIN : next G (covered T) e)\n        (FSUPP : fsupp (⦗set_compl is_init⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺)) :\n    exists T', trav_step T T'.","proof":"assert (wf_sc G sc) as WFSC by apply IMMCON.\nassert (complete G) as COM by apply IMMCON.\nrename e into e'.\ndestruct (forall_not_or_exists (next G (covered T)) W)      as [WNEXT|NWNEXT].\n{\ndesf.\ndestruct (classic (issued T e)).\n{\nexists (mkTC (covered T ∪₁ (eq e)) (issued T)).\ndestruct T as [C I]; simpls.\nexists e; left; unnw; splits; simpls.\n{\napply WNEXT.\n}\nunfold coverable.\nsplit; [by apply WNEXT|].\nleft; unnw; basic_solver.\n}\nexists (mkTC (covered T) (issued T ∪₁ (eq e))).\ndestruct T as [C I]; simpl in *.\nexists e; right; unnw; splits; simpls; try basic_solver.\neapply issuable_next_w; eauto.\nby unfolder.\n}\ndestruct (forall_not_or_exists (next G (covered T)) (coverable G sc T))       as [COV|NCOV].\n{\ndesf.\nexists (mkTC (covered T ∪₁ (eq e)) (issued T)).\nexists e; left; splits; simpls; auto.\napply COV.\n}\nassert ((exists w, W w /\\ ~ issued T w /\\ E w) ->            exists w, W w /\\ ~ issued T w /\\                      dom_cond (⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) (issued T) w /\\                      E w) as WMIN.\n{\nintros P; desf.\ninduction w using (well_founded_ind (wf_ar_rf_ppo_loc_ct WF COM IMMCON FSUPP)).\ndestruct (classic (dom_cond (⦗W⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺) (issued T) w)); eauto.\nunfolder in H0.\nunfold dom_rel in H0.\napply not_all_ex_not in H0; desf.\napply not_all_ex_not in H0; desf.\neapply H; eauto.\n{\napply seq_eqv_l.\nsplit; auto.\napply wf_ar_rf_ppo_loc_ctE, seq_eqv_lr in n3; auto.\nintros Iz0.\nforward eapply init_issued with (x := z0); eauto.\nbasic_solver 10.\n}\ncdes IMMCON.\napply wf_ar_rf_ppo_loc_ctE in n3; auto.\nby destruct_seq_l n3 as AA.\n}\nassert ((exists f, (F∩₁Sc) f  /\\ ~ covered T f /\\ E f) ->            exists f, (F∩₁Sc) f /\\ ~ covered T f /\\                      doma (⦗F∩₁Sc⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗eq f⦘) (covered T) /\\                      E f) as FMIN.\n{\nintros P; desf.\ninduction f using (well_founded_ind (wf_ar_rf_ppo_loc_ct WF COM IMMCON FSUPP)).\ndestruct (classic (doma (⦗F∩₁Sc⦘ ⨾ (ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺ ⨾ ⦗eq f⦘) (covered T)))        as [H0 | H0]; eauto.\nrewrite seq_eqv_r, seq_eqv_l in H0.\nunfold doma in H0.\napply not_all_ex_not in H0; desf.\napply not_all_ex_not in H0; desf.\napply imply_to_and in H0; desf.\neapply H; eauto.\n2: {\napply wf_ar_rf_ppo_loc_ctE, seq_eqv_lr in H2; auto.\nby desc.\n}\ncdes IMMCON.\napply seq_eqv_l.\nsplit; auto.\neapply read_or_fence_is_not_init; eauto.\ntype_solver.\n}\nassert (forall n, next G (covered T) n ->                      R n \\/ (F∩₁Sc) n) as RorF.\n{\nintros; destruct (lab_rwf lab n); auto.\ndesf.\n{\nby apply NWNEXT in H.\n}\nright.\nsplit; auto.\ndestruct (classic (is_sc lab n)) as [|NEQ]; [done|exfalso].\nset (NN := H).\napply NCOV in NN.\nunfold coverable in NN.\napply not_and_or in NN; desf; apply NN.\n{\napply H.\n}\nright; split; auto.\ncdes IMMCON.\nunfold dom_cond.\nrewrite (wf_scD Wf_sc).\ntype_solver.\n}\nassert (forall r, R r -> next G (covered T) r ->                      ~ coverable G sc T r ->      exists w, W w /\\ rf w r /\\ ~ issued T w) as WIS.\n{\nclear NCOV.\nintros r RR RNEXT NCOV.\nunfold coverable in NCOV.\napply not_and_or in NCOV; desf.\n{\nexfalso; apply NCOV.\napply RNEXT.\n}\napply not_or_and in NCOV; desf.\napply not_or_and in NCOV; desf.\napply not_and_or in NCOV1; desf.\nassert (exists w, rf w r) as [w RF].\n{\nedestruct COM; esplit; eauto.\napply RNEXT.\n}\nexists w; splits; auto.\n{\napply (wf_rfD WF) in RF.\napply seq_eqv_l in RF; desf.\n}\nintros II.\napply NCOV1.\nintros x [y H].\napply seq_eqv_r in H; desf.\nassert (w = x); [|by subst].\neapply (wf_rff WF); eauto.\n}\ndestruct (forall_not_or_exists (next G (covered T)) R)      as [RNEXT|NRNEXT].\n{\ndesf.\nassert (exists w', W w' /\\ ~ issued T w' /\\ E w') as XW.\n{\ndestruct (WIS e RNEXT0 RNEXT) as [w'].\n{\neapply NCOV; eauto.\n}\nexists w'; splits; desf.\napply wf_rfE in H0; auto.\napply seq_eqv_l in H0; desf.\n}\nassert (WMIN := WMIN XW).\nclear XW.\ndesf.\nassert (~ covered T w) as WNCOV.\n{\nintro H.\napply WMIN0.\nby apply (w_covered_issued TCCOH); split.\n}\ndestruct (exists_next (covered T) w WMIN2 WNCOV) as [n NSB]; desf.\ndestruct NSB as [HSB|HSB]; desf.\n{\nexfalso; eapply NWNEXT; eauto.\n}\nexists (mkTC (covered T) (issued T ∪₁ (eq w))).\nexists w; right; unnw; splits; simpls.\nset (nRorF := RorF).\nspecialize (nRorF n NSB0).\nsplit; [split; [split|]|]; auto.\nintros x [y H]; desc; subst.\napply seq_eqv_r in H.\ndesc; subst.\napply NNPP; intro COVX.\nassert (sb x y) as SBXY.\n{\nby apply bob_in_sb, fwbob_in_bob.\n}\nassert (sb^? n x) as NX.\n{\ndestruct (eq_dec_actid n x) as [EQNX|NEQNX]; [by left|right].\nedestruct (sb_semi_total_r ) as [LL|RR]; eauto.\n{\nintros H'.\napply COVX.\napply TCCOH; vauto.\napply (@wf_sbE G) in SBXY.\nunfolder in SBXY; basic_solver.\n}\nexfalso; apply COVX.\neapply NSB0; basic_solver 12.\n}\nassert (fwbob⁺ n y) as BOB.\n{\ndestruct NX as [NX|NX]; subst; [by apply t_step|].\napply sb_fwbob_in_fwbob.\neexists; eauto.\n}\nclear x H COVX NX SBXY.\ndesf.\n{\nassert (NY := NSB0).\napply NCOV in NSB0.\nunfold coverable in NSB0.\napply not_and_or in NSB0; desf.\n{\nexfalso; apply NSB0.\napply NY.\n}\napply not_or_and in NSB0; desf.\napply not_or_and in NSB0; desf.\napply NSB2; unnw; split; auto.\nclear NSB0 NSB1 NSB2.\nred.\nintros x' [y' H'].\napply seq_eqv_r in H'; desf.\napply rfi_union_rfe in H'; destruct H' as [RFI|RFE].\n{\ndestruct RFI as [RF SBXY].\napply (w_covered_issued TCCOH); split.\n2: by eapply NY; eexists; apply seq_eqv_r; eauto.\napply (wf_rfD WF) in RF.\napply seq_eqv_l in RF; desf.\n}\neapply WMIN1.\neexists.\napply seq_eqv_r.\nsplit; eauto.\napply seq_eqv_l; split.\n{\napply wf_rfeD in RFE; auto;            apply seq_eqv_l in RFE; desf.\n}\neapply ct_ct.\nexists y'.\nsplit.\n{\napply t_step.\nleft.\nby apply rfe_in_ar.\n}\nhahn_rewrite fwbob_in_bob in BOB.\nhahn_rewrite bob_in_ar in BOB.\neapply clos_trans_mori.\n2: by apply BOB.\nbasic_solver.\n}\nassert (exists f, (F∩₁Sc) f /\\ ~ covered T f /\\ E f) as FF.\n{\nexists n; splits; auto; apply NSB0.\n}\nspecialize (FMIN FF); clear FF; desf.\ndestruct (exists_next (covered T) f FMIN2 FMIN0) as [m MSB]; desf.\ndestruct MSB as [MSB|MSB].\n{\ndesf.\nspecialize (NCOV f MSB0).\napply NCOV.\nsplit.\n{\napply MSB0.\n}\nright; split; auto.\n{\ntype_solver.\n}\nintros x [z X].\napply seq_eqv_r in X; desf.\neapply FMIN1.\napply seq_eqv_l; split.\n{\ncdes IMMCON.\napply (wf_scD Wf_sc) in X.\napply seq_eqv_l in X; desf.\n}\napply seq_eqv_r; split; auto.\napply t_step.\nred.\nleft.\nby apply sc_in_ar.\n}\nassert (R m) as RM.\n{\nspecialize (RorF m MSB0).\ndesf; auto.\nexfalso.\ndestruct MSB0 as [MSB1 MSB2].\napply MSB2.\neapply FMIN1.\nhahn_rewrite seq_eqv_r.\nhahn_rewrite seq_eqv_l.\nsplits; eauto.\napply t_step.\nleft.\napply bob_in_ar.\napply sb_to_f_in_bob.\napply seq_eqv_r.\nsplit; auto.\nmode_solver.\n}\ndestruct (WIS m RM MSB0) as [w' [WW [WRF WI]]].\n{\nby apply NCOV.\n}\napply WI.\neapply WMIN1.\neexists.\napply seq_eqv_r.\nsplits; eauto.\nhahn_rewrite seq_eqv_l; splits; auto.\nassert ((ar G sc)⁺ w' f) as wfWF'.\n{\napply rfi_union_rfe in WRF; destruct WRF as [[RFI SB]|RFE].\n{\nassert (sb w' f) as SB'.\n{\neapply sb_trans; eauto.\n}\napply t_step.\napply (bob_in_ar sc).\napply sb_to_f_in_bob.\napply seq_eqv_r.\nsplit; auto.\nmode_solver.\n}\neapply t_trans; apply t_step.\n{\napply rfe_in_ar; eauto.\n}\napply bob_in_ar.\napply sb_to_f_in_bob.\napply seq_eqv_r.\nsplit; auto.\nmode_solver.\n}\nassert ((ar G sc ∪ rf ⨾ ppo ∩ same_loc)⁺ w' f) as wfWF.\n{\neapply clos_trans_mori.\n2: by apply wfWF'.\nbasic_solver.\n}\neapply t_trans; [apply wfWF|].\napply rt_ct; exists n.\nsplit.\n2: eapply clos_trans_mori; [|by apply BOB].\n2: rewrite fwbob_in_bob; rewrite bob_in_ar; basic_solver.\ndestruct (classic (f = n)) as [|FNEQ]; subst.\n{\napply rt_refl.\n}\napply rt_step.\nleft.\napply sc_in_ar.\ncdes IMMCON.\nedestruct wf_sc_total as [J|J]; eauto.\n{\nsplit; [split|].\n2,3: by apply FMIN.\napply (dom_r (wf_sbE G)) in MSB.\napply seq_eqv_r in MSB.\ndesf.\n}\n{\nsplit; [split|].\n2,3: by apply nRorF.\napply (dom_l (wf_sbE G)) in HSB.\napply seq_eqv_l in HSB.\ndesf.\n}\nexfalso.\napply NSB0.\neapply FMIN1.\napply seq_eqv_l; split; auto.\napply seq_eqv_r; split; eauto.\napply t_step.\nleft.\nby apply sc_in_ar.\n}\nassert (forall e, next G (covered T) e -> (F∩₁Sc) e) as FSC.\n{\nintros e H.\nspecialize (NWNEXT e H); specialize (NCOV e H);        specialize (NRNEXT e H).\ndestruct (lab_rwf lab e) as [ | [| FF]]; vauto; split; auto.\ndestruct (classic (Sc e)) as [SC|NSC]; auto.\nexfalso.\napply NCOV; split.\n{\napply H.\n}\nright; split; auto.\nunfold dom_cond.\nred.\nins.\ndestruct H0 as [y H0].\napply seq_eqv_r in H0; desf.\neapply wf_scD in H0.\n2: by apply IMMCON.\napply seq_eqv_l in H0.\ndestruct H0 as [_ H0].\napply seq_eqv_r in H0.\nmode_solver.\n}\nassert (exists f', (F∩₁Sc) f' /\\ ~ covered T f' /\\ E f') as XF.\n{\nexists e'; splits; try by apply N_FIN.\nby apply FSC.\n}\nexfalso.\ndestruct (FMIN XF) as [esc X]; desf.\ndestruct (exists_next (covered T) esc X2 X0); desf.\ndestruct H; desf.\n{\neapply NCOV; eauto.\nsplit; [apply H0|].\nright; split; [by apply X|].\nintros x [y H].\neapply X1.\napply seq_eqv_r in H; desf.\napply seq_eqv_l; split.\n{\neapply wf_scD in H.\n2: by apply IMMCON.\napply seq_eqv_l in H; desf.\n}\napply seq_eqv_r; split; auto.\napply t_step.\nleft.\nby apply sc_in_ar.\n}\nspecialize (FSC _ H0).\napply (NCOV _ H0).\ndestruct TCCOH; desf.\napply CC.\nrewrite seq_eqv_r, seq_eqv_l in X1.\neapply X1.\nsplits; eauto.\napply t_step.\nleft.\napply bob_in_ar.\napply sb_to_f_in_bob.\napply seq_eqv_r.\nsplit; auto.\nmode_solver.\n"}]