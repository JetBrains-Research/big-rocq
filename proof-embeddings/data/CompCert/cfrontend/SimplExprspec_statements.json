{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/SimplExprspec.v","fileSamples":[{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) : (do X <- f; g X) z1 = Res y z3 I ->\nexists\n  (x : A) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  f z1 = Res x z2 I1 /\\ g x z2 = Res y z3 I2.","proofString":"unfold bind.\ndestruct (f z1).\ncongruence.\ncaseEq (g a g'); intros; inv H0.\neconstructor; econstructor; econstructor; econstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) : match f z1 with\n| Err msg => Err msg\n| Res a g' i =>\n    match g a g' with\n    | Err msg => Err msg\n    | Res b g'' i' =>\n        Res b g'' (Ple_trans (gen_next z1) (gen_next g') (gen_next g'') i i')\n    end\nend = Res y z3 I ->\nexists\n  (x : A) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  f z1 = Res x z2 I1 /\\ g x z2 = Res y z3 I2.","proofString":"destruct (f z1).\ncongruence.\ncaseEq (g a g'); intros; inv H0.\neconstructor; econstructor; econstructor; econstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (e : errmsg) : Err e = Res y z3 I ->\nexists\n  (x : A) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  Err e = Res x z2 I1 /\\ g x z2 = Res y z3 I2.","proofString":"congruence."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (a : A) (g' : generator) (p : Ple (gen_next z1) (gen_next g')) : match g a g' with\n| Err msg => Err msg\n| Res b g'' i' =>\n    Res b g'' (Ple_trans (gen_next z1) (gen_next g') (gen_next g'') p i')\nend = Res y z3 I ->\nexists\n  (x : A) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  Res a g' p = Res x z2 I1 /\\ g x z2 = Res y z3 I2.","proofString":"caseEq (g a g'); intros; inv H0.\neconstructor; econstructor; econstructor; econstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (a : A) (g' : generator) (p : Ple (gen_next z1) (gen_next g')) (p0 : Ple (gen_next g') (gen_next z3)) (H : g a g' = Res y z3 p0) : exists\n  (x : A) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  Res a g' p = Res x z2 I1 /\\ g x z2 = Res y z3 I2.","proofString":"econstructor; econstructor; econstructor; econstructor; eauto."},{"statement":"forall (A B Csyntax : Type) (f : mon (A * B)) (g : A -> B -> mon Csyntax)\n  (y : Csyntax) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)),\n(do p <- f; g (fst p) (snd p)) z1 = Res y z3 I ->\nexists\n  (x1 : A) (x2 : B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  f z1 = Res (x1, x2) z2 I1 /\\ g x1 x2 z2 = Res y z3 I2.","proofString":"intros.\nexploit bind_inversion; eauto.\nintros [[x1 x2] [z2 [I1 [I2 [P Q]]]]].\nsimpl in Q.\nexists x1; exists x2; exists z2; exists I1; exists I2; auto."},{"statement":"(A : Type) (B : Type) (Csyntax : Type) (f : mon (A * B)) (g : A -> B -> mon Csyntax) (y : Csyntax) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (H : (do p <- f; g (fst p) (snd p)) z1 = Res y z3 I) : exists\n  (x1 : A) (x2 : B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  f z1 = Res (x1, x2) z2 I1 /\\ g x1 x2 z2 = Res y z3 I2.","proofString":"exploit bind_inversion; eauto.\nintros [[x1 x2] [z2 [I1 [I2 [P Q]]]]].\nsimpl in Q.\nexists x1; exists x2; exists z2; exists I1; exists I2; auto."},{"statement":"(A : Type) (B : Type) (Csyntax : Type) (f : mon (A * B)) (g : A -> B -> mon Csyntax) (y : Csyntax) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (H : (do p <- f; g (fst p) (snd p)) z1 = Res y z3 I) : (exists\n   (x : A * B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n (I2 : Ple (gen_next z2) (gen_next z3)),\n   f z1 = Res x z2 I1 /\\\n   (fun p : A * B => g (fst p) (snd p)) x z2 = Res y z3 I2) ->\nexists\n  (x1 : A) (x2 : B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) \n(I2 : Ple (gen_next z2) (gen_next z3)),\n  f z1 = Res (x1, x2) z2 I1 /\\ g x1 x2 z2 = Res y z3 I2.","proofString":"intros [[x1 x2] [z2 [I1 [I2 [P Q]]]]].\nsimpl in Q.\nexists x1; exists x2; exists z2; exists I1; exists I2; auto."},{"statement":"(A : Type) (B : Type) (Csyntax : Type) (f : mon (A * B)) (g : A -> B -> mon Csyntax) (y : Csyntax) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (H : (do p <- f; g (fst p) (snd p)) z1 = Res y z3 I) (x1 : A) (x2 : B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) (I2 : Ple (gen_next z2) (gen_next z3)) (P : f z1 = Res (x1, x2) z2 I1) (Q : g (fst (x1, x2)) (snd (x1, x2)) z2 = Res y z3 I2) : exists\n  (x0 : A) (x3 : B) (z0 : generator) (I0 : Ple (gen_next z1) (gen_next z0)) \n(I3 : Ple (gen_next z0) (gen_next z3)),\n  f z1 = Res (x0, x3) z0 I0 /\\ g x0 x3 z0 = Res y z3 I3.","proofString":"simpl in Q.\nexists x1; exists x2; exists z2; exists I1; exists I2; auto."},{"statement":"(A : Type) (B : Type) (Csyntax : Type) (f : mon (A * B)) (g : A -> B -> mon Csyntax) (y : Csyntax) (z1 z3 : generator) (I : Ple (gen_next z1) (gen_next z3)) (H : (do p <- f; g (fst p) (snd p)) z1 = Res y z3 I) (x1 : A) (x2 : B) (z2 : generator) (I1 : Ple (gen_next z1) (gen_next z2)) (I2 : Ple (gen_next z2) (gen_next z3)) (P : f z1 = Res (x1, x2) z2 I1) (Q : g x1 x2 z2 = Res y z3 I2) : exists\n  (x0 : A) (x3 : B) (z0 : generator) (I0 : Ple (gen_next z1) (gen_next z0)) \n(I3 : Ple (gen_next z0) (gen_next z3)),\n  f z1 = Res (x0, x3) z0 I0 /\\ g x0 x3 z0 = Res y z3 I3.","proofString":"exists x1; exists x2; exists z2; exists I1; exists I2; auto."},{"statement":"(ty : type) (g1 : generator) (id : ident) (g2 : generator) (I : Ple (gen_next g1) (gen_next g2)) (H : gensym ty g1 = Res id g2 I) : within id g1 g2.","proofString":"monadInv H.\nsplit.\napply Ple_refl.\napply Plt_succ."},{"statement":"(ty : type) (g1 : generator) (I : Ple (gen_next g1)\n  (gen_next\n     {|\n       gen_next := Pos.succ (gen_next g1);\n       gen_trail := (gen_next g1, ty) :: gen_trail g1\n     |})) : within (gen_next g1) g1\n  {|\n    gen_next := Pos.succ (gen_next g1);\n    gen_trail := (gen_next g1, ty) :: gen_trail g1\n  |}.","proofString":"split.\napply Ple_refl.\napply Plt_succ."},{"statement":"(ty : type) (g1 : generator) (I : Ple (gen_next g1)\n  (gen_next\n     {|\n       gen_next := Pos.succ (gen_next g1);\n       gen_trail := (gen_next g1, ty) :: gen_trail g1\n     |})) : Ple (gen_next g1) (gen_next g1).","proofString":"apply Ple_refl."},{"statement":"(ty : type) (g1 : generator) (I : Ple (gen_next g1)\n  (gen_next\n     {|\n       gen_next := Pos.succ (gen_next g1);\n       gen_trail := (gen_next g1, ty) :: gen_trail g1\n     |})) : Plt (gen_next g1)\n  (gen_next\n     {|\n       gen_next := Pos.succ (gen_next g1);\n       gen_trail := (gen_next g1, ty) :: gen_trail g1\n     |}).","proofString":"apply Plt_succ."},{"statement":"(id : ident) (g1 g2 g1' g2' : generator) (H : within id g1 g2) (H0 : Ple (gen_next g1') (gen_next g1)) (H1 : Ple (gen_next g2) (gen_next g2')) : within id g1' g2'.","proofString":"destruct H.\nsplit.\neapply Ple_trans; eauto.\neapply Plt_Ple_trans; eauto."},{"statement":"(id : ident) (g1 g2 g1' g2' : generator) (H : Ple (gen_next g1) id) (H2 : Plt id (gen_next g2)) (H0 : Ple (gen_next g1') (gen_next g1)) (H1 : Ple (gen_next g2) (gen_next g2')) : within id g1' g2'.","proofString":"split.\neapply Ple_trans; eauto.\neapply Plt_Ple_trans; eauto."},{"statement":"(id : ident) (g1 g2 g1' g2' : generator) (H : Ple (gen_next g1) id) (H2 : Plt id (gen_next g2)) (H0 : Ple (gen_next g1') (gen_next g1)) (H1 : Ple (gen_next g2) (gen_next g2')) : Ple (gen_next g1') id.","proofString":"eapply Ple_trans; eauto."},{"statement":"(id : ident) (g1 g2 g1' g2' : generator) (H : Ple (gen_next g1) id) (H2 : Plt id (gen_next g2)) (H0 : Ple (gen_next g1') (gen_next g1)) (H1 : Ple (gen_next g2) (gen_next g2')) : Plt id (gen_next g2').","proofString":"eapply Plt_Ple_trans; eauto."},{"statement":"(l : list ident) (g1 g2 g1' g2' : generator) (H : contained l g1 g2) (H0 : Ple (gen_next g1') (gen_next g1)) (H1 : Ple (gen_next g2) (gen_next g2')) (id : ident) (H2 : In id l) : within id g1' g2'.","proofString":"eapply within_widen; eauto."},{"statement":"(id : ident) (l : list ident) (g1 g2 : generator) (H : within id g1 g2) (H0 : contained l g1 g2) (id0 : ident) (H1 : In id0 (id :: l)) : within id0 g1 g2.","proofString":"simpl in H1; destruct H1.\nsubst id0.\nauto.\nauto."},{"statement":"(id : ident) (l : list ident) (g1 g2 : generator) (H : within id g1 g2) (H0 : contained l g1 g2) (id0 : ident) (H1 : id = id0) : within id0 g1 g2.","proofString":"subst id0.\nauto."},{"statement":"(id : ident) (l : list ident) (g1 g2 : generator) (H : within id g1 g2) (H0 : contained l g1 g2) : within id g1 g2.","proofString":"auto."},{"statement":"(id : ident) (l : list ident) (g1 g2 : generator) (H : within id g1 g2) (H0 : contained l g1 g2) (id0 : ident) (H1 : In id0 l) : within id0 g1 g2.","proofString":"auto."},{"statement":"(l1 l2 : list ident) (g1 g2 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g1 g2) (id : ident) (H1 : In id (l1 ++ l2)) : within id g1 g2.","proofString":"destruct (in_app_or _ _ _ H1); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x y : ident) (H1 : In x l1) (H2 : In y l2) : x <> y.","proofString":"red; intro; subst y.\nexploit H; eauto.\nintros [A B].\nexploit H0; eauto.\nintros [C D].\nelim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) : False.","proofString":"exploit H; eauto.\nintros [A B].\nexploit H0; eauto.\nintros [C D].\nelim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) : within x g1 g2 -> False.","proofString":"intros [A B].\nexploit H0; eauto.\nintros [C D].\nelim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) (A : Ple (gen_next g1) x) (B : Plt x (gen_next g2)) : False.","proofString":"exploit H0; eauto.\nintros [C D].\nelim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) (A : Ple (gen_next g1) x) (B : Plt x (gen_next g2)) : within x g2 g3 -> False.","proofString":"intros [C D].\nelim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) (A : Ple (gen_next g1) x) (B : Plt x (gen_next g2)) (C : Ple (gen_next g2) x) (D : Plt x (gen_next g3)) : False.","proofString":"elim (Plt_strict x).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l1 : list ident) (g2 : generator) (l2 : list ident) (g3 : generator) (H : contained l1 g1 g2) (H0 : contained l2 g2 g3) (x : ident) (H1 : In x l1) (H2 : In x l2) (A : Ple (gen_next g1) x) (B : Plt x (gen_next g2)) (C : Ple (gen_next g2) x) (D : Plt x (gen_next g3)) : Plt x x.","proofString":"apply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l : list ident) (g2 : generator) (id : ident) (g3 : generator) (H : contained l g1 g2) (H0 : within id g2 g3) (H1 : In id l) : False.","proofString":"exploit H; eauto.\nintros [C D].\ndestruct H0 as [A B].\nelim (Plt_strict id).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l : list ident) (g2 : generator) (id : ident) (g3 : generator) (H : contained l g1 g2) (H0 : within id g2 g3) (H1 : In id l) : within id g1 g2 -> False.","proofString":"intros [C D].\ndestruct H0 as [A B].\nelim (Plt_strict id).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l : list ident) (g2 : generator) (id : ident) (g3 : generator) (H : contained l g1 g2) (H0 : within id g2 g3) (H1 : In id l) (C : Ple (gen_next g1) id) (D : Plt id (gen_next g2)) : False.","proofString":"destruct H0 as [A B].\nelim (Plt_strict id).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l : list ident) (g2 : generator) (id : ident) (g3 : generator) (H : contained l g1 g2) (A : Ple (gen_next g2) id) (B : Plt id (gen_next g3)) (H1 : In id l) (C : Ple (gen_next g1) id) (D : Plt id (gen_next g2)) : False.","proofString":"elim (Plt_strict id).\napply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(g1 : generator) (l : list ident) (g2 : generator) (id : ident) (g3 : generator) (H : contained l g1 g2) (A : Ple (gen_next g2) id) (B : Plt id (gen_next g3)) (H1 : In id l) (C : Ple (gen_next g1) id) (D : Plt id (gen_next g2)) : Plt id id.","proofString":"apply Plt_Ple_trans with (gen_next g2); auto."},{"statement":"(dst : destination) (g1 g2 : generator) (H : dest_below dst g1) (H0 : Ple (gen_next g1) (gen_next g2)) : dest_below dst g2.","proofString":"destruct dst; simpl in *; eauto using Plt_Ple_trans."},{"statement":"(tmp : ident) (tycast ty : type) (g1 g2 : generator) (H : within tmp g1 g2) : dest_below (For_set (SDbase tycast ty tmp)) g2.","proofString":"destruct H.\nauto."},{"statement":"(tmp : ident) (tycast ty : type) (g1 g2 : generator) (H : Ple (gen_next g1) tmp) (H0 : Plt tmp (gen_next g2)) : dest_below (For_set (SDbase tycast ty tmp)) g2.","proofString":"auto."},{"statement":"(ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (I : Ple (gen_next g2) (gen_next g3)) (H : dest_below (For_set sd) g1) (H0 : (if type_eq ty (sd_head_type sd) then ret (sd_temp sd) else gensym ty) g2 =\nRes tmp g3 I) (H1 : Ple (gen_next g1) (gen_next g2)) : Plt (sd_temp sd) (gen_next g1) /\\\nPle (gen_next g1) (gen_next g2) /\\\nPle (gen_next g2) (gen_next g3) /\\\n(if type_eq ty (sd_head_type sd) then tmp = sd_temp sd else within tmp g2 g3).","proofString":"destruct type_eq.\ninv H0.\ntauto.\neauto with gensym."},{"statement":"(ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (I : Ple (gen_next g2) (gen_next g3)) (H : dest_below (For_set sd) g1) (e : ty = sd_head_type sd) (H0 : ret (sd_temp sd) g2 = Res tmp g3 I) (H1 : Ple (gen_next g1) (gen_next g2)) : Plt (sd_temp sd) (gen_next g1) /\\\nPle (gen_next g1) (gen_next g2) /\\\nPle (gen_next g2) (gen_next g3) /\\ tmp = sd_temp sd.","proofString":"inv H0.\ntauto."},{"statement":"(sd : set_destination) (g1 g3 : generator) (I : Ple (gen_next g3) (gen_next g3)) (H : dest_below (For_set sd) g1) (H1 : Ple (gen_next g1) (gen_next g3)) : Plt (sd_temp sd) (gen_next g1) /\\\nPle (gen_next g1) (gen_next g3) /\\\nPle (gen_next g3) (gen_next g3) /\\ sd_temp sd = sd_temp sd.","proofString":"tauto."},{"statement":"(ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (I : Ple (gen_next g2) (gen_next g3)) (H : dest_below (For_set sd) g1) (n : ty <> sd_head_type sd) (H0 : gensym ty g2 = Res tmp g3 I) (H1 : Ple (gen_next g1) (gen_next g2)) : Plt (sd_temp sd) (gen_next g1) /\\\nPle (gen_next g1) (gen_next g2) /\\\nPle (gen_next g2) (gen_next g3) /\\ within tmp g2 g3.","proofString":"eauto with gensym."},{"statement":"(tycast ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then tmp = sd_temp sd else within tmp g2 g3) : dest_below (For_set (SDcons tycast ty tmp sd)) g3.","proofString":"simpl.\ndestruct type_eq.\nsubst tmp.\nunfold Ple, Plt in *; lia.\ndestruct S; auto."},{"statement":"(tycast ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then tmp = sd_temp sd else within tmp g2 g3) : Plt tmp (gen_next g3).","proofString":"destruct type_eq.\nsubst tmp.\nunfold Ple, Plt in *; lia.\ndestruct S; auto."},{"statement":"(tycast ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) (S : tmp = sd_temp sd) : Plt tmp (gen_next g3).","proofString":"subst tmp.\nunfold Ple, Plt in *; lia."},{"statement":"(tycast ty : type) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) : Plt (sd_temp sd) (gen_next g3).","proofString":"unfold Ple, Plt in *; lia."},{"statement":"(tycast ty : type) (tmp : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (n : ty <> sd_head_type sd) (S : within tmp g2 g3) : Plt tmp (gen_next g3).","proofString":"destruct S; auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : dest_below (For_set sd) g1) (H0 : contained l g1 g2) : ~ In (sd_temp sd) l.","proofString":"simpl in H.\nred; intros.\nexploit H0; eauto.\nintros [A B].\nelim (Plt_strict (sd_temp sd)).\napply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : Plt (sd_temp sd) (gen_next g1)) (H0 : contained l g1 g2) : ~ In (sd_temp sd) l.","proofString":"red; intros.\nexploit H0; eauto.\nintros [A B].\nelim (Plt_strict (sd_temp sd)).\napply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : Plt (sd_temp sd) (gen_next g1)) (H0 : contained l g1 g2) (H1 : In (sd_temp sd) l) : False.","proofString":"exploit H0; eauto.\nintros [A B].\nelim (Plt_strict (sd_temp sd)).\napply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : Plt (sd_temp sd) (gen_next g1)) (H0 : contained l g1 g2) (H1 : In (sd_temp sd) l) : within (sd_temp sd) g1 g2 -> False.","proofString":"intros [A B].\nelim (Plt_strict (sd_temp sd)).\napply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : Plt (sd_temp sd) (gen_next g1)) (H0 : contained l g1 g2) (H1 : In (sd_temp sd) l) (A : Ple (gen_next g1) (sd_temp sd)) (B : Plt (sd_temp sd) (gen_next g2)) : False.","proofString":"elim (Plt_strict (sd_temp sd)).\napply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(sd : set_destination) (g1 g2 : generator) (l : list ident) (H : Plt (sd_temp sd) (gen_next g1)) (H0 : contained l g1 g2) (H1 : In (sd_temp sd) l) (A : Ple (gen_next g1) (sd_temp sd)) (B : Plt (sd_temp sd) (gen_next g2)) : Plt (sd_temp sd) (sd_temp sd).","proofString":"apply Plt_Ple_trans with (gen_next g1); auto."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 g4 : generator) (H : good_temp_for_sd ty t sd g1 g2 g3) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : list_disjoint tmp1 (t :: tmp2).","proofString":"destruct H as (P & Q & R & S).\napply list_disjoint_cons_r; eauto with gensym.\ndestruct type_eq.\nsubst t.\neapply sd_temp_notin; eauto.\neauto with gensym."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 g4 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : list_disjoint tmp1 (t :: tmp2).","proofString":"apply list_disjoint_cons_r; eauto with gensym.\ndestruct type_eq.\nsubst t.\neapply sd_temp_notin; eauto.\neauto with gensym."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 g4 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : ~ In t tmp1.","proofString":"destruct type_eq.\nsubst t.\neapply sd_temp_notin; eauto.\neauto with gensym."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 g4 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) (S : t = sd_temp sd) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : ~ In t tmp1.","proofString":"subst t.\neapply sd_temp_notin; eauto."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (sd : set_destination) (g1 g2 g3 g4 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : ~ In (sd_temp sd) tmp1.","proofString":"eapply sd_temp_notin; eauto."},{"statement":"(tmp1 tmp2 : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 g4 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (n : ty <> sd_head_type sd) (S : within t g2 g3) (H0 : contained tmp1 g1 g2) (H1 : contained tmp2 g3 g4) : ~ In t tmp1.","proofString":"eauto with gensym."},{"statement":"(tmp : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (H : good_temp_for_sd ty t sd g1 g2 g3) : In t (sd_temp sd :: used_temp_for_sd ty t sd ++ tmp).","proofString":"destruct H as (P & Q & R & S).\nunfold used_temp_for_sd.\ndestruct type_eq.\nsubst t.\nauto with coqlib.\nsimpl; auto."},{"statement":"(tmp : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) : In t (sd_temp sd :: used_temp_for_sd ty t sd ++ tmp).","proofString":"unfold used_temp_for_sd.\ndestruct type_eq.\nsubst t.\nauto with coqlib.\nsimpl; auto."},{"statement":"(tmp : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) : In t\n  (sd_temp sd\n   :: (if type_eq ty (sd_head_type sd) then nil else t :: nil) ++ tmp).","proofString":"destruct type_eq.\nsubst t.\nauto with coqlib.\nsimpl; auto."},{"statement":"(tmp : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) (S : t = sd_temp sd) : In t (sd_temp sd :: nil ++ tmp).","proofString":"subst t.\nauto with coqlib."},{"statement":"(tmp : list ident) (ty : type) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (e : ty = sd_head_type sd) : In (sd_temp sd) (sd_temp sd :: nil ++ tmp).","proofString":"auto with coqlib."},{"statement":"(tmp : list ident) (ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (n : ty <> sd_head_type sd) (S : within t g2 g3) : In t (sd_temp sd :: (t :: nil) ++ tmp).","proofString":"simpl; auto."},{"statement":"(ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (H : good_temp_for_sd ty t sd g1 g2 g3) : contained (used_temp_for_sd ty t sd) g2 g3.","proofString":"destruct H as (P & Q & R & S).\nunfold used_temp_for_sd.\ndestruct type_eq; eauto with gensym."},{"statement":"(ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) : contained (used_temp_for_sd ty t sd) g2 g3.","proofString":"unfold used_temp_for_sd.\ndestruct type_eq; eauto with gensym."},{"statement":"(ty : type) (t : ident) (sd : set_destination) (g1 g2 g3 : generator) (P : Plt (sd_temp sd) (gen_next g1)) (Q : Ple (gen_next g1) (gen_next g2)) (R : Ple (gen_next g2) (gen_next g3)) (S : if type_eq ty (sd_head_type sd) then t = sd_temp sd else within t g2 g3) : contained (if type_eq ty (sd_head_type sd) then nil else t :: nil) g2 g3.","proofString":"destruct type_eq; eauto with gensym."},{"statement":"(dst : destination) (sl : list statement) (a : expr) (sl' : list statement) (a' : expr) (H : finish dst sl a = (sl', a')) : sl' = sl ++ final dst a.","proofString":"destruct dst; simpl in *; inv H; rewrite ? app_nil_r; auto."},{"statement":"(dst : destination) (sl : list statement) (a : expr) (sl' : list statement) (a' : expr) (H : finish dst sl a = (sl', a')) : a' = a.","proofString":"destruct dst; simpl in *; inv H; auto."},{"statement":"(dst : destination) (tmps : list ident) : incl tmps (add_dest dst tmps).","proofString":"destruct dst; simpl; eauto with coqlib."},{"statement":"(le : temp_env) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr le dst r sl a tmps) : tr_expr le dst r sl a (add_dest dst tmps).","proofString":"apply tr_expr_monotone with tmps; auto.\napply add_dest_incl."},{"statement":"(le : temp_env) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr le dst r sl a tmps) : incl tmps (add_dest dst tmps).","proofString":"apply add_dest_incl."},{"statement":"(l : expr) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match l with\n| Efield r f _ =>\n    match typeof r with\n    | Tstruct id _ => is_bitfield_access_aux ce field_offset id f\n    | Tunion id _ => is_bitfield_access_aux ce union_field_offset id f\n    | _ => error (msg \"is_bitfield_access\")\n    end\n| _ => ret Full\nend g = Res bf g' I) : match l with\n| Efield r f _ =>\n    exists (co : composite) (ofs : Z),\n      match typeof r with\n      | Tstruct id _ =>\n          ce ! id = Some co /\\\n          field_offset ce f (co_members co) = OK (ofs, bf)\n      | Tunion id _ =>\n          ce ! id = Some co /\\\n          union_field_offset ce f (co_members co) = OK (ofs, bf)\n      | _ => False\n      end\n| _ => bf = Full\nend.","proofString":"destruct l; try (monadInv H; auto).\nassert (AUX: forall fn id,               is_bitfield_access_aux ce fn id i g = Res bf g' I ->               exists co ofs,               ce!id = Some co /\\ fn ce i (co_members co) = OK (ofs, bf)).\nunfold is_bitfield_access_aux; intros.\ndestruct ce!id as [co|]; try discriminate.\ndestruct (fn ce i (co_members co)) as [[ofs1 bf1]|] eqn:FN; inv H0.\nexists co, ofs1; auto.\ndestruct (typeof l); try discriminate; apply AUX; auto."},{"statement":"(l : expr) (i : ident) (t : type) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match typeof l with\n| Tstruct id _ => is_bitfield_access_aux ce field_offset id i\n| Tunion id _ => is_bitfield_access_aux ce union_field_offset id i\n| _ => error (msg \"is_bitfield_access\")\nend g = Res bf g' I) : exists (co : composite) (ofs : Z),\n  match typeof l with\n  | Tstruct id _ =>\n      ce ! id = Some co /\\ field_offset ce i (co_members co) = OK (ofs, bf)\n  | Tunion id _ =>\n      ce ! id = Some co /\\\n      union_field_offset ce i (co_members co) = OK (ofs, bf)\n  | _ => False\n  end.","proofString":"assert (AUX: forall fn id,               is_bitfield_access_aux ce fn id i g = Res bf g' I ->               exists co ofs,               ce!id = Some co /\\ fn ce i (co_members co) = OK (ofs, bf)).\nunfold is_bitfield_access_aux; intros.\ndestruct ce!id as [co|]; try discriminate.\ndestruct (fn ce i (co_members co)) as [[ofs1 bf1]|] eqn:FN; inv H0.\nexists co, ofs1; auto.\ndestruct (typeof l); try discriminate; apply AUX; auto."},{"statement":"(l : expr) (i : ident) (t : type) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match typeof l with\n| Tstruct id _ => is_bitfield_access_aux ce field_offset id i\n| Tunion id _ => is_bitfield_access_aux ce union_field_offset id i\n| _ => error (msg \"is_bitfield_access\")\nend g = Res bf g' I) : forall (fn : composite_env -> ident -> members -> res (Z * bitfield))\n  (id : ident),\nis_bitfield_access_aux ce fn id i g = Res bf g' I ->\nexists (co : composite) (ofs : Z),\n  ce ! id = Some co /\\ fn ce i (co_members co) = OK (ofs, bf).","proofString":"unfold is_bitfield_access_aux; intros.\ndestruct ce!id as [co|]; try discriminate.\ndestruct (fn ce i (co_members co)) as [[ofs1 bf1]|] eqn:FN; inv H0.\nexists co, ofs1; auto."},{"statement":"(l : expr) (i : ident) (t : type) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match typeof l with\n| Tstruct id0 _ => is_bitfield_access_aux ce field_offset id0 i\n| Tunion id0 _ => is_bitfield_access_aux ce union_field_offset id0 i\n| _ => error (msg \"is_bitfield_access\")\nend g = Res bf g' I) (fn : composite_env -> ident -> members -> res (Z * bitfield)) (id : ident) (H0 : match ce ! id with\n| Some co =>\n    match fn ce i (co_members co) with\n    | OK (_, bf0) => ret bf0\n    | Error _ => error (MSG \"unknown field \" :: CTX i :: nil)\n    end\n| None => error (MSG \"unknown composite \" :: CTX id :: nil)\nend g = Res bf g' I) : exists (co : composite) (ofs : Z),\n  ce ! id = Some co /\\ fn ce i (co_members co) = OK (ofs, bf).","proofString":"destruct ce!id as [co|]; try discriminate.\ndestruct (fn ce i (co_members co)) as [[ofs1 bf1]|] eqn:FN; inv H0.\nexists co, ofs1; auto."},{"statement":"(l : expr) (i : ident) (t : type) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match typeof l with\n| Tstruct id0 _ => is_bitfield_access_aux ce field_offset id0 i\n| Tunion id0 _ => is_bitfield_access_aux ce union_field_offset id0 i\n| _ => error (msg \"is_bitfield_access\")\nend g = Res bf g' I) (fn : composite_env -> ident -> members -> res (Z * bitfield)) (id : ident) (co : composite) (H0 : match fn ce i (co_members co) with\n| OK (_, bf0) => ret bf0\n| Error _ => error (MSG \"unknown field \" :: CTX i :: nil)\nend g = Res bf g' I) : exists (co0 : composite) (ofs : Z),\n  Some co = Some co0 /\\ fn ce i (co_members co0) = OK (ofs, bf).","proofString":"destruct (fn ce i (co_members co)) as [[ofs1 bf1]|] eqn:FN; inv H0.\nexists co, ofs1; auto."},{"statement":"(l : expr) (i : ident) (t : type) (bf : bitfield) (g' : generator) (I : Ple (gen_next g') (gen_next g')) (H : match typeof l with\n| Tstruct id0 _ => is_bitfield_access_aux ce field_offset id0 i\n| Tunion id0 _ => is_bitfield_access_aux ce union_field_offset id0 i\n| _ => error (msg \"is_bitfield_access\")\nend g' = Res bf g' I) (fn : composite_env -> ident -> members -> res (Z * bitfield)) (id : ident) (co : composite) (ofs1 : Z) (FN : fn ce i (co_members co) = OK (ofs1, bf)) : exists (co0 : composite) (ofs : Z),\n  Some co = Some co0 /\\ fn ce i (co_members co0) = OK (ofs, bf).","proofString":"exists co, ofs1; auto."},{"statement":"(l : expr) (i : ident) (t : type) (g : generator) (bf : bitfield) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : match typeof l with\n| Tstruct id _ => is_bitfield_access_aux ce field_offset id i\n| Tunion id _ => is_bitfield_access_aux ce union_field_offset id i\n| _ => error (msg \"is_bitfield_access\")\nend g = Res bf g' I) (AUX : forall (fn : composite_env -> ident -> members -> res (Z * bitfield))\n  (id : ident),\nis_bitfield_access_aux ce fn id i g = Res bf g' I ->\nexists (co : composite) (ofs : Z),\n  ce ! id = Some co /\\ fn ce i (co_members co) = OK (ofs, bf)) : exists (co : composite) (ofs : Z),\n  match typeof l with\n  | Tstruct id _ =>\n      ce ! id = Some co /\\ field_offset ce i (co_members co) = OK (ofs, bf)\n  | Tunion id _ =>\n      ce ! id = Some co /\\\n      union_field_offset ce i (co_members co) = OK (ofs, bf)\n  | _ => False\n  end.","proofString":"destruct (typeof l); try discriminate; apply AUX; auto."},{"statement":"(ty : type) (a : expr) (g : generator) (sl : list statement) (b : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : (if type_is_volatile ty\n then\n  do t <- gensym ty;\n  do bf <- is_bitfield_access ce a;\n  ret (make_set bf t a :: nil, Etempvar t ty)\n else ret (nil, a)) g = Res (sl, b) g' I) : exists tmps : list ident, tr_rvalof ty a sl b tmps /\\ contained tmps g g'.","proofString":"destruct (type_is_volatile ty) eqn:?; monadInv H.\nexists (x :: nil); split; eauto with gensym.\neconstructor; eauto using is_bitfield_access_meets_spec with coqlib.\nexists (@nil ident); split; eauto with gensym.\nconstructor; auto."},{"statement":"(ty : type) (a : expr) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (Heqb0 : type_is_volatile ty = true) (x : ident) (z : generator) (I0 : Ple (gen_next g) (gen_next z)) (I1 : Ple (gen_next z) (gen_next g')) (EQ : gensym ty g = Res x z I0) (x0 : bitfield) (I2 : Ple (gen_next z) (gen_next g')) (EQ1 : is_bitfield_access ce a z = Res x0 g' I2) (I3 : Ple (gen_next g') (gen_next g')) : exists tmps : list ident,\n  tr_rvalof ty a (make_set x0 x a :: nil) (Etempvar x ty) tmps /\\\n  contained tmps g g'.","proofString":"exists (x :: nil); split; eauto with gensym.\neconstructor; eauto using is_bitfield_access_meets_spec with coqlib."},{"statement":"(ty : type) (a : expr) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (Heqb0 : type_is_volatile ty = true) (x : ident) (z : generator) (I0 : Ple (gen_next g) (gen_next z)) (I1 : Ple (gen_next z) (gen_next g')) (EQ : gensym ty g = Res x z I0) (x0 : bitfield) (I2 : Ple (gen_next z) (gen_next g')) (EQ1 : is_bitfield_access ce a z = Res x0 g' I2) (I3 : Ple (gen_next g') (gen_next g')) : tr_rvalof ty a (make_set x0 x a :: nil) (Etempvar x ty) (x :: nil).","proofString":"econstructor; eauto using is_bitfield_access_meets_spec with coqlib."},{"statement":"(ty : type) (b : expr) (g' : generator) (I : Ple (gen_next g') (gen_next g')) (Heqb0 : type_is_volatile ty = false) : exists tmps : list ident, tr_rvalof ty b nil b tmps /\\ contained tmps g' g'.","proofString":"exists (@nil ident); split; eauto with gensym.\nconstructor; auto."},{"statement":"(ty : type) (b : expr) (g' : generator) (I : Ple (gen_next g') (gen_next g')) (Heqb0 : type_is_volatile ty = false) : tr_rvalof ty b nil b nil.","proofString":"constructor; auto."},{"statement":"(r : Csyntax.expr) (dst : destination) (g : generator) (sl : list statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr ce dst r g = Res (sl, a) g' I) (H0 : dest_below dst g) : exists tmps : list ident,\n  forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n  tr_top ge e le m dst r sl a tmps.","proofString":"exploit (proj1 transl_meets_spec); eauto.\nintros [tmps [A B]].\nexists (add_dest dst tmps); intros.\napply tr_top_base.\nauto."},{"statement":"(r : Csyntax.expr) (dst : destination) (g : generator) (sl : list statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr ce dst r g = Res (sl, a) g' I) (H0 : dest_below dst g) : (exists tmps : list ident,\n   (forall le : temp_env, tr_expr le dst r sl a (add_dest dst tmps)) /\\\n   contained tmps g g') ->\nexists tmps : list ident,\n  forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n  tr_top ge e le m dst r sl a tmps.","proofString":"intros [tmps [A B]].\nexists (add_dest dst tmps); intros.\napply tr_top_base.\nauto."},{"statement":"(r : Csyntax.expr) (dst : destination) (g : generator) (sl : list statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr ce dst r g = Res (sl, a) g' I) (H0 : dest_below dst g) (tmps : list ident) (A : forall le : temp_env, tr_expr le dst r sl a (add_dest dst tmps)) (B : contained tmps g g') : exists tmps0 : list ident,\n  forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n  tr_top ge e le m dst r sl a tmps0.","proofString":"exists (add_dest dst tmps); intros.\napply tr_top_base.\nauto."},{"statement":"(r : Csyntax.expr) (dst : destination) (g : generator) (sl : list statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr ce dst r g = Res (sl, a) g' I) (H0 : dest_below dst g) (tmps : list ident) (A : forall le0 : temp_env, tr_expr le0 dst r sl a (add_dest dst tmps)) (B : contained tmps g g') (ge : genv) (e : env) (le : temp_env) (m : mem) : tr_top ge e le m dst r sl a (add_dest dst tmps).","proofString":"apply tr_top_base.\nauto."},{"statement":"(r : Csyntax.expr) (dst : destination) (g : generator) (sl : list statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr ce dst r g = Res (sl, a) g' I) (H0 : dest_below dst g) (tmps : list ident) (A : forall le0 : temp_env, tr_expr le0 dst r sl a (add_dest dst tmps)) (B : contained tmps g g') (ge : genv) (e : env) (le : temp_env) (m : mem) : tr_expr le dst r sl a (add_dest dst tmps).","proofString":"auto."},{"statement":"(r : Csyntax.expr) (g : generator) (s : statement) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expression ce r g = Res (s, a) g' I) : tr_expression r s a.","proofString":"monadInv H.\nexploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g : generator) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, a) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : tr_expression r (makeseq x) a.","proofString":"exploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g : generator) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, a) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : (exists tmps : list ident,\n   forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n   tr_top ge e le m For_val r x a tmps) -> tr_expression r (makeseq x) a.","proofString":"intros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g : generator) (a : expr) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, a) g' I0) (I1 : Ple (gen_next g') (gen_next g')) (tmps : list ident) (A : forall (ge : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ge e le m For_val r x a tmps) : tr_expression r (makeseq x) a.","proofString":"econstructor; eauto."},{"statement":"(r : Csyntax.expr) (g : generator) (s : statement) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_expr_stmt ce r g = Res s g' I) : tr_expr_stmt r s.","proofString":"monadInv H.\nexploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_effects r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : tr_expr_stmt r (makeseq x).","proofString":"exploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_effects r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : (exists tmps : list ident,\n   forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n   tr_top ge e le m For_effects r x y tmps) -> tr_expr_stmt r (makeseq x).","proofString":"intros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_effects r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) (tmps : list ident) (A : forall (ge : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ge e le m For_effects r x y tmps) : tr_expr_stmt r (makeseq x).","proofString":"econstructor; eauto."},{"statement":"(r : Csyntax.expr) (s1 s2 : statement) (g : generator) (s : statement) (g' : generator) (I : Ple (gen_next g) (gen_next g')) (H : transl_if ce r s1 s2 g = Res s g' I) : tr_if r s1 s2 s.","proofString":"monadInv H.\nexploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (s1 s2 : statement) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : tr_if r s1 s2 (makeseq (x ++ makeif y s1 s2 :: nil)).","proofString":"exploit transl_expr_meets_spec; eauto.\nintros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (s1 s2 : statement) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) : (exists tmps : list ident,\n   forall (ge : genv) (e : env) (le : temp_env) (m : mem),\n   tr_top ge e le m For_val r x y tmps) ->\ntr_if r s1 s2 (makeseq (x ++ makeif y s1 s2 :: nil)).","proofString":"intros [tmps A].\neconstructor; eauto."},{"statement":"(r : Csyntax.expr) (s1 s2 : statement) (g g' : generator) (I : Ple (gen_next g) (gen_next g')) (x : list statement) (y : expr) (I0 : Ple (gen_next g) (gen_next g')) (EQ : transl_expr ce For_val r g = Res (x, y) g' I0) (I1 : Ple (gen_next g') (gen_next g')) (tmps : list ident) (A : forall (ge : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ge e le m For_val r x y tmps) : tr_if r s1 s2 (makeseq (x ++ makeif y s1 s2 :: nil)).","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (tf : function) (H : match transl_stmt ce (Csyntax.fn_body f) (initial_generator tt) with\n| Err msg => Error msg\n| Res tbody g _ =>\n    OK\n      {|\n        fn_return := Csyntax.fn_return f;\n        fn_callconv := Csyntax.fn_callconv f;\n        fn_params := Csyntax.fn_params f;\n        fn_vars := Csyntax.fn_vars f;\n        fn_temps := gen_trail g;\n        fn_body := tbody\n      |}\nend = OK tf) : tr_function f tf.","proofString":"destruct (transl_stmt ce (Csyntax.fn_body f) (initial_generator tt)) eqn:T; inv H.\nconstructor; auto.\nsimpl.\neapply transl_stmt_meets_spec; eauto."},{"statement":"(f : Csyntax.function) (s : statement) (g' : generator) (p : Ple (gen_next (initial_generator tt)) (gen_next g')) (T : transl_stmt ce (Csyntax.fn_body f) (initial_generator tt) = Res s g' p) : tr_function f\n  {|\n    fn_return := Csyntax.fn_return f;\n    fn_callconv := Csyntax.fn_callconv f;\n    fn_params := Csyntax.fn_params f;\n    fn_vars := Csyntax.fn_vars f;\n    fn_temps := gen_trail g';\n    fn_body := s\n  |}.","proofString":"constructor; auto.\nsimpl.\neapply transl_stmt_meets_spec; eauto."},{"statement":"(f : Csyntax.function) (s : statement) (g' : generator) (p : Ple (gen_next (initial_generator tt)) (gen_next g')) (T : transl_stmt ce (Csyntax.fn_body f) (initial_generator tt) = Res s g' p) : tr_stmt (Csyntax.fn_body f)\n  (fn_body\n     {|\n       fn_return := Csyntax.fn_return f;\n       fn_callconv := Csyntax.fn_callconv f;\n       fn_params := Csyntax.fn_params f;\n       fn_vars := Csyntax.fn_vars f;\n       fn_temps := gen_trail g';\n       fn_body := s\n     |}).","proofString":"simpl.\neapply transl_stmt_meets_spec; eauto."},{"statement":"(f : Csyntax.function) (s : statement) (g' : generator) (p : Ple (gen_next (initial_generator tt)) (gen_next g')) (T : transl_stmt ce (Csyntax.fn_body f) (initial_generator tt) = Res s g' p) : tr_stmt (Csyntax.fn_body f) s.","proofString":"eapply transl_stmt_meets_spec; eauto."},{"statement":"(p : Ctypes.program Csyntax.function) (fd : Csyntax.fundef) (tfd : fundef) (H : match fd with\n| Internal f =>\n    Errors.bind (transl_function (prog_comp_env p) f)\n      (fun tf : function => OK (Internal tf))\n| External ef targs tres cc => OK (External ef targs tres cc)\nend = OK tfd) : tr_fundef p fd tfd.","proofString":"destruct fd; Errors.monadInv H.\nconstructor.\neapply transl_function_spec; eauto.\nconstructor."},{"statement":"(p : Ctypes.program Csyntax.function) (f : Csyntax.function) (x : function) (EQ : transl_function (prog_comp_env p) f = OK x) : tr_fundef p (Internal f) (Internal x).","proofString":"constructor.\neapply transl_function_spec; eauto."},{"statement":"(p : Ctypes.program Csyntax.function) (f : Csyntax.function) (x : function) (EQ : transl_function (prog_comp_env p) f = OK x) : tr_function (prog_comp_env p) f x.","proofString":"eapply transl_function_spec; eauto."},{"statement":"(p : Ctypes.program Csyntax.function) (e : external_function) (l : list type) (t : type) (c : calling_convention) : tr_fundef p (External e l t c) (External e l t c).","proofString":"constructor."}]}