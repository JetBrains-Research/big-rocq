{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/hardware/TSO.v","fileSamples":[{"statement":"(WF : Wf G) : ppo ⊆ ⦗E⦘ ⨾ ppo ⨾ ⦗E⦘.","conclusion":"ppo ⊆ ⦗E⦘ ⨾ ppo ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"unfold ppo.\nrewrite (@wf_sbE G) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"rewrite (@wf_sbE G) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘ \\\n(fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘.","conclusion":"⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘ \\\n(fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : fence ⊆ ⦗E⦘ ⨾ fence ⨾ ⦗E⦘.","conclusion":"fence ⊆ ⦗E⦘ ⨾ fence ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"unfold fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"rewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗MFENCE⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘.","conclusion":"⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗MFENCE⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : implied_fence ⊆ ⦗E⦘ ⨾ implied_fence ⨾ ⦗E⦘.","conclusion":"implied_fence ⊆ ⦗E⦘ ⨾ implied_fence ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"unfold implied_fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘.","conclusion":"⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"rewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗dom_rel rmw⦘\n∪ ⦗codom_rel rmw⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘.","conclusion":"⦗W⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗dom_rel rmw⦘\n∪ ⦗codom_rel rmw⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘","hypotheses":"(WF : Wf G)","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : hb ⊆ ⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘.","conclusion":"hb ⊆ ⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘","hypotheses":"(WF : Wf G)","proofString":"apply dom_helper_3.\nunfold hb.\nunfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : hb ⊆ RW × RW.","conclusion":"hb ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"unfold hb.\nunfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ppo ∪ fence ∪ implied_fence ∪ rfe ∪ co ∪ fr ⊆ RW × RW.","conclusion":"ppo ∪ fence ∪ implied_fence ∪ rfe ∪ co ∪ fr ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"unfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr\n⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr\n⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr ⊆ \nRW × RW.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr ⊆ \nRW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ∪ co ∪ fr\n⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ∪ co ∪ fr\n⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ fr ⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ fr ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"generalize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : (fun a : actid => R_ex lab a) ⊆₁ R ->\n⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW.","conclusion":"(fun a : actid => R_ex lab a) ⊆₁ R ->\n⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : hb⁺ ⊆ ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘.","conclusion":"hb⁺ ⊆ ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘","hypotheses":"(WF : Wf G)","proofString":"apply dom_helper_3.\nrewrite (wf_hbD WF).\nrewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : hb⁺ ⊆ RW × RW.","conclusion":"hb⁺ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite (wf_hbD WF).\nrewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : (⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW.","conclusion":"(⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ (hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"rewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘ ⊆ RW × RW.","conclusion":"⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘ ⊆ RW × RW","hypotheses":"(WF : Wf G)","proofString":"basic_solver."},{"statement":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n≡ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n≡ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘","hypotheses":"","proofString":"split.\nby apply inclusion_minus_l; basic_solver 12.\nby unfolder; ins; desf; splits; eauto 10; intro; type_solver."},{"statement":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘.","conclusion":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘","hypotheses":"","proofString":"by apply inclusion_minus_l; basic_solver 12."},{"statement":"⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y).","conclusion":"⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)","hypotheses":"","proofString":"by unfolder; ins; desf; splits; eauto 10; intro; type_solver."},{"statement":"(A : Type) (r r' : relation A) : r ⊆ r ∩ r' ∪ r \\ r'.","conclusion":"r ⊆ r ∩ r' ∪ r \\ r'","hypotheses":"(A : Type) (r r' : relation A)","proofString":"red.\nintros x y Rxy.\ndestruct (classic (r' x y)); basic_solver."},{"statement":"(A : Type) (r r' : relation A) : forall x y : A, r x y -> (r ∩ r' ∪ r \\ r') x y.","conclusion":"forall x y : A, r x y -> (r ∩ r' ∪ r \\ r') x y","hypotheses":"(A : Type) (r r' : relation A)","proofString":"intros x y Rxy.\ndestruct (classic (r' x y)); basic_solver."},{"statement":"(A : Type) (r r' : relation A) (x y : A) (Rxy : r x y) : (r ∩ r' ∪ r \\ r') x y.","conclusion":"(r ∩ r' ∪ r \\ r') x y","hypotheses":"(A : Type) (r r' : relation A) (x y : A) (Rxy : r x y)","proofString":"destruct (classic (r' x y)); basic_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ∪ rfi ∪ rfe).","conclusion":"acyclic (sb ∪ rfi ∪ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"rewrite union_absorb_r with (r := rfi); [| unfold \"rfi\"; basic_solver].\napply acyclic_utt.\nby apply sb_trans.\napply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver.\nsplits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ∪ rfe).","conclusion":"acyclic (sb ∪ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"apply acyclic_utt.\nby apply sb_trans.\napply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver.\nsplits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : transitive sb.","conclusion":"transitive sb","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"by apply sb_trans."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : transitive rfe.","conclusion":"transitive rfe","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"apply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : rfe ⨾ rfe ⊆ rfe.","conclusion":"rfe ⨾ rfe ⊆ rfe","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"rewrite wf_rfeD; auto.\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : (⦗W⦘ ⨾ rfe ⨾ ⦗R⦘) ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ⊆ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘.","conclusion":"(⦗W⦘ ⨾ rfe ⨾ ⦗R⦘) ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ⊆ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"type_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive sb /\\ irreflexive rfe /\\ acyclic (sb ⨾ rfe).","conclusion":"irreflexive sb /\\ irreflexive rfe /\\ acyclic (sb ⨾ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"splits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive sb.","conclusion":"irreflexive sb","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"by apply sb_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive rfe.","conclusion":"irreflexive rfe","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"rewrite rfe_in_rf.\nby apply rf_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive rf.","conclusion":"irreflexive rf","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"by apply rf_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ⨾ rfe).","conclusion":"acyclic (sb ⨾ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"rewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘).","conclusion":"acyclic (sb ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"do 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (((sb ⨾ ⦗W⦘) ⨾ rfe) ⨾ ⦗R⦘).","conclusion":"acyclic (((sb ⨾ ⦗W⦘) ⨾ rfe) ⨾ ⦗R⦘)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"rewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe).","conclusion":"acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent)","proofString":"cdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb) : acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe).","conclusion":"acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb)","proofString":"red.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb) : irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","conclusion":"irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb)","proofString":"red in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","conclusion":"irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"eapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : Basics.flip inclusion hb⁺ (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","conclusion":"Basics.flip inclusion hb⁺ (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"red.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ hb⁺.","conclusion":"(⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ hb⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"rewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ (hb⁺)⁺.","conclusion":"(⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ (hb⁺)⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"apply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺.","conclusion":"⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"rewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb.","conclusion":"⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"rewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb.","conclusion":"(⦗R⦘ ⨾ sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"apply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb⁺.","conclusion":"⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb⁺","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"rewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb.","conclusion":"⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"repeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppo.","conclusion":"⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppo","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"unfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y).","conclusion":"⦗R⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"unfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : forall x y : actid,\nis_r lab x /\\ sb x y /\\ is_w lab y ->\n((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","conclusion":"forall x y : actid,\nis_r lab x /\\ sb x y /\\ is_w lab y ->\n((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺)","proofString":"ins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x /\\ sb x y /\\ is_w lab y) : ((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","conclusion":"((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x /\\ sb x y /\\ is_w lab y)","proofString":"desc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) : ((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","conclusion":"((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y)","proofString":"splits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) : ~ (is_w lab x /\\ is_r lab y).","conclusion":"~ (is_w lab x /\\ is_r lab y)","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y)","proofString":"intros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) (H2 : is_w lab x) (H3 : is_r lab y) : False.","conclusion":"False","hypotheses":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) (H2 : is_w lab x) (H3 : is_r lab y)","proofString":"type_solver."}]}