{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/FIX.v","fileSamples":[{"statement":"(x : R) (H : generic_format beta FIX_exp x) : FIX_format x.","proofString":"rewrite H.\neexists ; repeat split."},{"statement":"forall x : R, generic_format beta FIX_exp x <-> FIX_format x.","proofString":"intros x.\nsplit.\napply FIX_format_generic.\napply generic_format_FIX."},{"statement":"(x : R) : generic_format beta FIX_exp x <-> FIX_format x.","proofString":"split.\napply FIX_format_generic.\napply generic_format_FIX."},{"statement":"(x : R) : generic_format beta FIX_exp x -> FIX_format x.","proofString":"apply FIX_format_generic."},{"statement":"(x : R) : FIX_format x -> generic_format beta FIX_exp x.","proofString":"apply generic_format_FIX."},{"statement":"(x : R) : (if Req_bool x 0\n then\n  match negligible_exp FIX_exp with\n  | Some n => bpow (FIX_exp n)\n  | None => 0%R\n  end\n else bpow (cexp beta FIX_exp x)) = bpow emin.","proofString":"case Req_bool_spec; intros Zx.\ncase (negligible_exp_spec FIX_exp).\nintros T; specialize (T (emin-1)%Z); contradict T.\nunfold FIX_exp; lia.\nintros n _; reflexivity.\nreflexivity."},{"statement":"(x : R) (Zx : x = 0%R) : match negligible_exp FIX_exp with\n| Some n => bpow (FIX_exp n)\n| None => 0%R\nend = bpow emin.","proofString":"case (negligible_exp_spec FIX_exp).\nintros T; specialize (T (emin-1)%Z); contradict T.\nunfold FIX_exp; lia.\nintros n _; reflexivity."},{"statement":"(x : R) (Zx : x = 0%R) : (forall n : Z, (FIX_exp n < n)%Z) -> 0%R = bpow emin.","proofString":"intros T; specialize (T (emin-1)%Z); contradict T.\nunfold FIX_exp; lia."},{"statement":"(x : R) (Zx : x = 0%R) : ~ (FIX_exp (emin - 1) < emin - 1)%Z.","proofString":"unfold FIX_exp; lia."},{"statement":"(x : R) (Zx : x = 0%R) : forall n : Z, (n <= FIX_exp n)%Z -> bpow (FIX_exp n) = bpow emin.","proofString":"intros n _; reflexivity."},{"statement":"(x : R) (Zx : x <> 0%R) : bpow (cexp beta FIX_exp x) = bpow emin.","proofString":"reflexivity."},{"statement":"(f : R -> Z) (x : R) : round radix2 (FIX_exp 0) f x = IZR (f x).","proofString":"unfold round, F2R.\nsimpl.\nrewrite Rmult_1_r.\napply f_equal.\napply f_equal.\nunfold scaled_mantissa.\nsimpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : (IZR (f (scaled_mantissa radix2 (FIX_exp 0) x)) * 1)%R = IZR (f x).","proofString":"rewrite Rmult_1_r.\napply f_equal.\napply f_equal.\nunfold scaled_mantissa.\nsimpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : IZR (f (scaled_mantissa radix2 (FIX_exp 0) x)) = IZR (f x).","proofString":"apply f_equal.\napply f_equal.\nunfold scaled_mantissa.\nsimpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : f (scaled_mantissa radix2 (FIX_exp 0) x) = f x.","proofString":"apply f_equal.\nunfold scaled_mantissa.\nsimpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : scaled_mantissa radix2 (FIX_exp 0) x = x.","proofString":"unfold scaled_mantissa.\nsimpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : (x * bpow radix2 (- cexp radix2 (FIX_exp 0) x))%R = x.","proofString":"simpl.\napply Rmult_1_r."},{"statement":"(f : R -> Z) (x : R) : (x * 1)%R = x.","proofString":"apply Rmult_1_r."}]}