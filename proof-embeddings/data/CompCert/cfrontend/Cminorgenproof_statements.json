{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/Cminorgenproof.v","fileSamples":[{"statement":"(p : Csharpminor.program) (tp : program) (H : transl_program p = OK tp) : match_prog p tp.","proofString":"apply match_transform_partial_program; auto."},{"statement":"(f : Csharpminor.function) (tf : function) (cenv : compilenv) (size : Z) (H : transl_funbody cenv size f = OK tf) : fn_sig tf = Csharpminor.fn_sig f.","proofString":"unfold transl_funbody in H.\nmonadInv H; reflexivity."},{"statement":"(f : Csharpminor.function) (tf : function) (cenv : compilenv) (size : Z) (H : (do tbody <- transl_stmt cenv nil (Csharpminor.fn_body f);\n OK\n   {|\n     fn_sig := Csharpminor.fn_sig f;\n     fn_params := Csharpminor.fn_params f;\n     fn_vars := fn_temps f;\n     fn_stackspace := size;\n     fn_body := tbody\n   |}) = OK tf) : fn_sig tf = Csharpminor.fn_sig f.","proofString":"monadInv H; reflexivity."},{"statement":"(f : Csharpminor.function) (tf : fundef) : (do f' <- transl_function f; OK (Internal f')) = OK tf ->\nfunsig tf = Csharpminor.fn_sig f.","proofString":"unfold transl_function.\ndestruct (build_compilenv f).\ncase (zle z Ptrofs.max_unsigned); simpl bind; try congruence.\nintros.\nmonadInv H.\nsimpl.\neapply sig_preserved_body; eauto."},{"statement":"(f : Csharpminor.function) (tf : fundef) : (do f' <-\n (let (cenv, stacksize) := build_compilenv f in\n  if zle stacksize Ptrofs.max_unsigned\n  then transl_funbody cenv stacksize f\n  else Error (msg \"Cminorgen: too many local variables, stack size exceeded\"));\n OK (Internal f')) = OK tf -> funsig tf = Csharpminor.fn_sig f.","proofString":"destruct (build_compilenv f).\ncase (zle z Ptrofs.max_unsigned); simpl bind; try congruence.\nintros.\nmonadInv H.\nsimpl.\neapply sig_preserved_body; eauto."},{"statement":"(f : Csharpminor.function) (tf : fundef) (c : compilenv) (z : Z) : (do f' <-\n (if zle z Ptrofs.max_unsigned\n  then transl_funbody c z f\n  else Error (msg \"Cminorgen: too many local variables, stack size exceeded\"));\n OK (Internal f')) = OK tf -> funsig tf = Csharpminor.fn_sig f.","proofString":"case (zle z Ptrofs.max_unsigned); simpl bind; try congruence.\nintros.\nmonadInv H.\nsimpl.\neapply sig_preserved_body; eauto."},{"statement":"(f : Csharpminor.function) (tf : fundef) (c : compilenv) (z : Z) (l : z <= Ptrofs.max_unsigned) (H : (do f' <- transl_funbody c z f; OK (Internal f')) = OK tf) : funsig tf = Csharpminor.fn_sig f.","proofString":"monadInv H.\nsimpl.\neapply sig_preserved_body; eauto."},{"statement":"(f : Csharpminor.function) (c : compilenv) (z : Z) (l : z <= Ptrofs.max_unsigned) (x : function) (EQ : transl_funbody c z f = OK x) : funsig (Internal x) = Csharpminor.fn_sig f.","proofString":"simpl.\neapply sig_preserved_body; eauto."},{"statement":"(f : Csharpminor.function) (c : compilenv) (z : Z) (l : z <= Ptrofs.max_unsigned) (x : function) (EQ : transl_funbody c z f = OK x) : fn_sig x = Csharpminor.fn_sig f.","proofString":"eapply sig_preserved_body; eauto."},{"statement":"(e : external_function) (tf : fundef) : OK (External e) = OK tf -> funsig tf = ef_sig e.","proofString":"intro.\ninv H.\nreflexivity."},{"statement":"(e : external_function) (tf : fundef) (H : OK (External e) = OK tf) : funsig tf = ef_sig e.","proofString":"inv H.\nreflexivity."},{"statement":"(e : external_function) : funsig (External e) = ef_sig e.","proofString":"reflexivity."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b' : block) (lo hi : Z), In (b', lo, hi) nil -> b' <> b) (H0 : Mem.free_list m nil = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"simpl in H0.\ncongruence."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b' : block) (lo hi : Z), In (b', lo, hi) nil -> b' <> b) (H0 : Some m = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"congruence."},{"statement":"(a : block * Z * Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b' : block) (lo hi : Z), In (b', lo, hi) fbl -> b' <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b' : block) (lo hi : Z), In (b', lo, hi) (a :: fbl) -> b' <> b) (H0 : Mem.free_list m (a :: fbl) = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"destruct a as [[b' lo] hi].\ngeneralize H0.\nsimpl.\ncase_eq (Mem.free m b' lo hi); try congruence.\nintros m1 FR1 FRL.\ntransitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"generalize H0.\nsimpl.\ncase_eq (Mem.free m b' lo hi); try congruence.\nintros m1 FR1 FRL.\ntransitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') : Mem.free_list m ((b', lo, hi) :: fbl) = Some m' ->\nMem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"simpl.\ncase_eq (Mem.free m b' lo hi); try congruence.\nintros m1 FR1 FRL.\ntransitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') : match Mem.free m b' lo hi with\n| Some m'0 => Mem.free_list m'0 fbl\n| None => None\nend = Some m' -> Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"case_eq (Mem.free m b' lo hi); try congruence.\nintros m1 FR1 FRL.\ntransitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') : forall m0 : mem,\nMem.free m b' lo hi = Some m0 ->\nMem.free_list m0 fbl = Some m' ->\nMem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"intros m1 FR1 FRL.\ntransitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"transitivity (Mem.load chunk m1 b ofs).\neapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib.\neapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : Mem.load chunk m' b ofs = Mem.load chunk m1 b ofs.","proofString":"eapply IHfbl; eauto.\nintros.\neapply H.\neauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b.","proofString":"intros.\neapply H.\neauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'1 : block) (lo1 hi1 : Z), In (b'1, lo1, hi1) fbl -> b'1 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'1 : block) (lo1 hi1 : Z),\nIn (b'1, lo1, hi1) ((b', lo, hi) :: fbl) -> b'1 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') (b'0 : block) (lo0 hi0 : Z) (H1 : In (b'0, lo0, hi0) fbl) : b'0 <> b.","proofString":"eapply H.\neauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : Mem.load chunk m1 b ofs = Mem.load chunk m b ofs.","proofString":"eapply Mem.load_free; eauto.\nleft.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : b <> b' \\/ lo >= hi \\/ ofs + size_chunk chunk <= lo \\/ hi <= ofs.","proofString":"left.\napply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : b <> b'.","proofString":"apply not_eq_sym.\neapply H.\nauto with coqlib."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (chunk0 : memory_chunk) (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\n(forall (b'0 : block) (lo0 hi0 : Z), In (b'0, lo0, hi0) fbl -> b'0 <> b0) ->\nMem.free_list m0 fbl = Some m'0 ->\nMem.load chunk0 m'0 b0 ofs0 = Mem.load chunk0 m0 b0 ofs0) (chunk : memory_chunk) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : forall (b'0 : block) (lo0 hi0 : Z),\nIn (b'0, lo0, hi0) ((b', lo, hi) :: fbl) -> b'0 <> b) (H0 : Mem.free_list m ((b', lo, hi) :: fbl) = Some m') (m1 : mem) (FR1 : Mem.free m b' lo hi = Some m1) (FRL : Mem.free_list m1 fbl = Some m') : b' <> b.","proofString":"eapply H.\nauto with coqlib."},{"statement":"(m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) : Some m = Some m' -> Mem.perm m' b ofs k p -> Mem.perm m b ofs k p.","proofString":"congruence."},{"statement":"(a : block * Z * Z) (fbl : list (block * Z * Z)) (IHfbl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nMem.free_list m0 fbl = Some m'0 ->\nMem.perm m'0 b0 ofs0 k0 p0 -> Mem.perm m0 b0 ofs0 k0 p0) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) : (let (p0, hi) := a in\n let (b0, lo) := p0 in\n match Mem.free m b0 lo hi with\n | Some m'0 => Mem.free_list m'0 fbl\n | None => None\n end) = Some m' -> Mem.perm m' b ofs k p -> Mem.perm m b ofs k p.","proofString":"destruct a as [[b' lo] hi].\ncase_eq (Mem.free m b' lo hi); try congruence.\nintros.\neauto with mem."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nMem.free_list m0 fbl = Some m'0 ->\nMem.perm m'0 b0 ofs0 k0 p0 -> Mem.perm m0 b0 ofs0 k0 p0) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) : match Mem.free m b' lo hi with\n| Some m'0 => Mem.free_list m'0 fbl\n| None => None\nend = Some m' -> Mem.perm m' b ofs k p -> Mem.perm m b ofs k p.","proofString":"case_eq (Mem.free m b' lo hi); try congruence.\nintros.\neauto with mem."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (m0 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nMem.free_list m0 fbl = Some m'0 ->\nMem.perm m'0 b0 ofs0 k0 p0 -> Mem.perm m0 b0 ofs0 k0 p0) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) : forall m0 : mem,\nMem.free m b' lo hi = Some m0 ->\nMem.free_list m0 fbl = Some m' ->\nMem.perm m' b ofs k p -> Mem.perm m b ofs k p.","proofString":"intros.\neauto with mem."},{"statement":"(b' : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall (m1 m'0 : mem) (b0 : block) (ofs0 : Z) (k0 : perm_kind)\n  (p0 : permission),\nMem.free_list m1 fbl = Some m'0 ->\nMem.perm m'0 b0 ofs0 k0 p0 -> Mem.perm m1 b0 ofs0 k0 p0) (m m' : mem) (b : block) (ofs : Z) (k : perm_kind) (p : permission) (m0 : mem) (H : Mem.free m b' lo hi = Some m0) (H0 : Mem.free_list m0 fbl = Some m') (H1 : Mem.perm m' b ofs k p) : Mem.perm m b ofs k p.","proofString":"eauto with mem."},{"statement":"(m m' : mem) : Some m = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"congruence."},{"statement":"(a : block * Z * Z) (fbl : list (block * Z * Z)) (IHfbl : forall m0 m'0 : mem,\nMem.free_list m0 fbl = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) : (let (p0, hi) := a in\n let (b, lo) := p0 in\n match Mem.free m b lo hi with\n | Some m'0 => Mem.free_list m'0 fbl\n | None => None\n end) = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"destruct a as [[b lo] hi].\ncase_eq (Mem.free m b lo hi); intros; try congruence.\ntransitivity (Mem.nextblock m0).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall m0 m'0 : mem,\nMem.free_list m0 fbl = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m0) (m m' : mem) : match Mem.free m b lo hi with\n| Some m'0 => Mem.free_list m'0 fbl\n| None => None\nend = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"case_eq (Mem.free m b lo hi); intros; try congruence.\ntransitivity (Mem.nextblock m0).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall m1 m'0 : mem,\nMem.free_list m1 fbl = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m1) (m m' m0 : mem) (H : Mem.free m b lo hi = Some m0) (H0 : Mem.free_list m0 fbl = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"transitivity (Mem.nextblock m0).\neauto.\neapply Mem.nextblock_free; eauto."},{"statement":"(b : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall m1 m'0 : mem,\nMem.free_list m1 fbl = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m1) (m m' m0 : mem) (H : Mem.free m b lo hi = Some m0) (H0 : Mem.free_list m0 fbl = Some m') : Mem.nextblock m' = Mem.nextblock m0.","proofString":"eauto."},{"statement":"(b : block) (lo hi : Z) (fbl : list (block * Z * Z)) (IHfbl : forall m1 m'0 : mem,\nMem.free_list m1 fbl = Some m'0 -> Mem.nextblock m'0 = Mem.nextblock m1) (m m' m0 : mem) (H : Mem.free m b lo hi = Some m0) (H0 : Mem.free_list m0 fbl = Some m') : Mem.nextblock m0 = Mem.nextblock m.","proofString":"eapply Mem.nextblock_free; eauto."},{"statement":"(m m' : mem) (H : Some m = Some m') (b : block) (lo hi : Z) (H0 : False) : Mem.range_perm m b lo hi Cur Freeable.","proofString":"contradiction."},{"statement":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (H : (let (p0, hi0) := a in\n let (b0, lo0) := p0 in\n match Mem.free m b0 lo0 hi0 with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m') (b : block) (lo hi : Z) (H0 : a = (b, lo, hi) \\/ In (b, lo, hi) l) : Mem.range_perm m b lo hi Cur Freeable.","proofString":"revert H.\ndestruct a as [[b' lo'] hi'].\ncaseEq (Mem.free m b' lo' hi'); try congruence.\nintros m1 FREE1 FREE2.\ndestruct H0.\ninv H.\neauto with mem.\nred; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(a : block * Z * Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H0 : a = (b, lo, hi) \\/ In (b, lo, hi) l) : (let (p0, hi0) := a in\n let (b0, lo0) := p0 in\n match Mem.free m b0 lo0 hi0 with\n | Some m'0 => Mem.free_list m'0 l\n | None => None\n end) = Some m' -> Mem.range_perm m b lo hi Cur Freeable.","proofString":"destruct a as [[b' lo'] hi'].\ncaseEq (Mem.free m b' lo' hi'); try congruence.\nintros m1 FREE1 FREE2.\ndestruct H0.\ninv H.\neauto with mem.\nred; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H0 : (b', lo', hi') = (b, lo, hi) \\/ In (b, lo, hi) l) : match Mem.free m b' lo' hi' with\n| Some m'0 => Mem.free_list m'0 l\n| None => None\nend = Some m' -> Mem.range_perm m b lo hi Cur Freeable.","proofString":"caseEq (Mem.free m b' lo' hi'); try congruence.\nintros m1 FREE1 FREE2.\ndestruct H0.\ninv H.\neauto with mem.\nred; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H0 : (b', lo', hi') = (b, lo, hi) \\/ In (b, lo, hi) l) : forall m0 : mem,\nMem.free m b' lo' hi' = Some m0 ->\nMem.free_list m0 l = Some m' -> Mem.range_perm m b lo hi Cur Freeable.","proofString":"intros m1 FREE1 FREE2.\ndestruct H0.\ninv H.\neauto with mem.\nred; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H0 : (b', lo', hi') = (b, lo, hi) \\/ In (b, lo, hi) l) (m1 : mem) (FREE1 : Mem.free m b' lo' hi' = Some m1) (FREE2 : Mem.free_list m1 l = Some m') : Mem.range_perm m b lo hi Cur Freeable.","proofString":"destruct H0.\ninv H.\neauto with mem.\nred; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H : (b', lo', hi') = (b, lo, hi)) (m1 : mem) (FREE1 : Mem.free m b' lo' hi' = Some m1) (FREE2 : Mem.free_list m1 l = Some m') : Mem.range_perm m b lo hi Cur Freeable.","proofString":"inv H.\neauto with mem."},{"statement":"(l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (m1 : mem) (FREE1 : Mem.free m b lo hi = Some m1) (FREE2 : Mem.free_list m1 l = Some m') : Mem.range_perm m b lo hi Cur Freeable.","proofString":"eauto with mem."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H : In (b, lo, hi) l) (m1 : mem) (FREE1 : Mem.free m b' lo' hi' = Some m1) (FREE2 : Mem.free_list m1 l = Some m') : Mem.range_perm m b lo hi Cur Freeable.","proofString":"red; intros.\neapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H : In (b, lo, hi) l) (m1 : mem) (FREE1 : Mem.free m b' lo' hi' = Some m1) (FREE2 : Mem.free_list m1 l = Some m') (ofs : Z) (H0 : lo <= ofs < hi) : Mem.perm m b ofs Cur Freeable.","proofString":"eapply Mem.perm_free_3; eauto.\nexploit IHl; eauto."},{"statement":"(b' : block) (lo' hi' : Z) (l : list (block * Z * Z)) (IHl : forall m0 m'0 : mem,\nMem.free_list m0 l = Some m'0 ->\nforall (b0 : block) (lo0 hi0 : Z),\nIn (b0, lo0, hi0) l -> Mem.range_perm m0 b0 lo0 hi0 Cur Freeable) (m m' : mem) (b : block) (lo hi : Z) (H : In (b, lo, hi) l) (m1 : mem) (FREE1 : Mem.free m b' lo' hi' = Some m1) (FREE2 : Mem.free_list m1 l = Some m') (ofs : Z) (H0 : lo <= ofs < hi) : Mem.perm m1 b ofs Cur Freeable.","proofString":"exploit IHl; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (addr v : val) (m' : mem) (H : match addr with\n| Vptr b ofs => Mem.store chunk m b (Ptrofs.unsigned ofs) v\n| _ => None\nend = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"destruct addr; try discriminate.\neapply Mem.nextblock_store; eauto."},{"statement":"(chunk : memory_chunk) (m : mem) (b : block) (i : ptrofs) (v : val) (m' : mem) (H : Mem.store chunk m b (Ptrofs.unsigned i) v = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"eapply Mem.nextblock_store; eauto."},{"statement":"(f f' : meminj) (le : temp_env) (te : env) (H : match_temps f le te) (H0 : inject_incr f f') (id : positive) (v : val) (H1 : le ! id = Some v) : exists v' : val, te ! id = Some v' /\\ Val.inject f' v v'.","proofString":"destruct (H _ _ H1) as [v' [A B]].\nexists v'; eauto."},{"statement":"(f f' : meminj) (le : temp_env) (te : env) (H : match_temps f le te) (H0 : inject_incr f f') (id : positive) (v : val) (H1 : le ! id = Some v) (v' : val) (A : te ! id = Some v') (B : Val.inject f v v') : exists v'0 : val, te ! id = Some v'0 /\\ Val.inject f' v v'0.","proofString":"exists v'; eauto."},{"statement":"(f : meminj) (le : temp_env) (te : env) (id : positive) (v tv : val) (H : match_temps f le te) (H0 : Val.inject f v tv) (id0 : positive) (v0 : val) (H1 : (PTree.set id v le) ! id0 = Some v0) : exists v' : val, (PTree.set id tv te) ! id0 = Some v' /\\ Val.inject f v0 v'.","proofString":"rewrite PTree.gsspec in *.\ndestruct (peq id0 id).\ninv H1.\nexists tv; auto.\neauto."},{"statement":"(f : meminj) (le : temp_env) (te : env) (id : positive) (v tv : val) (H : match_temps f le te) (H0 : Val.inject f v tv) (id0 : positive) (v0 : val) (H1 : (if peq id0 id then Some v else le ! id0) = Some v0) : exists v' : val,\n  (if peq id0 id then Some tv else te ! id0) = Some v' /\\ Val.inject f v0 v'.","proofString":"destruct (peq id0 id).\ninv H1.\nexists tv; auto.\neauto."},{"statement":"(f : meminj) (le : temp_env) (te : env) (id : positive) (v tv : val) (H : match_temps f le te) (H0 : Val.inject f v tv) (id0 : positive) (v0 : val) (e : id0 = id) (H1 : Some v = Some v0) : exists v' : val, Some tv = Some v' /\\ Val.inject f v0 v'.","proofString":"inv H1.\nexists tv; auto."},{"statement":"(f : meminj) (le : temp_env) (te : env) (id : positive) (tv : val) (H : match_temps f le te) (v0 : val) (H0 : Val.inject f v0 tv) : exists v' : val, Some tv = Some v' /\\ Val.inject f v0 v'.","proofString":"exists tv; auto."},{"statement":"(f : meminj) (le : temp_env) (te : env) (id : positive) (v tv : val) (H : match_temps f le te) (H0 : Val.inject f v tv) (id0 : positive) (v0 : val) (n : id0 <> id) (H1 : le ! id0 = Some v0) : exists v' : val, te ! id0 = Some v' /\\ Val.inject f v0 v'.","proofString":"eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) : match_env f2 cenv e sp lo hi.","proofString":"destruct H.\nconstructor; auto.\nintros.\ngeninv (me_vars0 id); econstructor; eauto.\nintros.\neauto.\nintros.\nrewrite H2 in H; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) : match_env f2 cenv e sp lo hi.","proofString":"constructor; auto.\nintros.\ngeninv (me_vars0 id); econstructor; eauto.\nintros.\neauto.\nintros.\nrewrite H2 in H; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) : forall id : positive, match_var f2 sp e ! id cenv ! id.","proofString":"intros.\ngeninv (me_vars0 id); econstructor; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b : block) (sz : Z),\ne ! id0 = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz : Z), e ! id0 = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) (id : positive) : match_var f2 sp e ! id cenv ! id.","proofString":"geninv (me_vars0 id); econstructor; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz).","proofString":"intros.\neauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b0 : block) (sz : Z),\ne ! id = Some (b0, sz) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id : positive) (sz : Z), e ! id = Some (b0, sz)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : block) (delta0 : Z),\nf2 b0 = Some (sp, delta0) -> f1 b0 = Some (sp, delta0)) (H2 : forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) (b : block) (delta : Z) (H : f2 b = Some (sp, delta)) : exists (id : positive) (sz : Z), e ! id = Some (b, sz).","proofString":"eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta)) (H2 : forall b : positive, Plt b lo -> f2 b = f1 b) : forall (b tb : block) (delta : Z),\nf2 b = Some (tb, delta) -> Plt b lo -> Plt tb sp.","proofString":"intros.\nrewrite H2 in H; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b0 : block) (sz : Z),\ne ! id = Some (b0, sz) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id : positive) (sz : Z), e ! id = Some (b0, sz)) (me_incr0 : forall (b0 tb0 : block) (delta0 : Z),\nf1 b0 = Some (tb0, delta0) -> Plt b0 lo -> Plt tb0 sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : block) (delta0 : Z),\nf2 b0 = Some (sp, delta0) -> f1 b0 = Some (sp, delta0)) (H2 : forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) (b tb : block) (delta : Z) (H : f2 b = Some (tb, delta)) (H3 : Plt b lo) : Plt tb sp.","proofString":"rewrite H2 in H; eauto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) : f2 b = f1 b.","proofString":"case_eq (f1 b).\nintros [b' delta] EQ.\napply H; auto.\nintros EQ.\ncase_eq (f2 b).\nintros [b'1 delta1] EQ1.\nexploit H0; eauto.\nintros [C D].\ncontradiction.\nauto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) : forall p : block * Z, f1 b = Some p -> f2 b = Some p.","proofString":"intros [b' delta] EQ.\napply H; auto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (b' : block) (delta : Z) (EQ : f1 b = Some (b', delta)) : f2 b = Some (b', delta).","proofString":"apply H; auto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) : f1 b = None -> f2 b = None.","proofString":"intros EQ.\ncase_eq (f2 b).\nintros [b'1 delta1] EQ1.\nexploit H0; eauto.\nintros [C D].\ncontradiction.\nauto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (EQ : f1 b = None) : f2 b = None.","proofString":"case_eq (f2 b).\nintros [b'1 delta1] EQ1.\nexploit H0; eauto.\nintros [C D].\ncontradiction.\nauto."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (EQ : f1 b = None) : forall p : block * Z, f2 b = Some p -> Some p = None.","proofString":"intros [b'1 delta1] EQ1.\nexploit H0; eauto.\nintros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (EQ : f1 b = None) (b'1 : block) (delta1 : Z) (EQ1 : f2 b = Some (b'1, delta1)) : Some (b'1, delta1) = None.","proofString":"exploit H0; eauto.\nintros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (EQ : f1 b = None) (b'1 : block) (delta1 : Z) (EQ1 : f2 b = Some (b'1, delta1)) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b'1 ->\nSome (b'1, delta1) = None.","proofString":"intros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b : block) (H1 : Mem.valid_block m1 b) (EQ : f1 b = None) (b'1 : block) (delta1 : Z) (EQ1 : f2 b = Some (b'1, delta1)) (C : ~ Mem.valid_block m1 b) (D : ~ Mem.valid_block m1' b'1) : Some (b'1, delta1) = None.","proofString":"contradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') : f1 b = Some (b', delta).","proofString":"case_eq (f1 b).\nintros [b'1 delta1] EQ.\nexploit H; eauto.\ncongruence.\nintros.\nexploit H0; eauto.\nintros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') : forall p : block * Z, f1 b = Some p -> Some p = Some (b', delta).","proofString":"intros [b'1 delta1] EQ.\nexploit H; eauto.\ncongruence."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') (b'1 : block) (delta1 : Z) (EQ : f1 b = Some (b'1, delta1)) : Some (b'1, delta1) = Some (b', delta).","proofString":"exploit H; eauto.\ncongruence."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') (b'1 : block) (delta1 : Z) (EQ : f1 b = Some (b'1, delta1)) : f2 b = Some (b'1, delta1) -> Some (b'1, delta1) = Some (b', delta).","proofString":"congruence."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') : f1 b = None -> None = Some (b', delta).","proofString":"intros.\nexploit H0; eauto.\nintros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') (H3 : f1 b = None) : None = Some (b', delta).","proofString":"exploit H0; eauto.\nintros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') (H3 : f1 b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b' -> None = Some (b', delta).","proofString":"intros [C D].\ncontradiction."},{"statement":"(f1 f2 : meminj) (m1 m1' : mem) (H : inject_incr f1 f2) (H0 : inject_separated f1 f2 m1 m1') (b b' : block) (delta : Z) (H1 : f2 b = Some (b', delta)) (H2 : Mem.valid_block m1' b') (H3 : f1 b = None) (C : ~ Mem.valid_block m1 b) (D : ~ Mem.valid_block m1' b') : None = Some (b', delta).","proofString":"contradiction."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) : match_env f2 cenv e sp lo hi.","proofString":"apply match_env_invariant with f1; auto.\nintros.\neapply inject_incr_separated_same'; eauto.\nintros.\neapply inject_incr_separated_same; eauto.\nred.\ndestruct H.\nextlia."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta).","proofString":"intros.\neapply inject_incr_separated_same'; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) (b : block) (delta : Z) (H4 : f2 b = Some (sp, delta)) : f1 b = Some (sp, delta).","proofString":"eapply inject_incr_separated_same'; eauto."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) : forall b : positive, Plt b lo -> f2 b = f1 b.","proofString":"intros.\neapply inject_incr_separated_same; eauto.\nred.\ndestruct H.\nextlia."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) (b : positive) (H4 : Plt b lo) : f2 b = f1 b.","proofString":"eapply inject_incr_separated_same; eauto.\nred.\ndestruct H.\nextlia."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) (b : positive) (H4 : Plt b lo) : Mem.valid_block m1 b.","proofString":"red.\ndestruct H.\nextlia."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (H : match_env f1 cenv e sp lo hi) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) (b : positive) (H4 : Plt b lo) : Plt b (Mem.nextblock m1).","proofString":"destruct H.\nextlia."},{"statement":"(f1 : meminj) (cenv : compilenv) (e : Csharpminor.env) (sp lo hi : block) (f2 : meminj) (m1 m1' : mem) (me_vars0 : forall id : positive, match_var f1 sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b0 : block) (sz : Z),\ne ! id = Some (b0, sz) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b0, sz)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (H0 : inject_incr f1 f2) (H1 : inject_separated f1 f2 m1 m1') (H2 : Ple hi (Mem.nextblock m1)) (H3 : Plt sp (Mem.nextblock m1')) (b : positive) (H4 : Plt b lo) : Plt b (Mem.nextblock m1).","proofString":"extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (b : block) (ofs : Z) (f2 : meminj) (ME : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (ALLOC : Mem.alloc m1 0 sz = (m2, b)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (SAME : f2 b = Some (sp, ofs)) (OTHER : forall b' : block, b' <> b -> f2 b' = f1 b') (ENV : e ! id = None) : match_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\ninv ME; constructor.\nintros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor.\nrewrite NEXTBLOCK; extlia.\nintros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia.\nintros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence.\nintros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (b : block) (ofs : Z) (f2 : meminj) (ME : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (ALLOC : Mem.alloc m1 0 sz = (m2, b)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (SAME : f2 b = Some (sp, ofs)) (OTHER : forall b' : block, b' <> b -> f2 b' = f1 b') (ENV : e ! id = None) : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1) ->\nmatch_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"intros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\ninv ME; constructor.\nintros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor.\nrewrite NEXTBLOCK; extlia.\nintros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia.\nintros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence.\nintros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (b : block) (ofs : Z) (f2 : meminj) (ME : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (ALLOC : Mem.alloc m1 0 sz = (m2, b)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (SAME : f2 b = Some (sp, ofs)) (OTHER : forall b' : block, b' <> b -> f2 b' = f1 b') (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) : match_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"exploit Mem.alloc_result; eauto.\nintros RES.\ninv ME; constructor.\nintros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor.\nrewrite NEXTBLOCK; extlia.\nintros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia.\nintros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence.\nintros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (b : block) (ofs : Z) (f2 : meminj) (ME : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (ALLOC : Mem.alloc m1 0 sz = (m2, b)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (SAME : f2 b = Some (sp, ofs)) (OTHER : forall b' : block, b' <> b -> f2 b' = f1 b') (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) : b = Mem.nextblock m1 ->\nmatch_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"intros RES.\ninv ME; constructor.\nintros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor.\nrewrite NEXTBLOCK; extlia.\nintros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia.\nintros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence.\nintros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (b : block) (ofs : Z) (f2 : meminj) (ME : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (ALLOC : Mem.alloc m1 0 sz = (m2, b)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (SAME : f2 b = Some (sp, ofs)) (OTHER : forall b' : block, b' <> b -> f2 b' = f1 b') (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) : match_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"inv ME; constructor.\nintros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor.\nrewrite NEXTBLOCK; extlia.\nintros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia.\nintros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence.\nintros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : forall id0 : positive,\nmatch_var f2 sp (PTree.set id (Mem.nextblock m1, sz) e) ! id0 cenv ! id0.","proofString":"intros.\nrewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) : match_var f2 sp (PTree.set id (Mem.nextblock m1, sz) e) ! id0 cenv ! id0.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) : match_var f2 sp (if peq id0 id then Some (Mem.nextblock m1, sz) else e ! id0)\n  cenv ! id0.","proofString":"destruct (peq id0 id).\nsubst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto.\ngeneralize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) (e0 : id0 = id) : match_var f2 sp (Some (Mem.nextblock m1, sz)) cenv ! id0.","proofString":"subst id0.\nrewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : match_var f2 sp (Some (Mem.nextblock m1, sz)) cenv ! id.","proofString":"rewrite CENV.\nconstructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : match_var f2 sp (Some (Mem.nextblock m1, sz)) (Some ofs).","proofString":"constructor.\neconstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : Val.inject f2 (Vptr (Mem.nextblock m1) Ptrofs.zero)\n  (Vptr sp (Ptrofs.repr ofs)).","proofString":"econstructor.\neauto.\nrewrite Ptrofs.add_commut; rewrite Ptrofs.add_zero; auto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) (n : id0 <> id) : match_var f2 sp e ! id0 cenv ! id0.","proofString":"generalize (me_vars0 id0).\nrewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) (n : id0 <> id) : match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0 ->\nmatch_var f2 sp e ! id0 cenv ! id0.","proofString":"rewrite PTree.gro; auto.\nintros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) (n : id0 <> id) : match_var f1 sp e ! id0 cenv ! id0 -> match_var f2 sp e ! id0 cenv ! id0.","proofString":"intros M; inv M.\nconstructor; eauto.\nconstructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (n : id0 <> id) (b : block) (sz0 ofs0 : Z) (H1 : Val.inject f1 (Vptr b Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs0))) (H : Some (b, sz0) = e ! id0) (H0 : Some ofs0 = cenv ! id0) : match_var f2 sp (Some (b, sz0)) (Some ofs0).","proofString":"constructor; eauto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b : block) (sz0 : Z),\ne ! id1 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id1 : positive) (sz0 : Z), e ! id1 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (id0 : positive) (n : id0 <> id) (H0 : None = e ! id0) (H : None = cenv ! id0) : match_var f2 sp None None.","proofString":"constructor."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : Ple lo (Mem.nextblock m2).","proofString":"rewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : forall (id0 : positive) (b : block) (sz0 : Z),\n(PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0) ->\nPle lo b /\\ Plt b (Mem.nextblock m2).","proofString":"intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (b : block) (sz0 : Z) (H : (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0)) : Ple lo b /\\ Plt b (Mem.nextblock m2).","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (b : block) (sz0 : Z) (H : (if peq id0 id then Some (Mem.nextblock m1, sz) else e ! id0) = Some (b, sz0)) : Ple lo b /\\ Plt b (Mem.nextblock m2).","proofString":"destruct (peq id0 id).\ninv H.\nrewrite NEXTBLOCK; extlia.\nexploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (b : block) (sz0 : Z) (e0 : id0 = id) (H : Some (Mem.nextblock m1, sz) = Some (b, sz0)) : Ple lo b /\\ Plt b (Mem.nextblock m2).","proofString":"inv H.\nrewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 m2 : Mem.mem') (ofs : Z) (f2 : meminj) (sz0 : Z) (ALLOC : Mem.alloc m1 0 sz0 = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz : Z),\ne ! id0 = Some (b, sz) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz : Z), e ! id0 = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : Ple lo (Mem.nextblock m1) /\\ Plt (Mem.nextblock m1) (Mem.nextblock m2).","proofString":"rewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (b : block) (sz0 : Z) (n : id0 <> id) (H : e ! id0 = Some (b, sz0)) : Ple lo b /\\ Plt b (Mem.nextblock m2).","proofString":"exploit me_bounded0; eauto.\nrewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id1 : positive, match_var f1 sp e ! id1 (PTree.remove id cenv) ! id1) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id1 : positive) (b0 : block) (sz1 : Z),\ne ! id1 = Some (b0, sz1) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta : Z),\nf1 b0 = Some (sp, delta) ->\nexists (id1 : positive) (sz1 : Z), e ! id1 = Some (b0, sz1)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf1 b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (id0 : positive) (b : block) (sz0 : Z) (n : id0 <> id) (H : e ! id0 = Some (b, sz0)) : Ple lo b /\\ Plt b (Mem.nextblock m1) -> Ple lo b /\\ Plt b (Mem.nextblock m2).","proofString":"rewrite NEXTBLOCK; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"intros.\ndestruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f2 b = Some (sp, delta)) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"destruct (eq_block b (Mem.nextblock m1)).\nsubst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss.\nrewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f2 b = Some (sp, delta)) (e0 : b = Mem.nextblock m1) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"subst b.\nrewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta0 : Z),\nf1 b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf1 b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (delta : Z) (H : f2 (Mem.nextblock m1) = Some (sp, delta)) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 =\n  Some (Mem.nextblock m1, sz0).","proofString":"rewrite SAME in H; inv H.\nexists id; exists sz.\napply PTree.gss."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (delta : Z) (CENV : cenv ! id = Some delta) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, delta)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta0 : Z),\nf1 b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf1 b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 =\n  Some (Mem.nextblock m1, sz0).","proofString":"exists id; exists sz.\napply PTree.gss."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (delta : Z) (CENV : cenv ! id = Some delta) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, delta)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta0 : Z),\nf1 b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf1 b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) : (PTree.set id (Mem.nextblock m1, sz) e) ! id = Some (Mem.nextblock m1, sz).","proofString":"apply PTree.gss."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f2 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"rewrite OTHER in H; auto.\nexploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f1 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"exploit me_inv0; eauto.\nintros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f1 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) : (exists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) ->\nexists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"intros [id1 [sz1 EQ]].\nexists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f1 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) (id1 : positive) (sz1 : Z) (EQ : e ! id1 = Some (b, sz1)) : exists (id0 : positive) (sz0 : Z),\n  (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b, sz0).","proofString":"exists id1; exists sz1.\nrewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f1 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) (id1 : positive) (sz1 : Z) (EQ : e ! id1 = Some (b, sz1)) : (PTree.set id (Mem.nextblock m1, sz) e) ! id1 = Some (b, sz1).","proofString":"rewrite PTree.gso; auto.\ncongruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf1 b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (b : block) (delta : Z) (H : f1 b = Some (sp, delta)) (n : b <> Mem.nextblock m1) (id1 : positive) (sz1 : Z) (EQ : e ! id1 = Some (b, sz1)) : id1 <> id.","proofString":"congruence."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b (Mem.nextblock m1)) (me_inv0 : forall (b : block) (delta : Z),\nf1 b = Some (sp, delta) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta : Z),\nf1 b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : forall (b tb : block) (delta : Z),\nf2 b = Some (tb, delta) -> Plt b lo -> Plt tb sp.","proofString":"intros.\nrewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb0 : block) (delta0 : Z),\nf1 b0 = Some (tb0, delta0) -> Plt b0 lo -> Plt tb0 sp) (b tb : block) (delta : Z) (H : f2 b = Some (tb, delta)) (H0 : Plt b lo) : Plt tb sp.","proofString":"rewrite OTHER in H.\neauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb0 : block) (delta0 : Z),\nf1 b0 = Some (tb0, delta0) -> Plt b0 lo -> Plt tb0 sp) (b tb : block) (delta : Z) (H : f1 b = Some (tb, delta)) (H0 : Plt b lo) : Plt tb sp.","proofString":"eauto."},{"statement":"(f1 : meminj) (id : positive) (cenv : PTree.tree Z) (e : Csharpminor.env) (sp lo : block) (m1 : Mem.mem') (sz : Z) (m2 : Mem.mem') (ofs : Z) (f2 : meminj) (ALLOC : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (CENV : cenv ! id = Some ofs) (INCR : inject_incr f1 f2) (OTHER : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (SAME : f2 (Mem.nextblock m1) = Some (sp, ofs)) (ENV : e ! id = None) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (me_vars0 : forall id0 : positive, match_var f1 sp e ! id0 (PTree.remove id cenv) ! id0) (me_low_high0 : Ple lo (Mem.nextblock m1)) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 (Mem.nextblock m1)) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf1 b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb0 : block) (delta0 : Z),\nf1 b0 = Some (tb0, delta0) -> Plt b0 lo -> Plt tb0 sp) (b tb : block) (delta : Z) (H : f2 b = Some (tb, delta)) (H0 : Plt b lo) : b <> Mem.nextblock m1.","proofString":"unfold block in *; extlia."},{"statement":"(e : Csharpminor.env) (m1 m2 : mem) (H : match_bounds e m1) (H0 : forall (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p0 : permission),\ne ! id0 = Some (b0, sz0) ->\nMem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H1 : e ! id = Some (b, sz)) (H2 : Mem.perm m2 b ofs Max p) : 0 <= ofs < sz.","proofString":"eapply H; eauto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b : positive, Plt b hi -> f2 b = f1 b) (ofs : Z) (H3 : 0 <= ofs < sz) : Mem.perm tm2 sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"exploit H; eauto.\nintros [A | A].\nleft; auto.\nright.\ninv A.\nexploit me_bounded; eauto.\nintros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b : positive, Plt b hi -> f2 b = f1 b) (ofs : Z) (H3 : 0 <= ofs < sz) : Mem.perm tm1 sp ofs Cur Freeable \\/ is_reachable_from_env f1 e sp ofs ->\nMem.perm tm2 sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"intros [A | A].\nleft; auto.\nright.\ninv A.\nexploit me_bounded; eauto.\nintros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b : positive, Plt b hi -> f2 b = f1 b) (ofs : Z) (H3 : 0 <= ofs < sz) (A : Mem.perm tm1 sp ofs Cur Freeable) : Mem.perm tm2 sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"left; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b : positive, Plt b hi -> f2 b = f1 b) (ofs : Z) (H3 : 0 <= ofs < sz) (A : is_reachable_from_env f1 e sp ofs) : Mem.perm tm2 sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"right.\ninv A.\nexploit me_bounded; eauto.\nintros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b : positive, Plt b hi -> f2 b = f1 b) (ofs : Z) (H3 : 0 <= ofs < sz) (A : is_reachable_from_env f1 e sp ofs) : is_reachable_from_env f2 e sp ofs.","proofString":"inv A.\nexploit me_bounded; eauto.\nintros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b0 : positive, Plt b0 hi -> f2 b0 = f1 b0) (ofs : Z) (H3 : 0 <= ofs < sz) (id : positive) (b : block) (sz0 delta : Z) (H4 : e ! id = Some (b, sz0)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz0) : is_reachable_from_env f2 e sp ofs.","proofString":"exploit me_bounded; eauto.\nintros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b0 : positive, Plt b0 hi -> f2 b0 = f1 b0) (ofs : Z) (H3 : 0 <= ofs < sz) (id : positive) (b : block) (sz0 delta : Z) (H4 : e ! id = Some (b, sz0)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz0) : Ple lo b /\\ Plt b hi -> is_reachable_from_env f2 e sp ofs.","proofString":"intros [D E].\neconstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b0 : positive, Plt b0 hi -> f2 b0 = f1 b0) (ofs : Z) (H3 : 0 <= ofs < sz) (id : positive) (b : block) (sz0 delta : Z) (H4 : e ! id = Some (b, sz0)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz0) (D : Ple lo b) (E : Plt b hi) : is_reachable_from_env f2 e sp ofs.","proofString":"econstructor; eauto.\nrewrite H2; auto."},{"statement":"(f1 : meminj) (e : Csharpminor.env) (tm1 : mem) (sp : block) (sz : Z) (cenv : compilenv) (lo hi : block) (f2 : positive -> option (block * Z)) (tm2 : mem) (H : padding_freeable f1 e tm1 sp sz) (H0 : match_env f1 cenv e sp lo hi) (H1 : forall ofs0 : Z,\nMem.perm tm1 sp ofs0 Cur Freeable -> Mem.perm tm2 sp ofs0 Cur Freeable) (H2 : forall b0 : positive, Plt b0 hi -> f2 b0 = f1 b0) (ofs : Z) (H3 : 0 <= ofs < sz) (id : positive) (b : block) (sz0 delta : Z) (H4 : e ! id = Some (b, sz0)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz0) (D : Ple lo b) (E : Plt b hi) : f2 b = Some (sp, delta).","proofString":"rewrite H2; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) : is_reachable_from_env f e sp ofs \\/ ~ is_reachable_from_env f e sp ofs.","proofString":"set (pred := fun id_b_sz : ident * (block * Z) =>                 match id_b_sz with                 | (id, (b, sz)) =>                      match f b with                           | None => false                           | Some(sp', delta) =>                               if eq_block sp sp'                               then zle delta ofs && zlt ofs (delta + sz)                               else false                      end                 end).\ndestruct (List.existsb pred (PTree.elements e)) eqn:?.\nrewrite List.existsb_exists in Heqb.\ndestruct Heqb as [[id [b sz]] [A B]].\nsimpl in B.\ndestruct (f b) as [[sp' delta] |] eqn:?; try discriminate.\ndestruct (eq_block sp sp'); try discriminate.\ndestruct (andb_prop _ _ B).\nleft.\napply is_reachable_intro with id b sz delta.\napply PTree.elements_complete; auto.\ncongruence.\nsplit; eapply proj_sumbool_true; eauto.\nright; red; intro NE; inv NE.\nassert (existsb pred (PTree.elements e) = true).\nrewrite List.existsb_exists.\nexists (id, (b, sz)); split.\napply PTree.elements_correct; auto.\nsimpl.\nrewrite H0.\nrewrite dec_eq_true.\nunfold proj_sumbool.\ndestruct H1.\nrewrite zle_true; auto.\nrewrite zlt_true; auto.\ncongruence."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (id : ident) (b : block) (sz : Z) (A : In (id, (b, sz)) (PTree.elements e)) (B : match f b with\n| Some (sp', delta) =>\n    if eq_block sp sp' then zle delta ofs && zlt ofs (delta + sz) else false\n| None => false\nend = true) : is_reachable_from_env f e sp ofs \\/ ~ is_reachable_from_env f e sp ofs.","proofString":"destruct (f b) as [[sp' delta] |] eqn:?; try discriminate.\ndestruct (eq_block sp sp'); try discriminate.\ndestruct (andb_prop _ _ B).\nleft.\napply is_reachable_intro with id b sz delta.\napply PTree.elements_complete; auto.\ncongruence.\nsplit; eapply proj_sumbool_true; eauto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (id : ident) (b : block) (sz : Z) (A : In (id, (b, sz)) (PTree.elements e)) (sp' : block) (delta : Z) (Heqo : f b = Some (sp', delta)) (B : (if eq_block sp sp' then zle delta ofs && zlt ofs (delta + sz) else false) =\ntrue) : is_reachable_from_env f e sp ofs \\/ ~ is_reachable_from_env f e sp ofs.","proofString":"destruct (eq_block sp sp'); try discriminate.\ndestruct (andb_prop _ _ B).\nleft.\napply is_reachable_intro with id b sz delta.\napply PTree.elements_complete; auto.\ncongruence.\nsplit; eapply proj_sumbool_true; eauto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (id : ident) (b : block) (sz : Z) (A : In (id, (b, sz)) (PTree.elements e)) (sp' : block) (delta : Z) (Heqo : f b = Some (sp', delta)) (e0 : sp = sp') (B : zle delta ofs && zlt ofs (delta + sz) = true) : is_reachable_from_env f e sp ofs \\/ ~ is_reachable_from_env f e sp ofs.","proofString":"destruct (andb_prop _ _ B).\nleft.\napply is_reachable_intro with id b sz delta.\napply PTree.elements_complete; auto.\ncongruence.\nsplit; eapply proj_sumbool_true; eauto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) : In (id, (b, sz)) (PTree.elements e).","proofString":"apply PTree.elements_correct; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) : match f b with\n| Some (sp', delta0) =>\n    if eq_block sp sp'\n    then zle delta0 ofs && zlt ofs (delta0 + sz)\n    else false\n| None => false\nend = true.","proofString":"rewrite H0.\nrewrite dec_eq_true.\nunfold proj_sumbool.\ndestruct H1.\nrewrite zle_true; auto.\nrewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) : (if eq_block sp sp then zle delta ofs && zlt ofs (delta + sz) else false) =\ntrue.","proofString":"rewrite dec_eq_true.\nunfold proj_sumbool.\ndestruct H1.\nrewrite zle_true; auto.\nrewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) : zle delta ofs && zlt ofs (delta + sz) = true.","proofString":"unfold proj_sumbool.\ndestruct H1.\nrewrite zle_true; auto.\nrewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) : (if zle delta ofs then true else false) &&\n(if zlt ofs (delta + sz) then true else false) = true.","proofString":"destruct H1.\nrewrite zle_true; auto.\nrewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs) (H2 : ofs < delta + sz) : (if zle delta ofs then true else false) &&\n(if zlt ofs (delta + sz) then true else false) = true.","proofString":"rewrite zle_true; auto.\nrewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs) (H2 : ofs < delta + sz) : true && (if zlt ofs (delta + sz) then true else false) = true.","proofString":"rewrite zlt_true; auto."},{"statement":"(f : meminj) (e : Csharpminor.env) (sp : block) (ofs : Z) (pred : ident * (block * Z) -> bool) (Heqb : existsb pred (PTree.elements e) = false) (id : positive) (b : block) (sz delta : Z) (H : e ! id = Some (b, sz)) (H0 : f b = Some (sp, delta)) (H1 : delta <= ofs < delta + sz) (H2 : existsb pred (PTree.elements e) = true) : False.","proofString":"congruence."},{"statement":"(f : meminj) (hi : block) (H : match_globalenvs f hi) : meminj_preserves_globals ge f.","proofString":"inv H.\nsplit.\nintros.\napply DOMAIN.\neapply SYMBOLS.\neauto.\nsplit.\nintros.\napply DOMAIN.\neapply VARINFOS.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : meminj_preserves_globals ge f.","proofString":"split.\nintros.\napply DOMAIN.\neapply SYMBOLS.\neauto.\nsplit.\nintros.\napply DOMAIN.\neapply VARINFOS.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0).","proofString":"intros.\napply DOMAIN.\neapply SYMBOLS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b0 : positive, Plt b0 hi -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 hi) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 hi) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 hi) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : f b = Some (b, 0).","proofString":"apply DOMAIN.\neapply SYMBOLS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b0 : positive, Plt b0 hi -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 hi) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 hi) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 hi) (id : ident) (b : block) (H : Genv.find_symbol ge id = Some b) : Plt b hi.","proofString":"eapply SYMBOLS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : (forall (b : block) (gv : globvar unit),\n Genv.find_var_info ge b = Some gv -> f b = Some (b, 0)) /\\\n(forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\n Genv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1).","proofString":"split.\nintros.\napply DOMAIN.\neapply VARINFOS.\neauto.\nintros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0).","proofString":"intros.\napply DOMAIN.\neapply VARINFOS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b0 : positive, Plt b0 hi -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 hi) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 hi) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 hi) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv) : f b = Some (b, 0).","proofString":"apply DOMAIN.\neapply VARINFOS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b0 : positive, Plt b0 hi -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 hi) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 hi) (VARINFOS : forall (b0 : block) (gv0 : globvar unit),\nGenv.find_var_info ge b0 = Some gv0 -> Plt b0 hi) (b : block) (gv : globvar unit) (H : Genv.find_var_info ge b = Some gv) : Plt b hi.","proofString":"eapply VARINFOS.\neauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : forall (b1 b2 : block) (delta : Z) (gv : globvar unit),\nGenv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1.","proofString":"intros.\nsymmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv0 : globvar unit),\nGenv.find_var_info ge b = Some gv0 -> Plt b hi) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta)) : b2 = b1.","proofString":"symmetry.\neapply IMAGE; eauto."},{"statement":"(f : meminj) (hi : block) (DOMAIN : forall b : positive, Plt b hi -> f b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv0 : globvar unit),\nGenv.find_var_info ge b = Some gv0 -> Plt b hi) (b1 b2 : block) (delta : Z) (gv : globvar unit) (H : Genv.find_var_info ge b2 = Some gv) (H0 : f b1 = Some (b2, delta)) : b1 = b2.","proofString":"eapply IMAGE; eauto."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (hi : block) (bound tbound : positive) (H : match_globalenvs f1 hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : inject_incr f1 f2) (H3 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H4 : forall (sp : positive) (ofs : Z),\nPlt sp tbound ->\nMem.perm tm1 sp ofs Cur Freeable -> Mem.perm tm2 sp ofs Cur Freeable) (H5 : forall b : positive, Plt b bound -> f2 b = f1 b) (H6 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) : match_callstack f2 m2 tm2 nil bound tbound.","proofString":"econstructor; eauto.\ninv H.\nconstructor; intros; eauto.\neapply IMAGE; eauto.\neapply H6; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (hi : block) (bound tbound : positive) (H : match_globalenvs f1 hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : inject_incr f1 f2) (H3 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H4 : forall (sp : positive) (ofs : Z),\nPlt sp tbound ->\nMem.perm tm1 sp ofs Cur Freeable -> Mem.perm tm2 sp ofs Cur Freeable) (H5 : forall b : positive, Plt b bound -> f2 b = f1 b) (H6 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) : match_globalenvs f2 hi.","proofString":"inv H.\nconstructor; intros; eauto.\neapply IMAGE; eauto.\neapply H6; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : inject_incr f1 f2) (H3 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H4 : forall (sp : positive) (ofs : Z),\nPlt sp tbound ->\nMem.perm tm1 sp ofs Cur Freeable -> Mem.perm tm2 sp ofs Cur Freeable) (H5 : forall b : positive, Plt b bound -> f2 b = f1 b) (H6 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf1 b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : match_globalenvs f2 hi.","proofString":"constructor; intros; eauto.\neapply IMAGE; eauto.\neapply H6; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : inject_incr f1 f2) (H3 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H4 : forall (sp : positive) (ofs : Z),\nPlt sp tbound ->\nMem.perm tm1 sp ofs Cur Freeable -> Mem.perm tm2 sp ofs Cur Freeable) (H5 : forall b : positive, Plt b bound -> f2 b = f1 b) (H6 : forall (b b' : block) (delta0 : Z),\nf2 b = Some (b', delta0) -> Plt b' tbound -> f1 b = Some (b', delta0)) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H7 : Plt b2 hi) : b1 = b2.","proofString":"eapply IMAGE; eauto.\neapply H6; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : inject_incr f1 f2) (H3 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H4 : forall (sp : positive) (ofs : Z),\nPlt sp tbound ->\nMem.perm tm1 sp ofs Cur Freeable -> Mem.perm tm2 sp ofs Cur Freeable) (H5 : forall b : positive, Plt b bound -> f2 b = f1 b) (H6 : forall (b b' : block) (delta0 : Z),\nf2 b = Some (b', delta0) -> Plt b' tbound -> f1 b = Some (b', delta0)) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H7 : Plt b2 hi) : Plt b2 tbound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) : match_callstack f2 m2 tm2 (Frame cenv tf e le te sp lo hi :: cs) bound tbound.","proofString":"assert (Ple lo hi) by (eapply me_low_high; eauto).\neconstructor; eauto.\neapply match_temps_invariant; eauto.\neapply match_env_invariant; eauto.\nintros.\napply H3.\nextlia.\neapply match_bounds_invariant; eauto.\nintros.\neapply H1; eauto.\nexploit me_bounded; eauto.\nextlia.\neapply padding_freeable_invariant; eauto.\nintros.\napply H3.\nextlia.\neapply IHmatch_callstack; eauto.\nintros.\neapply H1; eauto.\nextlia.\nintros.\neapply H2; eauto.\nextlia.\nintros.\neapply H3; eauto.\nextlia.\nintros.\neapply H4; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : match_callstack f2 m2 tm2 (Frame cenv tf e le te sp lo hi :: cs) bound tbound.","proofString":"econstructor; eauto.\neapply match_temps_invariant; eauto.\neapply match_env_invariant; eauto.\nintros.\napply H3.\nextlia.\neapply match_bounds_invariant; eauto.\nintros.\neapply H1; eauto.\nexploit me_bounded; eauto.\nextlia.\neapply padding_freeable_invariant; eauto.\nintros.\napply H3.\nextlia.\neapply IHmatch_callstack; eauto.\nintros.\neapply H1; eauto.\nextlia.\nintros.\neapply H2; eauto.\nextlia.\nintros.\neapply H3; eauto.\nextlia.\nintros.\neapply H4; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : match_temps f2 le te.","proofString":"eapply match_temps_invariant; eauto."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : match_env f2 cenv e sp lo hi.","proofString":"eapply match_env_invariant; eauto.\nintros.\napply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall b : positive, Plt b lo -> f2 b = f1 b.","proofString":"intros.\napply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b lo) : f2 b = f1 b.","proofString":"apply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b lo) : Plt b bound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : match_bounds e m2.","proofString":"eapply match_bounds_invariant; eauto.\nintros.\neapply H1; eauto.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall (id : positive) (b : block) (sz ofs : Z) (p : permission),\ne ! id = Some (b, sz) -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p.","proofString":"intros.\neapply H1; eauto.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs0 : Z) (p0 : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) ->\n(forall (sp0 : positive) (ofs0 : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs0 : Z) (p0 : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (H2 : forall (sp0 : positive) (ofs0 : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H6 : e ! id = Some (b, sz)) (H7 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","proofString":"eapply H1; eauto.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs0 : Z) (p0 : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) ->\n(forall (sp0 : positive) (ofs0 : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs0 : Z) (p0 : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (H2 : forall (sp0 : positive) (ofs0 : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H6 : e ! id = Some (b, sz)) (H7 : Mem.perm m2 b ofs Max p) : Plt b bound.","proofString":"exploit me_bounded; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs0 : Z) (p0 : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) ->\n(forall (sp0 : positive) (ofs0 : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs0 : Z) (p0 : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (H2 : forall (sp0 : positive) (ofs0 : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H6 : e ! id = Some (b, sz)) (H7 : Mem.perm m2 b ofs Max p) : Ple lo b /\\ Plt b hi -> Plt b bound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : padding_freeable f2 e tm2 sp (fn_stackspace tf).","proofString":"eapply padding_freeable_invariant; eauto.\nintros.\napply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall b : positive, Plt b hi -> f2 b = f1 b.","proofString":"intros.\napply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b hi) : f2 b = f1 b.","proofString":"apply H3.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b hi) : Plt b bound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : match_callstack f2 m2 tm2 cs lo sp.","proofString":"eapply IHmatch_callstack; eauto.\nintros.\neapply H1; eauto.\nextlia.\nintros.\neapply H2; eauto.\nextlia.\nintros.\neapply H3; eauto.\nextlia.\nintros.\neapply H4; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall (b : positive) (ofs : Z) (p : permission),\nPlt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p.","proofString":"intros.\neapply H1; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs0 : Z) (p0 : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) ->\n(forall (sp0 : positive) (ofs0 : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs0 : Z) (p0 : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (H2 : forall (sp0 : positive) (ofs0 : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (ofs : Z) (p : permission) (H6 : Plt b lo) (H7 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","proofString":"eapply H1; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs0 : Z) (p0 : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) ->\n(forall (sp0 : positive) (ofs0 : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs0 : Z) (p0 : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (H2 : forall (sp0 : positive) (ofs0 : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs0 Cur Freeable -> Mem.perm tm2 sp0 ofs0 Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (ofs : Z) (p : permission) (H6 : Plt b lo) (H7 : Mem.perm m2 b ofs Max p) : Plt b bound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall (sp0 : positive) (ofs : Z),\nPlt sp0 sp ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable.","proofString":"intros.\neapply H2; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs0 : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) ->\n(forall (sp1 : positive) (ofs0 : Z),\n Plt sp1 sp ->\n Mem.perm tm1 sp1 ofs0 Cur Freeable -> Mem.perm tm2 sp1 ofs0 Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs0 : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (H2 : forall (sp1 : positive) (ofs0 : Z),\nPlt sp1 tbound ->\nMem.perm tm1 sp1 ofs0 Cur Freeable -> Mem.perm tm2 sp1 ofs0 Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) (sp0 : positive) (ofs : Z) (H6 : Plt sp0 sp) (H7 : Mem.perm tm1 sp0 ofs Cur Freeable) : Mem.perm tm2 sp0 ofs Cur Freeable.","proofString":"eapply H2; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs0 : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) ->\n(forall (sp1 : positive) (ofs0 : Z),\n Plt sp1 sp ->\n Mem.perm tm1 sp1 ofs0 Cur Freeable -> Mem.perm tm2 sp1 ofs0 Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs0 : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (H2 : forall (sp1 : positive) (ofs0 : Z),\nPlt sp1 tbound ->\nMem.perm tm1 sp1 ofs0 Cur Freeable -> Mem.perm tm2 sp1 ofs0 Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) (sp0 : positive) (ofs : Z) (H6 : Plt sp0 sp) (H7 : Mem.perm tm1 sp0 ofs Cur Freeable) : Plt sp0 tbound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall b : positive, Plt b lo -> f2 b = f1 b.","proofString":"intros.\neapply H3; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b lo) : f2 b = f1 b.","proofString":"eapply H3; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b' : block) (delta : Z),\n f2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' tbound -> f1 b0 = Some (b', delta)) (H5 : Ple lo hi) (b : positive) (H6 : Plt b lo) : Plt b bound.","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b : positive) (ofs : Z) (p : permission),\n Plt b lo -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b : positive, Plt b lo -> f2 b = f1 b) ->\n(forall (b b' : block) (delta : Z),\n f2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b : positive) (ofs : Z) (p : permission),\nPlt b bound -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b : positive, Plt b bound -> f2 b = f1 b) (H4 : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' tbound -> f1 b = Some (b', delta)) (H5 : Ple lo hi) : forall (b b' : block) (delta : Z),\nf2 b = Some (b', delta) -> Plt b' sp -> f1 b = Some (b', delta).","proofString":"intros.\neapply H4; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f2 b0 = Some (b'0, delta0) -> Plt b'0 sp -> f1 b0 = Some (b'0, delta0)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b'0 : block) (delta0 : Z),\nf2 b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f1 b0 = Some (b'0, delta0)) (H5 : Ple lo hi) (b b' : block) (delta : Z) (H6 : f2 b = Some (b', delta)) (H7 : Plt b' sp) : f1 b = Some (b', delta).","proofString":"eapply H4; eauto.\nextlia."},{"statement":"(f1 : meminj) (m1 tm1 : mem) (f2 : meminj) (m2 tm2 : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm1 sp (fn_stackspace tf)) (H : match_callstack f1 m1 tm1 cs lo sp) (IHmatch_callstack : inject_incr f1 f2 ->\n(forall (b0 : positive) (ofs : Z) (p : permission),\n Plt b0 lo -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) ->\n(forall (sp0 : positive) (ofs : Z),\n Plt sp0 sp ->\n Mem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) ->\n(forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0) ->\n(forall (b0 b'0 : block) (delta0 : Z),\n f2 b0 = Some (b'0, delta0) -> Plt b'0 sp -> f1 b0 = Some (b'0, delta0)) ->\nmatch_callstack f2 m2 tm2 cs lo sp) (H0 : inject_incr f1 f2) (H1 : forall (b0 : positive) (ofs : Z) (p : permission),\nPlt b0 bound -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (H2 : forall (sp0 : positive) (ofs : Z),\nPlt sp0 tbound ->\nMem.perm tm1 sp0 ofs Cur Freeable -> Mem.perm tm2 sp0 ofs Cur Freeable) (H3 : forall b0 : positive, Plt b0 bound -> f2 b0 = f1 b0) (H4 : forall (b0 b'0 : block) (delta0 : Z),\nf2 b0 = Some (b'0, delta0) -> Plt b'0 tbound -> f1 b0 = Some (b'0, delta0)) (H5 : Ple lo hi) (b b' : block) (delta : Z) (H6 : f2 b = Some (b', delta)) (H7 : Plt b' sp) : Plt b' tbound.","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (bound tbound : block) (bound' tbound' : positive) (H : match_callstack f m tm cs bound tbound) (H0 : Ple bound bound') (H1 : Ple tbound tbound') : match_callstack f m tm cs bound' tbound'.","proofString":"inv H.\neconstructor; eauto.\nextlia.\nextlia.\nconstructor; auto.\nextlia.\nextlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (hi : block) (H2 : match_globalenvs f hi) (H3 : Ple hi bound) (H4 : Ple hi tbound) : match_callstack f m tm nil bound' tbound'.","proofString":"econstructor; eauto.\nextlia.\nextlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (hi : block) (H2 : match_globalenvs f hi) (H3 : Ple hi bound) (H4 : Ple hi tbound) : Ple hi bound'.","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (hi : block) (H2 : match_globalenvs f hi) (H3 : Ple hi bound) (H4 : Ple hi tbound) : Ple hi tbound'.","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs0 : callstack) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs0 lo sp) : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs0) bound' tbound'.","proofString":"constructor; auto.\nextlia.\nextlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs0 : callstack) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs0 lo sp) : Ple hi bound'.","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (bound tbound : block) (bound' tbound' : positive) (H0 : Ple bound bound') (H1 : Ple tbound tbound') (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs0 : callstack) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs0 lo sp) : Plt sp tbound'.","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (bound tbound : block) (m tm : mem) (tf : function) (id : positive) (v tv : val) (H : Val.inject f v tv) (H0 : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs) bound tbound) : match_callstack f m tm\n  (Frame cenv tf e (PTree.set id v le) (PTree.set id tv te) sp lo hi :: cs)\n  bound tbound.","proofString":"inv H0.\nconstructor; auto.\neapply match_temps_assign; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (bound tbound : block) (m tm : mem) (tf : function) (id : positive) (v tv : val) (H : Val.inject f v tv) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) : match_callstack f m tm\n  (Frame cenv tf e (PTree.set id v le) (PTree.set id tv te) sp lo hi :: cs)\n  bound tbound.","proofString":"constructor; auto.\neapply match_temps_assign; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (bound tbound : block) (m tm : mem) (tf : function) (id : positive) (v tv : val) (H : Val.inject f v tv) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) : match_temps f (PTree.set id v le) (PTree.set id tv te).","proofString":"eapply match_temps_assign; eauto."},{"statement":"(e : PTree.tree (block * Z)) (id : positive) (b : block) (sz : Z) (H : e ! id = Some (b, sz)) : In (b, 0, sz) (map block_of_binding (PTree.elements e)).","proofString":"change (b, 0, sz) with (block_of_binding (id, (b, sz))).\napply List.in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(e : PTree.tree (block * Z)) (id : positive) (b : block) (sz : Z) (H : e ! id = Some (b, sz)) : In (block_of_binding (id, (b, sz))) (map block_of_binding (PTree.elements e)).","proofString":"apply List.in_map.\napply PTree.elements_correct.\nauto."},{"statement":"(e : PTree.tree (block * Z)) (id : positive) (b : block) (sz : Z) (H : e ! id = Some (b, sz)) : In (id, (b, sz)) (PTree.elements e).","proofString":"apply PTree.elements_correct.\nauto."},{"statement":"(e : PTree.tree (block * Z)) (id : positive) (b : block) (sz : Z) (H : e ! id = Some (b, sz)) : e ! id = Some (b, sz).","proofString":"auto."},{"statement":"(b : block) (lo hi : Z) (e : Csharpminor.env) (H : In (b, lo, hi) (map block_of_binding (PTree.elements e))) : exists id : positive, e ! id = Some (b, hi) /\\ lo = 0.","proofString":"exploit list_in_map_inv; eauto.\nintros [[id [b' sz]] [A B]].\nunfold block_of_binding in A.\ninv A.\nexists id; intuition.\napply PTree.elements_complete.\nauto."},{"statement":"(b : block) (lo hi : Z) (e : Csharpminor.env) (H : In (b, lo, hi) (map block_of_binding (PTree.elements e))) : (exists x : ident * (block * Z),\n   (b, lo, hi) = block_of_binding x /\\ In x (PTree.elements e)) ->\nexists id : positive, e ! id = Some (b, hi) /\\ lo = 0.","proofString":"intros [[id [b' sz]] [A B]].\nunfold block_of_binding in A.\ninv A.\nexists id; intuition.\napply PTree.elements_complete.\nauto."},{"statement":"(b : block) (lo hi : Z) (e : Csharpminor.env) (H : In (b, lo, hi) (map block_of_binding (PTree.elements e))) (id : ident) (b' : block) (sz : Z) (A : (b, lo, hi) = block_of_binding (id, (b', sz))) (B : In (id, (b', sz)) (PTree.elements e)) : exists id0 : positive, e ! id0 = Some (b, hi) /\\ lo = 0.","proofString":"unfold block_of_binding in A.\ninv A.\nexists id; intuition.\napply PTree.elements_complete.\nauto."},{"statement":"(b : block) (lo hi : Z) (e : Csharpminor.env) (H : In (b, lo, hi) (map block_of_binding (PTree.elements e))) (id : ident) (b' : block) (sz : Z) (A : (b, lo, hi) = (b', 0, sz)) (B : In (id, (b', sz)) (PTree.elements e)) : exists id0 : positive, e ! id0 = Some (b, hi) /\\ lo = 0.","proofString":"inv A.\nexists id; intuition.\napply PTree.elements_complete.\nauto."},{"statement":"(e : Csharpminor.env) (b' : block) (sz : Z) (H : In (b', 0, sz) (map block_of_binding (PTree.elements e))) (id : ident) (B : In (id, (b', sz)) (PTree.elements e)) : exists id0 : positive, e ! id0 = Some (b', sz) /\\ 0 = 0.","proofString":"exists id; intuition.\napply PTree.elements_complete.\nauto."},{"statement":"(e : Csharpminor.env) (b' : block) (sz : Z) (H : In (b', 0, sz) (map block_of_binding (PTree.elements e))) (id : ident) (B : In (id, (b', sz)) (PTree.elements e)) : e ! id = Some (b', sz).","proofString":"apply PTree.elements_complete.\nauto."},{"statement":"(e : Csharpminor.env) (b' : block) (sz : Z) (H : In (b', 0, sz) (map block_of_binding (PTree.elements e))) (id : ident) (B : In (id, (b', sz)) (PTree.elements e)) : In (id, (b', sz)) (PTree.elements e).","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (MCS : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) : exists tm' : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm' /\\\n  match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\n  Mem.inject f m' tm'.","proofString":"inv MCS.\ninv MENV.\nassert ({tm' | Mem.free tm sp 0 (fn_stackspace tf) = Some tm'}).\napply Mem.range_perm_free.\nred; intros.\nexploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia.\ndestruct X as  [tm' FREE].\nexploit nextblock_freelist; eauto.\nintro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) : exists tm' : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm' /\\\n  match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\n  Mem.inject f m' tm'.","proofString":"inv MENV.\nassert ({tm' | Mem.free tm sp 0 (fn_stackspace tf) = Some tm'}).\napply Mem.range_perm_free.\nred; intros.\nexploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia.\ndestruct X as  [tm' FREE].\nexploit nextblock_freelist; eauto.\nintro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : exists tm' : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm' /\\\n  match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\n  Mem.inject f m' tm'.","proofString":"assert ({tm' | Mem.free tm sp 0 (fn_stackspace tf) = Some tm'}).\napply Mem.range_perm_free.\nred; intros.\nexploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia.\ndestruct X as  [tm' FREE].\nexploit nextblock_freelist; eauto.\nintro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : {tm' : mem | Mem.free tm sp 0 (fn_stackspace tf) = Some tm'}.","proofString":"apply Mem.range_perm_free.\nred; intros.\nexploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) : Mem.range_perm tm sp 0 (fn_stackspace tf) Cur Freeable.","proofString":"red; intros.\nexploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) : Mem.perm tm sp ofs Cur Freeable.","proofString":"exploit PERM; eauto.\nintros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) : Mem.perm tm sp ofs Cur Freeable \\/ is_reachable_from_env f e sp ofs ->\nMem.perm tm sp ofs Cur Freeable.","proofString":"intros [A | A].\nauto.\ninv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (A : Mem.perm tm sp ofs Cur Freeable) : Mem.perm tm sp ofs Cur Freeable.","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (A : is_reachable_from_env f e sp ofs) : Mem.perm tm sp ofs Cur Freeable.","proofString":"inv A.\nassert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) : Mem.perm tm sp ofs Cur Freeable.","proofString":"assert (Mem.range_perm m b 0 sz Cur Freeable).\neapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto.\nreplace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) : Mem.range_perm m b 0 sz Cur Freeable.","proofString":"eapply free_list_freeable; eauto.\neapply in_blocks_of_env; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) : In (b, 0, sz) (blocks_of_env e).","proofString":"eapply in_blocks_of_env; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) (H3 : Mem.range_perm m b 0 sz Cur Freeable) : Mem.perm tm sp ofs Cur Freeable.","proofString":"replace ofs with ((ofs - delta) + delta) by lia.\neapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) (H3 : Mem.range_perm m b 0 sz Cur Freeable) : Mem.perm tm sp (ofs - delta + delta) Cur Freeable.","proofString":"eapply Mem.perm_inject; eauto.\napply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) (H3 : Mem.range_perm m b 0 sz Cur Freeable) : Mem.perm m b (ofs - delta) Cur Freeable.","proofString":"apply H3.\nlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz0 : Z),\ne ! id0 = Some (b0, sz0) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b0, sz0)) (me_incr0 : forall (b0 tb : block) (delta0 : Z),\nf b0 = Some (tb, delta0) -> Plt b0 lo -> Plt tb sp) (ofs : Z) (H : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H0 : e ! id = Some (b, sz)) (H1 : f b = Some (sp, delta)) (H2 : delta <= ofs < delta + sz) (H3 : Mem.range_perm m b 0 sz Cur Freeable) : 0 <= ofs - delta < sz.","proofString":"lia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (X : {tm' : mem | Mem.free tm sp 0 (fn_stackspace tf) = Some tm'}) : exists tm' : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm' /\\\n  match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\n  Mem.inject f m' tm'.","proofString":"destruct X as  [tm' FREE].\nexploit nextblock_freelist; eauto.\nintro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') : exists tm'0 : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm'0 /\\\n  match_callstack f m' tm'0 cs (Mem.nextblock m') (Mem.nextblock tm'0) /\\\n  Mem.inject f m' tm'0.","proofString":"exploit nextblock_freelist; eauto.\nintro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') : Mem.nextblock m' = Mem.nextblock m ->\nexists tm'0 : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm'0 /\\\n  match_callstack f m' tm'0 cs (Mem.nextblock m') (Mem.nextblock tm'0) /\\\n  Mem.inject f m' tm'0.","proofString":"intro NEXT.\nexploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) : exists tm'0 : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm'0 /\\\n  match_callstack f m' tm'0 cs (Mem.nextblock m') (Mem.nextblock tm'0) /\\\n  Mem.inject f m' tm'0.","proofString":"exploit Mem.nextblock_free; eauto.\nintro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) : Mem.nextblock tm' = Mem.nextblock tm ->\nexists tm'0 : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm'0 /\\\n  match_callstack f m' tm'0 cs (Mem.nextblock m') (Mem.nextblock tm'0) /\\\n  Mem.inject f m' tm'0.","proofString":"intro NEXT'.\nexists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : exists tm'0 : mem,\n  Mem.free tm sp 0 (fn_stackspace tf) = Some tm'0 /\\\n  match_callstack f m' tm'0 cs (Mem.nextblock m') (Mem.nextblock tm'0) /\\\n  Mem.inject f m' tm'0.","proofString":"exists tm'.\nsplit.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : Mem.free tm sp 0 (fn_stackspace tf) = Some tm' /\\\nmatch_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\nMem.inject f m' tm'.","proofString":"split.\nauto.\nsplit.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : Mem.free tm sp 0 (fn_stackspace tf) = Some tm'.","proofString":"auto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm') /\\\nMem.inject f m' tm'.","proofString":"split.\nrewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia.\neapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : match_callstack f m' tm' cs (Mem.nextblock m') (Mem.nextblock tm').","proofString":"rewrite NEXT; rewrite NEXT'.\napply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : match_callstack f m' tm' cs (Mem.nextblock m) (Mem.nextblock tm).","proofString":"apply match_callstack_incr_bound with lo sp; try lia.\napply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia.\nextlia.\nextlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : match_callstack f m' tm' cs lo sp.","proofString":"apply match_callstack_invariant with f m tm; auto.\nintros.\neapply perm_freelist; eauto.\nintros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : forall (b : positive) (ofs : Z) (p : permission),\nPlt b lo -> Mem.perm m' b ofs Max p -> Mem.perm m b ofs Max p.","proofString":"intros.\neapply perm_freelist; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b0 : block) (sz : Z),\ne ! id = Some (b0, sz) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta : Z),\nf b0 = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b0, sz)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b : positive) (ofs : Z) (p : permission) (H : Plt b lo) (H0 : Mem.perm m' b ofs Max p) : Mem.perm m b ofs Max p.","proofString":"eapply perm_freelist; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : forall (sp0 : positive) (ofs : Z),\nPlt sp0 sp ->\nMem.perm tm sp0 ofs Cur Freeable -> Mem.perm tm' sp0 ofs Cur Freeable.","proofString":"intros.\neapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (sp0 : positive) (ofs : Z) (H : Plt sp0 sp) (H0 : Mem.perm tm sp0 ofs Cur Freeable) : Mem.perm tm' sp0 ofs Cur Freeable.","proofString":"eapply Mem.perm_free_1; eauto.\nleft; unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (sp0 : positive) (ofs : Z) (H : Plt sp0 sp) (H0 : Mem.perm tm sp0 ofs Cur Freeable) : sp0 <> sp \\/ ofs < 0 \\/ fn_stackspace tf <= ofs.","proofString":"left; unfold block; extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : Ple lo (Mem.nextblock m).","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : Ple sp (Mem.nextblock tm).","proofString":"extlia."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : Mem.inject f m' tm'.","proofString":"eapply Mem.free_inject; eauto.\nintros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta : Z),\nf b = Some (sp, delta) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta : Z),\nf b = Some (tb, delta) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) : forall (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission),\nf b1 = Some (sp, delta) ->\nMem.perm m b1 ofs k p ->\n0 <= ofs + delta < fn_stackspace tf ->\nexists lo1 hi1 : Z, In (b1, lo1, hi1) (blocks_of_env e) /\\ lo1 <= ofs < hi1.","proofString":"intros.\nexploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta0 : Z),\nf b = Some (sp, delta0) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (sp, delta)) (H0 : Mem.perm m b1 ofs k p) (H1 : 0 <= ofs + delta < fn_stackspace tf) : exists lo1 hi1 : Z, In (b1, lo1, hi1) (blocks_of_env e) /\\ lo1 <= ofs < hi1.","proofString":"exploit me_inv0; eauto.\nintros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id : positive, match_var f sp e ! id cenv ! id) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id : positive) (b : block) (sz : Z),\ne ! id = Some (b, sz) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta0 : Z),\nf b = Some (sp, delta0) ->\nexists (id : positive) (sz : Z), e ! id = Some (b, sz)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (sp, delta)) (H0 : Mem.perm m b1 ofs k p) (H1 : 0 <= ofs + delta < fn_stackspace tf) : (exists (id : positive) (sz : Z), e ! id = Some (b1, sz)) ->\nexists lo1 hi1 : Z, In (b1, lo1, hi1) (blocks_of_env e) /\\ lo1 <= ofs < hi1.","proofString":"intros [id [sz A]].\nexists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta0 : Z),\nf b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (sp, delta)) (H0 : Mem.perm m b1 ofs k p) (H1 : 0 <= ofs + delta < fn_stackspace tf) (id : positive) (sz : Z) (A : e ! id = Some (b1, sz)) : exists lo1 hi1 : Z, In (b1, lo1, hi1) (blocks_of_env e) /\\ lo1 <= ofs < hi1.","proofString":"exists 0; exists sz; split.\neapply in_blocks_of_env; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta0 : Z),\nf b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (sp, delta)) (H0 : Mem.perm m b1 ofs k p) (H1 : 0 <= ofs + delta < fn_stackspace tf) (id : positive) (sz : Z) (A : e ! id = Some (b1, sz)) : In (b1, 0, sz) (blocks_of_env e).","proofString":"eapply in_blocks_of_env; eauto."},{"statement":"(f : meminj) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (m m' tm : mem) (INJ : Mem.inject f m tm) (FREELIST : Mem.free_list m (blocks_of_env e) = Some m') (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS0 : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b : block) (sz0 : Z),\ne ! id0 = Some (b, sz0) -> Ple lo b /\\ Plt b hi) (me_inv0 : forall (b : block) (delta0 : Z),\nf b = Some (sp, delta0) ->\nexists (id0 : positive) (sz0 : Z), e ! id0 = Some (b, sz0)) (me_incr0 : forall (b tb : block) (delta0 : Z),\nf b = Some (tb, delta0) -> Plt b lo -> Plt tb sp) (tm' : mem) (FREE : Mem.free tm sp 0 (fn_stackspace tf) = Some tm') (NEXT : Mem.nextblock m' = Mem.nextblock m) (NEXT' : Mem.nextblock tm' = Mem.nextblock tm) (b1 : block) (delta ofs : Z) (k : perm_kind) (p : permission) (H : f b1 = Some (sp, delta)) (H0 : Mem.perm m b1 ofs k p) (H1 : 0 <= ofs + delta < fn_stackspace tf) (id : positive) (sz : Z) (A : e ! id = Some (b1, sz)) : 0 <= ofs < sz.","proofString":"eapply BOUND0; eauto.\neapply Mem.perm_max.\neauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) : Mem.unchanged_on (loc_unmapped f1) m1 m2 ->\nMem.unchanged_on (loc_out_of_reach f1 m1) m1' m2' ->\ninject_incr f1 f2 ->\ninject_separated f1 f2 m1 m1' ->\n(forall (b : block) (ofs : Z) (p : permission),\n Mem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) ->\nforall (cs : callstack) (bound tbound : block),\nmatch_callstack f1 m1 m1' cs bound tbound ->\nPle bound (Mem.nextblock m1) ->\nPle tbound (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs bound tbound.","proofString":"intros UNMAPPED OUTOFREACH INCR SEPARATED MAXPERMS.\ninduction 1; intros.\napply mcs_nil with hi; auto.\ninv H.\nconstructor; auto.\nintros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nconstructor.\nauto.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_invariant; eauto.\nred in SEPARATED.\nintros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nintros.\nassert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia.\neapply match_bounds_invariant; eauto.\nintros.\neapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia.\nred; intros.\ndestruct (is_reachable_from_env_dec f1 e sp ofs).\ninv H3.\nright.\napply is_reachable_intro with id b sz delta; auto.\nexploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia.\neauto with mem.\neapply IHmatch_callstack; eauto.\ninv MENV; extlia.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) : forall (cs : callstack) (bound tbound : block),\nmatch_callstack f1 m1 m1' cs bound tbound ->\nPle bound (Mem.nextblock m1) ->\nPle tbound (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs bound tbound.","proofString":"induction 1; intros.\napply mcs_nil with hi; auto.\ninv H.\nconstructor; auto.\nintros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nconstructor.\nauto.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_invariant; eauto.\nred in SEPARATED.\nintros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nintros.\nassert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia.\neapply match_bounds_invariant; eauto.\nintros.\neapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia.\nred; intros.\ndestruct (is_reachable_from_env_dec f1 e sp ofs).\ninv H3.\nright.\napply is_reachable_intro with id b sz delta; auto.\nexploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia.\neauto with mem.\neapply IHmatch_callstack; eauto.\ninv MENV; extlia.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H : match_globalenvs f1 hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) : match_callstack f2 m2 m2' nil bound tbound.","proofString":"apply mcs_nil with hi; auto.\ninv H.\nconstructor; auto.\nintros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H : match_globalenvs f1 hi) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) : match_globalenvs f2 hi.","proofString":"inv H.\nconstructor; auto.\nintros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf1 b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : match_globalenvs f2 hi.","proofString":"constructor; auto.\nintros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf1 b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) : forall (b1 b2 : block) (delta : Z),\nf2 b1 = Some (b2, delta) -> Plt b2 hi -> b1 = b2.","proofString":"intros.\ncase_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) : b1 = b2.","proofString":"case_eq (f1 b1).\nintros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto.\nintro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) : forall p : block * Z, f1 b1 = Some p -> b1 = b2.","proofString":"intros [b2' delta'] EQ.\nrewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (b2' : block) (delta' : Z) (EQ : f1 b1 = Some (b2', delta')) : b1 = b2.","proofString":"rewrite (INCR _ _ _ EQ) in H.\ninv H.\neauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (b2' : block) (delta' : Z) (H : Some (b2', delta') = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = Some (b2', delta')) : b1 = b2.","proofString":"inv H.\neauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H4 : Plt b2 hi) (EQ : f1 b1 = Some (b2, delta)) : b1 = b2.","proofString":"eauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) : f1 b1 = None -> b1 = b2.","proofString":"intro EQ.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = None) : b1 = b2.","proofString":"exploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = None) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2 -> b1 = b2.","proofString":"intros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = None) (A : ~ Mem.valid_block m1 b1) (B : ~ Mem.valid_block m1' b2) : b1 = b2.","proofString":"elim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = None) (A : ~ Mem.valid_block m1 b1) (B : ~ Mem.valid_block m1' b2) : Mem.valid_block m1' b2.","proofString":"red.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (hi : block) (bound tbound : positive) (H0 : Ple hi bound) (H1 : Ple hi tbound) (H2 : Ple bound (Mem.nextblock m1)) (H3 : Ple tbound (Mem.nextblock m1')) (DOMAIN : forall b : positive, Plt b hi -> f1 b = Some (b, 0)) (IMAGE : forall (b0 b3 : block) (delta0 : Z),\nf1 b0 = Some (b3, delta0) -> Plt b3 hi -> b0 = b3) (SYMBOLS : forall (id : ident) (b : block), Genv.find_symbol ge id = Some b -> Plt b hi) (FUNCTIONS : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b hi) (VARINFOS : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b hi) (b1 b2 : block) (delta : Z) (H : f2 b1 = Some (b2, delta)) (H4 : Plt b2 hi) (EQ : f1 b1 = None) (A : ~ Mem.valid_block m1 b1) (B : ~ Mem.valid_block m1' b2) : Plt b2 (Mem.nextblock m1').","proofString":"extlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_callstack f2 m2 m2' (Frame cenv tf e le te sp lo hi :: cs) bound tbound.","proofString":"constructor.\nauto.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_invariant; eauto.\nred in SEPARATED.\nintros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nintros.\nassert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia.\neapply match_bounds_invariant; eauto.\nintros.\neapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia.\nred; intros.\ndestruct (is_reachable_from_env_dec f1 e sp ofs).\ninv H3.\nright.\napply is_reachable_intro with id b sz delta; auto.\nexploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia.\neauto with mem.\neapply IHmatch_callstack; eauto.\ninv MENV; extlia.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : Ple hi bound.","proofString":"auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : Plt sp tbound.","proofString":"auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_temps f2 le te.","proofString":"eapply match_temps_invariant; eauto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_env f2 cenv e sp lo hi.","proofString":"eapply match_env_invariant; eauto.\nred in SEPARATED.\nintros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia.\nintros.\nassert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta).","proofString":"red in SEPARATED.\nintros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : forall (b : block) (delta : Z),\nf2 b = Some (sp, delta) -> f1 b = Some (sp, delta).","proofString":"intros.\ndestruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) : f1 b = Some (sp, delta).","proofString":"destruct (f1 b) as [[b' delta']|] eqn:?.\nexploit INCR; eauto.\ncongruence.\nexploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (b' : block) (delta' : Z) (Heqo : f1 b = Some (b', delta')) : Some (b', delta') = Some (sp, delta).","proofString":"exploit INCR; eauto.\ncongruence."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (b' : block) (delta' : Z) (Heqo : f1 b = Some (b', delta')) : f2 b = Some (b', delta') -> Some (b', delta') = Some (sp, delta).","proofString":"congruence."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (Heqo : f1 b = None) : None = Some (sp, delta).","proofString":"exploit SEPARATED; eauto.\nintros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (Heqo : f1 b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' sp -> None = Some (sp, delta).","proofString":"intros [A B].\nelim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (Heqo : f1 b = None) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' sp) : None = Some (sp, delta).","proofString":"elim B.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (Heqo : f1 b = None) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' sp) : Mem.valid_block m1' sp.","proofString":"red.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : forall (b1 b2 : block) (delta0 : Z),\nf1 b1 = None ->\nf2 b1 = Some (b2, delta0) ->\n~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2) (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : block) (delta : Z) (H2 : f2 b = Some (sp, delta)) (Heqo : f1 b = None) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' sp) : Plt sp (Mem.nextblock m1').","proofString":"extlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : forall b : positive, Plt b lo -> f2 b = f1 b.","proofString":"intros.\nassert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) : f2 b = f1 b.","proofString":"assert (Ple lo hi) by (eapply me_low_high; eauto).\ndestruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) : f2 b = f1 b.","proofString":"destruct (f1 b) as [[b' delta']|] eqn:?.\napply INCR; auto.\ndestruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (b' : block) (delta' : Z) (Heqo : f1 b = Some (b', delta')) : f2 b = Some (b', delta').","proofString":"apply INCR; auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) : f2 b = None.","proofString":"destruct (f2 b) as [[b' delta']|] eqn:?; auto.\nexploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) (b' : block) (delta' : Z) (Heqo0 : f2 b = Some (b', delta')) : Some (b', delta') = None.","proofString":"exploit SEPARATED; eauto.\nintros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) (b' : block) (delta' : Z) (Heqo0 : f2 b = Some (b', delta')) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b' ->\nSome (b', delta') = None.","proofString":"intros [A B].\nelim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) (b' : block) (delta' : Z) (Heqo0 : f2 b = Some (b', delta')) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' b') : Some (b', delta') = None.","proofString":"elim A.\nred.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) (b' : block) (delta' : Z) (Heqo0 : f2 b = Some (b', delta')) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' b') : Mem.valid_block m1 b.","proofString":"red.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b0 -> Mem.perm m2 b0 ofs Max p -> Mem.perm m1 b0 ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (b : positive) (H2 : Plt b lo) (H3 : Ple lo hi) (Heqo : f1 b = None) (b' : block) (delta' : Z) (Heqo0 : f2 b = Some (b', delta')) (A : ~ Mem.valid_block m1 b) (B : ~ Mem.valid_block m1' b') : Plt b (Mem.nextblock m1).","proofString":"extlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_bounds e m2.","proofString":"eapply match_bounds_invariant; eauto.\nintros.\neapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : forall (id : positive) (b : block) (sz ofs : Z) (p : permission),\ne ! id = Some (b, sz) -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p.","proofString":"intros.\neapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p0 : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H2 : e ! id = Some (b, sz)) (H3 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","proofString":"eapply MAXPERMS; eauto.\nred.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p0 : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H2 : e ! id = Some (b, sz)) (H3 : Mem.perm m2 b ofs Max p) : Mem.valid_block m1 b.","proofString":"red.\nexploit me_bounded; eauto.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p0 : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H2 : e ! id = Some (b, sz)) (H3 : Mem.perm m2 b ofs Max p) : Plt b (Mem.nextblock m1).","proofString":"exploit me_bounded; eauto.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p0 : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p0 -> Mem.perm m1 b0 ofs0 Max p0) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H2 : e ! id = Some (b, sz)) (H3 : Mem.perm m2 b ofs Max p) : Ple lo b /\\ Plt b hi -> Plt b (Mem.nextblock m1).","proofString":"extlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : padding_freeable f2 e m2' sp (fn_stackspace tf).","proofString":"red; intros.\ndestruct (is_reachable_from_env_dec f1 e sp ofs).\ninv H3.\nright.\napply is_reachable_intro with id b sz delta; auto.\nexploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) : Mem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"destruct (is_reachable_from_env_dec f1 e sp ofs).\ninv H3.\nright.\napply is_reachable_intro with id b sz delta; auto.\nexploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : is_reachable_from_env f1 e sp ofs) : Mem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"inv H3.\nright.\napply is_reachable_intro with id b sz delta; auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H4 : e ! id = Some (b, sz)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz) : Mem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"right.\napply is_reachable_intro with id b sz delta; auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b0 : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b0 ->\nMem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (id : positive) (b : block) (sz delta : Z) (H4 : e ! id = Some (b, sz)) (H5 : f1 b = Some (sp, delta)) (H6 : delta <= ofs < delta + sz) : is_reachable_from_env f2 e sp ofs.","proofString":"apply is_reachable_intro with id b sz delta; auto."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) : Mem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"exploit PERM; eauto.\nintros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) : Mem.perm m1' sp ofs Cur Freeable \\/ is_reachable_from_env f1 e sp ofs ->\nMem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"intros [A|A]; try contradiction.\nleft.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) : Mem.perm m2' sp ofs Cur Freeable \\/ is_reachable_from_env f2 e sp ofs.","proofString":"left.\neapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) : Mem.perm m2' sp ofs Cur Freeable.","proofString":"eapply Mem.perm_unchanged_on; eauto.\nred; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) : loc_out_of_reach f1 m1 sp ofs.","proofString":"red; intros; red; intros.\nelim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : False.","proofString":"elim H3.\nexploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : is_reachable_from_env f1 e sp ofs.","proofString":"exploit me_inv; eauto.\nintros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) : (exists (id : positive) (sz : Z), e ! id = Some (b0, sz)) ->\nis_reachable_from_env f1 e sp ofs.","proofString":"intros [id [lv B]].\nexploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (id : positive) (lv : Z) (B : e ! id = Some (b0, lv)) : is_reachable_from_env f1 e sp ofs.","proofString":"exploit BOUND0; eauto.\nintros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (id : positive) (lv : Z) (B : e ! id = Some (b0, lv)) : 0 <= ofs - delta < lv -> is_reachable_from_env f1 e sp ofs.","proofString":"intros C.\napply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs0 : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs0 Max p -> Mem.perm m1 b ofs0 Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) (ofs : Z) (H2 : 0 <= ofs < fn_stackspace tf) (H3 : ~ is_reachable_from_env f1 e sp ofs) (A : Mem.perm m1' sp ofs Cur Freeable) (b0 : block) (delta : Z) (H4 : f1 b0 = Some (sp, delta)) (H5 : Mem.perm m1 b0 (ofs - delta) Max Nonempty) (id : positive) (lv : Z) (B : e ! id = Some (b0, lv)) (C : 0 <= ofs - delta < lv) : is_reachable_from_env f1 e sp ofs.","proofString":"apply is_reachable_intro with id b0 lv delta; auto; lia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_callstack f2 m2 m2' cs lo sp.","proofString":"eauto with mem.\neapply IHmatch_callstack; eauto.\ninv MENV; extlia.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : match_callstack f2 m2 m2' cs lo sp.","proofString":"eapply IHmatch_callstack; eauto.\ninv MENV; extlia.\nextlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : Ple lo (Mem.nextblock m1).","proofString":"inv MENV; extlia."},{"statement":"(f1 f2 : meminj) (m1 m2 m1' m2' : mem) (UNMAPPED : Mem.unchanged_on (loc_unmapped f1) m1 m2) (OUTOFREACH : Mem.unchanged_on (loc_out_of_reach f1 m1) m1' m2') (INCR : inject_incr f1 f2) (SEPARATED : inject_separated f1 f2 m1 m1') (MAXPERMS : forall (b : block) (ofs : Z) (p : permission),\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp : positive) (lo : block) (hi : positive) (cs : callstack) (bound tbound : positive) (BOUND : Ple hi bound) (TBOUND : Plt sp tbound) (MTMP : match_temps f1 le te) (MENV : match_env f1 cenv e sp lo hi) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e m1' sp (fn_stackspace tf)) (H : match_callstack f1 m1 m1' cs lo sp) (IHmatch_callstack : Ple lo (Mem.nextblock m1) ->\nPle sp (Mem.nextblock m1') -> match_callstack f2 m2 m2' cs lo sp) (H0 : Ple bound (Mem.nextblock m1)) (H1 : Ple tbound (Mem.nextblock m1')) : Ple sp (Mem.nextblock m1').","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) : match_callstack f m tm'\n  (Frame cenv tf empty_env le te sp (Mem.nextblock m) (Mem.nextblock m) :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm').","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\nconstructor.\nextlia.\nunfold block in *; extlia.\nauto.\nconstructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto.\nred; intros.\nrewrite PTree.gempty in H4.\ndiscriminate.\nred; intros.\nleft.\neapply Mem.perm_alloc_2; eauto.\neapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm) ->\nmatch_callstack f m tm'\n  (Frame cenv tf empty_env le te sp (Mem.nextblock m) (Mem.nextblock m) :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm').","proofString":"intros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\nconstructor.\nextlia.\nunfold block in *; extlia.\nauto.\nconstructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto.\nred; intros.\nrewrite PTree.gempty in H4.\ndiscriminate.\nred; intros.\nleft.\neapply Mem.perm_alloc_2; eauto.\neapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) : match_callstack f m tm'\n  (Frame cenv tf empty_env le te sp (Mem.nextblock m) (Mem.nextblock m) :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm').","proofString":"exploit Mem.alloc_result; eauto.\nintros RES.\nconstructor.\nextlia.\nunfold block in *; extlia.\nauto.\nconstructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto.\nred; intros.\nrewrite PTree.gempty in H4.\ndiscriminate.\nred; intros.\nleft.\neapply Mem.perm_alloc_2; eauto.\neapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) : sp = Mem.nextblock tm ->\nmatch_callstack f m tm'\n  (Frame cenv tf empty_env le te sp (Mem.nextblock m) (Mem.nextblock m) :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm').","proofString":"intros RES.\nconstructor.\nextlia.\nunfold block in *; extlia.\nauto.\nconstructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto.\nred; intros.\nrewrite PTree.gempty in H4.\ndiscriminate.\nred; intros.\nleft.\neapply Mem.perm_alloc_2; eauto.\neapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_callstack f m tm'\n  (Frame cenv tf empty_env le te sp (Mem.nextblock m) (Mem.nextblock m) :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm').","proofString":"constructor.\nextlia.\nunfold block in *; extlia.\nauto.\nconstructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto.\nred; intros.\nrewrite PTree.gempty in H4.\ndiscriminate.\nred; intros.\nleft.\neapply Mem.perm_alloc_2; eauto.\neapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : Ple (Mem.nextblock m) (Mem.nextblock m).","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : Plt sp (Mem.nextblock tm').","proofString":"unfold block in *; extlia."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_temps f le te.","proofString":"auto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_env f cenv empty_env sp (Mem.nextblock m) (Mem.nextblock m).","proofString":"constructor; intros.\nrewrite H3.\nrewrite PTree.gempty.\nconstructor.\nextlia.\nrewrite PTree.gempty in H4; discriminate.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\nrewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) : match_var f sp empty_env ! id cenv ! id.","proofString":"rewrite H3.\nrewrite PTree.gempty.\nconstructor."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) : match_var f sp empty_env ! id None.","proofString":"rewrite PTree.gempty.\nconstructor."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) : match_var f sp None None.","proofString":"constructor."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : Ple (Mem.nextblock m) (Mem.nextblock m).","proofString":"extlia."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) (b : block) (sz : Z) (H4 : empty_env ! id = Some (b, sz)) : Ple (Mem.nextblock m) b /\\ Plt b (Mem.nextblock m).","proofString":"rewrite PTree.gempty in H4; discriminate."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (b : block) (delta : Z) (H4 : f b = Some (sp, delta)) : exists (id : positive) (sz : Z), empty_env ! id = Some (b, sz).","proofString":"eelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (b : block) (delta : Z) (H4 : f b = Some (sp, delta)) : Mem.valid_block tm sp.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (b tb : block) (delta : Z) (H4 : f b = Some (tb, delta)) (H5 : Plt b (Mem.nextblock m)) : Plt tb sp.","proofString":"rewrite RES.\nchange (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (b tb : block) (delta : Z) (H4 : f b = Some (tb, delta)) (H5 : Plt b (Mem.nextblock m)) : Plt tb (Mem.nextblock tm).","proofString":"change (Mem.valid_block tm tb).\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (b tb : block) (delta : Z) (H4 : f b = Some (tb, delta)) (H5 : Plt b (Mem.nextblock m)) : Mem.valid_block tm tb.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_bounds empty_env m.","proofString":"red; intros.\nrewrite PTree.gempty in H4.\ndiscriminate."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H4 : empty_env ! id = Some (b, sz)) (H5 : Mem.perm m b ofs Max p) : 0 <= ofs < sz.","proofString":"rewrite PTree.gempty in H4.\ndiscriminate."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id0 : positive, cenv ! id0 = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (id : positive) (b : block) (sz ofs : Z) (p : permission) (H4 : None = Some (b, sz)) (H5 : Mem.perm m b ofs Max p) : 0 <= ofs < sz.","proofString":"discriminate."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : padding_freeable f empty_env tm' sp (fn_stackspace tf).","proofString":"red; intros.\nleft.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (ofs : Z) (H4 : 0 <= ofs < fn_stackspace tf) : Mem.perm tm' sp ofs Cur Freeable \\/ is_reachable_from_env f empty_env sp ofs.","proofString":"left.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (ofs : Z) (H4 : 0 <= ofs < fn_stackspace tf) : Mem.perm tm' sp ofs Cur Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_callstack f m tm' cs (Mem.nextblock m) sp.","proofString":"eapply match_callstack_invariant with (tm1 := tm); eauto.\nrewrite RES; auto.\nintros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : match_callstack f m tm cs (Mem.nextblock m) sp.","proofString":"rewrite RES; auto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) : forall (sp0 : positive) (ofs : Z),\nPlt sp0 sp ->\nMem.perm tm sp0 ofs Cur Freeable -> Mem.perm tm' sp0 ofs Cur Freeable.","proofString":"intros.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(f : meminj) (m tm : mem) (cs : callstack) (tf : function) (tm' : Mem.mem') (sp : block) (le : temp_env) (te : env) (cenv : PTree.tree Z) (H : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H0 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H1 : Mem.inject f m tm) (H2 : match_temps f le te) (H3 : forall id : positive, cenv ! id = None) (NEXTBLOCK : Mem.nextblock tm' = Pos.succ (Mem.nextblock tm)) (RES : sp = Mem.nextblock tm) (sp0 : positive) (ofs : Z) (H4 : Plt sp0 sp) (H5 : Mem.perm tm sp0 ofs Cur Freeable) : Mem.perm tm' sp0 ofs Cur Freeable.","proofString":"eapply Mem.perm_alloc_1; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H : match_callstack f1 m1 tm\n  (Frame (PTree.remove id cenv) tf e le te sp lo (Mem.nextblock m1) :: cs)\n  (Mem.nextblock m1) (Mem.nextblock tm)) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) : match_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"inv H.\nexploit Mem.nextblock_alloc; eauto.\nintros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\nassert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) : match_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"exploit Mem.nextblock_alloc; eauto.\nintros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\nassert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1) ->\nmatch_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"intros NEXTBLOCK.\nexploit Mem.alloc_result; eauto.\nintros RES.\nassert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) : match_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"exploit Mem.alloc_result; eauto.\nintros RES.\nassert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) : b = Mem.nextblock m1 ->\nmatch_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"intros RES.\nassert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) : match_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"assert (LO: Ple lo (Mem.nextblock m1)) by (eapply me_low_high; eauto).\nconstructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : match_callstack f2 m2 tm\n  (Frame cenv tf (PTree.set id (b, sz) e) le te sp lo (Mem.nextblock m2)\n   :: cs) (Mem.nextblock m2) (Mem.nextblock tm).","proofString":"constructor.\nextlia.\nauto.\neapply match_temps_invariant; eauto.\neapply match_env_alloc; eauto.\nred; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia.\nred; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence.\neapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : Ple (Mem.nextblock m2) (Mem.nextblock m2).","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : Plt sp (Mem.nextblock tm).","proofString":"auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : match_temps f2 le te.","proofString":"eapply match_temps_invariant; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : match_env f2 cenv (PTree.set id (b, sz) e) sp lo (Mem.nextblock m2).","proofString":"eapply match_env_alloc; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : match_bounds (PTree.set id (b, sz) e) m2.","proofString":"red; intros.\nrewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (H : (PTree.set id (b, sz) e) ! id0 = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : 0 <= ofs0 < sz0.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (H : (if peq id0 id then Some (b, sz) else e ! id0) = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : 0 <= ofs0 < sz0.","proofString":"destruct (peq id0 id).\ninversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto.\neapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (e0 : id0 = id) (H : Some (b, sz) = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : 0 <= ofs0 < sz0.","proofString":"inversion H.\nsubst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (e0 : id0 = id) (H : Some (b, sz) = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) (H8 : b = b0) (H9 : sz = sz0) : 0 <= ofs0 < sz0.","proofString":"subst b0 sz0 id0.\neapply Mem.perm_alloc_3; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (p : permission) (H6 : Mem.perm m2 b ofs0 Max p) (H : Some (b, sz) = Some (b, sz)) : 0 <= ofs0 < sz.","proofString":"eapply Mem.perm_alloc_3; eauto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (n : id0 <> id) (H : e ! id0 = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : 0 <= ofs0 < sz0.","proofString":"eapply BOUND0; eauto.\neapply Mem.perm_alloc_4; eauto.\nexploit me_bounded; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (n : id0 <> id) (H : e ! id0 = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : b0 <> b.","proofString":"exploit me_bounded; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (id0 : positive) (b0 : block) (sz0 ofs0 : Z) (p : permission) (n : id0 <> id) (H : e ! id0 = Some (b0, sz0)) (H6 : Mem.perm m2 b0 ofs0 Max p) : Ple lo b0 /\\ Plt b0 (Mem.nextblock m1) -> b0 <> b.","proofString":"unfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : padding_freeable f2 (PTree.set id (b, sz) e) tm sp (fn_stackspace tf).","proofString":"red; intros.\nexploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) : Mem.perm tm sp ofs0 Cur Freeable \\/\nis_reachable_from_env f2 (PTree.set id (b, sz) e) sp ofs0.","proofString":"exploit PERM; eauto.\nintros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) : Mem.perm tm sp ofs0 Cur Freeable \\/ is_reachable_from_env f1 e sp ofs0 ->\nMem.perm tm sp ofs0 Cur Freeable \\/\nis_reachable_from_env f2 (PTree.set id (b, sz) e) sp ofs0.","proofString":"intros [A|A].\nauto.\nright.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (A : Mem.perm tm sp ofs0 Cur Freeable) : Mem.perm tm sp ofs0 Cur Freeable \\/\nis_reachable_from_env f2 (PTree.set id (b, sz) e) sp ofs0.","proofString":"auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (A : is_reachable_from_env f1 e sp ofs0) : Mem.perm tm sp ofs0 Cur Freeable \\/\nis_reachable_from_env f2 (PTree.set id (b, sz) e) sp ofs0.","proofString":"right.\ninv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (A : is_reachable_from_env f1 e sp ofs0) : is_reachable_from_env f2 (PTree.set id (b, sz) e) sp ofs0.","proofString":"inv A.\napply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H4 : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (H3 : f2 (Mem.nextblock m1) = Some (sp, ofs)) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (id0 : positive) (b0 : block) (sz0 delta : Z) (H6 : e ! id0 = Some (b0, sz0)) (H7 : f1 b0 = Some (sp, delta)) (H8 : delta <= ofs0 < delta + sz0) : is_reachable_from_env f2 (PTree.set id (Mem.nextblock m1, sz) e) sp ofs0.","proofString":"apply is_reachable_intro with id0 b0 sz0 delta; auto.\nrewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H4 : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (H3 : f2 (Mem.nextblock m1) = Some (sp, ofs)) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (id0 : positive) (b0 : block) (sz0 delta : Z) (H6 : e ! id0 = Some (b0, sz0)) (H7 : f1 b0 = Some (sp, delta)) (H8 : delta <= ofs0 < delta + sz0) : (PTree.set id (Mem.nextblock m1, sz) e) ! id0 = Some (b0, sz0).","proofString":"rewrite PTree.gso.\nauto.\ncongruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H4 : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (H3 : f2 (Mem.nextblock m1) = Some (sp, ofs)) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (id0 : positive) (b0 : block) (sz0 delta : Z) (H6 : e ! id0 = Some (b0, sz0)) (H7 : f1 b0 = Some (sp, delta)) (H8 : delta <= ofs0 < delta + sz0) : e ! id0 = Some (b0, sz0).","proofString":"auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H4 : forall b' : block, b' <> Mem.nextblock m1 -> f2 b' = f1 b') (H3 : f2 (Mem.nextblock m1) = Some (sp, ofs)) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (LO : Ple lo (Mem.nextblock m1)) (ofs0 : Z) (H : 0 <= ofs0 < fn_stackspace tf) (id0 : positive) (b0 : block) (sz0 delta : Z) (H6 : e ! id0 = Some (b0, sz0)) (H7 : f1 b0 = Some (sp, delta)) (H8 : delta <= ofs0 < delta + sz0) : id0 <> id.","proofString":"congruence."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : match_callstack f2 m2 tm cs lo sp.","proofString":"eapply match_callstack_invariant with (m1 := m1); eauto.\nintros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia.\nintros.\napply H4.\nunfold block in *; extlia.\nintros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : forall (b0 : positive) (ofs0 : Z) (p : permission),\nPlt b0 lo -> Mem.perm m2 b0 ofs0 Max p -> Mem.perm m1 b0 ofs0 Max p.","proofString":"intros.\neapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 : positive) (ofs0 : Z) (p : permission) (H : Plt b0 lo) (H6 : Mem.perm m2 b0 ofs0 Max p) : Mem.perm m1 b0 ofs0 Max p.","proofString":"eapply Mem.perm_alloc_4; eauto.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 : positive) (ofs0 : Z) (p : permission) (H : Plt b0 lo) (H6 : Mem.perm m2 b0 ofs0 Max p) : b0 <> b.","proofString":"unfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : forall b0 : positive, Plt b0 lo -> f2 b0 = f1 b0.","proofString":"intros.\napply H4.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 : positive) (H : Plt b0 lo) : f2 b0 = f1 b0.","proofString":"apply H4.\nunfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 : positive) (H : Plt b0 lo) : b0 <> b.","proofString":"unfold block in *; extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b' : block, b' <> b -> f2 b' = f1 b') (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) : forall (b0 b' : block) (delta : Z),\nf2 b0 = Some (b', delta) -> Plt b' sp -> f1 b0 = Some (b', delta).","proofString":"intros.\ndestruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b'0 : block, b'0 <> b -> f2 b'0 = f1 b'0) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 b' : block) (delta : Z) (H : f2 b0 = Some (b', delta)) (H6 : Plt b' sp) : f1 b0 = Some (b', delta).","proofString":"destruct (eq_block b0 b).\nsubst b0.\nrewrite H3 in H.\ninv H.\nextlia.\nrewrite H4 in H; auto."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b'0 : block, b'0 <> b -> f2 b'0 = f1 b'0) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 b' : block) (delta : Z) (H : f2 b0 = Some (b', delta)) (H6 : Plt b' sp) (e0 : b0 = b) : f1 b0 = Some (b', delta).","proofString":"subst b0.\nrewrite H3 in H.\ninv H.\nextlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b'0 : block, b'0 <> b -> f2 b'0 = f1 b'0) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b' : block) (delta : Z) (H : f2 b = Some (b', delta)) (H6 : Plt b' sp) : f1 b = Some (b', delta).","proofString":"rewrite H3 in H.\ninv H.\nextlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b'0 : block, b'0 <> b -> f2 b'0 = f1 b'0) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b' : block) (delta : Z) (H : Some (sp, ofs) = Some (b', delta)) (H6 : Plt b' sp) : f1 b = Some (b', delta).","proofString":"inv H.\nextlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (f2 : meminj) (H0 : Mem.alloc m1 0 sz = (m2, Mem.nextblock m1)) (delta : Z) (H1 : cenv ! id = Some delta) (H2 : inject_incr f1 f2) (H4 : forall b'0 : block, b'0 <> Mem.nextblock m1 -> f2 b'0 = f1 b'0) (b' : block) (H3 : f2 (Mem.nextblock m1) = Some (b', delta)) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt b' (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e b' lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (MCS : match_callstack f1 m1 tm cs lo b') (PERM : padding_freeable f1 e tm b' (fn_stackspace tf)) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (LO : Ple lo (Mem.nextblock m1)) (H6 : Plt b' b') : f1 (Mem.nextblock m1) = Some (b', delta).","proofString":"extlia."},{"statement":"(f1 : meminj) (m1 tm : mem) (id : positive) (cenv : PTree.tree Z) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo : block) (cs : list frame) (sz : Z) (m2 : Mem.mem') (b : block) (f2 : meminj) (ofs : Z) (H0 : Mem.alloc m1 0 sz = (m2, b)) (H1 : cenv ! id = Some ofs) (H2 : inject_incr f1 f2) (H3 : f2 b = Some (sp, ofs)) (H4 : forall b'0 : block, b'0 <> b -> f2 b'0 = f1 b'0) (H5 : e ! id = None) (BOUND : Ple (Mem.nextblock m1) (Mem.nextblock m1)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f1 le te) (MENV : match_env f1 (PTree.remove id cenv) e sp lo (Mem.nextblock m1)) (BOUND0 : match_bounds e m1) (PERM : padding_freeable f1 e tm sp (fn_stackspace tf)) (MCS : match_callstack f1 m1 tm cs lo sp) (NEXTBLOCK : Mem.nextblock m2 = Pos.succ (Mem.nextblock m1)) (RES : b = Mem.nextblock m1) (LO : Ple lo (Mem.nextblock m1)) (b0 b' : block) (delta : Z) (H : f2 b0 = Some (b', delta)) (H6 : Plt b' sp) (n : b0 <> b) : f1 b0 = Some (b', delta).","proofString":"rewrite H4 in H; auto."},{"statement":"(id : positive) (cenv : compilenv) (H : ~ False) : cenv ! id = cenv ! id.","proofString":"auto."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\n~ In id (map fst vars) -> (cenv_remove cenv0 vars) ! id = cenv0 ! id) (cenv : compilenv) (H : ~ (fst a = id \\/ In id (map fst vars))) : (PTree.remove (fst a) (cenv_remove cenv vars)) ! id = cenv ! id.","proofString":"rewrite PTree.gro.\napply IHvars.\nintuition.\nintuition."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\n~ In id (map fst vars) -> (cenv_remove cenv0 vars) ! id = cenv0 ! id) (cenv : compilenv) (H : ~ (fst a = id \\/ In id (map fst vars))) : (cenv_remove cenv vars) ! id = cenv ! id.","proofString":"apply IHvars.\nintuition."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\n~ In id (map fst vars) -> (cenv_remove cenv0 vars) ! id = cenv0 ! id) (cenv : compilenv) (H : ~ (fst a = id \\/ In id (map fst vars))) : ~ In id (map fst vars).","proofString":"intuition."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\n~ In id (map fst vars) -> (cenv_remove cenv0 vars) ! id = cenv0 ! id) (cenv : compilenv) (H : ~ (fst a = id \\/ In id (map fst vars))) : id <> fst a.","proofString":"intuition."},{"statement":"(id : positive) (cenv : compilenv) (H : False) : cenv ! id = None.","proofString":"contradiction."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\nIn id (map fst vars) -> (cenv_remove cenv0 vars) ! id = None) (cenv : compilenv) (H : fst a = id \\/ In id (map fst vars)) : (PTree.remove (fst a) (cenv_remove cenv vars)) ! id = None.","proofString":"rewrite PTree.grspec.\ndestruct (PTree.elt_eq id (fst a)).\nauto.\ndestruct H; intuition auto with exfalso."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\nIn id (map fst vars) -> (cenv_remove cenv0 vars) ! id = None) (cenv : compilenv) (H : fst a = id \\/ In id (map fst vars)) : (if PTree.elt_eq id (fst a) then None else (cenv_remove cenv vars) ! id) =\nNone.","proofString":"destruct (PTree.elt_eq id (fst a)).\nauto.\ndestruct H; intuition auto with exfalso."},{"statement":"(id : positive) (a : positive * Z) (vars : list (positive * Z)) (IHvars : forall cenv0 : compilenv,\nIn id (map fst vars) -> (cenv_remove cenv0 vars) ! id = None) (cenv : compilenv) (H : fst a = id \\/ In id (map fst vars)) (n : id <> fst a) : (cenv_remove cenv vars) ! id = None.","proofString":"destruct H; intuition auto with exfalso."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) : forall (e1 : Csharpminor.env) (m1 : mem) (vars : list (ident * Z))\n  (e2 : Csharpminor.env) (m2 : mem),\nalloc_variables e1 m1 vars e2 m2 ->\nforall f1 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f1 sp m1 ->\n(forall (id : ident) (sz : Z), In (id, sz) vars -> e1 ! id = None) ->\nmatch_callstack f1 m1 tm\n  (Frame (cenv_remove cenv vars) tf e1 le te sp lo (Mem.nextblock m1) :: cs)\n  (Mem.nextblock m1) (Mem.nextblock tm) ->\nMem.inject f1 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"induction 1; intros f1 NOREPET COMPAT SEP1 SEP2 UNBOUND MCS MINJ.\nsimpl in MCS.\nexists f1; auto.\nsimpl in NOREPET.\ninv NOREPET.\nexploit (COMPAT id sz).\nauto with coqlib.\nintros [ofs [CENV [ALIGNED [LOB HIB]]]].\nexploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (NOREPET : list_norepet (map fst ((id, sz) :: vars))) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) : exists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"simpl in NOREPET.\ninv NOREPET.\nexploit (COMPAT id sz).\nauto with coqlib.\nintros [ofs [CENV [ALIGNED [LOB HIB]]]].\nexploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (NOREPET : list_norepet (id :: map fst vars)) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) : exists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"inv NOREPET.\nexploit (COMPAT id sz).\nauto with coqlib.\nintros [ofs [CENV [ALIGNED [LOB HIB]]]].\nexploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) : exists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"exploit (COMPAT id sz).\nauto with coqlib.\nintros [ofs [CENV [ALIGNED [LOB HIB]]]].\nexploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) : In (id, sz) ((id, sz) :: vars).","proofString":"auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs k p -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) : (exists ofs : Z,\n   cenv ! id = Some ofs /\\\n   Mem.inj_offset_aligned ofs sz /\\\n   0 <= ofs /\\ ofs + Z.max 0 sz <= fn_stackspace tf) ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"intros [ofs [CENV [ALIGNED [LOB HIB]]]].\nexploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) : exists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm.","proofString":"exploit Mem.alloc_left_mapped_inject.\neexact MINJ.\neexact H.\neexact VALID.\ninstantiate (1 := ofs).\nzify.\nlia.\nintros.\nexploit STKSIZE; eauto.\nlia.\nintros.\napply STKPERMS.\nzify.\nlia.\nreplace (sz - 0) with sz by lia.\nauto.\nintros.\neapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia.\nintros [f2 [A [B [C D]]]].\nexploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"zify.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (z5 : Z) (HIB : ofs + z5 <= fn_stackspace tf) (H5 : 0 < sz /\\ z5 = sz \\/ sz <= 0 /\\ z5 = 0) : 0 <= ofs <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : Mem.perm tm sp ofs0 k p) : ofs = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned.","proofString":"exploit STKSIZE; eauto.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : Mem.perm tm sp ofs0 k p) : 0 <= ofs0 < fn_stackspace tf -> ofs = 0 \\/ 0 <= ofs0 < Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : 0 <= ofs0 < sz) : Mem.perm tm sp (ofs0 + ofs) k p.","proofString":"apply STKPERMS.\nzify.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : 0 <= ofs0 < sz) : 0 <= ofs0 + ofs < fn_stackspace tf.","proofString":"zify.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (z5 : Z) (HIB : ofs + z5 <= fn_stackspace tf) (ofs0 : Z) (k : perm_kind) (p : permission) (H1 : 0 <= ofs0 < sz) (H5 : 0 < sz /\\ z5 = sz \\/ sz <= 0 /\\ z5 = 0) : 0 <= ofs0 + ofs < fn_stackspace tf.","proofString":"lia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) : Mem.inj_offset_aligned ofs sz.","proofString":"auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f2 : meminj,\n  match_callstack f2 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f2 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (b : block) (delta' ofs0 : Z) (k : perm_kind) (p : permission) (H1 : f1 b = Some (sp, delta')) (H2 : Mem.perm m b ofs0 k p) (H5 : 0 + ofs <= ofs0 + delta' < sz + ofs) : False.","proofString":"eapply SEP2.\neauto with coqlib.\neexact CENV.\neauto.\neauto.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : exists f0 : meminj,\n  match_callstack f0 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f0 m2 tm.","proofString":"exploit (IHalloc_variables f2); eauto.\nred; intros.\neapply COMPAT.\nauto with coqlib.\nred; intros.\neapply SEP1; eauto with coqlib.\nred; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto.\nintros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\neapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : cenv_compat cenv vars (fn_stackspace tf).","proofString":"red; intros.\neapply COMPAT.\nauto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 : Z) (H1 : In (id0, sz0) vars) : exists ofs0 : Z,\n  cenv ! id0 = Some ofs0 /\\\n  Mem.inj_offset_aligned ofs0 sz0 /\\\n  0 <= ofs0 /\\ ofs0 + Z.max 0 sz0 <= fn_stackspace tf.","proofString":"eapply COMPAT.\nauto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 : Z) (H1 : In (id0, sz0) vars) : In (id0, sz0) ((id, sz) :: vars).","proofString":"auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : cenv_separated cenv vars.","proofString":"red; intros.\neapply SEP1; eauto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id1 : ident) (sz1 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (H1 : In (id1, sz1) vars) (H2 : In (id2, sz2) vars) (H5 : cenv ! id1 = Some ofs1) (H6 : cenv ! id2 = Some ofs2) (H7 : id1 <> id2) : ofs1 + sz1 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"eapply SEP1; eauto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : cenv_mem_separated cenv vars f2 sp m1.","proofString":"red; intros.\nexploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b0 : block, b0 <> b1 -> f2 b0 = f1 b0) (id0 : ident) (sz0 ofs0 : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H5 : f2 b = Some (sp, delta)) (H6 : Mem.perm m1 b ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) : False.","proofString":"exploit Mem.perm_alloc_inv; eauto.\ndestruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b0 : block, b0 <> b1 -> f2 b0 = f1 b0) (id0 : ident) (sz0 ofs0 : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H5 : f2 b = Some (sp, delta)) (H6 : Mem.perm m1 b ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) : (if eq_block b b1 then 0 <= ofs' < sz else Mem.perm m b ofs' k p) -> False.","proofString":"destruct (eq_block b b1); intros P.\nsubst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia.\neapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b0 : block, b0 <> b1 -> f2 b0 = f1 b0) (id0 : ident) (sz0 ofs0 : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H5 : f2 b = Some (sp, delta)) (H6 : Mem.perm m1 b ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (e0 : b = b1) (P : 0 <= ofs' < sz) : False.","proofString":"subst b.\nrewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 ofs0 delta ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H6 : Mem.perm m1 b1 ofs' k p) (H5 : f2 b1 = Some (sp, delta)) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (P : 0 <= ofs' < sz) : False.","proofString":"rewrite C in H5; inv H5.\nexploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs k0 p0 -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (delta : Z) (HIB : delta + Z.max 0 sz <= fn_stackspace tf) (LOB : 0 <= delta) (ALIGNED : Mem.inj_offset_aligned delta sz) (CENV : cenv ! id = Some delta) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, delta)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 ofs0 ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H6 : Mem.perm m1 b1 ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (P : 0 <= ofs' < sz) : False.","proofString":"exploit SEP1.\neapply in_eq.\neapply in_cons; eauto.\neauto.\neauto.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto.\nlia."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs k0 p0 -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (delta : Z) (HIB : delta + Z.max 0 sz <= fn_stackspace tf) (LOB : 0 <= delta) (ALIGNED : Mem.inj_offset_aligned delta sz) (CENV : cenv ! id = Some delta) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, delta)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 ofs0 ofs' : Z) (k : perm_kind) (p : permission) (H2 : cenv ! id = Some ofs0) (H1 : In (id, sz0) vars) (H6 : Mem.perm m1 b1 ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (P : 0 <= ofs' < sz) : False.","proofString":"elim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs k0 p0 -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (delta : Z) (HIB : delta + Z.max 0 sz <= fn_stackspace tf) (LOB : 0 <= delta) (ALIGNED : Mem.inj_offset_aligned delta sz) (CENV : cenv ! id = Some delta) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, delta)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 ofs0 ofs' : Z) (k : perm_kind) (p : permission) (H2 : cenv ! id = Some ofs0) (H1 : In (id, sz0) vars) (H6 : Mem.perm m1 b1 ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (P : 0 <= ofs' < sz) : In id (map fst vars).","proofString":"change id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs k0 p0 -> 0 <= ofs < fn_stackspace tf) (STKPERMS : forall (ofs : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs < fn_stackspace tf -> Mem.perm tm sp ofs k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (delta : Z) (HIB : delta + Z.max 0 sz <= fn_stackspace tf) (LOB : 0 <= delta) (ALIGNED : Mem.inj_offset_aligned delta sz) (CENV : cenv ! id = Some delta) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, delta)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 ofs0 ofs' : Z) (k : perm_kind) (p : permission) (H2 : cenv ! id = Some ofs0) (H1 : In (id, sz0) vars) (H6 : Mem.perm m1 b1 ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (P : 0 <= ofs' < sz) : In (fst (id, sz0)) (map fst vars).","proofString":"apply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm tm sp ofs1 k0 p0 -> 0 <= ofs1 < fn_stackspace tf) (STKPERMS : forall (ofs1 : Z) (k0 : perm_kind) (p0 : permission),\n0 <= ofs1 < fn_stackspace tf -> Mem.perm tm sp ofs1 k0 p0) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b0 : block, b0 <> b1 -> f2 b0 = f1 b0) (id0 : ident) (sz0 ofs0 : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H1 : In (id0, sz0) vars) (H2 : cenv ! id0 = Some ofs0) (H5 : f2 b = Some (sp, delta)) (H6 : Mem.perm m1 b ofs' k p) (H7 : ofs0 <= ofs' + delta < sz0 + ofs0) (n : b <> b1) (P : Mem.perm m b ofs' k p) : False.","proofString":"eapply SEP2.\napply in_cons; eauto.\neauto.\nrewrite D in H5; eauto.\neauto.\nauto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None.","proofString":"intros.\nrewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 : Z) (H1 : In (id0, sz0) vars) : (PTree.set id (b1, sz) e) ! id0 = None.","proofString":"rewrite PTree.gso.\neapply UNBOUND; eauto with coqlib.\nred; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 : Z) (H1 : In (id0, sz0) vars) : e ! id0 = None.","proofString":"eapply UNBOUND; eauto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id1 : ident) (sz1 : Z),\n In (id1, sz1) vars -> (PTree.set id (b1, sz) e) ! id1 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id1 : ident) (sz1 : Z),\nIn (id1, sz1) ((id, sz) :: vars) -> e ! id1 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (id0 : ident) (sz0 : Z) (H1 : In (id0, sz0) vars) : id0 <> id.","proofString":"red; intros; subst id0.\nelim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 : Z) (H1 : In (id, sz0) vars) : False.","proofString":"elim H3.\nchange id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 : Z) (H1 : In (id, sz0) vars) : In id (map fst vars).","proofString":"change id with (fst (id, sz0)).\napply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz1 : Z),\n In (id0, sz1) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz1 : Z),\nIn (id0, sz1) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) (sz0 : Z) (H1 : In (id, sz0) vars) : In (fst (id, sz0)) (map fst vars).","proofString":"apply in_map; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : match_callstack f2 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm).","proofString":"eapply match_callstack_alloc_left; eauto.\nrewrite cenv_remove_gso; auto.\napply UNBOUND with sz; auto with coqlib."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : (cenv_remove cenv vars) ! id = Some ofs.","proofString":"rewrite cenv_remove_gso; auto."},{"statement":"(tm : mem) (sp : block) (tf : function) (cenv : compilenv) (le : temp_env) (te : env) (lo : block) (cs : list frame) (VALID : Mem.valid_block tm sp) (REPRES : fn_stackspace tf <= Ptrofs.max_unsigned) (STKSIZE : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm tm sp ofs0 k p -> 0 <= ofs0 < fn_stackspace tf) (STKPERMS : forall (ofs0 : Z) (k : perm_kind) (p : permission),\n0 <= ofs0 < fn_stackspace tf -> Mem.perm tm sp ofs0 k p) (e : PTree.tree (block * Z)) (m : mem) (id : positive) (sz : Z) (vars : list (ident * Z)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csharpminor.env) (H : Mem.alloc m 0 sz = (m1, b1)) (H0 : alloc_variables (PTree.set id (b1, sz) e) m1 vars e2 m2) (IHalloc_variables : forall f0 : meminj,\nlist_norepet (map fst vars) ->\ncenv_compat cenv vars (fn_stackspace tf) ->\ncenv_separated cenv vars ->\ncenv_mem_separated cenv vars f0 sp m1 ->\n(forall (id0 : ident) (sz0 : Z),\n In (id0, sz0) vars -> (PTree.set id (b1, sz) e) ! id0 = None) ->\nmatch_callstack f0 m1 tm\n  (Frame (cenv_remove cenv vars) tf (PTree.set id (b1, sz) e) le te sp lo\n     (Mem.nextblock m1) :: cs) (Mem.nextblock m1) \n  (Mem.nextblock tm) ->\nMem.inject f0 m1 tm ->\nexists f3 : meminj,\n  match_callstack f3 m2 tm\n    (Frame cenv tf e2 le te sp lo (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm) /\\ Mem.inject f3 m2 tm) (f1 : meminj) (COMPAT : cenv_compat cenv ((id, sz) :: vars) (fn_stackspace tf)) (SEP1 : cenv_separated cenv ((id, sz) :: vars)) (SEP2 : cenv_mem_separated cenv ((id, sz) :: vars) f1 sp m) (UNBOUND : forall (id0 : ident) (sz0 : Z),\nIn (id0, sz0) ((id, sz) :: vars) -> e ! id0 = None) (MCS : match_callstack f1 m tm\n  (Frame (cenv_remove cenv ((id, sz) :: vars)) tf e le te sp lo\n     (Mem.nextblock m) :: cs) (Mem.nextblock m) (Mem.nextblock tm)) (MINJ : Mem.inject f1 m tm) (H3 : ~ In id (map fst vars)) (H4 : list_norepet (map fst vars)) (ofs : Z) (CENV : cenv ! id = Some ofs) (ALIGNED : Mem.inj_offset_aligned ofs sz) (LOB : 0 <= ofs) (HIB : ofs + Z.max 0 sz <= fn_stackspace tf) (f2 : meminj) (A : Mem.inject f2 m1 tm) (B : inject_incr f1 f2) (C : f2 b1 = Some (sp, ofs)) (D : forall b : block, b <> b1 -> f2 b = f1 b) : e ! id = None.","proofString":"apply UNBOUND with sz; auto with coqlib."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : exists f2 : meminj,\n  match_callstack f2 m2 tm2\n    (Frame cenv fn e le te sp (Mem.nextblock m1) (Mem.nextblock m2) :: cs)\n    (Mem.nextblock m2) (Mem.nextblock tm2) /\\ Mem.inject f2 m2 tm2.","proofString":"eapply match_callstack_alloc_variables_rec; eauto.\neapply Mem.valid_new_block; eauto.\nintros.\neapply Mem.perm_alloc_3; eauto.\nintros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto.\ninstantiate (1 := f1).\nred; intros.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto.\neapply match_callstack_alloc_right; eauto.\nintros.\ndestruct (In_dec peq id (map fst vars)).\napply cenv_remove_gss; auto.\nrewrite cenv_remove_gso; auto.\ndestruct (cenv!id) as [ofs|] eqn:?; auto.\nelim n; eauto.\neapply Mem.alloc_right_inject; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : Mem.valid_block tm2 sp.","proofString":"eapply Mem.valid_new_block; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm tm2 sp ofs k p -> 0 <= ofs < fn_stackspace fn.","proofString":"intros.\neapply Mem.perm_alloc_3; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs0 : Z),\ncenv ! id = Some ofs0 -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (ofs : Z) (k : perm_kind) (p : permission) (H9 : Mem.perm tm2 sp ofs k p) : 0 <= ofs < fn_stackspace fn.","proofString":"eapply Mem.perm_alloc_3; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : forall (ofs : Z) (k : perm_kind) (p : permission),\n0 <= ofs < fn_stackspace fn -> Mem.perm tm2 sp ofs k p.","proofString":"intros.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs0 : Z),\ncenv ! id = Some ofs0 -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (ofs : Z) (k : perm_kind) (p : permission) (H9 : 0 <= ofs < fn_stackspace fn) : Mem.perm tm2 sp ofs k p.","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.perm_alloc_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs0 : Z),\ncenv ! id = Some ofs0 -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (ofs : Z) (k : perm_kind) (p : permission) (H9 : 0 <= ofs < fn_stackspace fn) : Mem.perm tm2 sp ofs k Freeable.","proofString":"eapply Mem.perm_alloc_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : cenv_mem_separated cenv vars f1 sp m1.","proofString":"red; intros.\neelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs0 : Z),\ncenv ! id0 = Some ofs0 -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : ident) (sz ofs : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H9 : In (id, sz) vars) (H10 : cenv ! id = Some ofs) (H11 : f1 b = Some (sp, delta)) (H12 : Mem.perm m1 b ofs' k p) (H13 : ofs <= ofs' + delta < sz + ofs) : False.","proofString":"eelim Mem.fresh_block_alloc; eauto.\neapply Mem.valid_block_inject_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs0 : Z),\ncenv ! id0 = Some ofs0 -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : ident) (sz ofs : Z) (b : block) (delta ofs' : Z) (k : perm_kind) (p : permission) (H9 : In (id, sz) vars) (H10 : cenv ! id = Some ofs) (H11 : f1 b = Some (sp, delta)) (H12 : Mem.perm m1 b ofs' k p) (H13 : ofs <= ofs' + delta < sz + ofs) : Mem.valid_block tm1 sp.","proofString":"eapply Mem.valid_block_inject_2; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) : forall id : positive, (cenv_remove cenv vars) ! id = None.","proofString":"intros.\ndestruct (In_dec peq id (map fst vars)).\napply cenv_remove_gss; auto.\nrewrite cenv_remove_gso; auto.\ndestruct (cenv!id) as [ofs|] eqn:?; auto.\nelim n; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs : Z),\ncenv ! id0 = Some ofs -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : positive) : (cenv_remove cenv vars) ! id = None.","proofString":"destruct (In_dec peq id (map fst vars)).\napply cenv_remove_gss; auto.\nrewrite cenv_remove_gso; auto.\ndestruct (cenv!id) as [ofs|] eqn:?; auto.\nelim n; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs : Z),\ncenv ! id0 = Some ofs -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : positive) (i : In id (map fst vars)) : (cenv_remove cenv vars) ! id = None.","proofString":"apply cenv_remove_gss; auto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs : Z),\ncenv ! id0 = Some ofs -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : positive) (n : ~ In id (map fst vars)) : (cenv_remove cenv vars) ! id = None.","proofString":"rewrite cenv_remove_gso; auto.\ndestruct (cenv!id) as [ofs|] eqn:?; auto.\nelim n; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs : Z),\ncenv ! id0 = Some ofs -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : positive) (n : ~ In id (map fst vars)) : cenv ! id = None.","proofString":"destruct (cenv!id) as [ofs|] eqn:?; auto.\nelim n; eauto."},{"statement":"(tm1 : mem) (sp : block) (tm2 : Mem.mem') (m1 : mem) (vars : list (ident * Z)) (e : Csharpminor.env) (m2 : mem) (cenv : compilenv) (f1 : meminj) (cs : callstack) (fn : function) (le : temp_env) (te : env) (H : Mem.alloc tm1 0 (fn_stackspace fn) = (tm2, sp)) (H0 : fn_stackspace fn <= Ptrofs.max_unsigned) (H1 : alloc_variables empty_env m1 vars e m2) (H2 : list_norepet (map fst vars)) (H3 : cenv_compat cenv vars (fn_stackspace fn)) (H4 : cenv_separated cenv vars) (H5 : forall (id0 : positive) (ofs0 : Z),\ncenv ! id0 = Some ofs0 -> In id0 (map fst vars)) (H6 : Mem.inject f1 m1 tm1) (H7 : match_callstack f1 m1 tm1 cs (Mem.nextblock m1) (Mem.nextblock tm1)) (H8 : match_temps f1 le te) (id : positive) (n : ~ In id (map fst vars)) (ofs : Z) (Heqo : cenv ! id = Some ofs) : Some ofs = None.","proofString":"elim n; eauto."},{"statement":"(sz : Z) : (if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8) >\n0.","proofString":"destruct (zlt sz 2).\nlia.\ndestruct (zlt sz 4).\nlia.\ndestruct (zlt sz 8); lia."},{"statement":"(sz : Z) (l : sz < 2) : 1 > 0.","proofString":"lia."},{"statement":"(sz : Z) (g : sz >= 2) : (if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8) > 0.","proofString":"destruct (zlt sz 4).\nlia.\ndestruct (zlt sz 8); lia."},{"statement":"(sz : Z) (g : sz >= 2) (l : sz < 4) : 2 > 0.","proofString":"lia."},{"statement":"(sz : Z) (g : sz >= 2) (g0 : sz >= 4) : (if zlt sz 8 then 4 else 8) > 0.","proofString":"destruct (zlt sz 8); lia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) (cenv' : compilenv) (stksz' : Z) (H : (PTree.set id (align stksz (block_alignment sz)) cenv,\n align stksz (block_alignment sz) + Z.max 0 sz) = (\ncenv', stksz')) : stksz <= stksz'.","proofString":"inv H.\ngeneralize (align_le stksz (block_alignment sz) (block_alignment_pos sz)).\nassert (0 <= Z.max 0 sz).\napply Zmax_bound_l.\nlia.\nlia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) : stksz <= align stksz (block_alignment sz) + Z.max 0 sz.","proofString":"generalize (align_le stksz (block_alignment sz) (block_alignment_pos sz)).\nassert (0 <= Z.max 0 sz).\napply Zmax_bound_l.\nlia.\nlia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) : stksz <= align stksz (block_alignment sz) ->\nstksz <= align stksz (block_alignment sz) + Z.max 0 sz.","proofString":"assert (0 <= Z.max 0 sz).\napply Zmax_bound_l.\nlia.\nlia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) : 0 <= Z.max 0 sz.","proofString":"apply Zmax_bound_l.\nlia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) : 0 <= 0.","proofString":"lia."},{"statement":"(id : ident) (sz : Z) (cenv : compilenv) (stksz : Z) (H : 0 <= Z.max 0 sz) : stksz <= align stksz (block_alignment sz) ->\nstksz <= align stksz (block_alignment sz) + Z.max 0 sz.","proofString":"lia."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : (align_chunk chunk | align stacksize (block_alignment sz)).","proofString":"apply Z.divide_trans with (block_alignment sz).\nunfold align_chunk.\nunfold block_alignment.\ngeneralize Z.divide_1_l; intro.\ngeneralize Z.divide_refl; intro.\nassert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto.\napply align_divides.\napply block_alignment_pos."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : (align_chunk chunk | block_alignment sz).","proofString":"unfold align_chunk.\nunfold block_alignment.\ngeneralize Z.divide_1_l; intro.\ngeneralize Z.divide_refl; intro.\nassert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | block_alignment sz).","proofString":"unfold block_alignment.\ngeneralize Z.divide_1_l; intro.\ngeneralize Z.divide_refl; intro.\nassert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"generalize Z.divide_1_l; intro.\ngeneralize Z.divide_refl; intro.\nassert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"generalize Z.divide_refl; intro.\nassert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"assert (2 | 4).\nexists 2; auto.\nassert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) : (2 | 4).","proofString":"exists 2; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"assert (2 | 8).\nexists 4; auto.\nassert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) : (2 | 8).","proofString":"exists 4; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"assert (4 | 8).\nexists 2; auto.\ndestruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) : (4 | 8).","proofString":"exists 2; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end\n| if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"destruct (zlt sz 2).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (l : sz < 2) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | 1).","proofString":"destruct chunk; simpl in *; auto; extlia."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (g : sz >= 2) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"destruct (zlt sz 4).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (g : sz >= 2) (l : sz < 4) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | 2).","proofString":"destruct chunk; simpl in *; auto; extlia."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (g : sz >= 2) (g0 : sz >= 4) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | if zlt sz 8 then 4 else 8).","proofString":"destruct (zlt sz 8).\ndestruct chunk; simpl in *; auto; extlia.\ndestruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (g : sz >= 2) (g0 : sz >= 4) (l : sz < 8) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | 4).","proofString":"destruct chunk; simpl in *; auto; extlia."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) (H0 : forall n : Z, (1 | n)) (H1 : forall n : Z, (n | n)) (H2 : (2 | 4)) (H3 : (2 | 8)) (H4 : (4 | 8)) (g : sz >= 2) (g0 : sz >= 4) (g1 : sz >= 8) : (match chunk with\n | Mbool | Mint8signed | Mint8unsigned => 1\n | Mint16signed | Mint16unsigned => 2\n | Mint64 => 8\n | _ => 4\n end | 8).","proofString":"destruct chunk; simpl; auto."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : (block_alignment sz | align stacksize (block_alignment sz)).","proofString":"apply align_divides.\napply block_alignment_pos."},{"statement":"(stacksize sz : Z) (chunk : memory_chunk) (H : size_chunk chunk <= sz) : block_alignment sz > 0.","proofString":"apply block_alignment_pos."},{"statement":"(stacksize sz : Z) : Mem.inj_offset_aligned (align stacksize (block_alignment sz)) (Z.max 0 sz).","proofString":"replace (block_alignment sz) with (block_alignment (Z.max 0 sz)).\napply inj_offset_aligned_block.\nrewrite Zmax_spec.\ndestruct (zlt sz 0); auto.\ntransitivity 1.\nreflexivity.\nunfold block_alignment.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) : Mem.inj_offset_aligned (align stacksize (block_alignment (Z.max 0 sz)))\n  (Z.max 0 sz).","proofString":"apply inj_offset_aligned_block."},{"statement":"(stacksize sz : Z) : block_alignment (Z.max 0 sz) = block_alignment sz.","proofString":"rewrite Zmax_spec.\ndestruct (zlt sz 0); auto.\ntransitivity 1.\nreflexivity.\nunfold block_alignment.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) : block_alignment (if zlt sz 0 then 0 else sz) = block_alignment sz.","proofString":"destruct (zlt sz 0); auto.\ntransitivity 1.\nreflexivity.\nunfold block_alignment.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) (l : sz < 0) : block_alignment 0 = block_alignment sz.","proofString":"transitivity 1.\nreflexivity.\nunfold block_alignment.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) (l : sz < 0) : block_alignment 0 = 1.","proofString":"reflexivity."},{"statement":"(stacksize sz : Z) (l : sz < 0) : 1 = block_alignment sz.","proofString":"unfold block_alignment.\nrewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) (l : sz < 0) : 1 =\n(if zlt sz 2 then 1 else if zlt sz 4 then 2 else if zlt sz 8 then 4 else 8).","proofString":"rewrite zlt_true.\nauto.\nlia."},{"statement":"(stacksize sz : Z) (l : sz < 0) : 1 = 1.","proofString":"auto."},{"statement":"(stacksize sz : Z) (l : sz < 0) : sz < 2.","proofString":"lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (ASV : (PTree.set id (align sz1 (block_alignment sz)) cenv1,\n align sz1 (block_alignment sz) + Z.max 0 sz) = (cenv2, sz2)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) : cenv_compat cenv2 (vars ++ (id, sz) :: nil) sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: nil).","proofString":"inv ASV.\nassert (LE: sz1 <= align sz1 (block_alignment sz)).\napply align_le.\napply block_alignment_pos.\nassert (EITHER: forall id' sz',             In (id', sz') (vars ++ (id, sz) :: nil) ->             In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)).\nintros.\nrewrite in_app in H.\ndestruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction.\nsplit; red; intros.\napply EITHER in H.\ndestruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia.\napply EITHER in H; apply EITHER in H0.\ndestruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) : cenv_compat (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil) (align sz1 (block_alignment sz) + Z.max 0 sz) /\\\ncenv_separated (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil).","proofString":"assert (LE: sz1 <= align sz1 (block_alignment sz)).\napply align_le.\napply block_alignment_pos.\nassert (EITHER: forall id' sz',             In (id', sz') (vars ++ (id, sz) :: nil) ->             In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)).\nintros.\nrewrite in_app in H.\ndestruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction.\nsplit; red; intros.\napply EITHER in H.\ndestruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia.\napply EITHER in H; apply EITHER in H0.\ndestruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) : sz1 <= align sz1 (block_alignment sz).","proofString":"apply align_le.\napply block_alignment_pos."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) : block_alignment sz > 0.","proofString":"apply block_alignment_pos."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) : cenv_compat (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil) (align sz1 (block_alignment sz) + Z.max 0 sz) /\\\ncenv_separated (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil).","proofString":"assert (EITHER: forall id' sz',             In (id', sz') (vars ++ (id, sz) :: nil) ->             In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)).\nintros.\nrewrite in_app in H.\ndestruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction.\nsplit; red; intros.\napply EITHER in H.\ndestruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia.\napply EITHER in H; apply EITHER in H0.\ndestruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"intros.\nrewrite in_app in H.\ndestruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : In (id', sz') (vars ++ (id, sz) :: nil)) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"rewrite in_app in H.\ndestruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : In (id', sz') vars \\/ In (id', sz') ((id, sz) :: nil)) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"destruct H.\nleft; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto.\nsimpl in H.\ndestruct H.\nauto.\ncontradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : In (id', sz') vars) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"left; split; auto.\nred; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : In (id', sz') vars) : id' <> id.","proofString":"red; intros; subst id'.\nelim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (sz' : Z) (H : In (id, sz') vars) : False.","proofString":"elim NOREPET.\nchange id with (fst (id, sz')).\napply in_map; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (sz' : Z) (H : In (id, sz') vars) : In id (map fst vars).","proofString":"change id with (fst (id, sz')).\napply in_map; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (sz' : Z) (H : In (id, sz') vars) : In (fst (id, sz')) (map fst vars).","proofString":"apply in_map; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : In (id', sz') ((id, sz) :: nil)) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"simpl in H.\ndestruct H.\nauto.\ncontradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : (id, sz) = (id', sz') \\/ False) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"destruct H.\nauto.\ncontradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : (id, sz) = (id', sz')) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (id' : ident) (sz' : Z) (H : False) : In (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz).","proofString":"contradiction."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : cenv_compat (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil) (align sz1 (block_alignment sz) + Z.max 0 sz) /\\\ncenv_separated (PTree.set id (align sz1 (block_alignment sz)) cenv1)\n  (vars ++ (id, sz) :: nil).","proofString":"split; red; intros.\napply EITHER in H.\ndestruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia.\napply EITHER in H; apply EITHER in H0.\ndestruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (H : In (id0, sz0) (vars ++ (id, sz) :: nil)) : exists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\\n  0 <= ofs /\\\n  ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"apply EITHER in H.\ndestruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (H : In (id0, sz0) vars /\\ id0 <> id \\/ (id0, sz0) = (id, sz)) : exists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\\n  0 <= ofs /\\\n  ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"destruct H as [[P Q] | P].\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia.\ninv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) : exists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\\n  0 <= ofs /\\\n  ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"exploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) : (exists ofs : Z,\n   cenv1 ! id0 = Some ofs /\\\n   Mem.inj_offset_aligned ofs sz0 /\\ 0 <= ofs /\\ ofs + Z.max 0 sz0 <= sz1) ->\nexists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\\n  0 <= ofs /\\\n  ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"intros [ofs [A [B [C D]]]].\nexists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : exists ofs0 : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs0 /\\\n  Mem.inj_offset_aligned ofs0 sz0 /\\\n  0 <= ofs0 /\\\n  ofs0 + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"exists ofs.\nsplit.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\nMem.inj_offset_aligned ofs sz0 /\\\n0 <= ofs /\\ ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\nrewrite PTree.gso; auto.\nsplit.\nauto.\nsplit.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs.","proofString":"rewrite PTree.gso; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : Mem.inj_offset_aligned ofs sz0 /\\\n0 <= ofs /\\ ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\nauto.\nsplit.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : Mem.inj_offset_aligned ofs sz0.","proofString":"auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : 0 <= ofs /\\ ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\nauto.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : 0 <= ofs.","proofString":"auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : In (id0, sz0) vars) (Q : id0 <> id) (ofs : Z) (A : cenv1 ! id0 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"zify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id0 : ident) (sz0 : Z) (P : (id0, sz0) = (id, sz)) : exists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id0 = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\\n  0 <= ofs /\\\n  ofs + Z.max 0 sz0 <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"inv P.\nexists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : exists ofs : Z,\n  (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz /\\\n  0 <= ofs /\\ ofs + Z.max 0 sz <= align sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"exists (align sz1 (block_alignment sz)).\nsplit.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id =\nSome (align sz1 (block_alignment sz)) /\\\nMem.inj_offset_aligned (align sz1 (block_alignment sz)) sz /\\\n0 <= align sz1 (block_alignment sz) /\\\nalign sz1 (block_alignment sz) + Z.max 0 sz <=\nalign sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\napply PTree.gss.\nsplit.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id =\nSome (align sz1 (block_alignment sz)).","proofString":"apply PTree.gss."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : Mem.inj_offset_aligned (align sz1 (block_alignment sz)) sz /\\\n0 <= align sz1 (block_alignment sz) /\\\nalign sz1 (block_alignment sz) + Z.max 0 sz <=\nalign sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\napply inj_offset_aligned_block.\nsplit.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : Mem.inj_offset_aligned (align sz1 (block_alignment sz)) sz.","proofString":"apply inj_offset_aligned_block."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : 0 <= align sz1 (block_alignment sz) /\\\nalign sz1 (block_alignment sz) + Z.max 0 sz <=\nalign sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"split.\nlia.\nlia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : 0 <= align sz1 (block_alignment sz).","proofString":"lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) : align sz1 (block_alignment sz) + Z.max 0 sz <=\nalign sz1 (block_alignment sz) + Z.max 0 sz.","proofString":"lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (H : In (id1, sz0) (vars ++ (id, sz) :: nil)) (H0 : In (id2, sz2) (vars ++ (id, sz) :: nil)) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"apply EITHER in H; apply EITHER in H0.\ndestruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (H : In (id1, sz0) vars /\\ id1 <> id \\/ (id1, sz0) = (id, sz)) (H0 : In (id2, sz2) vars /\\ id2 <> id \\/ (id2, sz2) = (id, sz)) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"destruct H as [[P Q] | P]; destruct H0 as [[R S] | R].\nrewrite PTree.gso in *; auto.\neapply SEP; eauto.\ninv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia.\ninv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia.\ncongruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (R : In (id2, sz2) vars) (S : id2 <> id) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"rewrite PTree.gso in *; auto.\neapply SEP; eauto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (R : In (id2, sz2) vars) (S : id2 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"eapply SEP; eauto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (R : (id2, sz2) = (id, sz)) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"inv R.\nrewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 ofs2 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H3 : id1 <> id) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id = Some ofs2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz <= ofs1.","proofString":"rewrite PTree.gso in H1; auto.\nrewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 ofs2 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id = Some ofs2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz <= ofs1.","proofString":"rewrite PTree.gss in H2; inv H2.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) : ofs1 + sz0 <= align sz1 (block_alignment sz) \\/\nalign sz1 (block_alignment sz) + sz <= ofs1.","proofString":"exploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) : (exists ofs : Z,\n   cenv1 ! id1 = Some ofs /\\\n   Mem.inj_offset_aligned ofs sz0 /\\ 0 <= ofs /\\ ofs + Z.max 0 sz0 <= sz1) ->\nofs1 + sz0 <= align sz1 (block_alignment sz) \\/\nalign sz1 (block_alignment sz) + sz <= ofs1.","proofString":"intros [ofs [A [B [C D]]]].\nassert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) (ofs : Z) (A : cenv1 ! id1 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) : ofs1 + sz0 <= align sz1 (block_alignment sz) \\/\nalign sz1 (block_alignment sz) + sz <= ofs1.","proofString":"assert (ofs = ofs1) by congruence.\nsubst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) (ofs : Z) (A : cenv1 ! id1 = Some ofs) (B : Mem.inj_offset_aligned ofs sz0) (C : 0 <= ofs) (D : ofs + Z.max 0 sz0 <= sz1) (H : ofs = ofs1) : ofs1 + sz0 <= align sz1 (block_alignment sz) \\/\nalign sz1 (block_alignment sz) + sz <= ofs1.","proofString":"subst ofs.\nleft.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) (D : ofs1 + Z.max 0 sz0 <= sz1) (C : 0 <= ofs1) (B : Mem.inj_offset_aligned ofs1 sz0) (A : cenv1 ! id1 = Some ofs1) : ofs1 + sz0 <= align sz1 (block_alignment sz) \\/\nalign sz1 (block_alignment sz) + sz <= ofs1.","proofString":"left.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (P : In (id1, sz0) vars) (Q : id1 <> id) (H1 : cenv1 ! id1 = Some ofs1) (H3 : id1 <> id) (D : ofs1 + Z.max 0 sz0 <= sz1) (C : 0 <= ofs1) (B : Mem.inj_offset_aligned ofs1 sz0) (A : cenv1 ! id1 = Some ofs1) : ofs1 + sz0 <= align sz1 (block_alignment sz).","proofString":"zify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (P : (id1, sz0) = (id, sz)) (R : In (id2, sz2) vars) (S : id2 <> id) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"inv P.\nrewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id <> id2) : ofs1 + sz <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"rewrite PTree.gso in H2; auto.\nrewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id = Some ofs1) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) : ofs1 + sz <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"rewrite PTree.gss in H1; inv H1.\nexploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) : align sz1 (block_alignment sz) + sz <= ofs2 \\/\nofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"exploit COMPAT; eauto.\nintros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) : (exists ofs : Z,\n   cenv1 ! id2 = Some ofs /\\\n   Mem.inj_offset_aligned ofs sz2 /\\ 0 <= ofs /\\ ofs + Z.max 0 sz2 <= sz1) ->\nalign sz1 (block_alignment sz) + sz <= ofs2 \\/\nofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"intros [ofs [A [B [C D]]]].\nassert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) (ofs : Z) (A : cenv1 ! id2 = Some ofs) (B : Mem.inj_offset_aligned ofs sz2) (C : 0 <= ofs) (D : ofs + Z.max 0 sz2 <= sz1) : align sz1 (block_alignment sz) + sz <= ofs2 \\/\nofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"assert (ofs = ofs2) by congruence.\nsubst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) (ofs : Z) (A : cenv1 ! id2 = Some ofs) (B : Mem.inj_offset_aligned ofs sz2) (C : 0 <= ofs) (D : ofs + Z.max 0 sz2 <= sz1) (H : ofs = ofs2) : align sz1 (block_alignment sz) + sz <= ofs2 \\/\nofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"subst ofs.\nright.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) (D : ofs2 + Z.max 0 sz2 <= sz1) (C : 0 <= ofs2) (B : Mem.inj_offset_aligned ofs2 sz2) (A : cenv1 ! id2 = Some ofs2) : align sz1 (block_alignment sz) + sz <= ofs2 \\/\nofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"right.\nzify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id2 : ident) (sz2 ofs2 : Z) (R : In (id2, sz2) vars) (S : id2 <> id) (H2 : cenv1 ! id2 = Some ofs2) (H3 : id <> id2) (D : ofs2 + Z.max 0 sz2 <= sz1) (C : 0 <= ofs2) (B : Mem.inj_offset_aligned ofs2 sz2) (A : cenv1 ! id2 = Some ofs2) : ofs2 + sz2 <= align sz1 (block_alignment sz).","proofString":"zify; lia."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (id : ident) (sz : Z) (vars : list (ident * Z)) (NOREPET : ~ In id (map fst vars)) (POS : 0 <= sz1) (COMPAT : cenv_compat cenv1 vars sz1) (SEP : cenv_separated cenv1 vars) (LE : sz1 <= align sz1 (block_alignment sz)) (EITHER : forall (id' : ident) (sz' : Z),\nIn (id', sz') (vars ++ (id, sz) :: nil) ->\nIn (id', sz') vars /\\ id' <> id \\/ (id', sz') = (id, sz)) (id1 : ident) (sz0 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (P : (id1, sz0) = (id, sz)) (R : (id2, sz2) = (id, sz)) (H1 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id1 = Some ofs1) (H2 : (PTree.set id (align sz1 (block_alignment sz)) cenv1) ! id2 = Some ofs2) (H3 : id1 <> id2) : ofs1 + sz0 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"congruence."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : (cenv1, sz1) = (cenv2, sz2)) (H0 : list_norepet (map fst vars)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) : cenv_compat cenv2 (vars ++ nil) sz2 /\\ cenv_separated cenv2 (vars ++ nil).","proofString":"rewrite app_nil_r.\ninv H; auto."},{"statement":"(cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : (cenv1, sz1) = (cenv2, sz2)) (H0 : list_norepet (map fst vars)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) : cenv_compat cenv2 vars sz2 /\\ cenv_separated cenv2 vars.","proofString":"inv H; auto."},{"statement":"(a : ident * Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) a) vars' = (cenv2, sz2)) (H0 : list_norepet (fst a :: map fst vars' ++ map fst vars)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) : cenv_compat cenv2 (vars ++ a :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ a :: vars').","proofString":"destruct a as [id sz].\nsimpl in H0.\ninv H0.\nrewrite in_app in H6.\nrewrite list_norepet_app in H7.\ndestruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H0 : list_norepet (fst (id, sz) :: map fst vars' ++ map fst vars)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"simpl in H0.\ninv H0.\nrewrite in_app in H6.\nrewrite list_norepet_app in H7.\ndestruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H0 : list_norepet (id :: map fst vars' ++ map fst vars)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"inv H0.\nrewrite in_app in H6.\nrewrite list_norepet_app in H7.\ndestruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ In id (map fst vars' ++ map fst vars)) (H7 : list_norepet (map fst vars' ++ map fst vars)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"rewrite in_app in H6.\nrewrite list_norepet_app in H7.\ndestruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (H7 : list_norepet (map fst vars' ++ map fst vars)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"rewrite list_norepet_app in H7.\ndestruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (H7 : list_norepet (map fst vars') /\\\nlist_norepet (map fst vars) /\\ list_disjoint (map fst vars') (map fst vars)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"destruct H7 as [P [Q R]].\ndestruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (H : assign_variables (assign_variable (cenv1, sz1) (id, sz)) vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"destruct (assign_variable (cenv1, sz1) (id, sz)) as [cenv' sz'] eqn:?.\nexploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"exploit assign_variable_sound.\neauto.\ninstantiate (1 := vars).\ntauto.\nauto.\nauto.\nauto.\nintros [A B].\nexploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) : ~ In id (map fst vars).","proofString":"tauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : cenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"exploit IHvars'.\neauto.\ninstantiate (1 := vars ++ ((id, sz) :: nil)).\nrewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto.\ngeneralize (assign_variable_incr _ _ _ _ _ _ Heqp).\nlia.\nauto.\nauto.\nrewrite app_ass.\nauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst vars' ++ map fst (vars ++ (id, sz) :: nil)).","proofString":"rewrite list_norepet_app.\nsplit.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst vars') /\\\nlist_norepet (map fst (vars ++ (id, sz) :: nil)) /\\\nlist_disjoint (map fst vars') (map fst (vars ++ (id, sz) :: nil)).","proofString":"split.\nauto.\nsplit.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst vars').","proofString":"auto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst (vars ++ (id, sz) :: nil)) /\\\nlist_disjoint (map fst vars') (map fst (vars ++ (id, sz) :: nil)).","proofString":"split.\nrewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto.\nrewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst (vars ++ (id, sz) :: nil)).","proofString":"rewrite map_app.\napply list_norepet_append_commut.\nsimpl.\nconstructor; auto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst vars ++ map fst ((id, sz) :: nil)).","proofString":"apply list_norepet_append_commut.\nsimpl.\nconstructor; auto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (map fst ((id, sz) :: nil) ++ map fst vars).","proofString":"simpl.\nconstructor; auto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_norepet (id :: map fst vars).","proofString":"constructor; auto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_disjoint (map fst vars') (map fst (vars ++ (id, sz) :: nil)).","proofString":"rewrite map_app.\nsimpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_disjoint (map fst vars') (map fst vars ++ map fst ((id, sz) :: nil)).","proofString":"simpl.\nred; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : list_disjoint (map fst vars') (map fst vars ++ id :: nil).","proofString":"red; intros.\nrewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : In y (map fst vars ++ id :: nil)) : x <> y.","proofString":"rewrite in_app in H4.\ndestruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : In y (map fst vars) \\/ In y (id :: nil)) : x <> y.","proofString":"destruct H4.\neauto.\nsimpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : In y (map fst vars)) : x <> y.","proofString":"eauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : In y (id :: nil)) : x <> y.","proofString":"simpl in H4.\ndestruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : id = y \\/ False) : x <> y.","proofString":"destruct H4.\nsubst y.\nred; intros; subst x.\ntauto.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : id = y) : x <> y.","proofString":"subst y.\nred; intros; subst x.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x : ident) (H0 : In x (map fst vars')) : x <> id.","proofString":"red; intros; subst x.\ntauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (H0 : In id (map fst vars')) : False.","proofString":"tauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) (x y : ident) (H0 : In x (map fst vars')) (H4 : False) : x <> y.","proofString":"tauto."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : sz1 <= sz' -> 0 <= sz'.","proofString":"lia."},{"statement":"(id : ident) (sz : Z) (vars' : list (ident * Z)) (IHvars' : forall (cenv0 : compilenv) (sz0 : Z) (cenv3 : compilenv) \n  (sz3 : Z) (vars0 : list (ident * Z)),\nassign_variables (cenv0, sz0) vars' = (cenv3, sz3) ->\nlist_norepet (map fst vars' ++ map fst vars0) ->\n0 <= sz0 ->\ncenv_compat cenv0 vars0 sz0 ->\ncenv_separated cenv0 vars0 ->\ncenv_compat cenv3 (vars0 ++ vars') sz3 /\\\ncenv_separated cenv3 (vars0 ++ vars')) (cenv1 : compilenv) (sz1 : Z) (cenv2 : compilenv) (sz2 : Z) (vars : list (ident * Z)) (cenv' : compilenv) (sz' : Z) (Heqp : assign_variable (cenv1, sz1) (id, sz) = (cenv', sz')) (H : assign_variables (cenv', sz') vars' = (cenv2, sz2)) (H1 : 0 <= sz1) (H2 : cenv_compat cenv1 vars sz1) (H3 : cenv_separated cenv1 vars) (H6 : ~ (In id (map fst vars') \\/ In id (map fst vars))) (P : list_norepet (map fst vars')) (Q : list_norepet (map fst vars)) (R : list_disjoint (map fst vars') (map fst vars)) (A : cenv_compat cenv' (vars ++ (id, sz) :: nil) sz') (B : cenv_separated cenv' (vars ++ (id, sz) :: nil)) : cenv_compat cenv2 (vars ++ ((id, sz) :: nil) ++ vars') sz2 /\\\ncenv_separated cenv2 (vars ++ ((id, sz) :: nil) ++ vars') ->\ncenv_compat cenv2 (vars ++ (id, sz) :: vars') sz2 /\\\ncenv_separated cenv2 (vars ++ (id, sz) :: vars').","proofString":"auto."},{"statement":"(A : Type) (x : A) (l l' : list A) (H : Permutation l l') (IHPermutation : list_norepet l -> list_norepet l') (H0 : list_norepet (x :: l)) : list_norepet (x :: l').","proofString":"inv H0.\nconstructor; auto.\nred; intros; elim H3.\napply Permutation_in with l'; auto.\napply Permutation_sym; auto."},{"statement":"(A : Type) (x : A) (l l' : list A) (H : Permutation l l') (IHPermutation : list_norepet l -> list_norepet l') (H3 : ~ In x l) (H4 : list_norepet l) : list_norepet (x :: l').","proofString":"constructor; auto.\nred; intros; elim H3.\napply Permutation_in with l'; auto.\napply Permutation_sym; auto."},{"statement":"(A : Type) (x : A) (l l' : list A) (H : Permutation l l') (IHPermutation : list_norepet l -> list_norepet l') (H3 : ~ In x l) (H4 : list_norepet l) : ~ In x l'.","proofString":"red; intros; elim H3.\napply Permutation_in with l'; auto.\napply Permutation_sym; auto."},{"statement":"(A : Type) (x : A) (l l' : list A) (H : Permutation l l') (IHPermutation : list_norepet l -> list_norepet l') (H3 : ~ In x l) (H4 : list_norepet l) (H0 : In x l') : In x l.","proofString":"apply Permutation_in with l'; auto.\napply Permutation_sym; auto."},{"statement":"(A : Type) (x : A) (l l' : list A) (H : Permutation l l') (IHPermutation : list_norepet l -> list_norepet l') (H3 : ~ In x l) (H4 : list_norepet l) (H0 : In x l') : Permutation l' l.","proofString":"apply Permutation_sym; auto."},{"statement":"(A : Type) (x y : A) (l : list A) (H : list_norepet (y :: x :: l)) : list_norepet (x :: y :: l).","proofString":"inv H.\nsimpl in H2.\ninv H3.\nconstructor.\nsimpl; intuition.\nconstructor.\nintuition.\nauto."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ In y (x :: l)) (H3 : list_norepet (x :: l)) : list_norepet (x :: y :: l).","proofString":"simpl in H2.\ninv H3.\nconstructor.\nsimpl; intuition.\nconstructor.\nintuition.\nauto."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H3 : list_norepet (x :: l)) : list_norepet (x :: y :: l).","proofString":"inv H3.\nconstructor.\nsimpl; intuition.\nconstructor.\nintuition.\nauto."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H1 : ~ In x l) (H4 : list_norepet l) : list_norepet (x :: y :: l).","proofString":"constructor.\nsimpl; intuition.\nconstructor.\nintuition.\nauto."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H1 : ~ In x l) (H4 : list_norepet l) : ~ In x (y :: l).","proofString":"simpl; intuition."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H1 : ~ In x l) (H4 : list_norepet l) : list_norepet (y :: l).","proofString":"constructor.\nintuition.\nauto."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H1 : ~ In x l) (H4 : list_norepet l) : ~ In y l.","proofString":"intuition."},{"statement":"(A : Type) (x y : A) (l : list A) (H2 : ~ (x = y \\/ In y l)) (H1 : ~ In x l) (H4 : list_norepet l) : list_norepet l.","proofString":"auto."},{"statement":"(A : Type) (l l' l'' : list A) (H : Permutation l l') (H0 : Permutation l' l'') (IHPermutation1 : list_norepet l -> list_norepet l') (IHPermutation2 : list_norepet l' -> list_norepet l'') (H1 : list_norepet l) : list_norepet l''.","proofString":"eauto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort (Csharpminor.fn_vars f)) =\n(cenv, sz)) (H0 : list_norepet (map fst (Csharpminor.fn_vars f))) : cenv_compat cenv (Csharpminor.fn_vars f) sz /\\\ncenv_separated cenv (Csharpminor.fn_vars f).","proofString":"set (vars1 := Csharpminor.fn_vars f) in *.\ngeneralize (VarSort.Permuted_sort vars1).\nintros P.\nset (vars2 := VarSort.sort vars1) in *.\nassert (cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2).\nchange vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction.\ndestruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : list_norepet (map fst vars1)) : cenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"generalize (VarSort.Permuted_sort vars1).\nintros P.\nset (vars2 := VarSort.sort vars1) in *.\nassert (cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2).\nchange vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction.\ndestruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : list_norepet (map fst vars1)) : Permutation vars1 (VarSort.sort vars1) ->\ncenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"intros P.\nset (vars2 := VarSort.sort vars1) in *.\nassert (cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2).\nchange vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction.\ndestruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 (VarSort.sort vars1)) : cenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"set (vars2 := VarSort.sort vars1) in *.\nassert (cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2).\nchange vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction.\ndestruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : cenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"assert (cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2).\nchange vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction.\ndestruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2.","proofString":"change vars2 with (nil ++ vars2).\neapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : cenv_compat cenv (nil ++ vars2) sz /\\ cenv_separated cenv (nil ++ vars2).","proofString":"eapply assign_variables_sound.\neexact H.\nsimpl.\nrewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto.\nlia.\nred; intros.\ncontradiction.\nred; intros.\ncontradiction."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : list_norepet (map fst vars2 ++ nil).","proofString":"rewrite app_nil_r.\napply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : list_norepet (map fst vars2).","proofString":"apply permutation_norepet with (map fst vars1); auto.\napply Permutation_map.\nauto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : Permutation (map fst vars1) (map fst vars2).","proofString":"apply Permutation_map.\nauto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) : Permutation vars1 vars2.","proofString":"auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (id : ident) (sz0 : Z) (H1 : In (id, sz0) nil) : exists ofs : Z,\n  (PTree.empty Z) ! id = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\ 0 <= ofs /\\ ofs + Z.max 0 sz0 <= 0.","proofString":"contradiction."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (id1 : ident) (sz1 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (H1 : In (id1, sz1) nil) (H2 : In (id2, sz2) nil) (H3 : (PTree.empty Z) ! id1 = Some ofs1) (H4 : (PTree.empty Z) ! id2 = Some ofs2) (H5 : id1 <> id2) : ofs1 + sz1 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"contradiction."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (H1 : cenv_compat cenv vars2 sz /\\ cenv_separated cenv vars2) : cenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"destruct H1 as [A B].\nsplit.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) : cenv_compat cenv vars1 sz /\\ cenv_separated cenv vars1.","proofString":"split.\nred; intros.\napply A.\napply Permutation_in with vars1; auto.\nred; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) : cenv_compat cenv vars1 sz.","proofString":"red; intros.\napply A.\napply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) (id : ident) (sz0 : Z) (H1 : In (id, sz0) vars1) : exists ofs : Z,\n  cenv ! id = Some ofs /\\\n  Mem.inj_offset_aligned ofs sz0 /\\ 0 <= ofs /\\ ofs + Z.max 0 sz0 <= sz.","proofString":"apply A.\napply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) (id : ident) (sz0 : Z) (H1 : In (id, sz0) vars1) : In (id, sz0) vars2.","proofString":"apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) : cenv_separated cenv vars1.","proofString":"red; intros.\neapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : list_norepet (map fst vars1)) (P : Permutation vars1 vars2) (A : cenv_compat cenv vars2 sz) (B : cenv_separated cenv vars2) (id1 : ident) (sz1 ofs1 : Z) (id2 : ident) (sz2 ofs2 : Z) (H1 : In (id1, sz1) vars1) (H2 : In (id2, sz2) vars1) (H3 : cenv ! id1 = Some ofs1) (H4 : cenv ! id2 = Some ofs2) (H5 : id1 <> id2) : ofs1 + sz1 <= ofs2 \\/ ofs2 + sz2 <= ofs1.","proofString":"eapply B; eauto; apply Permutation_in with vars1; auto."},{"statement":"(id : positive) (cesz : compilenv * Z) (H : (fst cesz) ! id <> None) : (fst cesz) ! id <> None \\/ False.","proofString":"auto."},{"statement":"(id : positive) (a : ident * Z) (vars : list (ident * Z)) (IHvars : forall cesz0 : compilenv * Z,\n(fst (assign_variables cesz0 vars)) ! id <> None ->\n(fst cesz0) ! id <> None \\/ In id (map fst vars)) (cesz : compilenv * Z) (H : (fst (assign_variables (assign_variable cesz a) vars)) ! id <> None) : (fst cesz) ! id <> None \\/ fst a = id \\/ In id (map fst vars).","proofString":"exploit IHvars; eauto.\nunfold assign_variable.\ndestruct a as [id1 sz1].\ndestruct cesz as [cenv stksz].\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (a : ident * Z) (vars : list (ident * Z)) (IHvars : forall cesz0 : compilenv * Z,\n(fst (assign_variables cesz0 vars)) ! id <> None ->\n(fst cesz0) ! id <> None \\/ In id (map fst vars)) (cesz : compilenv * Z) (H : (fst (assign_variables (assign_variable cesz a) vars)) ! id <> None) : (fst (assign_variable cesz a)) ! id <> None \\/ In id (map fst vars) ->\n(fst cesz) ! id <> None \\/ fst a = id \\/ In id (map fst vars).","proofString":"unfold assign_variable.\ndestruct a as [id1 sz1].\ndestruct cesz as [cenv stksz].\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (a : ident * Z) (vars : list (ident * Z)) (IHvars : forall cesz0 : compilenv * Z,\n(fst (assign_variables cesz0 vars)) ! id <> None ->\n(fst cesz0) ! id <> None \\/ In id (map fst vars)) (cesz : compilenv * Z) (H : (fst (assign_variables (assign_variable cesz a) vars)) ! id <> None) : (fst\n   (let (id0, sz) := a in\n    let (cenv, stacksize) := cesz in\n    (PTree.set id0 (align stacksize (block_alignment sz)) cenv,\n     align stacksize (block_alignment sz) + Z.max 0 sz))) ! id <> None \\/\nIn id (map fst vars) ->\n(fst cesz) ! id <> None \\/ fst a = id \\/ In id (map fst vars).","proofString":"destruct a as [id1 sz1].\ndestruct cesz as [cenv stksz].\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz0 : compilenv * Z,\n(fst (assign_variables cesz0 vars)) ! id <> None ->\n(fst cesz0) ! id <> None \\/ In id (map fst vars)) (cesz : compilenv * Z) (H : (fst (assign_variables (assign_variable cesz (id1, sz1)) vars)) ! id <> None) : (fst\n   (let (cenv, stacksize) := cesz in\n    (PTree.set id1 (align stacksize (block_alignment sz1)) cenv,\n     align stacksize (block_alignment sz1) + Z.max 0 sz1))) ! id <> None \\/\nIn id (map fst vars) ->\n(fst cesz) ! id <> None \\/ fst (id1, sz1) = id \\/ In id (map fst vars).","proofString":"destruct cesz as [cenv stksz].\nsimpl.\nrewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz : compilenv * Z,\n(fst (assign_variables cesz vars)) ! id <> None ->\n(fst cesz) ! id <> None \\/ In id (map fst vars)) (cenv : compilenv) (stksz : Z) (H : (fst (assign_variables (assign_variable (cenv, stksz) (id1, sz1)) vars)) ! id <>\nNone) : (fst\n   (PTree.set id1 (align stksz (block_alignment sz1)) cenv,\n    align stksz (block_alignment sz1) + Z.max 0 sz1)) ! id <> None \\/\nIn id (map fst vars) ->\n(fst (cenv, stksz)) ! id <> None \\/\nfst (id1, sz1) = id \\/ In id (map fst vars).","proofString":"simpl.\nrewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz : compilenv * Z,\n(fst (assign_variables cesz vars)) ! id <> None ->\n(fst cesz) ! id <> None \\/ In id (map fst vars)) (cenv : compilenv) (stksz : Z) (H : (fst (assign_variables (assign_variable (cenv, stksz) (id1, sz1)) vars)) ! id <>\nNone) : (PTree.set id1 (align stksz (block_alignment sz1)) cenv) ! id <> None \\/\nIn id (map fst vars) -> cenv ! id <> None \\/ id1 = id \\/ In id (map fst vars).","proofString":"rewrite PTree.gsspec.\ndestruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz : compilenv * Z,\n(fst (assign_variables cesz vars)) ! id <> None ->\n(fst cesz) ! id <> None \\/ In id (map fst vars)) (cenv : compilenv) (stksz : Z) (H : (fst (assign_variables (assign_variable (cenv, stksz) (id1, sz1)) vars)) ! id <>\nNone) : (if peq id id1 then Some (align stksz (block_alignment sz1)) else cenv ! id) <>\nNone \\/ In id (map fst vars) ->\ncenv ! id <> None \\/ id1 = id \\/ In id (map fst vars).","proofString":"destruct (peq id id1).\nauto.\ntauto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz : compilenv * Z,\n(fst (assign_variables cesz vars)) ! id <> None ->\n(fst cesz) ! id <> None \\/ In id (map fst vars)) (cenv : compilenv) (stksz : Z) (H : (fst (assign_variables (assign_variable (cenv, stksz) (id1, sz1)) vars)) ! id <>\nNone) (e : id = id1) : Some (align stksz (block_alignment sz1)) <> None \\/ In id (map fst vars) ->\ncenv ! id <> None \\/ id1 = id \\/ In id (map fst vars).","proofString":"auto."},{"statement":"(id : positive) (id1 : ident) (sz1 : Z) (vars : list (ident * Z)) (IHvars : forall cesz : compilenv * Z,\n(fst (assign_variables cesz vars)) ! id <> None ->\n(fst cesz) ! id <> None \\/ In id (map fst vars)) (cenv : compilenv) (stksz : Z) (H : (fst (assign_variables (assign_variable (cenv, stksz) (id1, sz1)) vars)) ! id <>\nNone) (n : id <> id1) : cenv ! id <> None \\/ In id (map fst vars) ->\ncenv ! id <> None \\/ id1 = id \\/ In id (map fst vars).","proofString":"tauto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort (Csharpminor.fn_vars f)) =\n(cenv, sz)) (H0 : cenv ! id = Some ofs) : In id (map fst (Csharpminor.fn_vars f)).","proofString":"set (vars1 := Csharpminor.fn_vars f) in *.\ngeneralize (VarSort.Permuted_sort vars1).\nintros P.\nset (vars2 := VarSort.sort vars1) in *.\ngeneralize (assign_variables_domain id vars2 (PTree.empty Z, 0)).\nrewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : cenv ! id = Some ofs) : In id (map fst vars1).","proofString":"generalize (VarSort.Permuted_sort vars1).\nintros P.\nset (vars2 := VarSort.sort vars1) in *.\ngeneralize (assign_variables_domain id vars2 (PTree.empty Z, 0)).\nrewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : cenv ! id = Some ofs) : Permutation vars1 (VarSort.sort vars1) -> In id (map fst vars1).","proofString":"intros P.\nset (vars2 := VarSort.sort vars1) in *.\ngeneralize (assign_variables_domain id vars2 (PTree.empty Z, 0)).\nrewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) (VarSort.sort vars1) = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 (VarSort.sort vars1)) : In id (map fst vars1).","proofString":"set (vars2 := VarSort.sort vars1) in *.\ngeneralize (assign_variables_domain id vars2 (PTree.empty Z, 0)).\nrewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) : In id (map fst vars1).","proofString":"generalize (assign_variables_domain id vars2 (PTree.empty Z, 0)).\nrewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) : ((fst (assign_variables (PTree.empty Z, 0) vars2)) ! id <> None ->\n (fst (PTree.empty Z, 0)) ! id <> None \\/ In id (map fst vars2)) ->\nIn id (map fst vars1).","proofString":"rewrite H.\nsimpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) : ((fst (cenv, sz)) ! id <> None ->\n (fst (PTree.empty Z, 0)) ! id <> None \\/ In id (map fst vars2)) ->\nIn id (map fst vars1).","proofString":"simpl.\nintros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) : (cenv ! id <> None -> (PTree.empty Z) ! id <> None \\/ In id (map fst vars2)) ->\nIn id (map fst vars1).","proofString":"intros.\ndestruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) (H1 : cenv ! id <> None -> (PTree.empty Z) ! id <> None \\/ In id (map fst vars2)) : In id (map fst vars1).","proofString":"destruct H1.\ncongruence.\nrewrite PTree.gempty in H1.\ncongruence.\napply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) : cenv ! id <> None.","proofString":"congruence."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) (H1 : (PTree.empty Z) ! id <> None) : In id (map fst vars1).","proofString":"rewrite PTree.gempty in H1.\ncongruence."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) (H1 : In id (map fst vars2)) : In id (map fst vars1).","proofString":"apply Permutation_in with (map fst vars2); auto.\napply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) (H1 : In id (map fst vars2)) : Permutation (map fst vars2) (map fst vars1).","proofString":"apply Permutation_map.\napply Permutation_sym; auto."},{"statement":"(f : Csharpminor.function) (cenv : compilenv) (sz : Z) (id : positive) (ofs : Z) (vars1 : list (ident * Z)) (vars2 : list (ident * Z)) (H : assign_variables (PTree.empty Z, 0) vars2 = (cenv, sz)) (H0 : cenv ! id = Some ofs) (P : Permutation vars1 vars2) (H1 : In id (map fst vars2)) : Permutation vars2 vars1.","proofString":"apply Permutation_sym; auto."},{"statement":"(id : positive) (v : val) (H : (PTree.empty val) ! id = Some v) : False /\\ v = Vundef.","proofString":"rewrite PTree.gempty in H.\ncongruence."},{"statement":"(id : positive) (v : val) (H : None = Some v) : False /\\ v = Vundef.","proofString":"congruence."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (H : (PTree.set a Vundef (create_undef_temps temps)) ! id = Some v) : (a = id \\/ In id temps) /\\ v = Vundef.","proofString":"rewrite PTree.gsspec in H.\ndestruct (peq id a).\nsplit.\nauto.\ncongruence.\nexploit IHtemps; eauto.\ntauto."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (H : (if peq id a then Some Vundef else (create_undef_temps temps) ! id) = Some v) : (a = id \\/ In id temps) /\\ v = Vundef.","proofString":"destruct (peq id a).\nsplit.\nauto.\ncongruence.\nexploit IHtemps; eauto.\ntauto."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (e : id = a) (H : Some Vundef = Some v) : (a = id \\/ In id temps) /\\ v = Vundef.","proofString":"split.\nauto.\ncongruence."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (e : id = a) (H : Some Vundef = Some v) : a = id \\/ In id temps.","proofString":"auto."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (e : id = a) (H : Some Vundef = Some v) : v = Vundef.","proofString":"congruence."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (n : id <> a) (H : (create_undef_temps temps) ! id = Some v) : (a = id \\/ In id temps) /\\ v = Vundef.","proofString":"exploit IHtemps; eauto.\ntauto."},{"statement":"(id : positive) (v : val) (a : ident) (temps : list ident) (IHtemps : (create_undef_temps temps) ! id = Some v -> In id temps /\\ v = Vundef) (n : id <> a) (H : (create_undef_temps temps) ! id = Some v) : In id temps /\\ v = Vundef -> (a = id \\/ In id temps) /\\ v = Vundef.","proofString":"tauto."},{"statement":"(id : positive) (vl : list val) (te : env) (H : ~ False) : te ! id = te ! id.","proofString":"auto."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl0 : list val) (te0 : env),\n~ In id il -> (set_params' vl0 il te0) ! id = te0 ! id) (vl : list val) (te : env) (H : ~ (a = id \\/ In id il)) : match vl with\n| nil => set_params' nil il (PTree.set a Vundef te)\n| v1 :: vs => set_params' vs il (PTree.set a v1 te)\nend ! id = te ! id.","proofString":"destruct vl; rewrite IHil.\napply PTree.gso.\nintuition.\nintuition.\napply PTree.gso.\nintuition.\nintuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl : list val) (te0 : env),\n~ In id il -> (set_params' vl il te0) ! id = te0 ! id) (te : env) (H : ~ (a = id \\/ In id il)) : (PTree.set a Vundef te) ! id = te ! id.","proofString":"apply PTree.gso.\nintuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl : list val) (te0 : env),\n~ In id il -> (set_params' vl il te0) ! id = te0 ! id) (te : env) (H : ~ (a = id \\/ In id il)) : id <> a.","proofString":"intuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl : list val) (te0 : env),\n~ In id il -> (set_params' vl il te0) ! id = te0 ! id) (te : env) (H : ~ (a = id \\/ In id il)) : ~ In id il.","proofString":"intuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl0 : list val) (te0 : env),\n~ In id il -> (set_params' vl0 il te0) ! id = te0 ! id) (v : val) (vl : list val) (te : env) (H : ~ (a = id \\/ In id il)) : (PTree.set a v te) ! id = te ! id.","proofString":"apply PTree.gso.\nintuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl0 : list val) (te0 : env),\n~ In id il -> (set_params' vl0 il te0) ! id = te0 ! id) (v : val) (vl : list val) (te : env) (H : ~ (a = id \\/ In id il)) : id <> a.","proofString":"intuition."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl0 : list val) (te0 : env),\n~ In id il -> (set_params' vl0 il te0) ! id = te0 ! id) (v : val) (vl : list val) (te : env) (H : ~ (a = id \\/ In id il)) : ~ In id il.","proofString":"intuition."},{"statement":"(id : positive) (vl : list val) (te1 te2 : env) (H : False) : te1 ! id = te2 ! id.","proofString":"contradiction."},{"statement":"(id a : positive) (il : list positive) (IHil : forall (vl0 : list val) (te0 te3 : env),\nIn id il -> (set_params' vl0 il te0) ! id = (set_params' vl0 il te3) ! id) (vl : list val) (te1 te2 : env) (H : a = id \\/ In id il) : match vl with\n| nil => set_params' nil il (PTree.set a Vundef te1)\n| v1 :: vs => set_params' vs il (PTree.set a v1 te1)\nend ! id =\nmatch vl with\n| nil => set_params' nil il (PTree.set a Vundef te2)\n| v1 :: vs => set_params' vs il (PTree.set a v1 te2)\nend ! id.","proofString":"destruct vl; destruct (List.in_dec peq id il); auto;  repeat rewrite set_params'_outside; auto;  assert (a = id) by intuition; subst a; repeat rewrite PTree.gss; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (vl : list val) (id : positive) (H : list_norepet (a :: il)) : match vl with\n| nil => PTree.set a Vundef (set_params nil il)\n| v1 :: vs => PTree.set a v1 (set_params vs il)\nend ! id =\nmatch vl with\n| nil => set_params' nil il (PTree.set a Vundef (PTree.empty val))\n| v1 :: vs => set_params' vs il (PTree.set a v1 (PTree.empty val))\nend ! id.","proofString":"inv H.\ndestruct vl.\nrewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto.\nrewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) : match vl with\n| nil => PTree.set a Vundef (set_params nil il)\n| v1 :: vs => PTree.set a v1 (set_params vs il)\nend ! id =\nmatch vl with\n| nil => set_params' nil il (PTree.set a Vundef (PTree.empty val))\n| v1 :: vs => set_params' vs il (PTree.set a v1 (PTree.empty val))\nend ! id.","proofString":"destruct vl.\nrewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto.\nrewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) : (PTree.set a Vundef (set_params nil il)) ! id =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) : (if peq id a then Some Vundef else (set_params nil il) ! id) =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"destruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (e : id = a) : Some Vundef =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"subst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto."},{"statement":"(il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In id il) (H3 : list_norepet il) : Some Vundef =\n(set_params' nil il (PTree.set id Vundef (PTree.empty val))) ! id.","proofString":"rewrite set_params'_outside; auto.\nrewrite PTree.gss; auto."},{"statement":"(il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In id il) (H3 : list_norepet il) : Some Vundef = (PTree.set id Vundef (PTree.empty val)) ! id.","proofString":"rewrite PTree.gss; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) : (set_params nil il) ! id =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"rewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) : (set_params' nil il (PTree.empty val)) ! id =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"destruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (i : In id il) : (set_params' nil il (PTree.empty val)) ! id =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"apply set_params'_inside; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (n0 : ~ In id il) : (set_params' nil il (PTree.empty val)) ! id =\n(set_params' nil il (PTree.set a Vundef (PTree.empty val))) ! id.","proofString":"repeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl il) ! id0 = (set_params' vl il (PTree.empty val)) ! id0) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (n0 : ~ In id il) : (PTree.empty val) ! id = (PTree.set a Vundef (PTree.empty val)) ! id.","proofString":"rewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) : (PTree.set a v (set_params vl il)) ! id =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) : (if peq id a then Some v else (set_params vl il) ! id) =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"destruct (peq id a).\nsubst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto.\nrewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (e : id = a) : Some v = (set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"subst a.\nrewrite set_params'_outside; auto.\nrewrite PTree.gss; auto."},{"statement":"(il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In id il) (H3 : list_norepet il) : Some v = (set_params' vl il (PTree.set id v (PTree.empty val))) ! id.","proofString":"rewrite set_params'_outside; auto.\nrewrite PTree.gss; auto."},{"statement":"(il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In id il) (H3 : list_norepet il) : Some v = (PTree.set id v (PTree.empty val)) ! id.","proofString":"rewrite PTree.gss; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) : (set_params vl il) ! id =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"rewrite IHil; auto.\ndestruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) : (set_params' vl il (PTree.empty val)) ! id =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"destruct (List.in_dec peq id il).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (i : In id il) : (set_params' vl il (PTree.empty val)) ! id =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"apply set_params'_inside; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (n0 : ~ In id il) : (set_params' vl il (PTree.empty val)) ! id =\n(set_params' vl il (PTree.set a v (PTree.empty val))) ! id.","proofString":"repeat rewrite set_params'_outside; auto.\nrewrite PTree.gso; auto."},{"statement":"(a : ident) (il : list ident) (IHil : forall (vl0 : list val) (id0 : positive),\nlist_norepet il ->\n(set_params vl0 il) ! id0 = (set_params' vl0 il (PTree.empty val)) ! id0) (v : val) (vl : list val) (id : positive) (H2 : ~ In a il) (H3 : list_norepet il) (n : id <> a) (n0 : ~ In id il) : (PTree.empty val) ! id = (PTree.set a v (PTree.empty val)) ! id.","proofString":"rewrite PTree.gso; auto."},{"statement":"(e : env) (id : positive) (H : ~ False) : e ! id = e ! id.","proofString":"auto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : ~ In id il -> (set_locals il e) ! id = e ! id) (H : ~ (a = id \\/ In id il)) : (PTree.set a Vundef (set_locals il e)) ! id = e ! id.","proofString":"rewrite PTree.gso.\napply IHil.\ntauto.\nintuition."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : ~ In id il -> (set_locals il e) ! id = e ! id) (H : ~ (a = id \\/ In id il)) : (set_locals il e) ! id = e ! id.","proofString":"apply IHil.\ntauto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : ~ In id il -> (set_locals il e) ! id = e ! id) (H : ~ (a = id \\/ In id il)) : ~ In id il.","proofString":"tauto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : ~ In id il -> (set_locals il e) ! id = e ! id) (H : ~ (a = id \\/ In id il)) : id <> a.","proofString":"intuition."},{"statement":"(e : env) (id : positive) (H : False) : e ! id = Some Vundef.","proofString":"contradiction."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : a = id \\/ In id il) : (PTree.set a Vundef (set_locals il e)) ! id = Some Vundef.","proofString":"destruct H.\nsubst a.\napply PTree.gss.\nrewrite PTree.gsspec.\ndestruct (peq id a).\nauto.\nauto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : a = id) : (PTree.set a Vundef (set_locals il e)) ! id = Some Vundef.","proofString":"subst a.\napply PTree.gss."},{"statement":"(e : env) (id : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) : (PTree.set id Vundef (set_locals il e)) ! id = Some Vundef.","proofString":"apply PTree.gss."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : In id il) : (PTree.set a Vundef (set_locals il e)) ! id = Some Vundef.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id a).\nauto.\nauto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : In id il) : (if peq id a then Some Vundef else (set_locals il e) ! id) = Some Vundef.","proofString":"destruct (peq id a).\nauto.\nauto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : In id il) (e0 : id = a) : Some Vundef = Some Vundef.","proofString":"auto."},{"statement":"(e : env) (id a : positive) (il : list positive) (IHil : In id il -> (set_locals il e) ! id = Some Vundef) (H : In id il) (n : id <> a) : (set_locals il e) ! id = Some Vundef.","proofString":"auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) : (set_locals vars (set_params vals params)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"destruct (in_dec peq id vars).\nassert (~In id params).\napply list_disjoint_notin with vars; auto.\napply list_disjoint_sym; auto.\nrewrite set_locals_inside; auto.\nrewrite set_params'_outside; auto.\nrewrite set_locals_inside; auto.\nrewrite set_locals_outside; auto.\nrewrite set_params_set_params'; auto.\ndestruct (in_dec peq id params).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite set_locals_outside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) : (set_locals vars (set_params vals params)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"assert (~In id params).\napply list_disjoint_notin with vars; auto.\napply list_disjoint_sym; auto.\nrewrite set_locals_inside; auto.\nrewrite set_params'_outside; auto.\nrewrite set_locals_inside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) : ~ In id params.","proofString":"apply list_disjoint_notin with vars; auto.\napply list_disjoint_sym; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) : list_disjoint vars params.","proofString":"apply list_disjoint_sym; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) (H1 : ~ In id params) : (set_locals vars (set_params vals params)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"rewrite set_locals_inside; auto.\nrewrite set_params'_outside; auto.\nrewrite set_locals_inside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) (H1 : ~ In id params) : Some Vundef =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"rewrite set_params'_outside; auto.\nrewrite set_locals_inside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (i : In id vars) (H1 : ~ In id params) : Some Vundef = (set_locals vars (PTree.empty val)) ! id.","proofString":"rewrite set_locals_inside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) : (set_locals vars (set_params vals params)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"rewrite set_locals_outside; auto.\nrewrite set_params_set_params'; auto.\ndestruct (in_dec peq id params).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite set_locals_outside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) : (set_params vals params) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"rewrite set_params_set_params'; auto.\ndestruct (in_dec peq id params).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite set_locals_outside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) : (set_params' vals params (PTree.empty val)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"destruct (in_dec peq id params).\napply set_params'_inside; auto.\nrepeat rewrite set_params'_outside; auto.\nrewrite set_locals_outside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) (i : In id params) : (set_params' vals params (PTree.empty val)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"apply set_params'_inside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) (n0 : ~ In id params) : (set_params' vals params (PTree.empty val)) ! id =\n(set_params' vals params (set_locals vars (PTree.empty val))) ! id.","proofString":"repeat rewrite set_params'_outside; auto.\nrewrite set_locals_outside; auto."},{"statement":"(vars : list ident) (vals : list val) (params : list ident) (id : positive) (H : list_norepet params) (H0 : list_disjoint params vars) (n : ~ In id vars) (n0 : ~ In id params) : (PTree.empty val) ! id = (set_locals vars (PTree.empty val)) ! id.","proofString":"rewrite set_locals_outside; auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) : exists v' : val,\n  (set_locals temps (set_params tvals params)) ! id = Some v' /\\\n  Val.inject f v v'.","proofString":"exploit bind_parameters_agree_rec; eauto.\ninstantiate (1 := set_locals temps (PTree.empty val)).\nred; intros.\nexploit create_undef_temps_val; eauto.\nintros [A B].\nsubst v0.\nexists Vundef; split.\napply set_locals_inside; auto.\nauto.\nintros [v' [A B]].\nexists v'; split; auto.\nrewrite <- A.\napply set_locals_set_params'; auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) : match_temps f (create_undef_temps temps) (set_locals temps (PTree.empty val)).","proofString":"red; intros.\nexploit create_undef_temps_val; eauto.\nintros [A B].\nsubst v0.\nexists Vundef; split.\napply set_locals_inside; auto.\nauto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (v0 : val) (H4 : (create_undef_temps temps) ! id0 = Some v0) : exists v' : val,\n  (set_locals temps (PTree.empty val)) ! id0 = Some v' /\\ Val.inject f v0 v'.","proofString":"exploit create_undef_temps_val; eauto.\nintros [A B].\nsubst v0.\nexists Vundef; split.\napply set_locals_inside; auto.\nauto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (v0 : val) (H4 : (create_undef_temps temps) ! id0 = Some v0) : In id0 temps /\\ v0 = Vundef ->\nexists v' : val,\n  (set_locals temps (PTree.empty val)) ! id0 = Some v' /\\ Val.inject f v0 v'.","proofString":"intros [A B].\nsubst v0.\nexists Vundef; split.\napply set_locals_inside; auto.\nauto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (v0 : val) (H4 : (create_undef_temps temps) ! id0 = Some v0) (A : In id0 temps) (B : v0 = Vundef) : exists v' : val,\n  (set_locals temps (PTree.empty val)) ! id0 = Some v' /\\ Val.inject f v0 v'.","proofString":"subst v0.\nexists Vundef; split.\napply set_locals_inside; auto.\nauto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (H4 : (create_undef_temps temps) ! id0 = Some Vundef) (A : In id0 temps) : exists v' : val,\n  (set_locals temps (PTree.empty val)) ! id0 = Some v' /\\\n  Val.inject f Vundef v'.","proofString":"exists Vundef; split.\napply set_locals_inside; auto.\nauto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (H4 : (create_undef_temps temps) ! id0 = Some Vundef) (A : In id0 temps) : (set_locals temps (PTree.empty val)) ! id0 = Some Vundef.","proofString":"apply set_locals_inside; auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (id0 : positive) (H4 : (create_undef_temps temps) ! id0 = Some Vundef) (A : In id0 temps) : Val.inject f Vundef Vundef.","proofString":"auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (v' : val) (A : (set_params' tvals params (set_locals temps (PTree.empty val))) ! id =\nSome v') (B : Val.inject f v v') : exists v'0 : val,\n  (set_locals temps (set_params tvals params)) ! id = Some v'0 /\\\n  Val.inject f v v'0.","proofString":"exists v'; split; auto.\nrewrite <- A.\napply set_locals_set_params'; auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (v' : val) (A : (set_params' tvals params (set_locals temps (PTree.empty val))) ! id =\nSome v') (B : Val.inject f v v') : (set_locals temps (set_params tvals params)) ! id = Some v'.","proofString":"rewrite <- A.\napply set_locals_set_params'; auto."},{"statement":"(f : meminj) (params temps : list ident) (vals tvals : list val) (le : temp_env) (H : bind_parameters params vals (create_undef_temps temps) = Some le) (H0 : Val.inject_list f vals tvals) (H1 : list_norepet params) (H2 : list_disjoint params temps) (id : positive) (v : val) (H3 : le ! id = Some v) (v' : val) (A : (set_params' tvals params (set_locals temps (PTree.empty val))) ! id =\nSome v') (B : Val.inject f v v') : (set_locals temps (set_params tvals params)) ! id =\n(set_params' tvals params (set_locals temps (PTree.empty val))) ! id.","proofString":"apply set_locals_set_params'; auto."},{"statement":"(fn : Csharpminor.function) (cenv : compilenv) (tf : function) (m : mem) (e : Csharpminor.env) (m' tm : mem) (tm' : Mem.mem') (sp : block) (f : meminj) (cs : callstack) (args targs : list val) (le : temp_env) (H : build_compilenv fn = (cenv, fn_stackspace tf)) (H0 : fn_stackspace tf <= Ptrofs.max_unsigned) (H1 : list_norepet (map fst (Csharpminor.fn_vars fn))) (H2 : list_norepet (Csharpminor.fn_params fn)) (H3 : list_disjoint (Csharpminor.fn_params fn) (fn_temps fn)) (H4 : alloc_variables empty_env m (Csharpminor.fn_vars fn) e m') (H5 : bind_parameters (Csharpminor.fn_params fn) args\n  (create_undef_temps (fn_temps fn)) = Some le) (H6 : Val.inject_list f args targs) (H7 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H8 : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H9 : Mem.inject f m tm) (te : env) (C1 : cenv_compat cenv (Csharpminor.fn_vars fn) (fn_stackspace tf)) (C2 : cenv_separated cenv (Csharpminor.fn_vars fn)) : forall (id : positive) (ofs : Z),\ncenv ! id = Some ofs -> In id (map fst (Csharpminor.fn_vars fn)).","proofString":"intros.\neapply build_compilenv_domain; eauto."},{"statement":"(fn : Csharpminor.function) (cenv : compilenv) (tf : function) (m : mem) (e : Csharpminor.env) (m' tm : mem) (tm' : Mem.mem') (sp : block) (f : meminj) (cs : callstack) (args targs : list val) (le : temp_env) (H : build_compilenv fn = (cenv, fn_stackspace tf)) (H0 : fn_stackspace tf <= Ptrofs.max_unsigned) (H1 : list_norepet (map fst (Csharpminor.fn_vars fn))) (H2 : list_norepet (Csharpminor.fn_params fn)) (H3 : list_disjoint (Csharpminor.fn_params fn) (fn_temps fn)) (H4 : alloc_variables empty_env m (Csharpminor.fn_vars fn) e m') (H5 : bind_parameters (Csharpminor.fn_params fn) args\n  (create_undef_temps (fn_temps fn)) = Some le) (H6 : Val.inject_list f args targs) (H7 : Mem.alloc tm 0 (fn_stackspace tf) = (tm', sp)) (H8 : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (H9 : Mem.inject f m tm) (te : env) (C1 : cenv_compat cenv (Csharpminor.fn_vars fn) (fn_stackspace tf)) (C2 : cenv_separated cenv (Csharpminor.fn_vars fn)) (id : positive) (ofs : Z) (H10 : cenv ! id = Some ofs) : In id (map fst (Csharpminor.fn_vars fn)).","proofString":"eapply build_compilenv_domain; eauto."},{"statement":"(f : meminj) (b : bool) : Val.inject f (if b then Vtrue else Vfalse) (if b then Vtrue else Vfalse).","proofString":"destruct b; constructor."},{"statement":"(f : meminj) : Val.inject f Vundef Vundef.","proofString":"constructor."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.zero_ext 8 v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.zero_ext 8 tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.sign_ext 8 v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.sign_ext 8 tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.zero_ext 16 v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.zero_ext 16 tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.sign_ext 16 v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.sign_ext 16 tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.negint v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.negint tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.notint v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.notint tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.negf v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.negf tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.absf v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.absf tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.negfs v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.negfs tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.absfs v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.absfs tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.singleoffloat v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.singleoffloat tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.floatofsingle v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.floatofsingle tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.intoffloat v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.intoffloat tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vint (Float.to_int f0) = Some v) : exists tv : val, Val.intoffloat (Vfloat f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vint (Float.to_int f0) = Some v) : exists tv : val,\n  option_map Vint (Float.to_int f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float) (i : int) : exists tv : val, Some (Vint i) = Some tv /\\ Val.inject f (Vint i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.intuoffloat v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.intuoffloat tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vint (Float.to_intu f0) = Some v) : exists tv : val, Val.intuoffloat (Vfloat f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vint (Float.to_intu f0) = Some v) : exists tv : val,\n  option_map Vint (Float.to_intu f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float) (i : int) : exists tv : val, Some (Vint i) = Some tv /\\ Val.inject f (Vint i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.floatofint v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.floatofint tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Val.floatofint (Vint i) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_int i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Some (Vfloat (Float.of_int i)) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_int i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.floatofintu v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.floatofintu tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Val.floatofintu (Vint i) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_intu i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Some (Vfloat (Float.of_intu i)) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_intu i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.intofsingle v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.intofsingle tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float32.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vint (Float32.to_int f0) = Some v) : exists tv : val, Val.intofsingle (Vsingle f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float32.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vint (Float32.to_int f0) = Some v) : exists tv : val,\n  option_map Vint (Float32.to_int f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float32.to_int f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float32) (i : int) : exists tv : val, Some (Vint i) = Some tv /\\ Val.inject f (Vint i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.intuofsingle v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.intuofsingle tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float32.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vint (Float32.to_intu f0) = Some v) : exists tv : val, Val.intuofsingle (Vsingle f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float32.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vint (Float32.to_intu f0) = Some v) : exists tv : val,\n  option_map Vint (Float32.to_intu f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float32.to_intu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float32) (i : int) : exists tv : val, Some (Vint i) = Some tv /\\ Val.inject f (Vint i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.singleofint v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.singleofint tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Val.singleofint (Vint i) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_int i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Some (Vsingle (Float32.of_int i)) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_int i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.singleofintu v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.singleofintu tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Val.singleofintu (Vint i) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int) : exists tv : val,\n  Some (Vsingle (Float32.of_intu i)) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_intu i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.negl v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.negl tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.notl v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.notl tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.loword v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.loword tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.longofint v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.longofint tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Some (Val.longofintu v1) = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Some (Val.longofintu tv1) = Some tv /\\ Val.inject f v tv.","proofString":"inv H; inv H0; simpl; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.longoffloat v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.longoffloat tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vlong (Float.to_long f0) = Some v) : exists tv : val, Val.longoffloat (Vfloat f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vlong (Float.to_long f0) = Some v) : exists tv : val,\n  option_map Vlong (Float.to_long f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float) (i : int64) : exists tv : val, Some (Vlong i) = Some tv /\\ Val.inject f (Vlong i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.longuoffloat v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.longuoffloat tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vlong (Float.to_longu f0) = Some v) : exists tv : val, Val.longuoffloat (Vfloat f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float) (H1 : option_map Vlong (Float.to_longu f0) = Some v) : exists tv : val,\n  option_map Vlong (Float.to_longu f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float) (i : int64) : exists tv : val, Some (Vlong i) = Some tv /\\ Val.inject f (Vlong i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.floatoflong v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.floatoflong tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Val.floatoflong (Vlong i) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_long i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Some (Vfloat (Float.of_long i)) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_long i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.floatoflongu v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.floatoflongu tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Val.floatoflongu (Vlong i) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_longu i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Some (Vfloat (Float.of_longu i)) = Some tv /\\\n  Val.inject f (Vfloat (Float.of_longu i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.longofsingle v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.longofsingle tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float32.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vlong (Float32.to_long f0) = Some v) : exists tv : val, Val.longofsingle (Vsingle f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float32.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vlong (Float32.to_long f0) = Some v) : exists tv : val,\n  option_map Vlong (Float32.to_long f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float32.to_long f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float32) (i : int64) : exists tv : val, Some (Vlong i) = Some tv /\\ Val.inject f (Vlong i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.longuofsingle v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.longuofsingle tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\ndestruct (Float32.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vlong (Float32.to_longu f0) = Some v) : exists tv : val,\n  Val.longuofsingle (Vsingle f0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl.\ndestruct (Float32.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (f0 : float32) (H1 : option_map Vlong (Float32.to_longu f0) = Some v) : exists tv : val,\n  option_map Vlong (Float32.to_longu f0) = Some tv /\\ Val.inject f v tv.","proofString":"destruct (Float32.to_longu f0); simpl in *; inv H1.\nTrivialExists."},{"statement":"(f : meminj) (f0 : float32) (i : int64) : exists tv : val, Some (Vlong i) = Some tv /\\ Val.inject f (Vlong i) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.singleoflong v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.singleoflong tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Val.singleoflong (Vlong i) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_long i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Some (Vsingle (Float32.of_long i)) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_long i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v : val) (H : Val.singleoflongu v1 = Some v) (H0 : Val.inject f v1 tv1) : exists tv : val, Val.singleoflongu tv1 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; simpl in H; inv H.\nsimpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Val.singleoflongu (Vlong i) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) tv.","proofString":"simpl.\nTrivialExists."},{"statement":"(f : meminj) (i : int64) : exists tv : val,\n  Some (Vsingle (Float32.of_longu i)) = Some tv /\\\n  Val.inject f (Vsingle (Float32.of_longu i)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.add tv1 tv2) = Some tv /\\ Val.inject f (Val.add v1 v2) tv.","proofString":"TrivialExists.\napply Val.add_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.add v1 v2) (Val.add tv1 tv2).","proofString":"apply Val.add_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.sub tv1 tv2) = Some tv /\\ Val.inject f (Val.sub v1 v2) tv.","proofString":"TrivialExists.\napply Val.sub_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.sub v1 v2) (Val.sub tv1 tv2).","proofString":"apply Val.sub_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.mul tv1 tv2) = Some tv /\\ Val.inject f (Val.mul v1 v2) tv.","proofString":"TrivialExists.\ninv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.mul v1 v2) (Val.mul tv1 tv2).","proofString":"inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.divs v1 v2 = Some v) : exists tv : val, Val.divs tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : Val.divs (Vint i) (Vint i0) = Some v) : exists tv : val, Val.divs (Vint i) (Vint i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.divs i i0))) = Some v) : exists tv : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.divs i i0))) = Some tv /\\ \n  Val.inject f v tv.","proofString":"destruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.divu v1 v2 = Some v) : exists tv : val, Val.divu tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : Val.divu (Vint i) (Vint i0) = Some v) : exists tv : val, Val.divu (Vint i) (Vint i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) = Some v) : exists tv : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.divu i i0))) =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : exists tv : val,\n  Some (Vint (Int.divu i i0)) = Some tv /\\\n  Val.inject f (Vint (Int.divu i i0)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.mods v1 v2 = Some v) : exists tv : val, Val.mods tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : Val.mods (Vint i) (Vint i0) = Some v) : exists tv : val, Val.mods (Vint i) (Vint i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : (if\n  Int.eq i0 Int.zero\n  || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n then None\n else Some (Vint (Int.mods i i0))) = Some v) : exists tv : val,\n  (if\n    Int.eq i0 Int.zero\n    || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone\n   then None\n   else Some (Vint (Int.mods i i0))) = Some tv /\\ \n  Val.inject f v tv.","proofString":"destruct (Int.eq i0 Int.zero      || Int.eq i (Int.repr Int.min_signed) && Int.eq i0 Int.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.modu v1 v2 = Some v) : exists tv : val, Val.modu tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : Val.modu (Vint i) (Vint i0) = Some v) : exists tv : val, Val.modu (Vint i) (Vint i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) (H4 : (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) = Some v) : exists tv : val,\n  (if Int.eq i0 Int.zero then None else Some (Vint (Int.modu i i0))) =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (Int.eq i0 Int.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : exists tv : val,\n  Some (Vint (Int.modu i i0)) = Some tv /\\\n  Val.inject f (Vint (Int.modu i i0)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.and tv1 tv2) = Some tv /\\ Val.inject f (Val.and v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.or tv1 tv2) = Some tv /\\ Val.inject f (Val.or v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.xor tv1 tv2) = Some tv /\\ Val.inject f (Val.xor v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shl tv1 tv2) = Some tv /\\ Val.inject f (Val.shl v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shl i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shr tv1 tv2) = Some tv /\\ Val.inject f (Val.shr v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shr i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shru tv1 tv2) = Some tv /\\ Val.inject f (Val.shru v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : Val.inject f\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef)\n  (if Int.ltu i0 Int.iwordsize then Vint (Int.shru i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int.iwordsize); constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.addf tv1 tv2) = Some tv /\\ Val.inject f (Val.addf v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.subf tv1 tv2) = Some tv /\\ Val.inject f (Val.subf v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.mulf tv1 tv2) = Some tv /\\ Val.inject f (Val.mulf v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.divf tv1 tv2) = Some tv /\\ Val.inject f (Val.divf v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.addfs tv1 tv2) = Some tv /\\ Val.inject f (Val.addfs v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.subfs tv1 tv2) = Some tv /\\ Val.inject f (Val.subfs v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.mulfs tv1 tv2) = Some tv /\\ Val.inject f (Val.mulfs v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.divfs tv1 tv2) = Some tv /\\ Val.inject f (Val.divfs v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.addl tv1 tv2) = Some tv /\\ Val.inject f (Val.addl v1 v2) tv.","proofString":"TrivialExists.\napply Val.addl_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.addl v1 v2) (Val.addl tv1 tv2).","proofString":"apply Val.addl_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.subl tv1 tv2) = Some tv /\\ Val.inject f (Val.subl v1 v2) tv.","proofString":"TrivialExists.\napply Val.subl_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.subl v1 v2) (Val.subl tv1 tv2).","proofString":"apply Val.subl_inject; auto."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.mull tv1 tv2) = Some tv /\\ Val.inject f (Val.mull v1 v2) tv.","proofString":"TrivialExists.\ninv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.mull v1 v2) (Val.mull tv1 tv2).","proofString":"inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.divls v1 v2 = Some v) : exists tv : val, Val.divls tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : Val.divls (Vlong i) (Vlong i0) = Some v) : exists tv : val,\n  Val.divls (Vlong i) (Vlong i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.divs i i0))) = Some v) : exists tv : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.divs i i0))) = Some tv /\\ \n  Val.inject f v tv.","proofString":"destruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.divlu v1 v2 = Some v) : exists tv : val, Val.divlu tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : Val.divlu (Vlong i) (Vlong i0) = Some v) : exists tv : val,\n  Val.divlu (Vlong i) (Vlong i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\nSome v) : exists tv : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.divu i i0))) =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) : exists tv : val,\n  Some (Vlong (Int64.divu i i0)) = Some tv /\\\n  Val.inject f (Vlong (Int64.divu i i0)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.modls v1 v2 = Some v) : exists tv : val, Val.modls tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : Val.modls (Vlong i) (Vlong i0) = Some v) : exists tv : val,\n  Val.modls (Vlong i) (Vlong i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : (if\n  Int64.eq i0 Int64.zero\n  || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n then None\n else Some (Vlong (Int64.mods i i0))) = Some v) : exists tv : val,\n  (if\n    Int64.eq i0 Int64.zero\n    || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone\n   then None\n   else Some (Vlong (Int64.mods i i0))) = Some tv /\\ \n  Val.inject f v tv.","proofString":"destruct (Int64.eq i0 Int64.zero      || Int64.eq i (Int64.repr Int64.min_signed) && Int64.eq i0 Int64.mone); inv H4; TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.modlu v1 v2 = Some v) : exists tv : val, Val.modlu tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"inv H0; try discriminate; inv H1; try discriminate.\nsimpl in *.\ndestruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : Val.modlu (Vlong i) (Vlong i0) = Some v) : exists tv : val,\n  Val.modlu (Vlong i) (Vlong i0) = Some tv /\\ Val.inject f v tv.","proofString":"simpl in *.\ndestruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (v : val) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) (H4 : (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\nSome v) : exists tv : val,\n  (if Int64.eq i0 Int64.zero then None else Some (Vlong (Int64.modu i i0))) =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (Int64.eq i0 Int64.zero); inv H4.\nTrivialExists."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) : exists tv : val,\n  Some (Vlong (Int64.modu i i0)) = Some tv /\\\n  Val.inject f (Vlong (Int64.modu i i0)) tv.","proofString":"TrivialExists."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.andl tv1 tv2) = Some tv /\\ Val.inject f (Val.andl v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.orl tv1 tv2) = Some tv /\\ Val.inject f (Val.orl v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.xorl tv1 tv2) = Some tv /\\ Val.inject f (Val.xorl v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shll tv1 tv2) = Some tv /\\ Val.inject f (Val.shll v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shl' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shrl tv1 tv2) = Some tv /\\ Val.inject f (Val.shrl v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shr' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.shrlu tv1 tv2) = Some tv /\\ Val.inject f (Val.shrlu v1 v2) tv.","proofString":"TrivialExists; inv H0; inv H1; simpl; auto.\ndestruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (m tm : mem) (H2 : Mem.inject f m tm) (i : int64) (i0 : int) : Val.inject f\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef)\n  (if Int.ltu i0 Int64.iwordsize' then Vlong (Int64.shru' i i0) else Vundef).","proofString":"destruct (Int.ltu i0 Int64.iwordsize'); constructor."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.cmp c tv1 tv2) = Some tv /\\ Val.inject f (Val.cmp c v1 v2) tv.","proofString":"TrivialExists.\ninv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.cmp c v1 v2) (Val.cmp c tv1 tv2).","proofString":"inv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int) : Val.inject f (Val.cmp c (Vint i) (Vint i0)) (Val.cmp c (Vint i) (Vint i0)).","proofString":"apply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.cmpu (Mem.valid_pointer tm) c tv1 tv2) = Some tv /\\\n  Val.inject f (Val.cmpu (Mem.valid_pointer m) c v1 v2) tv.","proofString":"TrivialExists.\nunfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:E.\nreplace (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\napply val_inject_val_of_optbool.\nsymmetry.\neapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nsimpl; auto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.cmpu (Mem.valid_pointer m) c v1 v2)\n  (Val.cmpu (Mem.valid_pointer tm) c tv1 tv2).","proofString":"unfold Val.cmpu.\ndestruct (Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:E.\nreplace (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\napply val_inject_val_of_optbool.\nsymmetry.\neapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nsimpl; auto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer m) c v1 v2))\n  (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2)).","proofString":"destruct (Val.cmpu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:E.\nreplace (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\napply val_inject_val_of_optbool.\nsymmetry.\neapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\nsimpl; auto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Val.inject f (Val.of_optbool (Some b))\n  (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2)).","proofString":"replace (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\napply val_inject_val_of_optbool.\nsymmetry.\neapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Val.inject f (Val.of_optbool (Some b)) (Val.of_optbool (Some b)).","proofString":"apply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Some b = Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2.","proofString":"symmetry.\neapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2 = Some b.","proofString":"eapply Val.cmpu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs)\n|| Mem.valid_pointer m b1 (Ptrofs.unsigned ofs - 1) = true ->\nMem.valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n|| Mem.valid_pointer tm b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) - 1) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs)\n|| Mem.valid_pointer m b1 (Ptrofs.unsigned ofs - 1) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (E : Val.cmpu_bool (Mem.valid_pointer m) c v1 v2 = None) : Val.inject f (Val.of_optbool None)\n  (Val.of_optbool (Val.cmpu_bool (Mem.valid_pointer tm) c tv1 tv2)).","proofString":"simpl; auto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.cmpf c tv1 tv2) = Some tv /\\ Val.inject f (Val.cmpf c v1 v2) tv.","proofString":"TrivialExists.\ninv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.cmpf c v1 v2) (Val.cmpf c tv1 tv2).","proofString":"inv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (m tm : mem) (H2 : Mem.inject f m tm) (f0 f1 : float) : Val.inject f (Val.cmpf c (Vfloat f0) (Vfloat f1))\n  (Val.cmpf c (Vfloat f0) (Vfloat f1)).","proofString":"apply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : exists tv : val,\n  Some (Val.cmpfs c tv1 tv2) = Some tv /\\ Val.inject f (Val.cmpfs c v1 v2) tv.","proofString":"TrivialExists.\ninv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) : Val.inject f (Val.cmpfs c v1 v2) (Val.cmpfs c tv1 tv2).","proofString":"inv H0; inv H1; auto.\napply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (m tm : mem) (H2 : Mem.inject f m tm) (f0 f1 : float32) : Val.inject f (Val.cmpfs c (Vsingle f0) (Vsingle f1))\n  (Val.cmpfs c (Vsingle f0) (Vsingle f1)).","proofString":"apply val_inject_val_of_optbool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.cmpl c v1 v2 = Some v) : exists tv : val, Val.cmpl c tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"unfold Val.cmpl in *.\ninv H0; inv H1; simpl in H4; inv H4.\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : option_map Val.of_bool (Val.cmpl_bool c v1 v2) = Some v) : exists tv : val,\n  option_map Val.of_bool (Val.cmpl_bool c tv1 tv2) = Some tv /\\\n  Val.inject f v tv.","proofString":"inv H0; inv H1; simpl in H4; inv H4.\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool."},{"statement":"(f : meminj) (c : comparison) (m tm : mem) (H2 : Mem.inject f m tm) (i i0 : int64) : exists tv : val,\n  option_map Val.of_bool (Val.cmpl_bool c (Vlong i) (Vlong i0)) = Some tv /\\\n  Val.inject f (Val.of_bool (Int64.cmp c i i0)) tv.","proofString":"econstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : Val.cmplu (Mem.valid_pointer m) c v1 v2 = Some v) : exists tv : val,\n  Val.cmplu (Mem.valid_pointer tm) c tv1 tv2 = Some tv /\\ Val.inject f v tv.","proofString":"unfold Val.cmplu in *.\ndestruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:E.\nsimpl in H4; inv H4.\nreplace (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool.\nsymmetry.\neapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\ndiscriminate."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (H4 : option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) =\nSome v) : exists tv : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) =\n  Some tv /\\ Val.inject f v tv.","proofString":"destruct (Val.cmplu_bool (Mem.valid_pointer m) c v1 v2) as [b|] eqn:E.\nsimpl in H4; inv H4.\nreplace (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool.\nsymmetry.\neapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto.\ndiscriminate."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) (H4 : option_map Val.of_bool (Some b) = Some v) : exists tv : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) =\n  Some tv /\\ Val.inject f v tv.","proofString":"simpl in H4; inv H4.\nreplace (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool.\nsymmetry.\neapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : exists tv : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) =\n  Some tv /\\ Val.inject f (Val.of_bool b) tv.","proofString":"replace (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) with (Some b).\neconstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool.\nsymmetry.\neapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : exists tv : val,\n  option_map Val.of_bool (Some b) = Some tv /\\\n  Val.inject f (Val.of_bool b) tv.","proofString":"econstructor; split.\nsimpl; eauto.\napply val_inject_val_of_bool."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Some b = Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2.","proofString":"symmetry.\neapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2 = Some b.","proofString":"eapply Val.cmplu_bool_inject; eauto.\nintros; eapply Mem.valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_val; eauto.\nintros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto.\nintros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs) = true ->\nMem.valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.","proofString":"intros; eapply Mem.valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs)\n|| Mem.valid_pointer m b1 (Ptrofs.unsigned ofs - 1) = true ->\nMem.valid_pointer tm b2\n  (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n|| Mem.valid_pointer tm b2\n     (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) - 1) = true.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_val; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs : ptrofs) (b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs)\n|| Mem.valid_pointer m b1 (Ptrofs.unsigned ofs - 1) = true ->\n0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <=\nPtrofs.max_unsigned.","proofString":"intros; eapply Mem.weak_valid_pointer_inject_no_overflow; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (b : bool) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = Some b) : forall (b1 : block) (ofs1 : ptrofs) (b2 : block) (ofs2 : ptrofs)\n  (b1' : block) (delta1 : Z) (b2' : block) (delta2 : Z),\nb1 <> b2 ->\nMem.valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->\nMem.valid_pointer m b2 (Ptrofs.unsigned ofs2) = true ->\nf b1 = Some (b1', delta1) ->\nf b2 = Some (b2', delta2) ->\nb1' <> b2' \\/\nPtrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <>\nPtrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).","proofString":"intros; eapply Mem.different_pointers_inject; eauto."},{"statement":"(f : meminj) (c : comparison) (v1 tv1 v2 tv2 v : val) (m tm : mem) (H0 : Val.inject f v1 tv1) (H1 : Val.inject f v2 tv2) (H2 : Mem.inject f m tm) (E : Val.cmplu_bool (Mem.valid_pointer m) c v1 v2 = None) (H4 : option_map Val.of_bool None = Some v) : exists tv : val,\n  option_map Val.of_bool (Val.cmplu_bool (Mem.valid_pointer tm) c tv1 tv2) =\n  Some tv /\\ Val.inject f v tv.","proofString":"discriminate."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H0 : eval_var_addr ge e id b) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    match cenv ! id with\n    | Some ofs => Econst (Oaddrstack (Ptrofs.repr ofs))\n    | None => Econst (Oaddrsymbol id Ptrofs.zero)\n    end tv /\\ Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"assert (match_var f sp e!id cenv!id).\ninv H.\ninv MENV.\nauto.\ninv H1; inv H0; try congruence.\nexists (Vptr sp (Ptrofs.repr ofs)); split.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto.\ncongruence.\nexploit match_callstack_match_globalenvs; eauto.\nintros [bnd MG].\ninv MG.\nexists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H0 : eval_var_addr ge e id b) : match_var f sp e ! id cenv ! id.","proofString":"inv H.\ninv MENV.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H0 : eval_var_addr ge e id b) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) : match_var f sp e ! id cenv ! id.","proofString":"inv MENV.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H0 : eval_var_addr ge e id b) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) (me_vars0 : forall id0 : positive, match_var f sp e ! id0 cenv ! id0) (me_low_high0 : Ple lo hi) (me_bounded0 : forall (id0 : positive) (b0 : block) (sz : Z),\ne ! id0 = Some (b0, sz) -> Ple lo b0 /\\ Plt b0 hi) (me_inv0 : forall (b0 : block) (delta : Z),\nf b0 = Some (sp, delta) ->\nexists (id0 : positive) (sz : Z), e ! id0 = Some (b0, sz)) (me_incr0 : forall (b0 tb : block) (delta : Z),\nf b0 = Some (tb, delta) -> Plt b0 lo -> Plt tb sp) : match_var f sp e ! id cenv ! id.","proofString":"auto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H0 : eval_var_addr ge e id b) (H1 : match_var f sp e ! id cenv ! id) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    match cenv ! id with\n    | Some ofs => Econst (Oaddrstack (Ptrofs.repr ofs))\n    | None => Econst (Oaddrsymbol id Ptrofs.zero)\n    end tv /\\ Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"inv H1; inv H0; try congruence.\nexists (Vptr sp (Ptrofs.repr ofs)); split.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto.\ncongruence.\nexploit match_callstack_match_globalenvs; eauto.\nintros [bnd MG].\ninv MG.\nexists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (b0 : block) (sz ofs : Z) (H4 : Val.inject f (Vptr b0 Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs))) (H2 : Some (b0, sz) = e ! id) (H3 : Some ofs = cenv ! id) (sz0 : Z) (H1 : e ! id = Some (b, sz0)) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    (Econst (Oaddrstack (Ptrofs.repr ofs))) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"exists (Vptr sp (Ptrofs.repr ofs)); split.\nconstructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto.\ncongruence."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (b0 : block) (sz ofs : Z) (H4 : Val.inject f (Vptr b0 Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs))) (H2 : Some (b0, sz) = e ! id) (H3 : Some ofs = cenv ! id) (sz0 : Z) (H1 : e ! id = Some (b, sz0)) : eval_expr tge (Vptr sp Ptrofs.zero) te tm\n  (Econst (Oaddrstack (Ptrofs.repr ofs))) (Vptr sp (Ptrofs.repr ofs)).","proofString":"constructor.\nsimpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (b0 : block) (sz ofs : Z) (H4 : Val.inject f (Vptr b0 Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs))) (H2 : Some (b0, sz) = e ! id) (H3 : Some ofs = cenv ! id) (sz0 : Z) (H1 : e ! id = Some (b, sz0)) : eval_constant tge (Vptr sp Ptrofs.zero) (Oaddrstack (Ptrofs.repr ofs)) =\nSome (Vptr sp (Ptrofs.repr ofs)).","proofString":"simpl.\nrewrite Ptrofs.add_zero_l; auto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (b0 : block) (sz ofs : Z) (H4 : Val.inject f (Vptr b0 Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs))) (H2 : Some (b0, sz) = e ! id) (H3 : Some ofs = cenv ! id) (sz0 : Z) (H1 : e ! id = Some (b, sz0)) : Some (Vptr sp (Ptrofs.add Ptrofs.zero (Ptrofs.repr ofs))) =\nSome (Vptr sp (Ptrofs.repr ofs)).","proofString":"rewrite Ptrofs.add_zero_l; auto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (b0 : block) (sz ofs : Z) (H4 : Val.inject f (Vptr b0 Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs))) (H2 : Some (b0, sz) = e ! id) (H3 : Some ofs = cenv ! id) (sz0 : Z) (H1 : e ! id = Some (b, sz0)) : Val.inject f (Vptr b Ptrofs.zero) (Vptr sp (Ptrofs.repr ofs)).","proofString":"congruence."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    (Econst (Oaddrsymbol id Ptrofs.zero)) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"exploit match_callstack_match_globalenvs; eauto.\nintros [bnd MG].\ninv MG.\nexists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) : (exists hi0 : block, match_globalenvs f hi0) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    (Econst (Oaddrsymbol id Ptrofs.zero)) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"intros [bnd MG].\ninv MG.\nexists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (MG : match_globalenvs f bnd) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    (Econst (Oaddrsymbol id Ptrofs.zero)) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"inv MG.\nexists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm\n    (Econst (Oaddrsymbol id Ptrofs.zero)) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"exists (Vptr b Ptrofs.zero); split.\nconstructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : eval_expr tge (Vptr sp Ptrofs.zero) te tm\n  (Econst (Oaddrsymbol id Ptrofs.zero)) (Vptr b Ptrofs.zero).","proofString":"constructor.\nsimpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : eval_constant tge (Vptr sp Ptrofs.zero) (Oaddrsymbol id Ptrofs.zero) =\nSome (Vptr b Ptrofs.zero).","proofString":"simpl.\nunfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : Some (Genv.symbol_address tge id Ptrofs.zero) = Some (Vptr b Ptrofs.zero).","proofString":"unfold Genv.symbol_address.\nrewrite symbols_preserved.\nrewrite H2.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : Some\n  match Genv.find_symbol tge id with\n  | Some b0 => Vptr b0 Ptrofs.zero\n  | None => Vundef\n  end = Some (Vptr b Ptrofs.zero).","proofString":"rewrite symbols_preserved.\nrewrite H2.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : Some\n  match Genv.find_symbol ge id with\n  | Some b0 => Vptr b0 Ptrofs.zero\n  | None => Vundef\n  end = Some (Vptr b Ptrofs.zero).","proofString":"rewrite H2.\nauto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : Some (Vptr b Ptrofs.zero) = Some (Vptr b Ptrofs.zero).","proofString":"auto."},{"statement":"(cenv : compilenv) (id : ident) (f : meminj) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (m : mem) (cs : list frame) (tm : mem) (b : block) (H : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (H3 : None = e ! id) (H4 : None = cenv ! id) (H1 : e ! id = None) (H2 : Genv.find_symbol ge id = Some b) (bnd : block) (DOMAIN : forall b0 : positive, Plt b0 bnd -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bnd -> b1 = b2) (SYMBOLS : forall (id0 : ident) (b0 : block),\nGenv.find_symbol ge id0 = Some b0 -> Plt b0 bnd) (FUNCTIONS : forall (b0 : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd -> Plt b0 bnd) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bnd) : Val.inject f (Vptr b Ptrofs.zero) (Vptr b Ptrofs.zero).","proofString":"econstructor; eauto."},{"statement":"(f : meminj) (v tv : val) (b : bool) (H : Val.bool_of_val v b) (H0 : Val.inject f v tv) : Val.bool_of_val tv b.","proofString":"inv H0; inv H; constructor; auto."},{"statement":"(f : meminj) (sp : val) (i : int) : exists tv : val, Some (Vint i) = Some tv /\\ Val.inject f (Vint i) tv.","proofString":"exists (Vint i); auto."},{"statement":"(f : meminj) (sp : val) (f0 : float) : exists tv : val, Some (Vfloat f0) = Some tv /\\ Val.inject f (Vfloat f0) tv.","proofString":"exists (Vfloat f0); auto."},{"statement":"(f : meminj) (sp : val) (f0 : float32) : exists tv : val, Some (Vsingle f0) = Some tv /\\ Val.inject f (Vsingle f0) tv.","proofString":"exists (Vsingle f0); auto."},{"statement":"(f : meminj) (sp : val) (i : int64) : exists tv : val, Some (Vlong i) = Some tv /\\ Val.inject f (Vlong i) tv.","proofString":"exists (Vlong i); auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (id : positive) (v : val) (H : le ! id = Some v) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Evar id) tv /\\ Val.inject f v tv.","proofString":"inv MATCH.\nexploit MTMP; eauto.\nintros [tv [A B]].\nexists tv; split.\nconstructor; auto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (id : positive) (v : val) (H : le ! id = Some v) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Evar id) tv /\\ Val.inject f v tv.","proofString":"exploit MTMP; eauto.\nintros [tv [A B]].\nexists tv; split.\nconstructor; auto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (id : positive) (v : val) (H : le ! id = Some v) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) : (exists v' : val, te ! id = Some v' /\\ Val.inject f v v') ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Evar id) tv /\\ Val.inject f v tv.","proofString":"intros [tv [A B]].\nexists tv; split.\nconstructor; auto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (id : positive) (v : val) (H : le ! id = Some v) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) (tv : val) (A : te ! id = Some tv) (B : Val.inject f v tv) : exists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Evar id) tv0 /\\\n  Val.inject f v tv0.","proofString":"exists tv; split.\nconstructor; auto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (id : positive) (v : val) (H : le ! id = Some v) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) (tv : val) (A : te ! id = Some tv) (B : Val.inject f v tv) : eval_expr tge (Vptr sp Ptrofs.zero) te tm (Evar id) tv.","proofString":"constructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (id : positive) (v : val) (H : le ! id = Some v) (BOUND : Ple hi (Mem.nextblock m)) (TBOUND : Plt sp (Mem.nextblock tm)) (MTMP : match_temps f le te) (MENV : match_env f cenv e sp lo hi) (BOUND0 : match_bounds e m) (PERM : padding_freeable f e tm sp (fn_stackspace tf)) (MCS : match_callstack f m tm cs lo sp) (tv : val) (A : te ! id = Some tv) (B : Val.inject f v tv) : Val.inject f v tv.","proofString":"auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (id : ident) (b : block) (H : eval_var_addr ge e id b) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (var_addr cenv id) tv /\\\n  Val.inject f (Vptr b Ptrofs.zero) tv.","proofString":"eapply var_addr_correct; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (cst : Csharpminor.constant) (v : val) (H : Csharpminor.eval_constant cst = Some v) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Econst (transl_constant cst)) tv /\\\n  Val.inject f v tv.","proofString":"exploit transl_constant_correct; eauto.\nintros [tv [A B]].\nexists tv; split; eauto.\nconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv /\\\n  Val.inject f v tv.","proofString":"exploit IHeval_expr; eauto.\nintros [tv1 [EVAL1 INJ1]].\nexploit eval_unop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split; auto.\neconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) : (exists tv : val,\n   eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv /\\ Val.inject f v1 tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv1 [EVAL1 INJ1]].\nexploit eval_unop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split; auto.\neconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv /\\\n  Val.inject f v tv.","proofString":"exploit eval_unop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split; auto.\neconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : (exists tv : val, eval_unop op tv1 = Some tv /\\ Val.inject f v tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv [EVAL INJ]].\nexists tv; split; auto.\neconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (x : expr) (EQ : transl_expr cenv a1 = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv : val) (EVAL : eval_unop op tv1 = Some tv) (INJ : Val.inject f v tv) : exists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv0 /\\\n  Val.inject f v tv0.","proofString":"exists tv; split; auto.\neconstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : unary_operation) (a1 : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_unop op v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (x : expr) (EQ : transl_expr cenv a1 = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv : val) (EVAL : eval_unop op tv1 = Some tv) (INJ : Val.inject f v tv) : eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eunop op x) tv.","proofString":"econstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"exploit IHeval_expr1; eauto.\nintros [tv1 [EVAL1 INJ1]].\nexploit IHeval_expr2; eauto.\nintros [tv2 [EVAL2 INJ2]].\nexploit eval_binop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) : (exists tv : val,\n   eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv /\\ Val.inject f v1 tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv1 [EVAL1 INJ1]].\nexploit IHeval_expr2; eauto.\nintros [tv2 [EVAL2 INJ2]].\nexploit eval_binop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"exploit IHeval_expr2; eauto.\nintros [tv2 [EVAL2 INJ2]].\nexploit eval_binop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : (exists tv : val,\n   eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv /\\ Val.inject f v2 tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv2 [EVAL2 INJ2]].\nexploit eval_binop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv2 : val) (EVAL2 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (INJ2 : Val.inject f v2 tv2) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"exploit eval_binop_compat; eauto.\nintros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v2 tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv2 : val) (EVAL2 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (INJ2 : Val.inject f v2 tv2) : (exists tv : val, eval_binop op tv1 tv2 tm = Some tv /\\ Val.inject f v tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv [EVAL INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v2 tv0) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv2 : val) (EVAL2 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (INJ2 : Val.inject f v2 tv2) (tv : val) (EVAL : eval_binop op tv1 tv2 tm = Some tv) (INJ : Val.inject f v tv) : exists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv0 /\\\n  Val.inject f v tv0.","proofString":"exists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v2 tv0) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv2 : val) (EVAL2 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (INJ2 : Val.inject f v2 tv2) (tv : val) (EVAL : eval_binop op tv1 tv2 tm = Some tv) (INJ : Val.inject f v tv) : eval_expr tge (Vptr sp Ptrofs.zero) te tm (Ebinop op x x0) tv.","proofString":"econstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (op : binary_operation) (a1 a2 : Csharpminor.expr) (v1 v2 v : val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_expr ge e le m a2 v2) (H1 : Csharpminor.eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall ta : expr,\ntransl_expr cenv a1 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (IHeval_expr2 : forall ta : expr,\ntransl_expr cenv a2 = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v2 tv0) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : expr) (EQ1 : transl_expr cenv a2 = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv2 : val) (EVAL2 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (INJ2 : Val.inject f v2 tv2) (tv : val) (EVAL : eval_binop op tv1 tv2 tm = Some tv) (INJ : Val.inject f v tv) : Val.inject f v tv.","proofString":"auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a = OK x) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv /\\\n  Val.inject f v tv.","proofString":"exploit IHeval_expr; eauto.\nintros [tv1 [EVAL1 INJ1]].\nexploit Mem.loadv_inject; eauto.\nintros [tv [LOAD INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a = OK x) : (exists tv : val,\n   eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv /\\ Val.inject f v1 tv) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv1 [EVAL1 INJ1]].\nexploit Mem.loadv_inject; eauto.\nintros [tv [LOAD INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : exists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv /\\\n  Val.inject f v tv.","proofString":"exploit Mem.loadv_inject; eauto.\nintros [tv [LOAD INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv /\\ Val.inject f v1 tv) (x : expr) (EQ : transl_expr cenv a = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) : (exists v2 : val, Mem.loadv chunk tm tv1 = Some v2 /\\ Val.inject f v v2) ->\nexists tv : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv /\\\n  Val.inject f v tv.","proofString":"intros [tv [LOAD INJ]].\nexists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (x : expr) (EQ : transl_expr cenv a = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv : val) (LOAD : Mem.loadv chunk tm tv1 = Some tv) (INJ : Val.inject f v tv) : exists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv0 /\\\n  Val.inject f v tv0.","proofString":"exists tv; split.\neconstructor; eauto.\nauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (x : expr) (EQ : transl_expr cenv a = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv : val) (LOAD : Mem.loadv chunk tm tv1 = Some tv) (INJ : Val.inject f v tv) : eval_expr tge (Vptr sp Ptrofs.zero) te tm (Eload chunk x) tv.","proofString":"econstructor; eauto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (chunk : memory_chunk) (a : Csharpminor.expr) (v1 v : val) (H : Csharpminor.eval_expr ge e le m a v1) (H0 : Mem.loadv chunk m v1 = Some v) (IHeval_expr : forall ta : expr,\ntransl_expr cenv a = OK ta ->\nexists tv0 : val,\n  eval_expr tge (Vptr sp Ptrofs.zero) te tm ta tv0 /\\ Val.inject f v1 tv0) (x : expr) (EQ : transl_expr cenv a = OK x) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (INJ1 : Val.inject f v1 tv1) (tv : val) (LOAD : Mem.loadv chunk tm tv1 = Some tv) (INJ : Val.inject f v tv) : Val.inject f v tv.","proofString":"auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) : exists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm nil tv /\\\n  Val.inject_list f nil tv.","proofString":"exists (@nil val); split.\nconstructor.\nconstructor."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) : eval_exprlist tge (Vptr sp Ptrofs.zero) te tm nil nil.","proofString":"constructor."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) : Val.inject_list f nil nil.","proofString":"constructor."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) : exists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) tv /\\\n  Val.inject_list f (v1 :: vl) tv.","proofString":"exploit transl_expr_correct; eauto.\nintros [tv1 [EVAL1 VINJ1]].\nexploit IHeval_exprlist; eauto.\nintros [tv2 [EVAL2 VINJ2]].\nexists (tv1 :: tv2); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) : (exists tv : val,\n   eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv /\\ Val.inject f v1 tv) ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) tv /\\\n  Val.inject_list f (v1 :: vl) tv.","proofString":"intros [tv1 [EVAL1 VINJ1]].\nexploit IHeval_exprlist; eauto.\nintros [tv2 [EVAL2 VINJ2]].\nexists (tv1 :: tv2); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (VINJ1 : Val.inject f v1 tv1) : exists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) tv /\\\n  Val.inject_list f (v1 :: vl) tv.","proofString":"exploit IHeval_exprlist; eauto.\nintros [tv2 [EVAL2 VINJ2]].\nexists (tv1 :: tv2); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (VINJ1 : Val.inject f v1 tv1) : (exists tv : list val,\n   eval_exprlist tge (Vptr sp Ptrofs.zero) te tm x0 tv /\\\n   Val.inject_list f vl tv) ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) tv /\\\n  Val.inject_list f (v1 :: vl) tv.","proofString":"intros [tv2 [EVAL2 VINJ2]].\nexists (tv1 :: tv2); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (VINJ1 : Val.inject f v1 tv1) (tv2 : list val) (EVAL2 : eval_exprlist tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (VINJ2 : Val.inject_list f vl tv2) : exists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) tv /\\\n  Val.inject_list f (v1 :: vl) tv.","proofString":"exists (tv1 :: tv2); split.\nconstructor; auto.\nconstructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (VINJ1 : Val.inject f v1 tv1) (tv2 : list val) (EVAL2 : eval_exprlist tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (VINJ2 : Val.inject_list f vl tv2) : eval_exprlist tge (Vptr sp Ptrofs.zero) te tm (x :: x0) (tv1 :: tv2).","proofString":"constructor; auto."},{"statement":"(f : meminj) (m tm : mem) (cenv : compilenv) (tf : function) (e : Csharpminor.env) (le : temp_env) (te : env) (sp lo hi : block) (cs : list frame) (MINJ : Mem.inject f m tm) (MATCH : match_callstack f m tm (Frame cenv tf e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (a1 : Csharpminor.expr) (al : list Csharpminor.expr) (v1 : val) (vl : list val) (H : Csharpminor.eval_expr ge e le m a1 v1) (H0 : Csharpminor.eval_exprlist ge e le m al vl) (IHeval_exprlist : forall ta : list expr,\ntransl_exprlist cenv al = OK ta ->\nexists tv : list val,\n  eval_exprlist tge (Vptr sp Ptrofs.zero) te tm ta tv /\\\n  Val.inject_list f vl tv) (x : expr) (EQ : transl_expr cenv a1 = OK x) (x0 : list expr) (EQ1 : transl_exprlist cenv al = OK x0) (tv1 : val) (EVAL1 : eval_expr tge (Vptr sp Ptrofs.zero) te tm x tv1) (VINJ1 : Val.inject f v1 tv1) (tv2 : list val) (EVAL2 : eval_exprlist tge (Vptr sp Ptrofs.zero) te tm x0 tv2) (VINJ2 : Val.inject_list f vl tv2) : Val.inject_list f (v1 :: vl) (tv1 :: tv2).","proofString":"constructor; auto."},{"statement":"(bound : block) (v : val) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (H : Genv.find_funct ge v = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f v tv) : tv = v.","proofString":"exploit Genv.find_funct_inv; eauto.\nintros [b EQ].\nsubst v.\nrewrite Genv.find_funct_find_funct_ptr in H.\nassert (f b = Some(b, 0)).\ninv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto.\ninv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (v : val) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (H : Genv.find_funct ge v = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f v tv) : (exists b : block, v = Vptr b Ptrofs.zero) -> tv = v.","proofString":"intros [b EQ].\nsubst v.\nrewrite Genv.find_funct_find_funct_ptr in H.\nassert (f b = Some(b, 0)).\ninv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto.\ninv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (v : val) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (H : Genv.find_funct ge v = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f v tv) (b : block) (EQ : v = Vptr b Ptrofs.zero) : tv = v.","proofString":"subst v.\nrewrite Genv.find_funct_find_funct_ptr in H.\nassert (f b = Some(b, 0)).\ninv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto.\ninv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct ge (Vptr b Ptrofs.zero) = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) : tv = Vptr b Ptrofs.zero.","proofString":"rewrite Genv.find_funct_find_funct_ptr in H.\nassert (f b = Some(b, 0)).\ninv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto.\ninv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) : tv = Vptr b Ptrofs.zero.","proofString":"assert (f b = Some(b, 0)).\ninv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto.\ninv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) : f b = Some (b, 0).","proofString":"inv H0.\napply DOMAIN.\neapply FUNCTIONS; eauto."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : f b = Some (b, 0).","proofString":"apply DOMAIN.\neapply FUNCTIONS; eauto."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) (DOMAIN : forall b0 : positive, Plt b0 bound -> f b0 = Some (b0, 0)) (IMAGE : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) -> Plt b2 bound -> b1 = b2) (SYMBOLS : forall (id : ident) (b0 : block),\nGenv.find_symbol ge id = Some b0 -> Plt b0 bound) (FUNCTIONS : forall (b0 : block) (fd0 : Csharpminor.fundef),\nGenv.find_funct_ptr ge b0 = Some fd0 -> Plt b0 bound) (VARINFOS : forall (b0 : block) (gv : globvar unit),\nGenv.find_var_info ge b0 = Some gv -> Plt b0 bound) : Plt b bound.","proofString":"eapply FUNCTIONS; eauto."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (tv : val) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : match_globalenvs f bound) (H1 : Val.inject f (Vptr b Ptrofs.zero) tv) (H2 : f b = Some (b, 0)) : tv = Vptr b Ptrofs.zero.","proofString":"inv H1.\nrewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (b : block) (H : Genv.find_funct_ptr ge b = Some fd) (H0 : match_globalenvs f bound) (H2 : f b = Some (b, 0)) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr delta)) = Vptr b Ptrofs.zero.","proofString":"rewrite H2 in H5; inv H5.\nreflexivity."},{"statement":"(bound : block) (fd : Csharpminor.fundef) (f : meminj) (b2 : block) (H : Genv.find_funct_ptr ge b2 = Some fd) (H0 : match_globalenvs f bound) (H2 : f b2 = Some (b2, 0)) : Vptr b2 (Ptrofs.add Ptrofs.zero (Ptrofs.repr 0)) = Vptr b2 Ptrofs.zero.","proofString":"reflexivity."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (cenv : compilenv) (xenv : exit_env) (H : True) : exists tk' : cont,\n  star step tge (State tfn Sskip Kstop sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont Csharpminor.Kstop tk' cenv nil nil.","proofString":"econstructor; split.\napply star_refl.\nsplit.\nexact I.\neconstructor; eauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (cenv : compilenv) (xenv : exit_env) (H : True) : is_call_cont Kstop.","proofString":"exact I."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (cenv : compilenv) (xenv : exit_env) (H : True) : match_cont Csharpminor.Kstop Kstop cenv nil nil.","proofString":"econstructor; eauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (k : Csharpminor.cont) (tk : cont) (cenv : compilenv) (xenv : exit_env) (cs : callstack) (H : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk' : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs) (H0 : Csharpminor.is_call_cont k) : exists tk' : cont,\n  star step tge (State tfn Sskip (Kblock tk) sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs.","proofString":"exploit IHmatch_cont; eauto.\nintros [tk' [A B]].\nexists tk'; split.\neapply star_left; eauto.\nconstructor.\ntraceEq.\nauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (k : Csharpminor.cont) (tk : cont) (cenv : compilenv) (xenv : exit_env) (cs : callstack) (H : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk' : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs) (H0 : Csharpminor.is_call_cont k) : (exists tk' : cont,\n   star step tge (State tfn Sskip tk sp te tm) E0\n     (State tfn Sskip tk' sp te tm) /\\\n   is_call_cont tk' /\\ match_cont k tk' cenv nil cs) ->\nexists tk' : cont,\n  star step tge (State tfn Sskip (Kblock tk) sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs.","proofString":"intros [tk' [A B]].\nexists tk'; split.\neapply star_left; eauto.\nconstructor.\ntraceEq.\nauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (k : Csharpminor.cont) (tk : cont) (cenv : compilenv) (xenv : exit_env) (cs : callstack) (H : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk'0 : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk'0 sp te tm) /\\\n  is_call_cont tk'0 /\\ match_cont k tk'0 cenv nil cs) (H0 : Csharpminor.is_call_cont k) (tk' : cont) (A : star step tge (State tfn Sskip tk sp te tm) E0 (State tfn Sskip tk' sp te tm)) (B : is_call_cont tk' /\\ match_cont k tk' cenv nil cs) : exists tk'0 : cont,\n  star step tge (State tfn Sskip (Kblock tk) sp te tm) E0\n    (State tfn Sskip tk'0 sp te tm) /\\\n  is_call_cont tk'0 /\\ match_cont k tk'0 cenv nil cs.","proofString":"exists tk'; split.\neapply star_left; eauto.\nconstructor.\ntraceEq.\nauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (k : Csharpminor.cont) (tk : cont) (cenv : compilenv) (xenv : exit_env) (cs : callstack) (H : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk'0 : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk'0 sp te tm) /\\\n  is_call_cont tk'0 /\\ match_cont k tk'0 cenv nil cs) (H0 : Csharpminor.is_call_cont k) (tk' : cont) (A : star step tge (State tfn Sskip tk sp te tm) E0 (State tfn Sskip tk' sp te tm)) (B : is_call_cont tk' /\\ match_cont k tk' cenv nil cs) : star step tge (State tfn Sskip (Kblock tk) sp te tm) E0\n  (State tfn Sskip tk' sp te tm).","proofString":"eapply star_left; eauto.\nconstructor.\ntraceEq."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (k : Csharpminor.cont) (tk : cont) (cenv : compilenv) (xenv : exit_env) (cs : callstack) (H : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk'0 : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk'0 sp te tm) /\\\n  is_call_cont tk'0 /\\ match_cont k tk'0 cenv nil cs) (H0 : Csharpminor.is_call_cont k) (tk' : cont) (A : star step tge (State tfn Sskip tk sp te tm) E0 (State tfn Sskip tk' sp te tm)) (B : is_call_cont tk' /\\ match_cont k tk' cenv nil cs) : is_call_cont tk' /\\ match_cont k tk' cenv nil cs.","proofString":"auto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (optid : option ident) (fn : Csharpminor.function) (e : Csharpminor.env) (le : temp_env) (k : Csharpminor.cont) (tfn0 : function) (sp0 : block) (te0 : env) (tk : cont) (cenv : compilenv) (xenv : exit_env) (lo hi : block) (cs : callstack) (sz : Z) (cenv' : compilenv) (H : transl_funbody cenv sz fn = OK tfn0) (H0 : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk' : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs) (H1 : True) : exists tk' : cont,\n  star step tge\n    (State tfn Sskip (Kcall optid tfn0 (Vptr sp0 Ptrofs.zero) te0 tk) sp te\n       tm) E0 (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\\n  match_cont (Csharpminor.Kcall optid fn e le k) tk' cenv' nil\n    (Frame cenv tfn0 e le te0 sp0 lo hi :: cs).","proofString":"econstructor; split.\napply star_refl.\nsplit.\nexact I.\neconstructor; eauto."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (optid : option ident) (fn : Csharpminor.function) (e : Csharpminor.env) (le : temp_env) (k : Csharpminor.cont) (tfn0 : function) (sp0 : block) (te0 : env) (tk : cont) (cenv : compilenv) (xenv : exit_env) (lo hi : block) (cs : callstack) (sz : Z) (cenv' : compilenv) (H : transl_funbody cenv sz fn = OK tfn0) (H0 : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk' : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs) (H1 : True) : is_call_cont (Kcall optid tfn0 (Vptr sp0 Ptrofs.zero) te0 tk).","proofString":"exact I."},{"statement":"(tfn : function) (te : env) (sp : val) (tm : mem) (optid : option ident) (fn : Csharpminor.function) (e : Csharpminor.env) (le : temp_env) (k : Csharpminor.cont) (tfn0 : function) (sp0 : block) (te0 : env) (tk : cont) (cenv : compilenv) (xenv : exit_env) (lo hi : block) (cs : callstack) (sz : Z) (cenv' : compilenv) (H : transl_funbody cenv sz fn = OK tfn0) (H0 : match_cont k tk cenv xenv cs) (IHmatch_cont : Csharpminor.is_call_cont k ->\nexists tk' : cont,\n  star step tge (State tfn Sskip tk sp te tm) E0\n    (State tfn Sskip tk' sp te tm) /\\\n  is_call_cont tk' /\\ match_cont k tk' cenv nil cs) (H1 : True) : match_cont (Csharpminor.Kcall optid fn e le k)\n  (Kcall optid tfn0 (Vptr sp0 Ptrofs.zero) te0 tk) cenv' nil\n  (Frame cenv tfn0 e le te0 sp0 lo hi :: cs).","proofString":"econstructor; eauto."},{"statement":"(base : nat) : exists n : nat, lbl_stmt_tail LSnil n LSnil /\\ base = (n + base)%nat.","proofString":"exists O; split.\nconstructor.\nlia."},{"statement":"(base : nat) : lbl_stmt_tail LSnil 0 LSnil.","proofString":"constructor."},{"statement":"(base : nat) : base = (0 + base)%nat.","proofString":"lia."},{"statement":"(o : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) : exists n : nat,\n  lbl_stmt_tail (LScons o s sl) n\n    match o with\n    | Some _ => select_switch_default sl\n    | None => LScons o s sl\n    end /\\\n  snd\n    match o with\n    | Some ni =>\n        let (tbl, dfl) := switch_table sl (S base) in\n        ((ni, base) :: tbl, dfl)\n    | None => let (tbl, _) := switch_table sl (S base) in (tbl, base)\n    end = (n + base)%nat.","proofString":"destruct o.\ndestruct (IHsl (S base)) as (n & P & Q).\nexists (S n); split.\nconstructor; auto.\ndestruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nlia.\nexists O; split.\nconstructor.\ndestruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nauto."},{"statement":"(z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) : exists n : nat,\n  lbl_stmt_tail (LScons (Some z) s sl) n (select_switch_default sl) /\\\n  snd (let (tbl, dfl) := switch_table sl (S base) in ((z, base) :: tbl, dfl)) =\n  (n + base)%nat.","proofString":"destruct (IHsl (S base)) as (n & P & Q).\nexists (S n); split.\nconstructor; auto.\ndestruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nlia."},{"statement":"(z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n0 : nat,\n  lbl_stmt_tail sl n0 (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n0 + base0)%nat) (base n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (Q : snd (switch_table sl (S base)) = (n + S base)%nat) : exists n0 : nat,\n  lbl_stmt_tail (LScons (Some z) s sl) n0 (select_switch_default sl) /\\\n  snd (let (tbl, dfl) := switch_table sl (S base) in ((z, base) :: tbl, dfl)) =\n  (n0 + base)%nat.","proofString":"exists (S n); split.\nconstructor; auto.\ndestruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nlia."},{"statement":"(z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n0 : nat,\n  lbl_stmt_tail sl n0 (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n0 + base0)%nat) (base n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (Q : snd (switch_table sl (S base)) = (n + S base)%nat) : lbl_stmt_tail (LScons (Some z) s sl) (S n) (select_switch_default sl).","proofString":"constructor; auto."},{"statement":"(z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n0 : nat,\n  lbl_stmt_tail sl n0 (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n0 + base0)%nat) (base n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (Q : snd (switch_table sl (S base)) = (n + S base)%nat) : snd (let (tbl, dfl) := switch_table sl (S base) in ((z, base) :: tbl, dfl)) =\n(S n + base)%nat.","proofString":"destruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nlia."},{"statement":"(z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n0 : nat,\n  lbl_stmt_tail sl n0 (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n0 + base0)%nat) (base n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (tbl : list (Z * nat)) (dfl : nat) (Q : dfl = (n + S base)%nat) : dfl = S (n + base).","proofString":"lia."},{"statement":"(s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) : exists n : nat,\n  lbl_stmt_tail (LScons None s sl) n (LScons None s sl) /\\\n  snd (let (tbl, _) := switch_table sl (S base) in (tbl, base)) =\n  (n + base)%nat.","proofString":"exists O; split.\nconstructor.\ndestruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nauto."},{"statement":"(s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) : lbl_stmt_tail (LScons None s sl) 0 (LScons None s sl).","proofString":"constructor."},{"statement":"(s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) : snd (let (tbl, _) := switch_table sl (S base) in (tbl, base)) =\n(0 + base)%nat.","proofString":"destruct (switch_table sl (S base)) as [tbl dfl]; simpl in *.\nauto."},{"statement":"(s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 : nat,\nexists n : nat,\n  lbl_stmt_tail sl n (select_switch_default sl) /\\\n  snd (switch_table sl base0) = (n + base0)%nat) (base : nat) (tbl : list (Z * nat)) (dfl : nat) : base = base.","proofString":"auto."},{"statement":"(i : Z) (base dfl : nat) : dfl = dfl.","proofString":"auto."},{"statement":"(i : Z) (o : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) : match\n  match o with\n  | Some c =>\n      if zeq c i then Some (LScons o s sl) else select_switch_case i sl\n  | None => select_switch_case i sl\n  end\nwith\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons o s sl) n sl' /\\\n      switch_target i dfl\n        (fst\n           match o with\n           | Some ni =>\n               let (tbl, dfl0) := switch_table sl (S base) in\n               ((ni, base) :: tbl, dfl0)\n           | None => let (tbl, _) := switch_table sl (S base) in (tbl, base)\n           end) = (n + base)%nat\n| None =>\n    switch_target i dfl\n      (fst\n         match o with\n         | Some ni =>\n             let (tbl, dfl0) := switch_table sl (S base) in\n             ((ni, base) :: tbl, dfl0)\n         | None => let (tbl, _) := switch_table sl (S base) in (tbl, base)\n         end) = dfl\nend.","proofString":"destruct (switch_table sl (S base)) as [tbl1 dfl1] eqn:ST.\ndestruct o; simpl.\nrewrite dec_eq_sym.\ndestruct (zeq i z).\nexists O; split; auto.\nconstructor.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i : Z) (o : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match\n  match o with\n  | Some c =>\n      if zeq c i then Some (LScons o s sl) else select_switch_case i sl\n  | None => select_switch_case i sl\n  end\nwith\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons o s sl) n sl' /\\\n      switch_target i dfl\n        (fst\n           match o with\n           | Some ni => ((ni, base) :: tbl1, dfl1)\n           | None => (tbl1, base)\n           end) = (n + base)%nat\n| None =>\n    switch_target i dfl\n      (fst\n         match o with\n         | Some ni => ((ni, base) :: tbl1, dfl1)\n         | None => (tbl1, base)\n         end) = dfl\nend.","proofString":"destruct o; simpl.\nrewrite dec_eq_sym.\ndestruct (zeq i z).\nexists O; split; auto.\nconstructor.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match\n  (if zeq z i then Some (LScons (Some z) s sl) else select_switch_case i sl)\nwith\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n sl' /\\\n      (if zeq i z then base else switch_target i dfl tbl1) = (n + base)%nat\n| None => (if zeq i z then base else switch_target i dfl tbl1) = dfl\nend.","proofString":"rewrite dec_eq_sym.\ndestruct (zeq i z).\nexists O; split; auto.\nconstructor.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match\n  (if zeq i z then Some (LScons (Some z) s sl) else select_switch_case i sl)\nwith\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n sl' /\\\n      (if zeq i z then base else switch_target i dfl tbl1) = (n + base)%nat\n| None => (if zeq i z then base else switch_target i dfl tbl1) = dfl\nend.","proofString":"destruct (zeq i z).\nexists O; split; auto.\nconstructor.\nspecialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (e : i = z) : exists n : nat,\n  lbl_stmt_tail (LScons (Some z) s sl) n (LScons (Some z) s sl) /\\\n  base = (n + base)%nat.","proofString":"exists O; split; auto.\nconstructor."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (e : i = z) : lbl_stmt_tail (LScons (Some z) s sl) 0 (LScons (Some z) s sl).","proofString":"constructor."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail sl n0 sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n0 + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n0 sl' /\\\n      switch_target i dfl tbl1 = (n0 + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"specialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail sl n0 sl' /\\\n      switch_target i dfl (fst (switch_table sl (S base))) =\n      (n0 + S base)%nat\n| None => switch_target i dfl (fst (switch_table sl (S base))) = dfl\nend) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n0 sl' /\\\n      switch_target i dfl tbl1 = (n0 + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"rewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail sl n0 sl' /\\\n      switch_target i dfl (fst (tbl1, dfl1)) = (n0 + S base)%nat\n| None => switch_target i dfl (fst (tbl1, dfl1)) = dfl\nend) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n0 sl' /\\\n      switch_target i dfl tbl1 = (n0 + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"simpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail sl n0 sl' /\\ switch_target i dfl tbl1 = (n0 + S base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : match select_switch_case i sl with\n| Some sl' =>\n    exists n0 : nat,\n      lbl_stmt_tail (LScons (Some z) s sl) n0 sl' /\\\n      switch_target i dfl tbl1 = (n0 + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"destruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (IHsl : exists n0 : nat,\n  lbl_stmt_tail sl n0 l /\\ switch_target i dfl tbl1 = (n0 + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : exists n0 : nat,\n  lbl_stmt_tail (LScons (Some z) s sl) n0 l /\\\n  switch_target i dfl tbl1 = (n0 + base)%nat.","proofString":"destruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : exists n0 : nat,\n  lbl_stmt_tail (LScons (Some z) s sl) n0 l /\\\n  switch_target i dfl tbl1 = (n0 + base)%nat.","proofString":"exists (S x); split.\nconstructor; auto.\nlia."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : lbl_stmt_tail (LScons (Some z) s sl) (S x) l.","proofString":"constructor; auto."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : switch_target i dfl tbl1 = (S x + base)%nat.","proofString":"lia."},{"statement":"(i z : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : switch_target i dfl tbl1 = dfl) (ST : switch_table sl (S base) = (tbl1, dfl1)) (n : i <> z) : switch_target i dfl tbl1 = dfl.","proofString":"auto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (IHsl : forall base0 dfl0 : nat,\nmatch select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl0 (fst (switch_table sl base0)) = (n + base0)%nat\n| None => switch_target i dfl0 (fst (switch_table sl base0)) = dfl0\nend) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons None s sl) n sl' /\\\n      switch_target i dfl tbl1 = (n + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"specialize (IHsl (S base) dfl).\nrewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl (fst (switch_table sl (S base))) = (n + S base)%nat\n| None => switch_target i dfl (fst (switch_table sl (S base))) = dfl\nend) (tbl1 : list (Z * nat)) (dfl1 : nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons None s sl) n sl' /\\\n      switch_target i dfl tbl1 = (n + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"rewrite ST in IHsl.\nsimpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i dfl (fst (tbl1, dfl1)) = (n + S base)%nat\n| None => switch_target i dfl (fst (tbl1, dfl1)) = dfl\nend) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons None s sl) n sl' /\\\n      switch_target i dfl tbl1 = (n + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"simpl in *.\ndestruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\ switch_target i dfl tbl1 = (n + S base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend) (ST : switch_table sl (S base) = (tbl1, dfl1)) : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail (LScons None s sl) n sl' /\\\n      switch_target i dfl tbl1 = (n + base)%nat\n| None => switch_target i dfl tbl1 = dfl\nend.","proofString":"destruct (select_switch_case i sl).\ndestruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia.\nauto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (IHsl : exists n : nat,\n  lbl_stmt_tail sl n l /\\ switch_target i dfl tbl1 = (n + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : exists n : nat,\n  lbl_stmt_tail (LScons None s sl) n l /\\\n  switch_target i dfl tbl1 = (n + base)%nat.","proofString":"destruct IHsl as (x & P & Q).\nexists (S x); split.\nconstructor; auto.\nlia."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : exists n : nat,\n  lbl_stmt_tail (LScons None s sl) n l /\\\n  switch_target i dfl tbl1 = (n + base)%nat.","proofString":"exists (S x); split.\nconstructor; auto.\nlia."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : lbl_stmt_tail (LScons None s sl) (S x) l.","proofString":"constructor; auto."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (l : lbl_stmt) (x : nat) (P : lbl_stmt_tail sl x l) (Q : switch_target i dfl tbl1 = (x + S base)%nat) (ST : switch_table sl (S base) = (tbl1, dfl1)) : switch_target i dfl tbl1 = (S x + base)%nat.","proofString":"lia."},{"statement":"(i : Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (base dfl : nat) (tbl1 : list (Z * nat)) (dfl1 : nat) (IHsl : switch_target i dfl tbl1 = dfl) (ST : switch_table sl (S base) = (tbl1, dfl1)) : switch_target i dfl tbl1 = dfl.","proofString":"auto."},{"statement":"(i : Z) (sl : lbl_stmt) : lbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)))\n  match select_switch_case i sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end.","proofString":"generalize (switch_table_case i sl O (snd (switch_table sl O))).\ndestruct (select_switch_case i sl) as [sl'|].\nintros (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence.\nintros E; rewrite E.\ndestruct (switch_table_default sl O) as (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl : lbl_stmt) : match select_switch_case i sl with\n| Some sl' =>\n    exists n : nat,\n      lbl_stmt_tail sl n sl' /\\\n      switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\n      (n + 0)%nat\n| None =>\n    switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\n    snd (switch_table sl 0)\nend ->\nlbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)))\n  match select_switch_case i sl with\n  | Some sl' => sl'\n  | None => select_switch_default sl\n  end.","proofString":"destruct (select_switch_case i sl) as [sl'|].\nintros (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence.\nintros E; rewrite E.\ndestruct (switch_table_default sl O) as (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl sl' : lbl_stmt) : (exists n : nat,\n   lbl_stmt_tail sl n sl' /\\\n   switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\n   (n + 0)%nat) ->\nlbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0))) sl'.","proofString":"intros (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl sl' : lbl_stmt) (n : nat) (P : lbl_stmt_tail sl n sl') (Q : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\n(n + 0)%nat) : lbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0))) sl'.","proofString":"replace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl sl' : lbl_stmt) (n : nat) (P : lbl_stmt_tail sl n sl') (Q : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) = n) : lbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0))) sl'.","proofString":"congruence."},{"statement":"(i : Z) (sl : lbl_stmt) : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\nsnd (switch_table sl 0) ->\nlbl_stmt_tail sl\n  (switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)))\n  (select_switch_default sl).","proofString":"intros E; rewrite E.\ndestruct (switch_table_default sl O) as (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl : lbl_stmt) (E : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\nsnd (switch_table sl 0)) : lbl_stmt_tail sl (snd (switch_table sl 0)) (select_switch_default sl).","proofString":"destruct (switch_table_default sl O) as (n & P & Q).\nreplace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl : lbl_stmt) (E : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\nsnd (switch_table sl 0)) (n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (Q : snd (switch_table sl 0) = (n + 0)%nat) : lbl_stmt_tail sl (snd (switch_table sl 0)) (select_switch_default sl).","proofString":"replace (n + O)%nat with n in Q by lia.\ncongruence."},{"statement":"(i : Z) (sl : lbl_stmt) (E : switch_target i (snd (switch_table sl 0)) (fst (switch_table sl 0)) =\nsnd (switch_table sl 0)) (n : nat) (P : lbl_stmt_tail sl n (select_switch_default sl)) (Q : snd (switch_table sl 0) = n) : lbl_stmt_tail sl (snd (switch_table sl 0)) (select_switch_default sl).","proofString":"congruence."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (body s : stmt) (H : transl_lblstmt cenv (switch_env LSnil xenv) LSnil body = OK s) : exists k' : cont,\n  transl_lblstmt_cont cenv xenv LSnil k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s k sp e m) E0 (State f body k' sp e m)).","proofString":"monadInv H.\neconstructor; split.\neconstructor.\nintros.\neapply plus_two.\nconstructor.\nconstructor.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (body : stmt) : exists k' : cont,\n  transl_lblstmt_cont cenv xenv LSnil k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f (Sseq (Sblock body) Sskip) k sp e m) E0\n     (State f body k' sp e m)).","proofString":"econstructor; split.\neconstructor.\nintros.\neapply plus_two.\nconstructor.\nconstructor.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (body : stmt) (f : function) (sp : val) (e : env) (m : mem) : plus step tge (State f (Sseq (Sblock body) Sskip) k sp e m) E0\n  (State f body (Kblock (Kseq Sskip k)) sp e m).","proofString":"eapply plus_two.\nconstructor.\nconstructor.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall body0 s1 : stmt,\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK s1 ->\nexists k' : cont,\n  transl_lblstmt_cont cenv xenv ls k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s1 k sp e m) E0 (State f body0 k' sp e m))) (body s0 : stmt) (H : transl_lblstmt cenv (switch_env (LScons o s ls) xenv) (LScons o s ls) body =\nOK s0) : exists k' : cont,\n  transl_lblstmt_cont cenv xenv (LScons o s ls) k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s0 k sp e m) E0 (State f body k' sp e m)).","proofString":"monadInv H.\nexploit IHls; eauto.\nintros [k' [A B]].\neconstructor; split.\neconstructor; eauto.\nintros.\neapply plus_star_trans.\neauto.\neapply star_left.\nconstructor.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall body0 s1 : stmt,\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK s1 ->\nexists k' : cont,\n  transl_lblstmt_cont cenv xenv ls k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s1 k sp e m) E0 (State f body0 k' sp e m))) (body s0 x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK s0) : exists k' : cont,\n  transl_lblstmt_cont cenv xenv (LScons o s ls) k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s0 k sp e m) E0 (State f body k' sp e m)).","proofString":"exploit IHls; eauto.\nintros [k' [A B]].\neconstructor; split.\neconstructor; eauto.\nintros.\neapply plus_star_trans.\neauto.\neapply star_left.\nconstructor.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall body0 s1 : stmt,\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK s1 ->\nexists k' : cont,\n  transl_lblstmt_cont cenv xenv ls k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s1 k sp e m) E0 (State f body0 k' sp e m))) (body s0 x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK s0) : (exists k' : cont,\n   transl_lblstmt_cont cenv xenv ls k k' /\\\n   (forall (f : function) (sp : val) (e : env) (m : mem),\n    plus step tge (State f s0 k sp e m) E0\n      (State f (Sseq (Sblock body) x) k' sp e m))) ->\nexists k' : cont,\n  transl_lblstmt_cont cenv xenv (LScons o s ls) k k' /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s0 k sp e m) E0 (State f body k' sp e m)).","proofString":"intros [k' [A B]].\neconstructor; split.\neconstructor; eauto.\nintros.\neapply plus_star_trans.\neauto.\neapply star_left.\nconstructor.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall body0 s1 : stmt,\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK s1 ->\nexists k'0 : cont,\n  transl_lblstmt_cont cenv xenv ls k k'0 /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s1 k sp e m) E0 (State f body0 k'0 sp e m))) (body s0 x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK s0) (k' : cont) (A : transl_lblstmt_cont cenv xenv ls k k') (B : forall (f : function) (sp : val) (e : env) (m : mem),\nplus step tge (State f s0 k sp e m) E0\n  (State f (Sseq (Sblock body) x) k' sp e m)) : exists k'0 : cont,\n  transl_lblstmt_cont cenv xenv (LScons o s ls) k k'0 /\\\n  (forall (f : function) (sp : val) (e : env) (m : mem),\n   plus step tge (State f s0 k sp e m) E0 (State f body k'0 sp e m)).","proofString":"econstructor; split.\neconstructor; eauto.\nintros.\neapply plus_star_trans.\neauto.\neapply star_left.\nconstructor.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall body0 s1 : stmt,\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK s1 ->\nexists k'0 : cont,\n  transl_lblstmt_cont cenv xenv ls k k'0 /\\\n  (forall (f0 : function) (sp0 : val) (e0 : env) (m0 : mem),\n   plus step tge (State f0 s1 k sp0 e0 m0) E0 (State f0 body0 k'0 sp0 e0 m0))) (body s0 x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK s0) (k' : cont) (A : transl_lblstmt_cont cenv xenv ls k k') (B : forall (f0 : function) (sp0 : val) (e0 : env) (m0 : mem),\nplus step tge (State f0 s0 k sp0 e0 m0) E0\n  (State f0 (Sseq (Sblock body) x) k' sp0 e0 m0)) (f : function) (sp : val) (e : env) (m : mem) : plus step tge (State f s0 k sp e m) E0\n  (State f body (Kblock (Kseq x k')) sp e m).","proofString":"eapply plus_star_trans.\neauto.\neapply star_left.\nconstructor.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (sl : lbl_stmt) (k k1 : cont) (H : transl_lblstmt_cont cenv xenv sl k k1) : exists k2 : cont,\n  star step tge (State f (Sexit 0) k1 sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl k k2.","proofString":"exists k1; split; auto.\napply star_refl."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (sl : lbl_stmt) (k k1 : cont) (H : transl_lblstmt_cont cenv xenv sl k k1) : star step tge (State f (Sexit 0) k1 sp e m) E0 (State f (Sexit 0) k1 sp e m).","proofString":"apply star_refl."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall k0 k2 : cont,\ntransl_lblstmt_cont cenv xenv sl k0 k2 ->\nexists k3 : cont,\n  star step tge (State f (Sexit n) k2 sp e m) E0\n    (State f (Sexit 0) k3 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k0 k3) (k k1 : cont) (H0 : transl_lblstmt_cont cenv xenv (LScons c s sl) k k1) : exists k2 : cont,\n  star step tge (State f (Sexit (S n)) k1 sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k k2.","proofString":"inv H0.\nexploit IHlbl_stmt_tail; eauto.\nintros (k2 & P & Q).\nexists k2; split; auto.\neapply star_left.\nconstructor.\neapply star_left.\nconstructor.\neexact P.\neauto.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall k0 k1 : cont,\ntransl_lblstmt_cont cenv xenv sl k0 k1 ->\nexists k2 : cont,\n  star step tge (State f (Sexit n) k1 sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k0 k2) (k : cont) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons c s sl) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv sl k k') : exists k2 : cont,\n  star step tge (State f (Sexit (S n)) (Kblock (Kseq ts k')) sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k k2.","proofString":"exploit IHlbl_stmt_tail; eauto.\nintros (k2 & P & Q).\nexists k2; split; auto.\neapply star_left.\nconstructor.\neapply star_left.\nconstructor.\neexact P.\neauto.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall k0 k1 : cont,\ntransl_lblstmt_cont cenv xenv sl k0 k1 ->\nexists k2 : cont,\n  star step tge (State f (Sexit n) k1 sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k0 k2) (k : cont) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons c s sl) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv sl k k') : (exists k2 : cont,\n   star step tge (State f (Sexit n) k' sp e m) E0\n     (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k k2) ->\nexists k2 : cont,\n  star step tge (State f (Sexit (S n)) (Kblock (Kseq ts k')) sp e m) E0\n    (State f (Sexit 0) k2 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k k2.","proofString":"intros (k2 & P & Q).\nexists k2; split; auto.\neapply star_left.\nconstructor.\neapply star_left.\nconstructor.\neexact P.\neauto.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall k0 k1 : cont,\ntransl_lblstmt_cont cenv xenv sl k0 k1 ->\nexists k3 : cont,\n  star step tge (State f (Sexit n) k1 sp e m) E0\n    (State f (Sexit 0) k3 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k0 k3) (k : cont) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons c s sl) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv sl k k') (k2 : cont) (P : star step tge (State f (Sexit n) k' sp e m) E0 (State f (Sexit 0) k2 sp e m)) (Q : transl_lblstmt_cont cenv xenv sl' k k2) : exists k0 : cont,\n  star step tge (State f (Sexit (S n)) (Kblock (Kseq ts k')) sp e m) E0\n    (State f (Sexit 0) k0 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k k0.","proofString":"exists k2; split; auto.\neapply star_left.\nconstructor.\neapply star_left.\nconstructor.\neexact P.\neauto.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall k0 k1 : cont,\ntransl_lblstmt_cont cenv xenv sl k0 k1 ->\nexists k3 : cont,\n  star step tge (State f (Sexit n) k1 sp e m) E0\n    (State f (Sexit 0) k3 sp e m) /\\ transl_lblstmt_cont cenv xenv sl' k0 k3) (k : cont) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons c s sl) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv sl k k') (k2 : cont) (P : star step tge (State f (Sexit n) k' sp e m) E0 (State f (Sexit 0) k2 sp e m)) (Q : transl_lblstmt_cont cenv xenv sl' k k2) : star step tge (State f (Sexit (S n)) (Kblock (Kseq ts k')) sp e m) E0\n  (State f (Sexit 0) k2 sp e m).","proofString":"eapply star_left.\nconstructor.\neapply star_left.\nconstructor.\neexact P.\neauto.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk tk' : cont) (H : match_cont k tk cenv xenv cs) (H0 : transl_lblstmt_cont cenv xenv LSnil tk tk') : match_cont (Csharpminor.Kseq Csharpminor.Sskip k) tk' cenv (false :: xenv) cs.","proofString":"inv H0.\napply match_Kblock2.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (H : match_cont k tk cenv xenv cs) : match_cont (Csharpminor.Kseq Csharpminor.Sskip k) \n  (Kblock (Kseq Sskip tk)) cenv (false :: xenv) cs.","proofString":"apply match_Kblock2.\neconstructor; eauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (H : match_cont k tk cenv xenv cs) : match_cont (Csharpminor.Kseq Csharpminor.Sskip k) \n  (Kseq Sskip tk) cenv xenv cs.","proofString":"econstructor; eauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall tk'0 : cont,\nmatch_cont k tk cenv xenv cs ->\ntransl_lblstmt_cont cenv xenv ls tk tk'0 ->\nmatch_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) tk'0 cenv\n  (false :: switch_env ls xenv) cs) (tk' : cont) (H : match_cont k tk cenv xenv cs) (H0 : transl_lblstmt_cont cenv xenv (LScons o s ls) tk tk') : match_cont (Csharpminor.Kseq (Csharpminor.Sseq s (seq_of_lbl_stmt ls)) k) tk'\n  cenv (false :: false :: switch_env ls xenv) cs.","proofString":"inv H0.\napply match_Kblock2.\neapply match_Kseq2.\nauto.\neauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall tk' : cont,\nmatch_cont k tk cenv xenv cs ->\ntransl_lblstmt_cont cenv xenv ls tk tk' ->\nmatch_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) tk' cenv\n  (false :: switch_env ls xenv) cs) (H : match_cont k tk cenv xenv cs) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons o s ls) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv ls tk k') : match_cont (Csharpminor.Kseq (Csharpminor.Sseq s (seq_of_lbl_stmt ls)) k)\n  (Kblock (Kseq ts k')) cenv (false :: false :: switch_env ls xenv) cs.","proofString":"apply match_Kblock2.\neapply match_Kseq2.\nauto.\neauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall tk' : cont,\nmatch_cont k tk cenv xenv cs ->\ntransl_lblstmt_cont cenv xenv ls tk tk' ->\nmatch_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) tk' cenv\n  (false :: switch_env ls xenv) cs) (H : match_cont k tk cenv xenv cs) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons o s ls) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv ls tk k') : match_cont (Csharpminor.Kseq (Csharpminor.Sseq s (seq_of_lbl_stmt ls)) k)\n  (Kseq ts k') cenv (false :: switch_env ls xenv) cs.","proofString":"eapply match_Kseq2.\nauto.\neauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall tk' : cont,\nmatch_cont k tk cenv xenv cs ->\ntransl_lblstmt_cont cenv xenv ls tk tk' ->\nmatch_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) tk' cenv\n  (false :: switch_env ls xenv) cs) (H : match_cont k tk cenv xenv cs) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons o s ls) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv ls tk k') : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts.","proofString":"auto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (k : Csharpminor.cont) (cs : callstack) (tk : cont) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall tk' : cont,\nmatch_cont k tk cenv xenv cs ->\ntransl_lblstmt_cont cenv xenv ls tk tk' ->\nmatch_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) tk' cenv\n  (false :: switch_env ls xenv) cs) (H : match_cont k tk cenv xenv cs) (ts : stmt) (k' : cont) (H6 : transl_stmt cenv (switch_env (LScons o s ls) xenv) s = OK ts) (H7 : transl_lblstmt_cont cenv xenv ls tk k') : match_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls) k) k' cenv\n  (false :: switch_env ls xenv) cs.","proofString":"eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (ls : lbl_stmt) (body : stmt) (tk' : cont) (TRF : transl_funbody cenv sz fn = OK tfn) (TR : transl_lblstmt cenv (switch_env ls xenv) ls body = OK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) (TK : transl_lblstmt_cont cenv xenv ls tk tk') : exists S : state,\n  plus step tge (State tfn (Sexit 0) tk' (Vptr sp Ptrofs.zero) te tm) E0 S /\\\n  match_states (Csharpminor.State fn (seq_of_lbl_stmt ls) k e le m) S.","proofString":"inv TK.\neconstructor; split.\neapply plus_two.\nconstructor.\nconstructor.\nauto.\neapply match_state; eauto.\neconstructor; split.\neapply plus_left.\nconstructor.\napply star_one.\nconstructor.\nauto.\nsimpl.\neapply match_state_seq; eauto.\nsimpl.\neapply switch_match_cont; eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (body : stmt) (TRF : transl_funbody cenv sz fn = OK tfn) (TR : transl_lblstmt cenv (switch_env LSnil xenv) LSnil body = OK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) : exists S : state,\n  plus step tge\n    (State tfn (Sexit 0) (Kblock (Kseq Sskip tk)) (Vptr sp Ptrofs.zero) te tm)\n    E0 S /\\\n  match_states (Csharpminor.State fn (seq_of_lbl_stmt LSnil) k e le m) S.","proofString":"econstructor; split.\neapply plus_two.\nconstructor.\nconstructor.\nauto.\neapply match_state; eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (body : stmt) (TRF : transl_funbody cenv sz fn = OK tfn) (i : option Z) (s : Csharpminor.stmt) (ls0 : lbl_stmt) (TR : transl_lblstmt cenv (switch_env (LScons i s ls0) xenv) (LScons i s ls0) body =\nOK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) (ts0 : stmt) (k' : cont) (H : transl_stmt cenv (switch_env (LScons i s ls0) xenv) s = OK ts0) (H0 : transl_lblstmt_cont cenv xenv ls0 tk k') : exists S : state,\n  plus step tge\n    (State tfn (Sexit 0) (Kblock (Kseq ts0 k')) (Vptr sp Ptrofs.zero) te tm)\n    E0 S /\\\n  match_states\n    (Csharpminor.State fn (seq_of_lbl_stmt (LScons i s ls0)) k e le m) S.","proofString":"econstructor; split.\neapply plus_left.\nconstructor.\napply star_one.\nconstructor.\nauto.\nsimpl.\neapply match_state_seq; eauto.\nsimpl.\neapply switch_match_cont; eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (body : stmt) (TRF : transl_funbody cenv sz fn = OK tfn) (i : option Z) (s : Csharpminor.stmt) (ls0 : lbl_stmt) (TR : transl_lblstmt cenv (switch_env (LScons i s ls0) xenv) (LScons i s ls0) body =\nOK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) (ts0 : stmt) (k' : cont) (H : transl_stmt cenv (switch_env (LScons i s ls0) xenv) s = OK ts0) (H0 : transl_lblstmt_cont cenv xenv ls0 tk k') : match_states\n  (Csharpminor.State fn (Csharpminor.Sseq s (seq_of_lbl_stmt ls0)) k e le m)\n  (State tfn ts0 k' (Vptr sp Ptrofs.zero) te tm).","proofString":"eapply match_state_seq; eauto.\nsimpl.\neapply switch_match_cont; eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (body : stmt) (TRF : transl_funbody cenv sz fn = OK tfn) (i : option Z) (s : Csharpminor.stmt) (ls0 : lbl_stmt) (TR : transl_lblstmt cenv (switch_env (LScons i s ls0) xenv) (LScons i s ls0) body =\nOK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) (ts0 : stmt) (k' : cont) (H : transl_stmt cenv (switch_env (LScons i s ls0) xenv) s = OK ts0) (H0 : transl_lblstmt_cont cenv xenv ls0 tk k') : match_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls0) k) k' cenv\n  (switch_env (LScons i s ls0) xenv) cs.","proofString":"simpl.\neapply switch_match_cont; eauto."},{"statement":"(fn : Csharpminor.function) (k : Csharpminor.cont) (e : Csharpminor.env) (le : temp_env) (m : mem) (tfn : function) (ts : stmt) (tk : cont) (sp : block) (te : env) (tm : mem) (cenv : compilenv) (xenv : exit_env) (f : meminj) (lo hi : block) (cs : list frame) (sz : Z) (body : stmt) (TRF : transl_funbody cenv sz fn = OK tfn) (i : option Z) (s : Csharpminor.stmt) (ls0 : lbl_stmt) (TR : transl_lblstmt cenv (switch_env (LScons i s ls0) xenv) (LScons i s ls0) body =\nOK ts) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm (Frame cenv tfn e le te sp lo hi :: cs)\n  (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont k tk cenv xenv cs) (ts0 : stmt) (k' : cont) (H : transl_stmt cenv (switch_env (LScons i s ls0) xenv) s = OK ts0) (H0 : transl_lblstmt_cont cenv xenv ls0 tk k') : match_cont (Csharpminor.Kseq (seq_of_lbl_stmt ls0) k) k' cenv\n  (false :: switch_env ls0 xenv) cs.","proofString":"eapply switch_match_cont; eauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (sl : lbl_stmt) (body ts : stmt) (H : transl_lblstmt cenv (switch_env sl xenv) sl body = OK ts) : exists body' ts' : stmt,\n  transl_lblstmt cenv (switch_env sl xenv) sl body' = OK ts'.","proofString":"exists body, ts; auto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall body0 ts0 : stmt,\ntransl_lblstmt cenv (switch_env sl xenv) sl body0 = OK ts0 ->\nexists body' ts' : stmt,\n  transl_lblstmt cenv (switch_env sl' xenv) sl' body' = OK ts') (body ts : stmt) (H0 : transl_lblstmt cenv (switch_env (LScons c s sl) xenv) (LScons c s sl) body =\nOK ts) : exists body' ts' : stmt,\n  transl_lblstmt cenv (switch_env sl' xenv) sl' body' = OK ts'.","proofString":"monadInv H0.\neauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (c : option Z) (s : Csharpminor.stmt) (sl : lbl_stmt) (n : nat) (sl' : lbl_stmt) (H : lbl_stmt_tail sl n sl') (IHlbl_stmt_tail : forall body0 ts0 : stmt,\ntransl_lblstmt cenv (switch_env sl xenv) sl body0 = OK ts0 ->\nexists body' ts' : stmt,\n  transl_lblstmt cenv (switch_env sl' xenv) sl' body' = OK ts') (body ts x : stmt) (EQ : transl_stmt cenv (false :: switch_env sl xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env sl xenv) sl (Sseq (Sblock body) x) = OK ts) : exists body' ts' : stmt,\n  transl_lblstmt cenv (switch_env sl' xenv) sl' body' = OK ts'.","proofString":"eauto."},{"statement":"(xenv : exit_env) (body ts : stmt) (tk1 tk2 : cont) (ts' : stmt) (tk' : cont) (H : transl_lblstmt cenv (switch_env LSnil xenv) LSnil body = OK ts) (H0 : transl_lblstmt_cont cenv xenv LSnil tk1 tk2) (H1 : find_label lbl body tk2 = Some (ts', tk')) : find_label lbl ts tk1 = Some (ts', tk').","proofString":"monadInv H.\ninv H0.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (body : stmt) (tk1 tk2 : cont) (ts' : stmt) (tk' : cont) (H0 : transl_lblstmt_cont cenv xenv LSnil tk1 tk2) (H1 : find_label lbl body tk2 = Some (ts', tk')) : find_label lbl (Sseq (Sblock body) Sskip) tk1 = Some (ts', tk').","proofString":"inv H0.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (body : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (H1 : find_label lbl body (Kblock (Kseq Sskip tk1)) = Some (ts', tk')) : find_label lbl (Sseq (Sblock body) Sskip) tk1 = Some (ts', tk').","proofString":"simpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (body : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (H1 : find_label lbl body (Kblock (Kseq Sskip tk1)) = Some (ts', tk')) : match find_label lbl body (Kblock (Kseq Sskip tk1)) with\n| Some sk => Some sk\n| None => None\nend = Some (ts', tk').","proofString":"rewrite H1.\nauto."},{"statement":"(xenv : exit_env) (body : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (H1 : find_label lbl body (Kblock (Kseq Sskip tk1)) = Some (ts', tk')) : Some (ts', tk') = Some (ts', tk').","proofString":"auto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts0 : stmt) (tk0 tk3 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts0 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk3 ->\nfind_label lbl body0 tk3 = Some (ts'0, tk'0) ->\nfind_label lbl ts0 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 tk2 : cont) (ts' : stmt) (tk' : cont) (H : transl_lblstmt cenv (switch_env (LScons o s ls) xenv) (LScons o s ls) body =\nOK ts) (H0 : transl_lblstmt_cont cenv xenv (LScons o s ls) tk1 tk2) (H1 : find_label lbl body tk2 = Some (ts', tk')) : find_label lbl ts tk1 = Some (ts', tk').","proofString":"monadInv H.\ninv H0.\nsimpl in H6.\neapply IHls; eauto.\nreplace x with ts0 by congruence.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts0 : stmt) (tk0 tk3 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts0 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk3 ->\nfind_label lbl body0 tk3 = Some (ts'0, tk'0) ->\nfind_label lbl ts0 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 tk2 : cont) (ts' : stmt) (tk' : cont) (H0 : transl_lblstmt_cont cenv xenv (LScons o s ls) tk1 tk2) (H1 : find_label lbl body tk2 = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) : find_label lbl ts tk1 = Some (ts', tk').","proofString":"inv H0.\nsimpl in H6.\neapply IHls; eauto.\nreplace x with ts0 by congruence.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (switch_env (LScons o s ls) xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : find_label lbl ts tk1 = Some (ts', tk').","proofString":"simpl in H6.\neapply IHls; eauto.\nreplace x with ts0 by congruence.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : find_label lbl ts tk1 = Some (ts', tk').","proofString":"eapply IHls; eauto.\nreplace x with ts0 by congruence.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : find_label lbl (Sseq (Sblock body) x) k' = Some (ts', tk').","proofString":"replace x with ts0 by congruence.\nsimpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : find_label lbl (Sseq (Sblock body) ts0) k' = Some (ts', tk').","proofString":"simpl.\nrewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : match find_label lbl body (Kblock (Kseq ts0 k')) with\n| Some sk => Some sk\n| None => find_label lbl ts0 k'\nend = Some (ts', tk').","proofString":"rewrite H1.\nauto."},{"statement":"(xenv : exit_env) (o : option Z) (s : Csharpminor.stmt) (ls : lbl_stmt) (IHls : forall (body0 ts1 : stmt) (tk0 tk2 : cont) (ts'0 : stmt) (tk'0 : cont),\ntransl_lblstmt cenv (switch_env ls xenv) ls body0 = OK ts1 ->\ntransl_lblstmt_cont cenv xenv ls tk0 tk2 ->\nfind_label lbl body0 tk2 = Some (ts'0, tk'0) ->\nfind_label lbl ts1 tk0 = Some (ts'0, tk'0)) (body ts : stmt) (tk1 : cont) (ts' : stmt) (tk' : cont) (ts0 : stmt) (k' : cont) (H1 : find_label lbl body (Kblock (Kseq ts0 k')) = Some (ts', tk')) (x : stmt) (EQ : transl_stmt cenv (false :: switch_env ls xenv) s = OK x) (EQ0 : transl_lblstmt cenv (switch_env ls xenv) ls (Sseq (Sblock body) x) = OK ts) (H6 : transl_stmt cenv (false :: switch_env ls xenv) s = OK ts0) (H7 : transl_lblstmt_cont cenv xenv ls tk1 k') : Some (ts', tk') = Some (ts', tk').","proofString":"auto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (size : Z) (f : Csharpminor.function) (tf : function) (k : Csharpminor.cont) (tk : cont) (cs : callstack) (lbl : Csharpminor.label) (s' : Csharpminor.stmt) (k' : Csharpminor.cont) (H : transl_funbody cenv size f = OK tf) (H0 : match_cont k tk cenv xenv cs) (H1 : Csharpminor.find_label lbl (Csharpminor.fn_body f) (Csharpminor.call_cont k) =\nSome (s', k')) : exists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n  find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk') /\\\n  transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs.","proofString":"monadInv H.\nsimpl.\nexploit transl_find_label.\neexact EQ.\neapply match_call_cont.\neexact H0.\ninstantiate (1 := lbl).\nrewrite H1.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (size : Z) (f : Csharpminor.function) (k : Csharpminor.cont) (tk : cont) (cs : callstack) (lbl : Csharpminor.label) (s' : Csharpminor.stmt) (k' : Csharpminor.cont) (H0 : match_cont k tk cenv xenv cs) (H1 : Csharpminor.find_label lbl (Csharpminor.fn_body f) (Csharpminor.call_cont k) =\nSome (s', k')) (x : stmt) (EQ : transl_stmt cenv nil (Csharpminor.fn_body f) = OK x) : exists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n  find_label lbl\n    (fn_body\n       {|\n         fn_sig := Csharpminor.fn_sig f;\n         fn_params := Csharpminor.fn_params f;\n         fn_vars := fn_temps f;\n         fn_stackspace := size;\n         fn_body := x\n       |}) (call_cont tk) = Some (ts', tk') /\\\n  transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs.","proofString":"simpl.\nexploit transl_find_label.\neexact EQ.\neapply match_call_cont.\neexact H0.\ninstantiate (1 := lbl).\nrewrite H1.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (size : Z) (f : Csharpminor.function) (k : Csharpminor.cont) (tk : cont) (cs : callstack) (lbl : Csharpminor.label) (s' : Csharpminor.stmt) (k' : Csharpminor.cont) (H0 : match_cont k tk cenv xenv cs) (H1 : Csharpminor.find_label lbl (Csharpminor.fn_body f) (Csharpminor.call_cont k) =\nSome (s', k')) (x : stmt) (EQ : transl_stmt cenv nil (Csharpminor.fn_body f) = OK x) : exists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n  find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n  transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs.","proofString":"exploit transl_find_label.\neexact EQ.\neapply match_call_cont.\neexact H0.\ninstantiate (1 := lbl).\nrewrite H1.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (size : Z) (f : Csharpminor.function) (k : Csharpminor.cont) (tk : cont) (cs : callstack) (lbl : Csharpminor.label) (s' : Csharpminor.stmt) (k' : Csharpminor.cont) (H0 : match_cont k tk cenv xenv cs) (H1 : Csharpminor.find_label lbl (Csharpminor.fn_body f) (Csharpminor.call_cont k) =\nSome (s', k')) (x : stmt) (EQ : transl_stmt cenv nil (Csharpminor.fn_body f) = OK x) : match\n  Csharpminor.find_label lbl (Csharpminor.fn_body f)\n    (Csharpminor.call_cont k)\nwith\n| Some (s'0, k'0) =>\n    exists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n      find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n      transl_stmt cenv xenv' s'0 = OK ts' /\\ match_cont k'0 tk' cenv xenv' cs\n| None => find_label lbl x (call_cont tk) = None\nend ->\nexists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n  find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n  transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs.","proofString":"rewrite H1.\nauto."},{"statement":"(cenv : compilenv) (xenv : exit_env) (size : Z) (f : Csharpminor.function) (k : Csharpminor.cont) (tk : cont) (cs : callstack) (lbl : Csharpminor.label) (s' : Csharpminor.stmt) (k' : Csharpminor.cont) (H0 : match_cont k tk cenv xenv cs) (H1 : Csharpminor.find_label lbl (Csharpminor.fn_body f) (Csharpminor.call_cont k) =\nSome (s', k')) (x : stmt) (EQ : transl_stmt cenv nil (Csharpminor.fn_body f) = OK x) : (exists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n   find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n   transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs) ->\nexists (ts' : stmt) (tk' : cont) (xenv' : exit_env),\n  find_label lbl x (call_cont tk) = Some (ts', tk') /\\\n  transl_stmt cenv xenv' s' = OK ts' /\\ match_cont k' tk' cenv xenv' cs.","proofString":"auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : match_globalenvs (Mem.flat_inj (Mem.nextblock m)) (Mem.nextblock m).","proofString":"constructor.\nintros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\nintros.\nunfold Mem.flat_inj in H0.\ndestruct (plt b1 (Mem.nextblock m)); congruence.\nintros.\neapply Genv.find_symbol_not_fresh; eauto.\nintros.\neapply Genv.find_funct_ptr_not_fresh; eauto.\nintros.\neapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : forall b : positive,\nPlt b (Mem.nextblock m) -> Mem.flat_inj (Mem.nextblock m) b = Some (b, 0).","proofString":"intros.\nunfold Mem.flat_inj.\napply pred_dec_true; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b : positive) (H0 : Plt b (Mem.nextblock m)) : Mem.flat_inj (Mem.nextblock m) b = Some (b, 0).","proofString":"unfold Mem.flat_inj.\napply pred_dec_true; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b : positive) (H0 : Plt b (Mem.nextblock m)) : (if plt b (Mem.nextblock m) then Some (b, 0) else None) = Some (b, 0).","proofString":"apply pred_dec_true; auto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : forall (b1 b2 : block) (delta : Z),\nMem.flat_inj (Mem.nextblock m) b1 = Some (b2, delta) ->\nPlt b2 (Mem.nextblock m) -> b1 = b2.","proofString":"intros.\nunfold Mem.flat_inj in H0.\ndestruct (plt b1 (Mem.nextblock m)); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b1 b2 : block) (delta : Z) (H0 : Mem.flat_inj (Mem.nextblock m) b1 = Some (b2, delta)) (H1 : Plt b2 (Mem.nextblock m)) : b1 = b2.","proofString":"unfold Mem.flat_inj in H0.\ndestruct (plt b1 (Mem.nextblock m)); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b1 b2 : block) (delta : Z) (H0 : (if plt b1 (Mem.nextblock m) then Some (b1, 0) else None) = Some (b2, delta)) (H1 : Plt b2 (Mem.nextblock m)) : b1 = b2.","proofString":"destruct (plt b1 (Mem.nextblock m)); congruence."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> Plt b (Mem.nextblock m).","proofString":"intros.\neapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (id : ident) (b : block) (H0 : Genv.find_symbol ge id = Some b) : Plt b (Mem.nextblock m).","proofString":"eapply Genv.find_symbol_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : forall (b : block) (fd : Csharpminor.fundef),\nGenv.find_funct_ptr ge b = Some fd -> Plt b (Mem.nextblock m).","proofString":"intros.\neapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b : block) (fd : Csharpminor.fundef) (H0 : Genv.find_funct_ptr ge b = Some fd) : Plt b (Mem.nextblock m).","proofString":"eapply Genv.find_funct_ptr_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) : forall (b : block) (gv : globvar unit),\nGenv.find_var_info ge b = Some gv -> Plt b (Mem.nextblock m).","proofString":"intros.\neapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(m : mem) (H : Genv.init_mem prog = Some m) (b : block) (gv : globvar unit) (H0 : Genv.find_var_info ge b = Some gv) : Plt b (Mem.nextblock m).","proofString":"eapply Genv.find_var_info_not_fresh; eauto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : prog_main prog = prog_main tprog.","proofString":"symmetry.\nunfold transl_program in TRANSL.\neapply match_program_main; eauto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : prog_main tprog = prog_main prog.","proofString":"unfold transl_program in TRANSL.\neapply match_program_main; eauto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : prog_main tprog = prog_main prog.","proofString":"eapply match_program_main; eauto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : funsig tf = Csharpminor.funsig f.","proofString":"apply sig_preserved; auto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : transl_fundef f = OK tf.","proofString":"auto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : Mem.inject (Mem.flat_inj (Mem.nextblock m0)) m0 m0.","proofString":"eapply Genv.initmem_inject; eauto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : match_callstack (Mem.flat_inj (Mem.nextblock m0)) m0 m0 nil\n  (Mem.nextblock m0) (Mem.nextblock m0).","proofString":"apply mcs_nil with (Mem.nextblock m0).\napply match_globalenvs_init; auto.\nextlia.\nextlia."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : match_globalenvs (Mem.flat_inj (Mem.nextblock m0)) (Mem.nextblock m0).","proofString":"apply match_globalenvs_init; auto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : Ple (Mem.nextblock m0) (Mem.nextblock m0).","proofString":"extlia."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : Ple (Mem.nextblock m0) (Mem.nextblock m0).","proofString":"extlia."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : match_cont Csharpminor.Kstop Kstop (PTree.empty Z) nil nil.","proofString":"constructor."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : Csharpminor.is_call_cont Csharpminor.Kstop.","proofString":"red; auto."},{"statement":"(b : block) (f : Csharpminor.fundef) (m0 : mem) (ge0 : Genv.t Csharpminor.fundef unit) (H : Genv.init_mem prog = Some m0) (H0 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H1 : Genv.find_funct_ptr ge0 b = Some f) (H2 : Csharpminor.funsig f = signature_main) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : transl_fundef f = OK tf) : Val.inject_list (Mem.flat_inj (Mem.nextblock m0)) nil nil.","proofString":"constructor."},{"statement":"(S : Csharpminor.state) (R : state) (r : int) (H : match_states S R) (H0 : Csharpminor.final_state S r) : final_state R r.","proofString":"inv H0.\ninv H.\ninv MK.\ninv RESINJ.\nconstructor."},{"statement":"(R : state) (r : int) (m : mem) (H : match_states (Csharpminor.Returnstate (Vint r) Csharpminor.Kstop m) R) : final_state R r.","proofString":"inv H.\ninv MK.\ninv RESINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tk : cont) (tm : mem) (f : meminj) (cs : callstack) (cenv : compilenv) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm cs (Mem.nextblock m) (Mem.nextblock tm)) (MK : match_cont Csharpminor.Kstop tk cenv nil cs) (RESINJ : Val.inject f (Vint r) tv) : final_state (Returnstate tv tk tm) r.","proofString":"inv MK.\ninv RESINJ.\nconstructor."},{"statement":"(r : int) (m : mem) (tv : val) (tm : mem) (f : meminj) (cenv : compilenv) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm nil (Mem.nextblock m) (Mem.nextblock tm)) (RESINJ : Val.inject f (Vint r) tv) : final_state (Returnstate tv Kstop tm) r.","proofString":"inv RESINJ.\nconstructor."},{"statement":"(r : int) (m tm : mem) (f : meminj) (cenv : compilenv) (MINJ : Mem.inject f m tm) (MCS : match_callstack f m tm nil (Mem.nextblock m) (Mem.nextblock tm)) : final_state (Returnstate (Vint r) Kstop tm) r.","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Csharpminor.semantics prog)) id.","proofString":"apply senv_preserved."}]}